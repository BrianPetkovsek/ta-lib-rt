/* TA-LIB Copyright (c) 1999-2008, Mario Fortier
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or
 * without modification, are permitted provided that the following
 * conditions are met:
 *
 * - Redistributions of source code must retain the above copyright
 *   notice, this list of conditions and the following disclaimer.
 *
 * - Redistributions in binary form must reproduce the above copyright
 *   notice, this list of conditions and the following disclaimer in
 *   the documentation and/or other materials provided with the
 *   distribution.
 *
 * - Neither name of author nor the names of its contributors
 *   may be used to endorse or promote products derived from this
 *   software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
 * REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
 * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/* List of contributors:
 *
 *  Initial  Name/description
 *  -------------------------------------------------------------------
 *  MF       Mario Fortier
 *  BT       Barry Tsung
 *
 * Change history:
 *
 *  MMDDYY BY     Description
 *  -------------------------------------------------------------------
 *  121005 MF     First Version
 *  022206 BT     1. initialization of candleSettings
 *                2. add SetCompatibility and GetCompatibility
 *                3. add SetUnstablePeriod, GetUnstablePeriod
 */

package com.tictactec.ta.lib;

public class Core {
   
   private int[] unstablePeriod;
   
   private CandleSetting[] candleSettings;
   
   private Compatibility compatibility;
   
   /** Creates a new instance of Core */
   public Core() {
      unstablePeriod = new int[com.tictactec.ta.lib.FuncUnstId.All
         .ordinal()];
      compatibility = Compatibility.Default;
      candleSettings = new CandleSetting[com.tictactec.ta.lib.CandleSettingType.AllCandleSettings
         .ordinal()];
      for(int i=0;i<candleSettings.length;i++){
         candleSettings[i] = new CandleSetting(TA_CandleDefaultSettings[i]);
      }
   }
   
   public RetCode SetCandleSettings(CandleSettingType settingType,
      RangeType rangeType, int avgPeriod, double factor) {
      if (settingType.ordinal() >= CandleSettingType.AllCandleSettings
         .ordinal())
         return RetCode.BadParam;
      candleSettings[settingType.ordinal()].settingType = settingType;
      candleSettings[settingType.ordinal()].rangeType = rangeType;
      candleSettings[settingType.ordinal()].avgPeriod = avgPeriod;
      candleSettings[settingType.ordinal()].factor = factor;
      return RetCode.Success;
   }
   
   final private CandleSetting TA_CandleDefaultSettings[] = {
      /*
      * real body is long when it's longer than the average of the 10
      * previous candles' real body
      */
      new CandleSetting(CandleSettingType.BodyLong,
         RangeType.RealBody, 10, 1.0),
      /*
      * real body is very long when it's longer than 3 times the average
      * of the 10 previous candles' real body
      */
      new CandleSetting(CandleSettingType.BodyVeryLong,
         RangeType.RealBody, 10, 3.0),
      /*
      * real body is short when it's shorter than the average of the 10
      * previous candles' real bodies
      */
      new CandleSetting(CandleSettingType.BodyShort,
         RangeType.RealBody, 10, 1.0),
      /*
      * real body is like doji's body when it's shorter than 10% the
      * average of the 10 previous candles' high-low range
      */
      new CandleSetting(CandleSettingType.BodyDoji,
         RangeType.HighLow, 10, 0.1),
      /* shadow is long when it's longer than the real body */
      new CandleSetting(CandleSettingType.ShadowLong,
         RangeType.RealBody, 0, 1.0),
      /* shadow is very long when it's longer than 2 times the real body */
      new CandleSetting(CandleSettingType.ShadowVeryLong,
         RangeType.RealBody, 0, 2.0),
      /*
      * shadow is short when it's shorter than half the average of the 10
      * previous candles' sum of shadows
      */
      new CandleSetting(CandleSettingType.ShadowShort,
         RangeType.Shadows, 10, 1.0),
      /*
      * shadow is very short when it's shorter than 10% the average of
      * the 10 previous candles' high-low range
      */
      new CandleSetting(CandleSettingType.ShadowVeryShort,
         RangeType.HighLow, 10, 0.1),
      /* when measuring distance between parts of candles or width of gaps */
      /*
      * "near" means "<= 20% of the average of the 5 previous candles'
      * high-low range"
      */
      new CandleSetting(CandleSettingType.Near,
         RangeType.HighLow, 5, 0.2),
      /* when measuring distance between parts of candles or width of gaps */
      /*
      * "far" means ">= 60% of the average of the 5 previous candles'
      * high-low range"
      */
      new CandleSetting(CandleSettingType.Far,
         RangeType.HighLow, 5, 0.6),
      /* when measuring distance between parts of candles or width of gaps */
      /*
      * "equal" means "<= 5% of the average of the 5 previous candles'
      * high-low range"
      */
      new CandleSetting(CandleSettingType.Equal,
         RangeType.HighLow, 5, 0.05) };
   
   public RetCode RestoreCandleDefaultSettings(
      CandleSettingType settingType) {
      int i;
      if (settingType.ordinal() > CandleSettingType.AllCandleSettings
         .ordinal())
         return RetCode.BadParam;
      if (settingType == CandleSettingType.AllCandleSettings) {
         for (i = 0; i < CandleSettingType.AllCandleSettings.ordinal(); ++i) {
            candleSettings[i].CopyFrom(TA_CandleDefaultSettings[i]);
         }
      } else {
         candleSettings[settingType.ordinal()]
            .CopyFrom(TA_CandleDefaultSettings[settingType.ordinal()]);
      }
      return RetCode.Success;
   }
   
   public RetCode SetUnstablePeriod(FuncUnstId id, int period)
   {
      if (id.ordinal() >= FuncUnstId.All
         .ordinal())
         return RetCode.BadParam;
      unstablePeriod[id.ordinal()] = period;
      return RetCode.Success;
   }
   
   public int GetUnstablePeriod(FuncUnstId id)
   {
      return unstablePeriod[id.ordinal()];
   }
   
   public void SetCompatibility(Compatibility compatibility)
   {
      this.compatibility = compatibility;
   }
   
   public Compatibility getCompatibility()
   {
      return compatibility;
   }
   
   /**** START GENCODE SECTION 1 - DO NOT DELETE THIS LINE ****/
   public int accbandsLookback( int optInTimePeriod )
   {
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 20;
      else if( ((int)optInTimePeriod < 2) || ((int)optInTimePeriod > 100000) )
         return -1;
      return smaLookback ( optInTimePeriod );
   }
   public RetCode accbands( int startIdx,
      int endIdx,
      double inHigh[],
      double inLow[],
      double inClose[],
      int optInTimePeriod,
      MInteger outBegIdx,
      MInteger outNBElement,
      double outRealUpperBand[],
      double outRealMiddleBand[],
      double outRealLowerBand[] )
   {
      RetCode retCode;
      double []tempBuffer1 ;
      double []tempBuffer2 ;
      MInteger outBegIdxDummy = new MInteger() ;
      MInteger outNbElementDummy = new MInteger() ;
      int i, j, outputSize, bufferSize, lookbackTotal;
      double tempReal;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 20;
      else if( ((int)optInTimePeriod < 2) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      lookbackTotal = smaLookback ( optInTimePeriod );
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      outputSize = endIdx-startIdx+1;
      bufferSize = outputSize+lookbackTotal;
      tempBuffer1 = new double[bufferSize] ;
      tempBuffer2 = new double[bufferSize] ;
      for(j=0, i=startIdx-lookbackTotal; i<=endIdx; i++, j++)
      {
         tempReal = inHigh[i]+inLow[i];
         if( ! (((- (0.00000000000001) )<tempReal)&&(tempReal< (0.00000000000001) )) )
         {
            tempReal = 4*(inHigh[i]-inLow[i])/tempReal;
            tempBuffer1[j] = inHigh[i]*(1+tempReal);
            tempBuffer2[j] = inLow[i]*(1-tempReal);
         }
         else
         {
            tempBuffer1[j] = inHigh[i];
            tempBuffer2[j] = inLow[i];
         }
      }
      retCode = sma ( startIdx, endIdx, inClose,
         optInTimePeriod,
         outBegIdxDummy , outNbElementDummy , outRealMiddleBand );
      if( (retCode != RetCode.Success ) || ((int) outNbElementDummy.value != outputSize) )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return retCode;
      }
      retCode = sma ( 0, bufferSize-1, tempBuffer1,
         optInTimePeriod,
         outBegIdxDummy , outNbElementDummy ,
         outRealUpperBand );
      if( (retCode != RetCode.Success ) || ((int) outNbElementDummy.value != outputSize) )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return retCode;
      }
      retCode = sma ( 0, bufferSize-1, tempBuffer2,
         optInTimePeriod,
         outBegIdxDummy , outNbElementDummy ,
         outRealLowerBand );
      if( (retCode != RetCode.Success ) || ((int) outNbElementDummy.value != outputSize) )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return retCode;
      }
      outBegIdx.value = startIdx;
      outNBElement.value = outputSize;
      return RetCode.Success ;
   }
   public int accbandsStateInit( struct TA_accbands_State** _state,
      int optInTimePeriod )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 20;
      else if( ((int)optInTimePeriod < 2) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct accbands ));
      _state.value .value .mem_index = 0;
      _state.value .value .optInTimePeriod = optInTimePeriod;
      _state.value .value .mem_size = accbandsLookback (optInTimePeriod );
      if ( _state.value .value .mem_size > 0)
         _state.value .value .memory = TA_Calloc( _state.value .value .mem_size , sizeof(struct TA_ACCBANDS_Data));
      else
         _state.value .value .memory = NULL;
      return RetCode.Success ;
   }
   public int accbandsState( struct TA_accbands_State* _state,
      double inHigh,
      double inLow,
      double inClose,
      double *outRealUpperBand,
      double *outRealMiddleBand,
      double *outRealLowerBand )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      size_t _cur_idx = _state.value .mem_index++;
      if ( _state.value .mem_size > 0) _cur_idx %= _state.value .mem_size ;
      if ( _state.value .mem_size > _state.value .mem_index - 1 ) {
         ( _state.value .memory+_cur_idx).value .inHigh = inHigh ;
         ( _state.value .memory+_cur_idx).value .inLow = inLow ;
         ( _state.value .memory+_cur_idx).value .inClose = inClose ;
         return RetCode.NeedMoreData ; }
      return RetCode.Success ;
   }
   public int accbandsStateFree( struct TA_accbands_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if ( _state.value != NULL) {
         if ( _state.value .value .memory != NULL) TA_Free( _state.value .value .memory );
         TA_Free( _state.value ); _state.value = NULL;}
      return RetCode.Success ;
   }
   public RetCode accbands( int startIdx,
      int endIdx,
      float inHigh[],
      float inLow[],
      float inClose[],
      int optInTimePeriod,
      MInteger outBegIdx,
      MInteger outNBElement,
      double outRealUpperBand[],
      double outRealMiddleBand[],
      double outRealLowerBand[] )
   {
      RetCode retCode;
      double []tempBuffer1 ;
      double []tempBuffer2 ;
      MInteger outBegIdxDummy = new MInteger() ;
      MInteger outNbElementDummy = new MInteger() ;
      int i, j, outputSize, bufferSize, lookbackTotal;
      double tempReal;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 20;
      else if( ((int)optInTimePeriod < 2) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      lookbackTotal = smaLookback ( optInTimePeriod );
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      outputSize = endIdx-startIdx+1;
      bufferSize = outputSize+lookbackTotal;
      tempBuffer1 = new double[bufferSize] ;
      tempBuffer2 = new double[bufferSize] ;
      for(j=0, i=startIdx-lookbackTotal; i<=endIdx; i++, j++)
      {
         tempReal = inHigh[i]+inLow[i];
         if( ! (((- (0.00000000000001) )<tempReal)&&(tempReal< (0.00000000000001) )) )
         {
            tempReal = 4*(inHigh[i]-inLow[i])/tempReal;
            tempBuffer1[j] = inHigh[i]*(1+tempReal);
            tempBuffer2[j] = inLow[i]*(1-tempReal);
         }
         else
         {
            tempBuffer1[j] = inHigh[i];
            tempBuffer2[j] = inLow[i];
         }
      }
      retCode = sma ( startIdx, endIdx, inClose,
         optInTimePeriod,
         outBegIdxDummy , outNbElementDummy , outRealMiddleBand );
      if( (retCode != RetCode.Success ) || ((int) outNbElementDummy.value != outputSize) )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return retCode;
      }
      retCode = sma ( 0, bufferSize-1, tempBuffer1,
         optInTimePeriod,
         outBegIdxDummy , outNbElementDummy ,
         outRealUpperBand );
      if( (retCode != RetCode.Success ) || ((int) outNbElementDummy.value != outputSize) )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return retCode;
      }
      retCode = sma ( 0, bufferSize-1, tempBuffer2,
         optInTimePeriod,
         outBegIdxDummy , outNbElementDummy ,
         outRealLowerBand );
      if( (retCode != RetCode.Success ) || ((int) outNbElementDummy.value != outputSize) )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return retCode;
      }
      outBegIdx.value = startIdx;
      outNBElement.value = outputSize;
      return RetCode.Success ;
   }
   /* Generated */
   public int acosLookback( )
   {
      return RetCode.Success ;
   }
   public RetCode acos( int startIdx,
      int endIdx,
      double inReal[],
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      int outIdx;
      int i;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      for( i=startIdx, outIdx=0; i <= endIdx; i++, outIdx++ )
      {
         outReal[outIdx] = Math.acos (inReal[i]);
      }
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   public int acosStateInit( struct TA_acos_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct acos ));
      _state.value .value .mem_index = 0;
      _state.value .value .mem_size = acosLookback ();
      if ( _state.value .value .mem_size > 0)
         _state.value .value .memory = TA_Calloc( _state.value .value .mem_size , sizeof(struct TA_ACOS_Data));
      else
         _state.value .value .memory = NULL;
      return RetCode.Success ;
   }
   public int acosState( struct TA_acos_State* _state,
      double inReal,
      double *outReal )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      size_t _cur_idx = _state.value .mem_index++;
      if ( _state.value .mem_size > 0) _cur_idx %= _state.value .mem_size ;
      if ( _state.value .mem_size > _state.value .mem_index - 1 ) {
         ( _state.value .memory+_cur_idx).value .inReal = inReal ;
         return RetCode.NeedMoreData ; }
      outReal.value = Math.acos (inReal);
      return RetCode.Success ;
   }
   public int acosStateFree( struct TA_acos_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if ( _state.value != NULL) {
         if ( _state.value .value .memory != NULL) TA_Free( _state.value .value .memory );
         TA_Free( _state.value ); _state.value = NULL;}
      return RetCode.Success ;
   }
   public RetCode acos( int startIdx,
      int endIdx,
      float inReal[],
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      int outIdx;
      int i;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      for( i=startIdx, outIdx=0; i <= endIdx; i++, outIdx++ )
      {
         outReal[outIdx] = Math.acos (inReal[i]);
      }
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   /* Generated */
   public int adLookback( )
   {
      return RetCode.Success ;
   }
   public RetCode ad( int startIdx,
      int endIdx,
      double inHigh[],
      double inLow[],
      double inClose[],
      double inVolume[],
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      int nbBar, currentBar, outIdx;
      double high, low, close, tmp;
      double ad;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      nbBar = endIdx-startIdx+1;
      outNBElement.value = nbBar;
      outBegIdx.value = startIdx;
      currentBar = startIdx;
      outIdx = 0;
      ad = 0.0;
      while( nbBar != 0 )
      {
         high = inHigh[currentBar];
         low = inLow[currentBar];
         tmp = high-low;
         close = inClose[currentBar];
         if( tmp > 0.0 )
            ad += (((close-low)-(high-close))/tmp)*((double)inVolume[currentBar]);
         outReal[outIdx++] = ad;
         currentBar++;
         nbBar--;
      }
      return RetCode.Success ;
   }
   public int adStateInit( struct TA_ad_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct ad ));
      _state.value .value .mem_index = 0;
      _state.value .value .mem_size = adLookback ();
      if ( _state.value .value .mem_size > 0)
         _state.value .value .memory = TA_Calloc( _state.value .value .mem_size , sizeof(struct TA_AD_Data));
      else
         _state.value .value .memory = NULL;
      return RetCode.Success ;
   }
   public int adState( struct TA_ad_State* _state,
      double inHigh,
      double inLow,
      double inClose,
      double inVolume,
      double *outReal )
   {
      double tmp;
      if (_state == NULL)
         return RetCode.BadParam ;
      size_t _cur_idx = _state.value .mem_index++;
      if ( _state.value .mem_size > 0) _cur_idx %= _state.value .mem_size ;
      if ( _state.value .mem_size > _state.value .mem_index - 1 ) {
         ( _state.value .memory+_cur_idx).value .inHigh = inHigh ;
         ( _state.value .memory+_cur_idx).value .inLow = inLow ;
         ( _state.value .memory+_cur_idx).value .inClose = inClose ;
         ( _state.value .memory+_cur_idx).value .inVolume = inVolume ;
         return RetCode.NeedMoreData ; }
      tmp = inHigh - inLow;
      if( tmp > 0.0 )
         outReal.value = (((inClose-inLow)-(inHigh-inClose))/tmp)*((double)inVolume);
      else
         outReal.value = 0.0;
      return RetCode.Success ;
   }
   public int adStateFree( struct TA_ad_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if ( _state.value != NULL) {
         if ( _state.value .value .memory != NULL) TA_Free( _state.value .value .memory );
         TA_Free( _state.value ); _state.value = NULL;}
      return RetCode.Success ;
   }
   public RetCode ad( int startIdx,
      int endIdx,
      float inHigh[],
      float inLow[],
      float inClose[],
      float inVolume[],
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      int nbBar, currentBar, outIdx;
      double high, low, close, tmp;
      double ad;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      nbBar = endIdx-startIdx+1;
      outNBElement.value = nbBar;
      outBegIdx.value = startIdx;
      currentBar = startIdx;
      outIdx = 0;
      ad = 0.0;
      while( nbBar != 0 )
      {
         high = inHigh[currentBar];
         low = inLow[currentBar];
         tmp = high-low;
         close = inClose[currentBar];
         if( tmp > 0.0 )
            ad += (((close-low)-(high-close))/tmp)*((double)inVolume[currentBar]);
         outReal[outIdx++] = ad;
         currentBar++;
         nbBar--;
      }
      return RetCode.Success ;
   }
   /* Generated */
   public int addLookback( )
   {
      return RetCode.Success ;
   }
   public RetCode add( int startIdx,
      int endIdx,
      double inReal0[],
      double inReal1[],
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      int outIdx;
      int i;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      for( i=startIdx, outIdx=0; i <= endIdx; i++, outIdx++ )
      {
         outReal[outIdx] = inReal0[i]+inReal1[i];
      }
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   public int addStateInit( struct TA_add_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct add ));
      _state.value .value .mem_index = 0;
      _state.value .value .mem_size = addLookback ();
      if ( _state.value .value .mem_size > 0)
         _state.value .value .memory = TA_Calloc( _state.value .value .mem_size , sizeof(struct TA_ADD_Data));
      else
         _state.value .value .memory = NULL;
      return RetCode.Success ;
   }
   public int addState( struct TA_add_State* _state,
      double inReal0,
      double inReal1,
      double *outReal )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      size_t _cur_idx = _state.value .mem_index++;
      if ( _state.value .mem_size > 0) _cur_idx %= _state.value .mem_size ;
      if ( _state.value .mem_size > _state.value .mem_index - 1 ) {
         ( _state.value .memory+_cur_idx).value .inReal0 = inReal0 ;
         ( _state.value .memory+_cur_idx).value .inReal1 = inReal1 ;
         return RetCode.NeedMoreData ; }
      outReal.value = inReal0 + inReal1;
      return RetCode.Success ;
   }
   public int addStateFree( struct TA_add_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if ( _state.value != NULL) {
         if ( _state.value .value .memory != NULL) TA_Free( _state.value .value .memory );
         TA_Free( _state.value ); _state.value = NULL;}
      return RetCode.Success ;
   }
   public RetCode add( int startIdx,
      int endIdx,
      float inReal0[],
      float inReal1[],
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      int outIdx;
      int i;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      for( i=startIdx, outIdx=0; i <= endIdx; i++, outIdx++ )
      {
         outReal[outIdx] = inReal0[i]+inReal1[i];
      }
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   /* Generated */
   public int adOscLookback( int optInFastPeriod,
      int optInSlowPeriod )
   {
      int slowestPeriod;
      if( (int)optInFastPeriod == ( Integer.MIN_VALUE ) )
         optInFastPeriod = 3;
      else if( ((int)optInFastPeriod < 2) || ((int)optInFastPeriod > 100000) )
         return -1;
      if( (int)optInSlowPeriod == ( Integer.MIN_VALUE ) )
         optInSlowPeriod = 10;
      else if( ((int)optInSlowPeriod < 2) || ((int)optInSlowPeriod > 100000) )
         return -1;
      if( optInFastPeriod < optInSlowPeriod )
         slowestPeriod = optInSlowPeriod;
      else
         slowestPeriod = optInFastPeriod;
      return emaLookback ( slowestPeriod );
   }
   public RetCode adOsc( int startIdx,
      int endIdx,
      double inHigh[],
      double inLow[],
      double inClose[],
      double inVolume[],
      int optInFastPeriod,
      int optInSlowPeriod,
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      int today, outIdx, lookbackTotal;
      int slowestPeriod;
      double high, low, close, tmp;
      double slowEMA, slowk, one_minus_slowk;
      double fastEMA, fastk, one_minus_fastk;
      double ad;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      if( (int)optInFastPeriod == ( Integer.MIN_VALUE ) )
         optInFastPeriod = 3;
      else if( ((int)optInFastPeriod < 2) || ((int)optInFastPeriod > 100000) )
         return RetCode.BadParam ;
      if( (int)optInSlowPeriod == ( Integer.MIN_VALUE ) )
         optInSlowPeriod = 10;
      else if( ((int)optInSlowPeriod < 2) || ((int)optInSlowPeriod > 100000) )
         return RetCode.BadParam ;
      if( optInFastPeriod < optInSlowPeriod )
         slowestPeriod = optInSlowPeriod;
      else
         slowestPeriod = optInFastPeriod;
      lookbackTotal = emaLookback ( slowestPeriod );
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      outBegIdx.value = startIdx;
      today = startIdx-lookbackTotal;
      ad = 0.0;
      fastk = ((double)2.0 / ((double)(optInFastPeriod + 1))) ;
      one_minus_fastk = 1.0 - fastk;
      slowk = ((double)2.0 / ((double)(optInSlowPeriod + 1))) ;
      one_minus_slowk = 1.0 - slowk;
      { high = inHigh[today]; low = inLow[today]; tmp = high-low; close = inClose[today]; if( tmp > 0.0 ) ad += (((close-low)-(high-close))/tmp)*((double)inVolume[today]); today++; } ;
      fastEMA = ad;
      slowEMA = ad;
      while( today < startIdx )
      {
         { high = inHigh[today]; low = inLow[today]; tmp = high-low; close = inClose[today]; if( tmp > 0.0 ) ad += (((close-low)-(high-close))/tmp)*((double)inVolume[today]); today++; } ;
         fastEMA = (fastk*ad)+(one_minus_fastk*fastEMA);
         slowEMA = (slowk*ad)+(one_minus_slowk*slowEMA);
      }
      outIdx = 0;
      while( today <= endIdx )
      {
         { high = inHigh[today]; low = inLow[today]; tmp = high-low; close = inClose[today]; if( tmp > 0.0 ) ad += (((close-low)-(high-close))/tmp)*((double)inVolume[today]); today++; } ;
         fastEMA = (fastk*ad)+(one_minus_fastk*fastEMA);
         slowEMA = (slowk*ad)+(one_minus_slowk*slowEMA);
         outReal[outIdx++] = fastEMA - slowEMA;
      }
      outNBElement.value = outIdx;
      return RetCode.Success ;
   }
   public int adOscStateInit( struct TA_adOsc_State** _state,
      int optInFastPeriod,
      int optInSlowPeriod )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if( (int)optInFastPeriod == ( Integer.MIN_VALUE ) )
         optInFastPeriod = 3;
      else if( ((int)optInFastPeriod < 2) || ((int)optInFastPeriod > 100000) )
         return RetCode.BadParam ;
      if( (int)optInSlowPeriod == ( Integer.MIN_VALUE ) )
         optInSlowPeriod = 10;
      else if( ((int)optInSlowPeriod < 2) || ((int)optInSlowPeriod > 100000) )
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct adOsc ));
      _state.value .value .mem_index = 0;
      _state.value .value .optInFastPeriod = optInFastPeriod;
      _state.value .value .optInSlowPeriod = optInSlowPeriod;
      _state.value .value .mem_size = adOscLookback (optInFastPeriod, optInSlowPeriod );
      if ( _state.value .value .mem_size > 0)
         _state.value .value .memory = TA_Calloc( _state.value .value .mem_size , sizeof(struct TA_ADOSC_Data));
      else
         _state.value .value .memory = NULL;
      return RetCode.Success ;
   }
   public int adOscState( struct TA_adOsc_State* _state,
      double inHigh,
      double inLow,
      double inClose,
      double inVolume,
      double *outReal )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      size_t _cur_idx = _state.value .mem_index++;
      if ( _state.value .mem_size > 0) _cur_idx %= _state.value .mem_size ;
      if ( _state.value .mem_size > _state.value .mem_index - 1 ) {
         ( _state.value .memory+_cur_idx).value .inHigh = inHigh ;
         ( _state.value .memory+_cur_idx).value .inLow = inLow ;
         ( _state.value .memory+_cur_idx).value .inClose = inClose ;
         ( _state.value .memory+_cur_idx).value .inVolume = inVolume ;
         return RetCode.NeedMoreData ; }
      return RetCode.Success ;
   }
   public int adOscStateFree( struct TA_adOsc_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if ( _state.value != NULL) {
         if ( _state.value .value .memory != NULL) TA_Free( _state.value .value .memory );
         TA_Free( _state.value ); _state.value = NULL;}
      return RetCode.Success ;
   }
   public RetCode adOsc( int startIdx,
      int endIdx,
      float inHigh[],
      float inLow[],
      float inClose[],
      float inVolume[],
      int optInFastPeriod,
      int optInSlowPeriod,
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      int today, outIdx, lookbackTotal;
      int slowestPeriod;
      double high, low, close, tmp;
      double slowEMA, slowk, one_minus_slowk;
      double fastEMA, fastk, one_minus_fastk;
      double ad;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      if( (int)optInFastPeriod == ( Integer.MIN_VALUE ) )
         optInFastPeriod = 3;
      else if( ((int)optInFastPeriod < 2) || ((int)optInFastPeriod > 100000) )
         return RetCode.BadParam ;
      if( (int)optInSlowPeriod == ( Integer.MIN_VALUE ) )
         optInSlowPeriod = 10;
      else if( ((int)optInSlowPeriod < 2) || ((int)optInSlowPeriod > 100000) )
         return RetCode.BadParam ;
      if( optInFastPeriod < optInSlowPeriod )
         slowestPeriod = optInSlowPeriod;
      else
         slowestPeriod = optInFastPeriod;
      lookbackTotal = emaLookback ( slowestPeriod );
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      outBegIdx.value = startIdx;
      today = startIdx-lookbackTotal;
      ad = 0.0;
      fastk = ((double)2.0 / ((double)(optInFastPeriod + 1))) ;
      one_minus_fastk = 1.0 - fastk;
      slowk = ((double)2.0 / ((double)(optInSlowPeriod + 1))) ;
      one_minus_slowk = 1.0 - slowk;
      { high = inHigh[today]; low = inLow[today]; tmp = high-low; close = inClose[today]; if( tmp > 0.0 ) ad += (((close-low)-(high-close))/tmp)*((double)inVolume[today]); today++; } ;
      fastEMA = ad;
      slowEMA = ad;
      while( today < startIdx )
      {
         { high = inHigh[today]; low = inLow[today]; tmp = high-low; close = inClose[today]; if( tmp > 0.0 ) ad += (((close-low)-(high-close))/tmp)*((double)inVolume[today]); today++; } ;
         fastEMA = (fastk*ad)+(one_minus_fastk*fastEMA);
         slowEMA = (slowk*ad)+(one_minus_slowk*slowEMA);
      }
      outIdx = 0;
      while( today <= endIdx )
      {
         { high = inHigh[today]; low = inLow[today]; tmp = high-low; close = inClose[today]; if( tmp > 0.0 ) ad += (((close-low)-(high-close))/tmp)*((double)inVolume[today]); today++; } ;
         fastEMA = (fastk*ad)+(one_minus_fastk*fastEMA);
         slowEMA = (slowk*ad)+(one_minus_slowk*slowEMA);
         outReal[outIdx++] = fastEMA - slowEMA;
      }
      outNBElement.value = outIdx;
      return RetCode.Success ;
   }
   /* Generated */
   public int adxLookback( int optInTimePeriod )
   {
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 14;
      else if( ((int)optInTimePeriod < 2) || ((int)optInTimePeriod > 100000) )
         return -1;
      return (2 * optInTimePeriod) + (this.unstablePeriod[FuncUnstId.Adx.ordinal()]) - 1;
   }
   public RetCode adx( int startIdx,
      int endIdx,
      double inHigh[],
      double inLow[],
      double inClose[],
      int optInTimePeriod,
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      int today, lookbackTotal, outIdx;
      double prevHigh, prevLow, prevClose;
      double prevMinusDM, prevPlusDM, prevTR;
      double tempReal, tempReal2, diffP, diffM;
      double minusDI, plusDI, sumDX, prevADX;
      int i;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 14;
      else if( ((int)optInTimePeriod < 2) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      lookbackTotal = (2*optInTimePeriod) + (this.unstablePeriod[FuncUnstId.Adx.ordinal()]) - 1;
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      outIdx = 0;
      outBegIdx.value = today = startIdx;
      prevMinusDM = 0.0;
      prevPlusDM = 0.0;
      prevTR = 0.0;
      today = startIdx - lookbackTotal;
      prevHigh = inHigh[today];
      prevLow = inLow[today];
      prevClose = inClose[today];
      i = optInTimePeriod-1;
      while( i-- > 0 )
      {
         today++;
         tempReal = inHigh[today];
         diffP = tempReal-prevHigh;
         prevHigh = tempReal;
         tempReal = inLow[today];
         diffM = prevLow-tempReal;
         prevLow = tempReal;
         if( (diffM > 0) && (diffP < diffM) )
         {
            prevMinusDM += diffM;
         }
         else if( (diffP > 0) && (diffP > diffM) )
         {
            prevPlusDM += diffP;
         }
         { tempReal = prevHigh-prevLow; tempReal2 = Math.abs (prevHigh-prevClose); if( tempReal2 > tempReal ) tempReal = tempReal2; tempReal2 = Math.abs (prevLow-prevClose); if( tempReal2 > tempReal ) tempReal = tempReal2; } ;
         prevTR += tempReal;
         prevClose = inClose[today];
      }
      sumDX = 0.0;
      i = optInTimePeriod;
      while( i-- > 0 )
      {
         today++;
         tempReal = inHigh[today];
         diffP = tempReal-prevHigh;
         prevHigh = tempReal;
         tempReal = inLow[today];
         diffM = prevLow-tempReal;
         prevLow = tempReal;
         prevMinusDM -= prevMinusDM/optInTimePeriod;
         prevPlusDM -= prevPlusDM/optInTimePeriod;
         if( (diffM > 0) && (diffP < diffM) )
         {
            prevMinusDM += diffM;
         }
         else if( (diffP > 0) && (diffP > diffM) )
         {
            prevPlusDM += diffP;
         }
         { tempReal = prevHigh-prevLow; tempReal2 = Math.abs (prevHigh-prevClose); if( tempReal2 > tempReal ) tempReal = tempReal2; tempReal2 = Math.abs (prevLow-prevClose); if( tempReal2 > tempReal ) tempReal = tempReal2; } ;
         prevTR = prevTR - (prevTR/optInTimePeriod) + tempReal;
         prevClose = inClose[today];
         if( ! (((- (0.00000000000001) )<prevTR)&&(prevTR< (0.00000000000001) )) )
         {
            minusDI = (100.0*(prevMinusDM/prevTR)) ;
            plusDI = (100.0*(prevPlusDM/prevTR)) ;
            tempReal = minusDI+plusDI;
            if( ! (((- (0.00000000000001) )<tempReal)&&(tempReal< (0.00000000000001) )) )
               sumDX += (100.0 * ( Math.abs (minusDI-plusDI)/tempReal)) ;
         }
      }
      prevADX = (sumDX / optInTimePeriod) ;
      i = (this.unstablePeriod[FuncUnstId.Adx.ordinal()]) ;
      while( i-- > 0 )
      {
         today++;
         tempReal = inHigh[today];
         diffP = tempReal-prevHigh;
         prevHigh = tempReal;
         tempReal = inLow[today];
         diffM = prevLow-tempReal;
         prevLow = tempReal;
         prevMinusDM -= prevMinusDM/optInTimePeriod;
         prevPlusDM -= prevPlusDM/optInTimePeriod;
         if( (diffM > 0) && (diffP < diffM) )
         {
            prevMinusDM += diffM;
         }
         else if( (diffP > 0) && (diffP > diffM) )
         {
            prevPlusDM += diffP;
         }
         { tempReal = prevHigh-prevLow; tempReal2 = Math.abs (prevHigh-prevClose); if( tempReal2 > tempReal ) tempReal = tempReal2; tempReal2 = Math.abs (prevLow-prevClose); if( tempReal2 > tempReal ) tempReal = tempReal2; } ;
         prevTR = prevTR - (prevTR/optInTimePeriod) + tempReal;
         prevClose = inClose[today];
         if( ! (((- (0.00000000000001) )<prevTR)&&(prevTR< (0.00000000000001) )) )
         {
            minusDI = (100.0*(prevMinusDM/prevTR)) ;
            plusDI = (100.0*(prevPlusDM/prevTR)) ;
            tempReal = minusDI+plusDI;
            if( ! (((- (0.00000000000001) )<tempReal)&&(tempReal< (0.00000000000001) )) )
            {
               tempReal = (100.0*( Math.abs (minusDI-plusDI)/tempReal)) ;
               prevADX = (((prevADX*(optInTimePeriod-1))+tempReal)/optInTimePeriod) ;
            }
         }
      }
      outReal[0] = prevADX;
      outIdx = 1;
      while( today < endIdx )
      {
         today++;
         tempReal = inHigh[today];
         diffP = tempReal-prevHigh;
         prevHigh = tempReal;
         tempReal = inLow[today];
         diffM = prevLow-tempReal;
         prevLow = tempReal;
         prevMinusDM -= prevMinusDM/optInTimePeriod;
         prevPlusDM -= prevPlusDM/optInTimePeriod;
         if( (diffM > 0) && (diffP < diffM) )
         {
            prevMinusDM += diffM;
         }
         else if( (diffP > 0) && (diffP > diffM) )
         {
            prevPlusDM += diffP;
         }
         { tempReal = prevHigh-prevLow; tempReal2 = Math.abs (prevHigh-prevClose); if( tempReal2 > tempReal ) tempReal = tempReal2; tempReal2 = Math.abs (prevLow-prevClose); if( tempReal2 > tempReal ) tempReal = tempReal2; } ;
         prevTR = prevTR - (prevTR/optInTimePeriod) + tempReal;
         prevClose = inClose[today];
         if( ! (((- (0.00000000000001) )<prevTR)&&(prevTR< (0.00000000000001) )) )
         {
            minusDI = (100.0*(prevMinusDM/prevTR)) ;
            plusDI = (100.0*(prevPlusDM/prevTR)) ;
            tempReal = minusDI+plusDI;
            if( ! (((- (0.00000000000001) )<tempReal)&&(tempReal< (0.00000000000001) )) )
            {
               tempReal = (100.0*( Math.abs (minusDI-plusDI)/tempReal)) ;
               prevADX = (((prevADX*(optInTimePeriod-1))+tempReal)/optInTimePeriod) ;
            }
         }
         outReal[outIdx++] = prevADX;
      }
      outNBElement.value = outIdx;
      return RetCode.Success ;
   }
   public int adxStateInit( struct TA_adx_State** _state,
      int optInTimePeriod )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 14;
      else if( ((int)optInTimePeriod < 2) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct adx ));
      _state.value .value .mem_index = 0;
      _state.value .value .optInTimePeriod = optInTimePeriod;
      _state.value .value .mem_size = adxLookback (optInTimePeriod );
      if ( _state.value .value .mem_size > 0)
         _state.value .value .memory = TA_Calloc( _state.value .value .mem_size , sizeof(struct TA_ADX_Data));
      else
         _state.value .value .memory = NULL;
      return RetCode.Success ;
   }
   public int adxState( struct TA_adx_State* _state,
      double inHigh,
      double inLow,
      double inClose,
      double *outReal )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      size_t _cur_idx = _state.value .mem_index++;
      if ( _state.value .mem_size > 0) _cur_idx %= _state.value .mem_size ;
      if ( _state.value .mem_size > _state.value .mem_index - 1 ) {
         ( _state.value .memory+_cur_idx).value .inHigh = inHigh ;
         ( _state.value .memory+_cur_idx).value .inLow = inLow ;
         ( _state.value .memory+_cur_idx).value .inClose = inClose ;
         return RetCode.NeedMoreData ; }
      return RetCode.Success ;
   }
   public int adxStateFree( struct TA_adx_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if ( _state.value != NULL) {
         if ( _state.value .value .memory != NULL) TA_Free( _state.value .value .memory );
         TA_Free( _state.value ); _state.value = NULL;}
      return RetCode.Success ;
   }
   public RetCode adx( int startIdx,
      int endIdx,
      float inHigh[],
      float inLow[],
      float inClose[],
      int optInTimePeriod,
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      int today, lookbackTotal, outIdx;
      double prevHigh, prevLow, prevClose;
      double prevMinusDM, prevPlusDM, prevTR;
      double tempReal, tempReal2, diffP, diffM;
      double minusDI, plusDI, sumDX, prevADX;
      int i;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 14;
      else if( ((int)optInTimePeriod < 2) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      lookbackTotal = (2*optInTimePeriod) + (this.unstablePeriod[FuncUnstId.Adx.ordinal()]) - 1;
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      outIdx = 0;
      outBegIdx.value = today = startIdx;
      prevMinusDM = 0.0;
      prevPlusDM = 0.0;
      prevTR = 0.0;
      today = startIdx - lookbackTotal;
      prevHigh = inHigh[today];
      prevLow = inLow[today];
      prevClose = inClose[today];
      i = optInTimePeriod-1;
      while( i-- > 0 )
      {
         today++;
         tempReal = inHigh[today];
         diffP = tempReal-prevHigh;
         prevHigh = tempReal;
         tempReal = inLow[today];
         diffM = prevLow-tempReal;
         prevLow = tempReal;
         if( (diffM > 0) && (diffP < diffM) )
         {
            prevMinusDM += diffM;
         }
         else if( (diffP > 0) && (diffP > diffM) )
         {
            prevPlusDM += diffP;
         }
         { tempReal = prevHigh-prevLow; tempReal2 = Math.abs (prevHigh-prevClose); if( tempReal2 > tempReal ) tempReal = tempReal2; tempReal2 = Math.abs (prevLow-prevClose); if( tempReal2 > tempReal ) tempReal = tempReal2; } ;
         prevTR += tempReal;
         prevClose = inClose[today];
      }
      sumDX = 0.0;
      i = optInTimePeriod;
      while( i-- > 0 )
      {
         today++;
         tempReal = inHigh[today];
         diffP = tempReal-prevHigh;
         prevHigh = tempReal;
         tempReal = inLow[today];
         diffM = prevLow-tempReal;
         prevLow = tempReal;
         prevMinusDM -= prevMinusDM/optInTimePeriod;
         prevPlusDM -= prevPlusDM/optInTimePeriod;
         if( (diffM > 0) && (diffP < diffM) )
         {
            prevMinusDM += diffM;
         }
         else if( (diffP > 0) && (diffP > diffM) )
         {
            prevPlusDM += diffP;
         }
         { tempReal = prevHigh-prevLow; tempReal2 = Math.abs (prevHigh-prevClose); if( tempReal2 > tempReal ) tempReal = tempReal2; tempReal2 = Math.abs (prevLow-prevClose); if( tempReal2 > tempReal ) tempReal = tempReal2; } ;
         prevTR = prevTR - (prevTR/optInTimePeriod) + tempReal;
         prevClose = inClose[today];
         if( ! (((- (0.00000000000001) )<prevTR)&&(prevTR< (0.00000000000001) )) )
         {
            minusDI = (100.0*(prevMinusDM/prevTR)) ;
            plusDI = (100.0*(prevPlusDM/prevTR)) ;
            tempReal = minusDI+plusDI;
            if( ! (((- (0.00000000000001) )<tempReal)&&(tempReal< (0.00000000000001) )) )
               sumDX += (100.0 * ( Math.abs (minusDI-plusDI)/tempReal)) ;
         }
      }
      prevADX = (sumDX / optInTimePeriod) ;
      i = (this.unstablePeriod[FuncUnstId.Adx.ordinal()]) ;
      while( i-- > 0 )
      {
         today++;
         tempReal = inHigh[today];
         diffP = tempReal-prevHigh;
         prevHigh = tempReal;
         tempReal = inLow[today];
         diffM = prevLow-tempReal;
         prevLow = tempReal;
         prevMinusDM -= prevMinusDM/optInTimePeriod;
         prevPlusDM -= prevPlusDM/optInTimePeriod;
         if( (diffM > 0) && (diffP < diffM) )
         {
            prevMinusDM += diffM;
         }
         else if( (diffP > 0) && (diffP > diffM) )
         {
            prevPlusDM += diffP;
         }
         { tempReal = prevHigh-prevLow; tempReal2 = Math.abs (prevHigh-prevClose); if( tempReal2 > tempReal ) tempReal = tempReal2; tempReal2 = Math.abs (prevLow-prevClose); if( tempReal2 > tempReal ) tempReal = tempReal2; } ;
         prevTR = prevTR - (prevTR/optInTimePeriod) + tempReal;
         prevClose = inClose[today];
         if( ! (((- (0.00000000000001) )<prevTR)&&(prevTR< (0.00000000000001) )) )
         {
            minusDI = (100.0*(prevMinusDM/prevTR)) ;
            plusDI = (100.0*(prevPlusDM/prevTR)) ;
            tempReal = minusDI+plusDI;
            if( ! (((- (0.00000000000001) )<tempReal)&&(tempReal< (0.00000000000001) )) )
            {
               tempReal = (100.0*( Math.abs (minusDI-plusDI)/tempReal)) ;
               prevADX = (((prevADX*(optInTimePeriod-1))+tempReal)/optInTimePeriod) ;
            }
         }
      }
      outReal[0] = prevADX;
      outIdx = 1;
      while( today < endIdx )
      {
         today++;
         tempReal = inHigh[today];
         diffP = tempReal-prevHigh;
         prevHigh = tempReal;
         tempReal = inLow[today];
         diffM = prevLow-tempReal;
         prevLow = tempReal;
         prevMinusDM -= prevMinusDM/optInTimePeriod;
         prevPlusDM -= prevPlusDM/optInTimePeriod;
         if( (diffM > 0) && (diffP < diffM) )
         {
            prevMinusDM += diffM;
         }
         else if( (diffP > 0) && (diffP > diffM) )
         {
            prevPlusDM += diffP;
         }
         { tempReal = prevHigh-prevLow; tempReal2 = Math.abs (prevHigh-prevClose); if( tempReal2 > tempReal ) tempReal = tempReal2; tempReal2 = Math.abs (prevLow-prevClose); if( tempReal2 > tempReal ) tempReal = tempReal2; } ;
         prevTR = prevTR - (prevTR/optInTimePeriod) + tempReal;
         prevClose = inClose[today];
         if( ! (((- (0.00000000000001) )<prevTR)&&(prevTR< (0.00000000000001) )) )
         {
            minusDI = (100.0*(prevMinusDM/prevTR)) ;
            plusDI = (100.0*(prevPlusDM/prevTR)) ;
            tempReal = minusDI+plusDI;
            if( ! (((- (0.00000000000001) )<tempReal)&&(tempReal< (0.00000000000001) )) )
            {
               tempReal = (100.0*( Math.abs (minusDI-plusDI)/tempReal)) ;
               prevADX = (((prevADX*(optInTimePeriod-1))+tempReal)/optInTimePeriod) ;
            }
         }
         outReal[outIdx++] = prevADX;
      }
      outNBElement.value = outIdx;
      return RetCode.Success ;
   }
   /* Generated */
   public int adxrLookback( int optInTimePeriod )
   {
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 14;
      else if( ((int)optInTimePeriod < 2) || ((int)optInTimePeriod > 100000) )
         return -1;
      if( optInTimePeriod > 1 )
         return optInTimePeriod + adxLookback ( optInTimePeriod) - 1;
      else
         return 3;
   }
   public RetCode adxr( int startIdx,
      int endIdx,
      double inHigh[],
      double inLow[],
      double inClose[],
      int optInTimePeriod,
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      double []adx ;
      int adxrLookback, i, j, outIdx, nbElement;
      RetCode retCode;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 14;
      else if( ((int)optInTimePeriod < 2) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      adxrLookback = adxrLookback ( optInTimePeriod );
      if( startIdx < adxrLookback )
         startIdx = adxrLookback;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      adx = new double[endIdx-startIdx+optInTimePeriod] ;
      retCode = adx ( startIdx-(optInTimePeriod-1), endIdx,
         inHigh, inLow, inClose,
         optInTimePeriod, outBegIdx, outNBElement, adx );
      if( retCode != RetCode.Success )
      {
         return retCode;
      }
      i = optInTimePeriod-1;
      j = 0;
      outIdx = 0;
      nbElement = endIdx-startIdx+2;
      while( --nbElement != 0 )
         outReal[outIdx++] = ((adx[i++]+adx[j++])/2.0) ;
      outBegIdx.value = startIdx;
      outNBElement.value = outIdx;
      return RetCode.Success ;
   }
   public int adxrStateInit( struct TA_adxr_State** _state,
      int optInTimePeriod )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 14;
      else if( ((int)optInTimePeriod < 2) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct adxr ));
      _state.value .value .mem_index = 0;
      _state.value .value .optInTimePeriod = optInTimePeriod;
      _state.value .value .mem_size = adxrLookback (optInTimePeriod );
      if ( _state.value .value .mem_size > 0)
         _state.value .value .memory = TA_Calloc( _state.value .value .mem_size , sizeof(struct TA_ADXR_Data));
      else
         _state.value .value .memory = NULL;
      return RetCode.Success ;
   }
   public int adxrState( struct TA_adxr_State* _state,
      double inHigh,
      double inLow,
      double inClose,
      double *outReal )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      size_t _cur_idx = _state.value .mem_index++;
      if ( _state.value .mem_size > 0) _cur_idx %= _state.value .mem_size ;
      if ( _state.value .mem_size > _state.value .mem_index - 1 ) {
         ( _state.value .memory+_cur_idx).value .inHigh = inHigh ;
         ( _state.value .memory+_cur_idx).value .inLow = inLow ;
         ( _state.value .memory+_cur_idx).value .inClose = inClose ;
         return RetCode.NeedMoreData ; }
      return RetCode.Success ;
   }
   public int adxrStateFree( struct TA_adxr_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if ( _state.value != NULL) {
         if ( _state.value .value .memory != NULL) TA_Free( _state.value .value .memory );
         TA_Free( _state.value ); _state.value = NULL;}
      return RetCode.Success ;
   }
   public RetCode adxr( int startIdx,
      int endIdx,
      float inHigh[],
      float inLow[],
      float inClose[],
      int optInTimePeriod,
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      double []adx ;
      int adxrLookback, i, j, outIdx, nbElement;
      RetCode retCode;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 14;
      else if( ((int)optInTimePeriod < 2) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      adxrLookback = adxrLookback ( optInTimePeriod );
      if( startIdx < adxrLookback )
         startIdx = adxrLookback;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      adx = new double[endIdx-startIdx+optInTimePeriod] ;
      retCode = adx ( startIdx-(optInTimePeriod-1), endIdx,
         inHigh, inLow, inClose,
         optInTimePeriod, outBegIdx, outNBElement, adx );
      if( retCode != RetCode.Success )
      {
         return retCode;
      }
      i = optInTimePeriod-1;
      j = 0;
      outIdx = 0;
      nbElement = endIdx-startIdx+2;
      while( --nbElement != 0 )
         outReal[outIdx++] = ((adx[i++]+adx[j++])/2.0) ;
      outBegIdx.value = startIdx;
      outNBElement.value = outIdx;
      return RetCode.Success ;
   }
   /* Generated */
   public int apoLookback( int optInFastPeriod,
      int optInSlowPeriod,
      MAType optInMAType )
   {
      if( (int)optInFastPeriod == ( Integer.MIN_VALUE ) )
         optInFastPeriod = 12;
      else if( ((int)optInFastPeriod < 2) || ((int)optInFastPeriod > 100000) )
         return -1;
      if( (int)optInSlowPeriod == ( Integer.MIN_VALUE ) )
         optInSlowPeriod = 26;
      else if( ((int)optInSlowPeriod < 2) || ((int)optInSlowPeriod > 100000) )
         return -1;
      return movingAverageLookback ( (((optInSlowPeriod) > (optInFastPeriod)) ? (optInSlowPeriod) : (optInFastPeriod)) , optInMAType );
   }
   public RetCode apo( int startIdx,
      int endIdx,
      double inReal[],
      int optInFastPeriod,
      int optInSlowPeriod,
      MAType optInMAType, MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      double []tempBuffer ;
      RetCode retCode;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      if( (int)optInFastPeriod == ( Integer.MIN_VALUE ) )
         optInFastPeriod = 12;
      else if( ((int)optInFastPeriod < 2) || ((int)optInFastPeriod > 100000) )
         return RetCode.BadParam ;
      if( (int)optInSlowPeriod == ( Integer.MIN_VALUE ) )
         optInSlowPeriod = 26;
      else if( ((int)optInSlowPeriod < 2) || ((int)optInSlowPeriod > 100000) )
         return RetCode.BadParam ;
      tempBuffer = new double[(endIdx-startIdx+1)] ;
      retCode = TA_INT_PO ( startIdx, endIdx,
         inReal,
         optInFastPeriod,
         optInSlowPeriod,
         optInMAType,
         outBegIdx,
         outNBElement,
         outReal,
         tempBuffer,
         0 );
      return retCode;
   }
   RetCode TA_INT_PO( int startIdx,
      int endIdx,
      double inReal[],
      int optInFastPeriod,
      int optInSlowPeriod,
      MAType optInMethod_2,
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[],
      double tempBuffer[],
      int doPercentageOutput )
   {
      RetCode retCode;
      double tempReal;
      int tempInteger;
      MInteger outBegIdx1 = new MInteger() ;
      MInteger outNbElement1 = new MInteger() ;
      MInteger outBegIdx2 = new MInteger() ;
      MInteger outNbElement2 = new MInteger() ;
      int i, j;
      if( optInSlowPeriod < optInFastPeriod )
      {
         tempInteger = optInSlowPeriod;
         optInSlowPeriod = optInFastPeriod;
         optInFastPeriod = tempInteger;
      }
      retCode = movingAverage ( startIdx, endIdx,
         inReal,
         optInFastPeriod,
         optInMethod_2,
         outBegIdx2 , outNbElement2 ,
         tempBuffer );
      if( retCode == RetCode.Success )
      {
         retCode = movingAverage ( startIdx, endIdx,
            inReal,
            optInSlowPeriod,
            optInMethod_2,
            outBegIdx1 , outNbElement1 ,
            outReal );
         if( retCode == RetCode.Success )
         {
            tempInteger = outBegIdx1.value - outBegIdx2.value ;
            if( doPercentageOutput != 0 )
            {
               for( i=0,j=tempInteger; i < outNbElement1.value ; i++, j++ )
               {
                  tempReal = outReal[i];
                  if( ! (((- (0.00000000000001) )<tempReal)&&(tempReal< (0.00000000000001) )) )
                     outReal[i] = ((tempBuffer[j]-tempReal)/tempReal)*100.0;
                  else
                     outReal[i] = 0.0;
               }
            }
            else
            {
               for( i=0,j=tempInteger; i < outNbElement1.value ; i++, j++ )
                  outReal[i] = tempBuffer[j]-outReal[i];
            }
            outBegIdx.value = outBegIdx1.value ;
            outNBElement.value = outNbElement1.value ;
         }
      }
      if( retCode != RetCode.Success )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
      }
      return retCode;
   }
   public int apoStateInit( struct TA_apo_State** _state,
      int optInFastPeriod,
      int optInSlowPeriod,
      MAType optInMAType )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if( (int)optInFastPeriod == ( Integer.MIN_VALUE ) )
         optInFastPeriod = 12;
      else if( ((int)optInFastPeriod < 2) || ((int)optInFastPeriod > 100000) )
         return RetCode.BadParam ;
      if( (int)optInSlowPeriod == ( Integer.MIN_VALUE ) )
         optInSlowPeriod = 26;
      else if( ((int)optInSlowPeriod < 2) || ((int)optInSlowPeriod > 100000) )
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct apo ));
      _state.value .value .mem_index = 0;
      _state.value .value .optInFastPeriod = optInFastPeriod;
      _state.value .value .optInSlowPeriod = optInSlowPeriod;
      _state.value .value .optInMAType = optInMAType;
      _state.value .value .mem_size = apoLookback (optInFastPeriod, optInSlowPeriod, optInMAType );
      if ( _state.value .value .mem_size > 0)
         _state.value .value .memory = TA_Calloc( _state.value .value .mem_size , sizeof(struct TA_APO_Data));
      else
         _state.value .value .memory = NULL;
      return RetCode.Success ;
   }
   public int apoState( struct TA_apo_State* _state,
      double inReal,
      double *outReal )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      size_t _cur_idx = _state.value .mem_index++;
      if ( _state.value .mem_size > 0) _cur_idx %= _state.value .mem_size ;
      if ( _state.value .mem_size > _state.value .mem_index - 1 ) {
         ( _state.value .memory+_cur_idx).value .inReal = inReal ;
         return RetCode.NeedMoreData ; }
      return RetCode.Success ;
   }
   public int apoStateFree( struct TA_apo_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if ( _state.value != NULL) {
         if ( _state.value .value .memory != NULL) TA_Free( _state.value .value .memory );
         TA_Free( _state.value ); _state.value = NULL;}
      return RetCode.Success ;
   }
   public RetCode apo( int startIdx,
      int endIdx,
      float inReal[],
      int optInFastPeriod,
      int optInSlowPeriod,
      MAType optInMAType, MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      double []tempBuffer ;
      RetCode retCode;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      if( (int)optInFastPeriod == ( Integer.MIN_VALUE ) )
         optInFastPeriod = 12;
      else if( ((int)optInFastPeriod < 2) || ((int)optInFastPeriod > 100000) )
         return RetCode.BadParam ;
      if( (int)optInSlowPeriod == ( Integer.MIN_VALUE ) )
         optInSlowPeriod = 26;
      else if( ((int)optInSlowPeriod < 2) || ((int)optInSlowPeriod > 100000) )
         return RetCode.BadParam ;
      tempBuffer = new double[(endIdx-startIdx+1)] ;
      retCode = TA_INT_PO ( startIdx, endIdx,
         inReal,
         optInFastPeriod,
         optInSlowPeriod,
         optInMAType,
         outBegIdx,
         outNBElement,
         outReal,
         tempBuffer,
         0 );
      return retCode;
   }
   RetCode TA_INT_PO( int startIdx,
      int endIdx,
      float inReal[],
      int optInFastPeriod,
      int optInSlowPeriod,
      MAType optInMethod_2,
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[],
      double tempBuffer[],
      int doPercentageOutput )
   {
      RetCode retCode;
      double tempReal;
      int tempInteger;
      MInteger outBegIdx1 = new MInteger() ;
      MInteger outNbElement1 = new MInteger() ;
      MInteger outBegIdx2 = new MInteger() ;
      MInteger outNbElement2 = new MInteger() ;
      int i, j;
      if( optInSlowPeriod < optInFastPeriod )
      {
         tempInteger = optInSlowPeriod;
         optInSlowPeriod = optInFastPeriod;
         optInFastPeriod = tempInteger;
      }
      retCode = movingAverage ( startIdx, endIdx,
         inReal,
         optInFastPeriod,
         optInMethod_2,
         outBegIdx2 , outNbElement2 ,
         tempBuffer );
      if( retCode == RetCode.Success )
      {
         retCode = movingAverage ( startIdx, endIdx,
            inReal,
            optInSlowPeriod,
            optInMethod_2,
            outBegIdx1 , outNbElement1 ,
            outReal );
         if( retCode == RetCode.Success )
         {
            tempInteger = outBegIdx1.value - outBegIdx2.value ;
            if( doPercentageOutput != 0 )
            {
               for( i=0,j=tempInteger; i < outNbElement1.value ; i++, j++ )
               {
                  tempReal = outReal[i];
                  if( ! (((- (0.00000000000001) )<tempReal)&&(tempReal< (0.00000000000001) )) )
                     outReal[i] = ((tempBuffer[j]-tempReal)/tempReal)*100.0;
                  else
                     outReal[i] = 0.0;
               }
            }
            else
            {
               for( i=0,j=tempInteger; i < outNbElement1.value ; i++, j++ )
                  outReal[i] = tempBuffer[j]-outReal[i];
            }
            outBegIdx.value = outBegIdx1.value ;
            outNBElement.value = outNbElement1.value ;
         }
      }
      if( retCode != RetCode.Success )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
      }
      return retCode;
   }
   /* Generated */
   public int aroonLookback( int optInTimePeriod )
   {
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 14;
      else if( ((int)optInTimePeriod < 2) || ((int)optInTimePeriod > 100000) )
         return -1;
      return optInTimePeriod;
   }
   public RetCode aroon( int startIdx,
      int endIdx,
      double inHigh[],
      double inLow[],
      int optInTimePeriod,
      MInteger outBegIdx,
      MInteger outNBElement,
      double outAroonDown[],
      double outAroonUp[] )
   {
      double lowest, highest, tmp, factor;
      int outIdx;
      int trailingIdx, lowestIdx, highestIdx, today, i;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 14;
      else if( ((int)optInTimePeriod < 2) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      if( startIdx < optInTimePeriod )
         startIdx = optInTimePeriod;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      outIdx = 0;
      today = startIdx;
      trailingIdx = startIdx-optInTimePeriod;
      lowestIdx = -1;
      highestIdx = -1;
      lowest = 0.0;
      highest = 0.0;
      factor = (double)100.0/(double)optInTimePeriod;
      while( today <= endIdx )
      {
         tmp = inLow[today];
         if( lowestIdx < trailingIdx )
         {
            lowestIdx = trailingIdx;
            lowest = inLow[lowestIdx];
            i = lowestIdx;
            while( ++i<=today )
            {
               tmp = inLow[i];
               if( tmp <= lowest )
               {
                  lowestIdx = i;
                  lowest = tmp;
               }
            }
         }
         else if( tmp <= lowest )
         {
            lowestIdx = today;
            lowest = tmp;
         }
         tmp = inHigh[today];
         if( highestIdx < trailingIdx )
         {
            highestIdx = trailingIdx;
            highest = inHigh[highestIdx];
            i = highestIdx;
            while( ++i<=today )
            {
               tmp = inHigh[i];
               if( tmp >= highest )
               {
                  highestIdx = i;
                  highest = tmp;
               }
            }
         }
         else if( tmp >= highest )
         {
            highestIdx = today;
            highest = tmp;
         }
         outAroonUp[outIdx] = factor*(optInTimePeriod-(today-highestIdx));
         outAroonDown[outIdx] = factor*(optInTimePeriod-(today-lowestIdx));
         outIdx++;
         trailingIdx++;
         today++;
      }
      outBegIdx.value = startIdx;
      outNBElement.value = outIdx;
      return RetCode.Success ;
   }
   public int aroonStateInit( struct TA_aroon_State** _state,
      int optInTimePeriod )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 14;
      else if( ((int)optInTimePeriod < 2) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct aroon ));
      _state.value .value .mem_index = 0;
      _state.value .value .optInTimePeriod = optInTimePeriod;
      _state.value .value .mem_size = aroonLookback (optInTimePeriod );
      if ( _state.value .value .mem_size > 0)
         _state.value .value .memory = TA_Calloc( _state.value .value .mem_size , sizeof(struct TA_AROON_Data));
      else
         _state.value .value .memory = NULL;
      return RetCode.Success ;
   }
   public int aroonState( struct TA_aroon_State* _state,
      double inHigh,
      double inLow,
      double *outAroonDown,
      double *outAroonUp )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      size_t _cur_idx = _state.value .mem_index++;
      if ( _state.value .mem_size > 0) _cur_idx %= _state.value .mem_size ;
      if ( _state.value .mem_size > _state.value .mem_index - 1 ) {
         ( _state.value .memory+_cur_idx).value .inHigh = inHigh ;
         ( _state.value .memory+_cur_idx).value .inLow = inLow ;
         return RetCode.NeedMoreData ; }
      return RetCode.Success ;
   }
   public int aroonStateFree( struct TA_aroon_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if ( _state.value != NULL) {
         if ( _state.value .value .memory != NULL) TA_Free( _state.value .value .memory );
         TA_Free( _state.value ); _state.value = NULL;}
      return RetCode.Success ;
   }
   public RetCode aroon( int startIdx,
      int endIdx,
      float inHigh[],
      float inLow[],
      int optInTimePeriod,
      MInteger outBegIdx,
      MInteger outNBElement,
      double outAroonDown[],
      double outAroonUp[] )
   {
      double lowest, highest, tmp, factor;
      int outIdx;
      int trailingIdx, lowestIdx, highestIdx, today, i;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 14;
      else if( ((int)optInTimePeriod < 2) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      if( startIdx < optInTimePeriod )
         startIdx = optInTimePeriod;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      outIdx = 0;
      today = startIdx;
      trailingIdx = startIdx-optInTimePeriod;
      lowestIdx = -1;
      highestIdx = -1;
      lowest = 0.0;
      highest = 0.0;
      factor = (double)100.0/(double)optInTimePeriod;
      while( today <= endIdx )
      {
         tmp = inLow[today];
         if( lowestIdx < trailingIdx )
         {
            lowestIdx = trailingIdx;
            lowest = inLow[lowestIdx];
            i = lowestIdx;
            while( ++i<=today )
            {
               tmp = inLow[i];
               if( tmp <= lowest )
               {
                  lowestIdx = i;
                  lowest = tmp;
               }
            }
         }
         else if( tmp <= lowest )
         {
            lowestIdx = today;
            lowest = tmp;
         }
         tmp = inHigh[today];
         if( highestIdx < trailingIdx )
         {
            highestIdx = trailingIdx;
            highest = inHigh[highestIdx];
            i = highestIdx;
            while( ++i<=today )
            {
               tmp = inHigh[i];
               if( tmp >= highest )
               {
                  highestIdx = i;
                  highest = tmp;
               }
            }
         }
         else if( tmp >= highest )
         {
            highestIdx = today;
            highest = tmp;
         }
         outAroonUp[outIdx] = factor*(optInTimePeriod-(today-highestIdx));
         outAroonDown[outIdx] = factor*(optInTimePeriod-(today-lowestIdx));
         outIdx++;
         trailingIdx++;
         today++;
      }
      outBegIdx.value = startIdx;
      outNBElement.value = outIdx;
      return RetCode.Success ;
   }
   /* Generated */
   public int aroonOscLookback( int optInTimePeriod )
   {
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 14;
      else if( ((int)optInTimePeriod < 2) || ((int)optInTimePeriod > 100000) )
         return -1;
      return optInTimePeriod;
   }
   public RetCode aroonOsc( int startIdx,
      int endIdx,
      double inHigh[],
      double inLow[],
      int optInTimePeriod,
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      double lowest, highest, tmp, factor, aroon;
      int outIdx;
      int trailingIdx, lowestIdx, highestIdx, today, i;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 14;
      else if( ((int)optInTimePeriod < 2) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      if( startIdx < optInTimePeriod )
         startIdx = optInTimePeriod;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      outIdx = 0;
      today = startIdx;
      trailingIdx = startIdx-optInTimePeriod;
      lowestIdx = -1;
      highestIdx = -1;
      lowest = 0.0;
      highest = 0.0;
      factor = (double)100.0/(double)optInTimePeriod;
      while( today <= endIdx )
      {
         tmp = inLow[today];
         if( lowestIdx < trailingIdx )
         {
            lowestIdx = trailingIdx;
            lowest = inLow[lowestIdx];
            i = lowestIdx;
            while( ++i<=today )
            {
               tmp = inLow[i];
               if( tmp <= lowest )
               {
                  lowestIdx = i;
                  lowest = tmp;
               }
            }
         }
         else if( tmp <= lowest )
         {
            lowestIdx = today;
            lowest = tmp;
         }
         tmp = inHigh[today];
         if( highestIdx < trailingIdx )
         {
            highestIdx = trailingIdx;
            highest = inHigh[highestIdx];
            i = highestIdx;
            while( ++i<=today )
            {
               tmp = inHigh[i];
               if( tmp >= highest )
               {
                  highestIdx = i;
                  highest = tmp;
               }
            }
         }
         else if( tmp >= highest )
         {
            highestIdx = today;
            highest = tmp;
         }
         aroon = factor*(highestIdx-lowestIdx);
         outReal[outIdx] = aroon;
         outIdx++;
         trailingIdx++;
         today++;
      }
      outBegIdx.value = startIdx;
      outNBElement.value = outIdx;
      return RetCode.Success ;
   }
   public int aroonOscStateInit( struct TA_aroonOsc_State** _state,
      int optInTimePeriod )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 14;
      else if( ((int)optInTimePeriod < 2) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct aroonOsc ));
      _state.value .value .mem_index = 0;
      _state.value .value .optInTimePeriod = optInTimePeriod;
      _state.value .value .mem_size = aroonOscLookback (optInTimePeriod );
      if ( _state.value .value .mem_size > 0)
         _state.value .value .memory = TA_Calloc( _state.value .value .mem_size , sizeof(struct TA_AROONOSC_Data));
      else
         _state.value .value .memory = NULL;
      return RetCode.Success ;
   }
   public int aroonOscState( struct TA_aroonOsc_State* _state,
      double inHigh,
      double inLow,
      double *outReal )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      size_t _cur_idx = _state.value .mem_index++;
      if ( _state.value .mem_size > 0) _cur_idx %= _state.value .mem_size ;
      if ( _state.value .mem_size > _state.value .mem_index - 1 ) {
         ( _state.value .memory+_cur_idx).value .inHigh = inHigh ;
         ( _state.value .memory+_cur_idx).value .inLow = inLow ;
         return RetCode.NeedMoreData ; }
      return RetCode.Success ;
   }
   public int aroonOscStateFree( struct TA_aroonOsc_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if ( _state.value != NULL) {
         if ( _state.value .value .memory != NULL) TA_Free( _state.value .value .memory );
         TA_Free( _state.value ); _state.value = NULL;}
      return RetCode.Success ;
   }
   public RetCode aroonOsc( int startIdx,
      int endIdx,
      float inHigh[],
      float inLow[],
      int optInTimePeriod,
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      double lowest, highest, tmp, factor, aroon;
      int outIdx;
      int trailingIdx, lowestIdx, highestIdx, today, i;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 14;
      else if( ((int)optInTimePeriod < 2) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      if( startIdx < optInTimePeriod )
         startIdx = optInTimePeriod;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      outIdx = 0;
      today = startIdx;
      trailingIdx = startIdx-optInTimePeriod;
      lowestIdx = -1;
      highestIdx = -1;
      lowest = 0.0;
      highest = 0.0;
      factor = (double)100.0/(double)optInTimePeriod;
      while( today <= endIdx )
      {
         tmp = inLow[today];
         if( lowestIdx < trailingIdx )
         {
            lowestIdx = trailingIdx;
            lowest = inLow[lowestIdx];
            i = lowestIdx;
            while( ++i<=today )
            {
               tmp = inLow[i];
               if( tmp <= lowest )
               {
                  lowestIdx = i;
                  lowest = tmp;
               }
            }
         }
         else if( tmp <= lowest )
         {
            lowestIdx = today;
            lowest = tmp;
         }
         tmp = inHigh[today];
         if( highestIdx < trailingIdx )
         {
            highestIdx = trailingIdx;
            highest = inHigh[highestIdx];
            i = highestIdx;
            while( ++i<=today )
            {
               tmp = inHigh[i];
               if( tmp >= highest )
               {
                  highestIdx = i;
                  highest = tmp;
               }
            }
         }
         else if( tmp >= highest )
         {
            highestIdx = today;
            highest = tmp;
         }
         aroon = factor*(highestIdx-lowestIdx);
         outReal[outIdx] = aroon;
         outIdx++;
         trailingIdx++;
         today++;
      }
      outBegIdx.value = startIdx;
      outNBElement.value = outIdx;
      return RetCode.Success ;
   }
   /* Generated */
   public int asinLookback( )
   {
      return RetCode.Success ;
   }
   public RetCode asin( int startIdx,
      int endIdx,
      double inReal[],
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      int outIdx;
      int i;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      for( i=startIdx, outIdx=0; i <= endIdx; i++, outIdx++ )
      {
         outReal[outIdx] = Math.asin (inReal[i]);
      }
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   public int asinStateInit( struct TA_asin_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct asin ));
      _state.value .value .mem_index = 0;
      _state.value .value .mem_size = asinLookback ();
      if ( _state.value .value .mem_size > 0)
         _state.value .value .memory = TA_Calloc( _state.value .value .mem_size , sizeof(struct TA_ASIN_Data));
      else
         _state.value .value .memory = NULL;
      return RetCode.Success ;
   }
   public int asinState( struct TA_asin_State* _state,
      double inReal,
      double *outReal )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      size_t _cur_idx = _state.value .mem_index++;
      if ( _state.value .mem_size > 0) _cur_idx %= _state.value .mem_size ;
      if ( _state.value .mem_size > _state.value .mem_index - 1 ) {
         ( _state.value .memory+_cur_idx).value .inReal = inReal ;
         return RetCode.NeedMoreData ; }
      outReal.value = Math.asin (inReal);
      return RetCode.Success ;
   }
   public int asinStateFree( struct TA_asin_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if ( _state.value != NULL) {
         if ( _state.value .value .memory != NULL) TA_Free( _state.value .value .memory );
         TA_Free( _state.value ); _state.value = NULL;}
      return RetCode.Success ;
   }
   public RetCode asin( int startIdx,
      int endIdx,
      float inReal[],
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      int outIdx;
      int i;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      for( i=startIdx, outIdx=0; i <= endIdx; i++, outIdx++ )
      {
         outReal[outIdx] = Math.asin (inReal[i]);
      }
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   /* Generated */
   public int atanLookback( )
   {
      return RetCode.Success ;
   }
   public RetCode atan( int startIdx,
      int endIdx,
      double inReal[],
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      int outIdx;
      int i;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      for( i=startIdx, outIdx=0; i <= endIdx; i++, outIdx++ )
      {
         outReal[outIdx] = Math.atan (inReal[i]);
      }
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   public int atanStateInit( struct TA_atan_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct atan ));
      _state.value .value .mem_index = 0;
      _state.value .value .mem_size = atanLookback ();
      if ( _state.value .value .mem_size > 0)
         _state.value .value .memory = TA_Calloc( _state.value .value .mem_size , sizeof(struct TA_ATAN_Data));
      else
         _state.value .value .memory = NULL;
      return RetCode.Success ;
   }
   public int atanState( struct TA_atan_State* _state,
      double inReal,
      double *outReal )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      size_t _cur_idx = _state.value .mem_index++;
      if ( _state.value .mem_size > 0) _cur_idx %= _state.value .mem_size ;
      if ( _state.value .mem_size > _state.value .mem_index - 1 ) {
         ( _state.value .memory+_cur_idx).value .inReal = inReal ;
         return RetCode.NeedMoreData ; }
      outReal.value = Math.atan (inReal);
      return RetCode.Success ;
   }
   public int atanStateFree( struct TA_atan_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if ( _state.value != NULL) {
         if ( _state.value .value .memory != NULL) TA_Free( _state.value .value .memory );
         TA_Free( _state.value ); _state.value = NULL;}
      return RetCode.Success ;
   }
   public RetCode atan( int startIdx,
      int endIdx,
      float inReal[],
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      int outIdx;
      int i;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      for( i=startIdx, outIdx=0; i <= endIdx; i++, outIdx++ )
      {
         outReal[outIdx] = Math.atan (inReal[i]);
      }
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   /* Generated */
   public int atrLookback( int optInTimePeriod )
   {
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 14;
      else if( ((int)optInTimePeriod < 1) || ((int)optInTimePeriod > 100000) )
         return -1;
      return optInTimePeriod + (this.unstablePeriod[FuncUnstId.Atr.ordinal()]) ;
   }
   public RetCode atr( int startIdx,
      int endIdx,
      double inHigh[],
      double inLow[],
      double inClose[],
      int optInTimePeriod,
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      RetCode retCode;
      int outIdx, today, lookbackTotal;
      int nbATR;
      MInteger outBegIdx1 = new MInteger() ;
      MInteger outNbElement1 = new MInteger() ;
      double prevATR;
      double []tempBuffer ;
      double []prevATRTemp = new double[1] ;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 14;
      else if( ((int)optInTimePeriod < 1) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      outBegIdx.value = 0 ;
      outNBElement.value = 0 ;
      lookbackTotal = atrLookback ( optInTimePeriod );
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
         return RetCode.Success ;
      if( optInTimePeriod <= 1 )
      {
         return trueRange ( startIdx, endIdx,
            inHigh, inLow, inClose,
            outBegIdx, outNBElement, outReal );
      }
      tempBuffer = new double[lookbackTotal+(endIdx-startIdx)+1] ;
      retCode = trueRange ( (startIdx-lookbackTotal+1), endIdx,
         inHigh, inLow, inClose,
         outBegIdx1 , outNbElement1 ,
         tempBuffer );
      if( retCode != RetCode.Success )
      {
         return retCode;
      }
      retCode = TA_INT_SMA ( optInTimePeriod-1,
         optInTimePeriod-1,
         tempBuffer, optInTimePeriod,
         outBegIdx1 , outNbElement1 ,
         prevATRTemp );
      if( retCode != RetCode.Success )
      {
         return retCode;
      }
      prevATR = prevATRTemp[0];
      today = optInTimePeriod;
      outIdx = (this.unstablePeriod[FuncUnstId.Atr.ordinal()]) ;
      while( outIdx != 0 )
      {
         prevATR *= optInTimePeriod - 1;
         prevATR += tempBuffer[today++];
         prevATR /= optInTimePeriod;
         outIdx--;
      }
      outIdx = 1;
      outReal[0] = prevATR;
      nbATR = (endIdx - startIdx)+1;
      while( --nbATR != 0 )
      {
         prevATR *= optInTimePeriod - 1;
         prevATR += tempBuffer[today++];
         prevATR /= optInTimePeriod;
         outReal[outIdx++] = prevATR;
      }
      outBegIdx.value = startIdx;
      outNBElement.value = outIdx;
      return retCode;
   }
   public int atrStateInit( struct TA_atr_State** _state,
      int optInTimePeriod )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 14;
      else if( ((int)optInTimePeriod < 1) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct atr ));
      _state.value .value .mem_index = 0;
      _state.value .value .optInTimePeriod = optInTimePeriod;
      _state.value .value .mem_size = atrLookback (optInTimePeriod );
      if ( _state.value .value .mem_size > 0)
         _state.value .value .memory = TA_Calloc( _state.value .value .mem_size , sizeof(struct TA_ATR_Data));
      else
         _state.value .value .memory = NULL;
      return RetCode.Success ;
   }
   public int atrState( struct TA_atr_State* _state,
      double inHigh,
      double inLow,
      double inClose,
      double *outReal )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      size_t _cur_idx = _state.value .mem_index++;
      if ( _state.value .mem_size > 0) _cur_idx %= _state.value .mem_size ;
      if ( _state.value .mem_size > _state.value .mem_index - 1 ) {
         ( _state.value .memory+_cur_idx).value .inHigh = inHigh ;
         ( _state.value .memory+_cur_idx).value .inLow = inLow ;
         ( _state.value .memory+_cur_idx).value .inClose = inClose ;
         return RetCode.NeedMoreData ; }
      return RetCode.Success ;
   }
   public int atrStateFree( struct TA_atr_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if ( _state.value != NULL) {
         if ( _state.value .value .memory != NULL) TA_Free( _state.value .value .memory );
         TA_Free( _state.value ); _state.value = NULL;}
      return RetCode.Success ;
   }
   public RetCode atr( int startIdx,
      int endIdx,
      float inHigh[],
      float inLow[],
      float inClose[],
      int optInTimePeriod,
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      RetCode retCode;
      int outIdx, today, lookbackTotal;
      int nbATR;
      MInteger outBegIdx1 = new MInteger() ;
      MInteger outNbElement1 = new MInteger() ;
      double prevATR;
      double []tempBuffer ;
      double []prevATRTemp = new double[1] ;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 14;
      else if( ((int)optInTimePeriod < 1) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      outBegIdx.value = 0 ;
      outNBElement.value = 0 ;
      lookbackTotal = atrLookback ( optInTimePeriod );
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
         return RetCode.Success ;
      if( optInTimePeriod <= 1 )
      {
         return trueRange ( startIdx, endIdx,
            inHigh, inLow, inClose,
            outBegIdx, outNBElement, outReal );
      }
      tempBuffer = new double[lookbackTotal+(endIdx-startIdx)+1] ;
      retCode = trueRange ( (startIdx-lookbackTotal+1), endIdx,
         inHigh, inLow, inClose,
         outBegIdx1 , outNbElement1 ,
         tempBuffer );
      if( retCode != RetCode.Success )
      {
         return retCode;
      }
      retCode = TA_INT_SMA ( optInTimePeriod-1,
         optInTimePeriod-1,
         tempBuffer, optInTimePeriod,
         outBegIdx1 , outNbElement1 ,
         prevATRTemp );
      if( retCode != RetCode.Success )
      {
         return retCode;
      }
      prevATR = prevATRTemp[0];
      today = optInTimePeriod;
      outIdx = (this.unstablePeriod[FuncUnstId.Atr.ordinal()]) ;
      while( outIdx != 0 )
      {
         prevATR *= optInTimePeriod - 1;
         prevATR += tempBuffer[today++];
         prevATR /= optInTimePeriod;
         outIdx--;
      }
      outIdx = 1;
      outReal[0] = prevATR;
      nbATR = (endIdx - startIdx)+1;
      while( --nbATR != 0 )
      {
         prevATR *= optInTimePeriod - 1;
         prevATR += tempBuffer[today++];
         prevATR /= optInTimePeriod;
         outReal[outIdx++] = prevATR;
      }
      outBegIdx.value = startIdx;
      outNBElement.value = outIdx;
      return retCode;
   }
   /* Generated */
   public int avgPriceLookback( )
   {
      return RetCode.Success ;
   }
   public RetCode avgPrice( int startIdx,
      int endIdx,
      double inOpen[],
      double inHigh[],
      double inLow[],
      double inClose[],
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      int outIdx, i;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      outIdx = 0;
      for( i=startIdx; i <= endIdx; i++ )
      {
         outReal[outIdx++] = ( inHigh [i] +
            inLow [i] +
            inClose[i] +
            inOpen [i]) / 4;
      }
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   public int avgPriceStateInit( struct TA_avgPrice_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct avgPrice ));
      _state.value .value .mem_index = 0;
      _state.value .value .mem_size = avgPriceLookback ();
      if ( _state.value .value .mem_size > 0)
         _state.value .value .memory = TA_Calloc( _state.value .value .mem_size , sizeof(struct TA_AVGPRICE_Data));
      else
         _state.value .value .memory = NULL;
      return RetCode.Success ;
   }
   public int avgPriceState( struct TA_avgPrice_State* _state,
      double inOpen,
      double inHigh,
      double inLow,
      double inClose,
      double *outReal )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      size_t _cur_idx = _state.value .mem_index++;
      if ( _state.value .mem_size > 0) _cur_idx %= _state.value .mem_size ;
      if ( _state.value .mem_size > _state.value .mem_index - 1 ) {
         ( _state.value .memory+_cur_idx).value .inOpen = inOpen ;
         ( _state.value .memory+_cur_idx).value .inHigh = inHigh ;
         ( _state.value .memory+_cur_idx).value .inLow = inLow ;
         ( _state.value .memory+_cur_idx).value .inClose = inClose ;
         return RetCode.NeedMoreData ; }
      outReal.value = ( inHigh + inLow + inClose + inOpen) / 4;
      return RetCode.Success ;
   }
   public int avgPriceStateFree( struct TA_avgPrice_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if ( _state.value != NULL) {
         if ( _state.value .value .memory != NULL) TA_Free( _state.value .value .memory );
         TA_Free( _state.value ); _state.value = NULL;}
      return RetCode.Success ;
   }
   public RetCode avgPrice( int startIdx,
      int endIdx,
      float inOpen[],
      float inHigh[],
      float inLow[],
      float inClose[],
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      int outIdx, i;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      outIdx = 0;
      for( i=startIdx; i <= endIdx; i++ )
      {
         outReal[outIdx++] = ( inHigh [i] +
            inLow [i] +
            inClose[i] +
            inOpen [i]) / 4;
      }
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   /* Generated */
   public int avgDevLookback( int optInTimePeriod )
   {
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 14;
      else if( ((int)optInTimePeriod < 2) || ((int)optInTimePeriod > 100000) )
         return -1;
      return optInTimePeriod-1;
   }
   public RetCode avgDev( int startIdx,
      int endIdx,
      double inReal[],
      int optInTimePeriod,
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      int today, outIdx, lookback;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 14;
      else if( ((int)optInTimePeriod < 2) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      lookback = optInTimePeriod - 1;
      if (startIdx < lookback) {
         startIdx = lookback;
      }
      today = startIdx;
      if( today > endIdx ) {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      outBegIdx.value = today;
      outIdx = 0;
      while (today <= endIdx) {
         double todaySum, todayDev;
         int i;
         todaySum = 0.0;
         for (i = 0; i < optInTimePeriod; i++) {
            todaySum += inReal[today-i];
         }
         todayDev = 0.0;
         for (i = 0; i < optInTimePeriod; i++) {
            todayDev += Math.abs (inReal[today-i] - todaySum/optInTimePeriod);
         }
         outReal[outIdx] = todayDev/optInTimePeriod;
         outIdx++;
         today++;
      }
      outNBElement.value = outIdx;
      return RetCode.Success ;
   }
   public int avgDevStateInit( struct TA_avgDev_State** _state,
      int optInTimePeriod )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 14;
      else if( ((int)optInTimePeriod < 2) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct avgDev ));
      _state.value .value .mem_index = 0;
      _state.value .value .optInTimePeriod = optInTimePeriod;
      _state.value .value .mem_size = avgDevLookback (optInTimePeriod );
      if ( _state.value .value .mem_size > 0)
         _state.value .value .memory = TA_Calloc( _state.value .value .mem_size , sizeof(struct TA_AVGDEV_Data));
      else
         _state.value .value .memory = NULL;
      return RetCode.Success ;
   }
   public int avgDevState( struct TA_avgDev_State* _state,
      double inReal,
      double *outReal )
   {
      size_t i;
      double temp;
      if (_state == NULL)
         return RetCode.BadParam ;
      size_t _cur_idx = _state.value .mem_index++;
      if ( _state.value .mem_size > 0) _cur_idx %= _state.value .mem_size ;
      if ( ( _state.value .mem_index == 1) )
         _state.value .sum = 0;
      if ( _state.value .mem_size > _state.value .mem_index - 1 )
      {
         _state.value .sum += inReal;
         ( _state.value .memory+_cur_idx).value .inReal = inReal ;
         return RetCode.NeedMoreData ;
      }
      _state.value .sum -= ( _state.value .memory+_cur_idx).value .inReal ;
      _state.value .sum += inReal;
      ( _state.value .memory+_cur_idx).value .inReal = inReal ;
      temp = 0.0;
      for (i = 0; i < _state.value .mem_size ; ++i) {
         temp += Math.abs ( ( _state.value .memory+i).value .inReal - _state.value .sum / _state.value .optInTimePeriod);
      }
      outReal.value = temp / _state.value .optInTimePeriod;
      return RetCode.Success ;
   }
   public int avgDevStateFree( struct TA_avgDev_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if ( _state.value != NULL) {
         if ( _state.value .value .memory != NULL) TA_Free( _state.value .value .memory );
         TA_Free( _state.value ); _state.value = NULL;}
      return RetCode.Success ;
   }
   public RetCode avgDev( int startIdx,
      int endIdx,
      float inReal[],
      int optInTimePeriod,
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      int today, outIdx, lookback;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 14;
      else if( ((int)optInTimePeriod < 2) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      lookback = optInTimePeriod - 1;
      if (startIdx < lookback) {
         startIdx = lookback;
      }
      today = startIdx;
      if( today > endIdx ) {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      outBegIdx.value = today;
      outIdx = 0;
      while (today <= endIdx) {
         double todaySum, todayDev;
         int i;
         todaySum = 0.0;
         for (i = 0; i < optInTimePeriod; i++) {
            todaySum += inReal[today-i];
         }
         todayDev = 0.0;
         for (i = 0; i < optInTimePeriod; i++) {
            todayDev += Math.abs (inReal[today-i] - todaySum/optInTimePeriod);
         }
         outReal[outIdx] = todayDev/optInTimePeriod;
         outIdx++;
         today++;
      }
      outNBElement.value = outIdx;
      return RetCode.Success ;
   }
   /* Generated */
   public int bbandsLookback( int optInTimePeriod,
      double optInNbDevUp,
      double optInNbDevDn,
      MAType optInMAType )
   {
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 5;
      else if( ((int)optInTimePeriod < 2) || ((int)optInTimePeriod > 100000) )
         return -1;
      if( optInNbDevUp == (-4e+37) )
         optInNbDevUp = 2.000000e+0;
      else if( (optInNbDevUp < -3.000000e+37) || (optInNbDevUp > 3.000000e+37) )
         return -1;
      if( optInNbDevDn == (-4e+37) )
         optInNbDevDn = 2.000000e+0;
      else if( (optInNbDevDn < -3.000000e+37) || (optInNbDevDn > 3.000000e+37) )
         return -1;
      return movingAverageLookback ( optInTimePeriod, optInMAType );
   }
   public RetCode bbands( int startIdx,
      int endIdx,
      double inReal[],
      int optInTimePeriod,
      double optInNbDevUp,
      double optInNbDevDn,
      MAType optInMAType, MInteger outBegIdx,
      MInteger outNBElement,
      double outRealUpperBand[],
      double outRealMiddleBand[],
      double outRealLowerBand[] )
   {
      RetCode retCode;
      int i;
      double tempReal, tempReal2;
      double []tempBuffer1 ;
      double []tempBuffer2 ;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 5;
      else if( ((int)optInTimePeriod < 2) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      if( optInNbDevUp == (-4e+37) )
         optInNbDevUp = 2.000000e+0;
      else if( (optInNbDevUp < -3.000000e+37) || (optInNbDevUp > 3.000000e+37) )
         return RetCode.BadParam ;
      if( optInNbDevDn == (-4e+37) )
         optInNbDevDn = 2.000000e+0;
      else if( (optInNbDevDn < -3.000000e+37) || (optInNbDevDn > 3.000000e+37) )
         return RetCode.BadParam ;
      if( inReal == outRealUpperBand )
      {
         tempBuffer1 = outRealMiddleBand;
         tempBuffer2 = outRealLowerBand;
      }
      else if( inReal == outRealLowerBand )
      {
         tempBuffer1 = outRealMiddleBand;
         tempBuffer2 = outRealUpperBand;
      }
      else if( inReal == outRealMiddleBand )
      {
         tempBuffer1 = outRealLowerBand;
         tempBuffer2 = outRealUpperBand;
      }
      else
      {
         tempBuffer1 = outRealMiddleBand;
         tempBuffer2 = outRealUpperBand;
      }
      if( (tempBuffer1 == inReal) || (tempBuffer2 == inReal) )
         return RetCode.BadParam ;
      retCode = movingAverage ( startIdx, endIdx, inReal,
         optInTimePeriod, optInMAType,
         outBegIdx, outNBElement, tempBuffer1 );
      if( (retCode != RetCode.Success ) || ((int) outNBElement.value == 0) )
      {
         outNBElement.value = 0 ;
         return retCode;
      }
      if( optInMAType == MAType.Sma )
      {
         TA_INT_stddev_using_precalc_ma ( inReal, tempBuffer1,
            (int) outBegIdx.value , (int) outNBElement.value ,
            optInTimePeriod, tempBuffer2 );
      }
      else
      {
         retCode = stdDev ( (int) outBegIdx.value , endIdx, inReal,
            optInTimePeriod, 1.0,
            outBegIdx, outNBElement, tempBuffer2 );
         if( retCode != RetCode.Success )
         {
            outNBElement.value = 0 ;
            return retCode;
         }
      }
      if( tempBuffer1 != outRealMiddleBand )
      {
         System.arraycopy(tempBuffer1,0,outRealMiddleBand,0,outNBElement.value ) ;
      }
      if( optInNbDevUp == optInNbDevDn )
      {
         if( optInNbDevUp == 1.0 )
         {
            for( i=0; i < (int) outNBElement.value ; i++ )
            {
               tempReal = tempBuffer2[i];
               tempReal2 = outRealMiddleBand[i];
               outRealUpperBand[i] = tempReal2 + tempReal;
               outRealLowerBand[i] = tempReal2 - tempReal;
            }
         }
         else
         {
            for( i=0; i < (int) outNBElement.value ; i++ )
            {
               tempReal = tempBuffer2[i] * optInNbDevUp;
               tempReal2 = outRealMiddleBand[i];
               outRealUpperBand[i] = tempReal2 + tempReal;
               outRealLowerBand[i] = tempReal2 - tempReal;
            }
         }
      }
      else if( optInNbDevUp == 1.0 )
      {
         for( i=0; i < (int) outNBElement.value ; i++ )
         {
            tempReal = tempBuffer2[i];
            tempReal2 = outRealMiddleBand[i];
            outRealUpperBand[i] = tempReal2 + tempReal;
            outRealLowerBand[i] = tempReal2 - (tempReal * optInNbDevDn);
         }
      }
      else if( optInNbDevDn == 1.0 )
      {
         for( i=0; i < (int) outNBElement.value ; i++ )
         {
            tempReal = tempBuffer2[i];
            tempReal2 = outRealMiddleBand[i];
            outRealLowerBand[i] = tempReal2 - tempReal;
            outRealUpperBand[i] = tempReal2 + (tempReal * optInNbDevUp);
         }
      }
      else
      {
         for( i=0; i < (int) outNBElement.value ; i++ )
         {
            tempReal = tempBuffer2[i];
            tempReal2 = outRealMiddleBand[i];
            outRealUpperBand[i] = tempReal2 + (tempReal * optInNbDevUp);
            outRealLowerBand[i] = tempReal2 - (tempReal * optInNbDevDn);
         }
      }
      return RetCode.Success ;
   }
   public int bbandsStateInit( struct TA_bbands_State** _state,
      int optInTimePeriod,
      double optInNbDevUp,
      double optInNbDevDn,
      MAType optInMAType )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 5;
      else if( ((int)optInTimePeriod < 2) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      if( optInNbDevUp == (-4e+37) )
         optInNbDevUp = 2.000000e+0;
      else if( (optInNbDevUp < -3.000000e+37) || (optInNbDevUp > 3.000000e+37) )
         return RetCode.BadParam ;
      if( optInNbDevDn == (-4e+37) )
         optInNbDevDn = 2.000000e+0;
      else if( (optInNbDevDn < -3.000000e+37) || (optInNbDevDn > 3.000000e+37) )
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct bbands ));
      _state.value .value .mem_index = 0;
      _state.value .value .optInTimePeriod = optInTimePeriod;
      _state.value .value .optInNbDevUp = optInNbDevUp;
      _state.value .value .optInNbDevDn = optInNbDevDn;
      _state.value .value .optInMAType = optInMAType;
      _state.value .value .mem_size = bbandsLookback (optInTimePeriod, optInNbDevUp, optInNbDevDn, optInMAType );
      if ( _state.value .value .mem_size > 0)
         _state.value .value .memory = TA_Calloc( _state.value .value .mem_size , sizeof(struct TA_BBANDS_Data));
      else
         _state.value .value .memory = NULL;
      return RetCode.Success ;
   }
   public int bbandsState( struct TA_bbands_State* _state,
      double inReal,
      double *outRealUpperBand,
      double *outRealMiddleBand,
      double *outRealLowerBand )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      size_t _cur_idx = _state.value .mem_index++;
      if ( _state.value .mem_size > 0) _cur_idx %= _state.value .mem_size ;
      if ( _state.value .mem_size > _state.value .mem_index - 1 ) {
         ( _state.value .memory+_cur_idx).value .inReal = inReal ;
         return RetCode.NeedMoreData ; }
      return RetCode.Success ;
   }
   public int bbandsStateFree( struct TA_bbands_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if ( _state.value != NULL) {
         if ( _state.value .value .memory != NULL) TA_Free( _state.value .value .memory );
         TA_Free( _state.value ); _state.value = NULL;}
      return RetCode.Success ;
   }
   public RetCode bbands( int startIdx,
      int endIdx,
      float inReal[],
      int optInTimePeriod,
      double optInNbDevUp,
      double optInNbDevDn,
      MAType optInMAType, MInteger outBegIdx,
      MInteger outNBElement,
      double outRealUpperBand[],
      double outRealMiddleBand[],
      double outRealLowerBand[] )
   {
      RetCode retCode;
      int i;
      double tempReal, tempReal2;
      double []tempBuffer1 ;
      double []tempBuffer2 ;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 5;
      else if( ((int)optInTimePeriod < 2) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      if( optInNbDevUp == (-4e+37) )
         optInNbDevUp = 2.000000e+0;
      else if( (optInNbDevUp < -3.000000e+37) || (optInNbDevUp > 3.000000e+37) )
         return RetCode.BadParam ;
      if( optInNbDevDn == (-4e+37) )
         optInNbDevDn = 2.000000e+0;
      else if( (optInNbDevDn < -3.000000e+37) || (optInNbDevDn > 3.000000e+37) )
         return RetCode.BadParam ;
      tempBuffer1 = outRealMiddleBand;
      tempBuffer2 = outRealLowerBand;
      retCode = movingAverage ( startIdx, endIdx, inReal,
         optInTimePeriod, optInMAType,
         outBegIdx, outNBElement, tempBuffer1 );
      if( (retCode != RetCode.Success ) || ((int) outNBElement.value == 0) )
      {
         outNBElement.value = 0 ;
         return retCode;
      }
      if( optInMAType == MAType.Sma )
      {
         TA_INT_stddev_using_precalc_ma ( inReal, tempBuffer1,
            (int) outBegIdx.value , (int) outNBElement.value ,
            optInTimePeriod, tempBuffer2 );
      }
      else
      {
         retCode = stdDev ( (int) outBegIdx.value , endIdx, inReal,
            optInTimePeriod, 1.0,
            outBegIdx, outNBElement, tempBuffer2 );
         if( retCode != RetCode.Success )
         {
            outNBElement.value = 0 ;
            return retCode;
         }
      }
      if( optInNbDevUp == optInNbDevDn )
      {
         if( optInNbDevUp == 1.0 )
         {
            for( i=0; i < (int) outNBElement.value ; i++ )
            {
               tempReal = tempBuffer2[i];
               tempReal2 = outRealMiddleBand[i];
               outRealUpperBand[i] = tempReal2 + tempReal;
               outRealLowerBand[i] = tempReal2 - tempReal;
            }
         }
         else
         {
            for( i=0; i < (int) outNBElement.value ; i++ )
            {
               tempReal = tempBuffer2[i] * optInNbDevUp;
               tempReal2 = outRealMiddleBand[i];
               outRealUpperBand[i] = tempReal2 + tempReal;
               outRealLowerBand[i] = tempReal2 - tempReal;
            }
         }
      }
      else if( optInNbDevUp == 1.0 )
      {
         for( i=0; i < (int) outNBElement.value ; i++ )
         {
            tempReal = tempBuffer2[i];
            tempReal2 = outRealMiddleBand[i];
            outRealUpperBand[i] = tempReal2 + tempReal;
            outRealLowerBand[i] = tempReal2 - (tempReal * optInNbDevDn);
         }
      }
      else if( optInNbDevDn == 1.0 )
      {
         for( i=0; i < (int) outNBElement.value ; i++ )
         {
            tempReal = tempBuffer2[i];
            tempReal2 = outRealMiddleBand[i];
            outRealLowerBand[i] = tempReal2 - tempReal;
            outRealUpperBand[i] = tempReal2 + (tempReal * optInNbDevUp);
         }
      }
      else
      {
         for( i=0; i < (int) outNBElement.value ; i++ )
         {
            tempReal = tempBuffer2[i];
            tempReal2 = outRealMiddleBand[i];
            outRealUpperBand[i] = tempReal2 + (tempReal * optInNbDevUp);
            outRealLowerBand[i] = tempReal2 - (tempReal * optInNbDevDn);
         }
      }
      return RetCode.Success ;
   }
   /* Generated */
   public int betaLookback( int optInTimePeriod )
   {
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 5;
      else if( ((int)optInTimePeriod < 1) || ((int)optInTimePeriod > 100000) )
         return -1;
      return optInTimePeriod;
   }
   public RetCode beta( int startIdx,
      int endIdx,
      double inReal0[],
      double inReal1[],
      int optInTimePeriod,
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      double S_xx = 0.0f;
      double S_xy = 0.0f;
      double S_x = 0.0f;
      double S_y = 0.0f;
      double last_price_x = 0.0f;
      double last_price_y = 0.0f;
      double trailing_last_price_x = 0.0f;
      double trailing_last_price_y = 0.0f;
      double tmp_real = 0.0f;
      double x;
      double y;
      double n = 0.0f;
      int i, outIdx;
      int trailingIdx, nbInitialElementNeeded;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 5;
      else if( ((int)optInTimePeriod < 1) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      nbInitialElementNeeded = optInTimePeriod;
      if( startIdx < nbInitialElementNeeded )
         startIdx = nbInitialElementNeeded;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      trailingIdx = startIdx-nbInitialElementNeeded;
      last_price_x = trailing_last_price_x = inReal0[trailingIdx];
      last_price_y = trailing_last_price_y = inReal1[trailingIdx];
      i = ++trailingIdx;
      while( i < startIdx )
      {
         tmp_real = inReal0[i];
         if( ! (((- (0.00000000000001) )<last_price_x)&&(last_price_x< (0.00000000000001) )) )
            x = (tmp_real-last_price_x)/last_price_x;
         else
            x = 0.0;
         last_price_x = tmp_real;
         tmp_real = inReal1[i++];
         if( ! (((- (0.00000000000001) )<last_price_y)&&(last_price_y< (0.00000000000001) )) )
            y = (tmp_real-last_price_y)/last_price_y;
         else
            y = 0.0;
         last_price_y = tmp_real;
         S_xx += x*x;
         S_xy += x*y;
         S_x += x;
         S_y += y;
      }
      outIdx = 0;
      n = (double)optInTimePeriod;
      do
      {
         tmp_real = inReal0[i];
         if( ! (((- (0.00000000000001) )<last_price_x)&&(last_price_x< (0.00000000000001) )) )
            x = (tmp_real-last_price_x)/last_price_x;
         else
            x = 0.0;
         last_price_x = tmp_real;
         tmp_real = inReal1[i++];
         if( ! (((- (0.00000000000001) )<last_price_y)&&(last_price_y< (0.00000000000001) )) )
            y = (tmp_real-last_price_y)/last_price_y;
         else
            y = 0.0;
         last_price_y = tmp_real;
         S_xx += x*x;
         S_xy += x*y;
         S_x += x;
         S_y += y;
         tmp_real = inReal0[trailingIdx];
         if( ! (((- (0.00000000000001) )<trailing_last_price_x)&&(trailing_last_price_x< (0.00000000000001) )) )
            x = (tmp_real-trailing_last_price_x)/trailing_last_price_x;
         else
            x = 0.0;
         trailing_last_price_x = tmp_real;
         tmp_real = inReal1[trailingIdx++];
         if( ! (((- (0.00000000000001) )<trailing_last_price_y)&&(trailing_last_price_y< (0.00000000000001) )) )
            y = (tmp_real-trailing_last_price_y)/trailing_last_price_y;
         else
            y = 0.0;
         trailing_last_price_y = tmp_real;
         tmp_real = (n * S_xx) - (S_x * S_x);
         if( ! (((- (0.00000000000001) )<tmp_real)&&(tmp_real< (0.00000000000001) )) )
            outReal[outIdx++] = ((n * S_xy) - (S_x * S_y)) / tmp_real;
         else
            outReal[outIdx++] = 0.0;
         S_xx -= x*x;
         S_xy -= x*y;
         S_x -= x;
         S_y -= y;
      } while( i <= endIdx );
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   public int betaStateInit( struct TA_beta_State** _state,
      int optInTimePeriod )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 5;
      else if( ((int)optInTimePeriod < 1) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct beta ));
      _state.value .value .mem_index = 0;
      _state.value .value .optInTimePeriod = optInTimePeriod;
      _state.value .value .mem_size = betaLookback (optInTimePeriod );
      if ( _state.value .value .mem_size > 0)
         _state.value .value .memory = TA_Calloc( _state.value .value .mem_size , sizeof(struct TA_BETA_Data));
      else
         _state.value .value .memory = NULL;
      return RetCode.Success ;
   }
   public int betaState( struct TA_beta_State* _state,
      double inReal0,
      double inReal1,
      double *outReal )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      size_t _cur_idx = _state.value .mem_index++;
      if ( _state.value .mem_size > 0) _cur_idx %= _state.value .mem_size ;
      if ( _state.value .mem_size > _state.value .mem_index - 1 ) {
         ( _state.value .memory+_cur_idx).value .inReal0 = inReal0 ;
         ( _state.value .memory+_cur_idx).value .inReal1 = inReal1 ;
         return RetCode.NeedMoreData ; }
      return RetCode.Success ;
   }
   public int betaStateFree( struct TA_beta_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if ( _state.value != NULL) {
         if ( _state.value .value .memory != NULL) TA_Free( _state.value .value .memory );
         TA_Free( _state.value ); _state.value = NULL;}
      return RetCode.Success ;
   }
   public RetCode beta( int startIdx,
      int endIdx,
      float inReal0[],
      float inReal1[],
      int optInTimePeriod,
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      double S_xx = 0.0f;
      double S_xy = 0.0f;
      double S_x = 0.0f;
      double S_y = 0.0f;
      double last_price_x = 0.0f;
      double last_price_y = 0.0f;
      double trailing_last_price_x = 0.0f;
      double trailing_last_price_y = 0.0f;
      double tmp_real = 0.0f;
      double x;
      double y;
      double n = 0.0f;
      int i, outIdx;
      int trailingIdx, nbInitialElementNeeded;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 5;
      else if( ((int)optInTimePeriod < 1) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      nbInitialElementNeeded = optInTimePeriod;
      if( startIdx < nbInitialElementNeeded )
         startIdx = nbInitialElementNeeded;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      trailingIdx = startIdx-nbInitialElementNeeded;
      last_price_x = trailing_last_price_x = inReal0[trailingIdx];
      last_price_y = trailing_last_price_y = inReal1[trailingIdx];
      i = ++trailingIdx;
      while( i < startIdx )
      {
         tmp_real = inReal0[i];
         if( ! (((- (0.00000000000001) )<last_price_x)&&(last_price_x< (0.00000000000001) )) )
            x = (tmp_real-last_price_x)/last_price_x;
         else
            x = 0.0;
         last_price_x = tmp_real;
         tmp_real = inReal1[i++];
         if( ! (((- (0.00000000000001) )<last_price_y)&&(last_price_y< (0.00000000000001) )) )
            y = (tmp_real-last_price_y)/last_price_y;
         else
            y = 0.0;
         last_price_y = tmp_real;
         S_xx += x*x;
         S_xy += x*y;
         S_x += x;
         S_y += y;
      }
      outIdx = 0;
      n = (double)optInTimePeriod;
      do
      {
         tmp_real = inReal0[i];
         if( ! (((- (0.00000000000001) )<last_price_x)&&(last_price_x< (0.00000000000001) )) )
            x = (tmp_real-last_price_x)/last_price_x;
         else
            x = 0.0;
         last_price_x = tmp_real;
         tmp_real = inReal1[i++];
         if( ! (((- (0.00000000000001) )<last_price_y)&&(last_price_y< (0.00000000000001) )) )
            y = (tmp_real-last_price_y)/last_price_y;
         else
            y = 0.0;
         last_price_y = tmp_real;
         S_xx += x*x;
         S_xy += x*y;
         S_x += x;
         S_y += y;
         tmp_real = inReal0[trailingIdx];
         if( ! (((- (0.00000000000001) )<trailing_last_price_x)&&(trailing_last_price_x< (0.00000000000001) )) )
            x = (tmp_real-trailing_last_price_x)/trailing_last_price_x;
         else
            x = 0.0;
         trailing_last_price_x = tmp_real;
         tmp_real = inReal1[trailingIdx++];
         if( ! (((- (0.00000000000001) )<trailing_last_price_y)&&(trailing_last_price_y< (0.00000000000001) )) )
            y = (tmp_real-trailing_last_price_y)/trailing_last_price_y;
         else
            y = 0.0;
         trailing_last_price_y = tmp_real;
         tmp_real = (n * S_xx) - (S_x * S_x);
         if( ! (((- (0.00000000000001) )<tmp_real)&&(tmp_real< (0.00000000000001) )) )
            outReal[outIdx++] = ((n * S_xy) - (S_x * S_y)) / tmp_real;
         else
            outReal[outIdx++] = 0.0;
         S_xx -= x*x;
         S_xy -= x*y;
         S_x -= x;
         S_y -= y;
      } while( i <= endIdx );
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   /* Generated */
   public int bopLookback( )
   {
      return RetCode.Success ;
   }
   public RetCode bop( int startIdx,
      int endIdx,
      double inOpen[],
      double inHigh[],
      double inLow[],
      double inClose[],
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      int outIdx, i;
      double tempReal;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      outIdx = 0;
      for( i=startIdx; i <= endIdx; i++ )
      {
         tempReal = inHigh[i]-inLow[i];
         if( (tempReal< (0.00000000000001) ) )
            outReal[outIdx++] = 0.0;
         else
            outReal[outIdx++] = (inClose[i] - inOpen[i])/tempReal;
      }
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   public int bopStateInit( struct TA_bop_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct bop ));
      _state.value .value .mem_index = 0;
      _state.value .value .mem_size = bopLookback ();
      if ( _state.value .value .mem_size > 0)
         _state.value .value .memory = TA_Calloc( _state.value .value .mem_size , sizeof(struct TA_BOP_Data));
      else
         _state.value .value .memory = NULL;
      return RetCode.Success ;
   }
   public int bopState( struct TA_bop_State* _state,
      double inOpen,
      double inHigh,
      double inLow,
      double inClose,
      double *outReal )
   {
      double tempReal;
      if (_state == NULL)
         return RetCode.BadParam ;
      size_t _cur_idx = _state.value .mem_index++;
      if ( _state.value .mem_size > 0) _cur_idx %= _state.value .mem_size ;
      if ( _state.value .mem_size > _state.value .mem_index - 1 ) {
         ( _state.value .memory+_cur_idx).value .inOpen = inOpen ;
         ( _state.value .memory+_cur_idx).value .inHigh = inHigh ;
         ( _state.value .memory+_cur_idx).value .inLow = inLow ;
         ( _state.value .memory+_cur_idx).value .inClose = inClose ;
         return RetCode.NeedMoreData ; }
      tempReal = inHigh-inLow;
      if( (tempReal< (0.00000000000001) ) )
         outReal.value = 0.0;
      else
         outReal.value = (inClose - inOpen)/tempReal;
      return RetCode.Success ;
   }
   public int bopStateFree( struct TA_bop_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if ( _state.value != NULL) {
         if ( _state.value .value .memory != NULL) TA_Free( _state.value .value .memory );
         TA_Free( _state.value ); _state.value = NULL;}
      return RetCode.Success ;
   }
   public RetCode bop( int startIdx,
      int endIdx,
      float inOpen[],
      float inHigh[],
      float inLow[],
      float inClose[],
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      int outIdx, i;
      double tempReal;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      outIdx = 0;
      for( i=startIdx; i <= endIdx; i++ )
      {
         tempReal = inHigh[i]-inLow[i];
         if( (tempReal< (0.00000000000001) ) )
            outReal[outIdx++] = 0.0;
         else
            outReal[outIdx++] = (inClose[i] - inOpen[i])/tempReal;
      }
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   /* Generated */
   public int cciLookback( int optInTimePeriod )
   {
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 14;
      else if( ((int)optInTimePeriod < 2) || ((int)optInTimePeriod > 100000) )
         return -1;
      return (optInTimePeriod-1);
   }
   public RetCode cci( int startIdx,
      int endIdx,
      double inHigh[],
      double inLow[],
      double inClose[],
      int optInTimePeriod,
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      double tempReal, tempReal2, theAverage, lastValue;
      int i, j, outIdx, lookbackTotal;
      int circBuffer_Idx = 0; double []circBuffer; int maxIdx_circBuffer = (30-1) ;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 14;
      else if( ((int)optInTimePeriod < 2) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      lookbackTotal = (optInTimePeriod-1);
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      { if( optInTimePeriod <= 0 ) return RetCode.AllocErr ; circBuffer = new double[optInTimePeriod]; maxIdx_circBuffer = (optInTimePeriod-1); } ;
      i=startIdx-lookbackTotal;
      if( optInTimePeriod > 1 )
      {
         while( i < startIdx )
         {
            circBuffer[circBuffer_Idx] = (inHigh[i]+inLow[i]+inClose[i])/3;
            i++;
            { circBuffer_Idx ++; if( circBuffer_Idx > maxIdx_circBuffer ) circBuffer_Idx = 0; } ;
         }
      }
      outIdx = 0;
      do
      {
         lastValue = (inHigh[i]+inLow[i]+inClose[i])/3;
         circBuffer[circBuffer_Idx] = lastValue;
         theAverage = 0;
         for( j=0; j < optInTimePeriod; j++ )
            theAverage += circBuffer[j];
         theAverage /= optInTimePeriod;
         tempReal2 = 0;
         for( j=0; j < optInTimePeriod; j++ )
            tempReal2 += Math.abs (circBuffer[j]-theAverage);
         tempReal = lastValue-theAverage;
         if( (tempReal != 0.0) && (tempReal2 != 0.0) )
         {
            outReal[outIdx++] = tempReal/(0.015*(tempReal2/optInTimePeriod));
         }
         else
            outReal[outIdx++] = 0.0;
         { circBuffer_Idx ++; if( circBuffer_Idx > maxIdx_circBuffer ) circBuffer_Idx = 0; } ;
         i++;
      } while( i <= endIdx );
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   public int cciStateInit( struct TA_cci_State** _state,
      int optInTimePeriod )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 14;
      else if( ((int)optInTimePeriod < 2) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct cci ));
      _state.value .value .mem_index = 0;
      _state.value .value .optInTimePeriod = optInTimePeriod;
      _state.value .value .mem_size = cciLookback (optInTimePeriod );
      if ( _state.value .value .mem_size > 0)
         _state.value .value .memory = TA_Calloc( _state.value .value .mem_size , sizeof(struct TA_CCI_Data));
      else
         _state.value .value .memory = NULL;
      return RetCode.Success ;
   }
   public int cciState( struct TA_cci_State* _state,
      double inHigh,
      double inLow,
      double inClose,
      double *outReal )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      size_t _cur_idx = _state.value .mem_index++;
      if ( _state.value .mem_size > 0) _cur_idx %= _state.value .mem_size ;
      if ( _state.value .mem_size > _state.value .mem_index - 1 ) {
         ( _state.value .memory+_cur_idx).value .inHigh = inHigh ;
         ( _state.value .memory+_cur_idx).value .inLow = inLow ;
         ( _state.value .memory+_cur_idx).value .inClose = inClose ;
         return RetCode.NeedMoreData ; }
      return RetCode.Success ;
   }
   public int cciStateFree( struct TA_cci_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if ( _state.value != NULL) {
         if ( _state.value .value .memory != NULL) TA_Free( _state.value .value .memory );
         TA_Free( _state.value ); _state.value = NULL;}
      return RetCode.Success ;
   }
   public RetCode cci( int startIdx,
      int endIdx,
      float inHigh[],
      float inLow[],
      float inClose[],
      int optInTimePeriod,
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      double tempReal, tempReal2, theAverage, lastValue;
      int i, j, outIdx, lookbackTotal;
      int circBuffer_Idx = 0; double []circBuffer; int maxIdx_circBuffer = (30-1) ;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 14;
      else if( ((int)optInTimePeriod < 2) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      lookbackTotal = (optInTimePeriod-1);
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      { if( optInTimePeriod <= 0 ) return RetCode.AllocErr ; circBuffer = new double[optInTimePeriod]; maxIdx_circBuffer = (optInTimePeriod-1); } ;
      i=startIdx-lookbackTotal;
      if( optInTimePeriod > 1 )
      {
         while( i < startIdx )
         {
            circBuffer[circBuffer_Idx] = (inHigh[i]+inLow[i]+inClose[i])/3;
            i++;
            { circBuffer_Idx ++; if( circBuffer_Idx > maxIdx_circBuffer ) circBuffer_Idx = 0; } ;
         }
      }
      outIdx = 0;
      do
      {
         lastValue = (inHigh[i]+inLow[i]+inClose[i])/3;
         circBuffer[circBuffer_Idx] = lastValue;
         theAverage = 0;
         for( j=0; j < optInTimePeriod; j++ )
            theAverage += circBuffer[j];
         theAverage /= optInTimePeriod;
         tempReal2 = 0;
         for( j=0; j < optInTimePeriod; j++ )
            tempReal2 += Math.abs (circBuffer[j]-theAverage);
         tempReal = lastValue-theAverage;
         if( (tempReal != 0.0) && (tempReal2 != 0.0) )
         {
            outReal[outIdx++] = tempReal/(0.015*(tempReal2/optInTimePeriod));
         }
         else
            outReal[outIdx++] = 0.0;
         { circBuffer_Idx ++; if( circBuffer_Idx > maxIdx_circBuffer ) circBuffer_Idx = 0; } ;
         i++;
      } while( i <= endIdx );
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   /* Generated */
   public int cdl2CrowsLookback( )
   {
      return (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) + 2;
   }
   public RetCode cdl2Crows( int startIdx,
      int endIdx,
      double inOpen[],
      double inHigh[],
      double inLow[],
      double inClose[],
      MInteger outBegIdx,
      MInteger outNBElement,
      int outInteger[] )
   {
      double BodyLongPeriodTotal;
      int i, outIdx, BodyLongTrailingIdx, lookbackTotal;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      lookbackTotal = cdl2CrowsLookback ();
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      BodyLongPeriodTotal = 0;
      BodyLongTrailingIdx = startIdx -2 - (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) ;
      i = BodyLongTrailingIdx;
      while( i < startIdx-2 ) {
         BodyLongPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      i = startIdx;
      outIdx = 0;
      do
      {
         if( ( inClose[i-2] >= inOpen[i-2] ? 1 : -1 ) == 1 &&
            ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) > ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) != 0.0? BodyLongPeriodTotal / (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-2] - inLow[i-2] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-2] - ( inClose[i-2] >= inOpen[i-2] ? inClose[i-2] : inOpen[i-2] ) ) + ( ( inClose[i-2] >= inOpen[i-2] ? inOpen[i-2] : inClose[i-2] ) - inLow[i-2] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( inClose[i-1] >= inOpen[i-1] ? 1 : -1 ) == -1 &&
            ( (((inOpen[i-1]) < (inClose[i-1])) ? (inOpen[i-1]) : (inClose[i-1])) > (((inOpen[i-2]) > (inClose[i-2])) ? (inOpen[i-2]) : (inClose[i-2])) ) &&
            ( inClose[i] >= inOpen[i] ? 1 : -1 ) == -1 &&
            inOpen[i] < inOpen[i-1] && inOpen[i] > inClose[i-1] &&
            inClose[i] > inOpen[i-2] && inClose[i] < inClose[i-2]
            )
            outInteger[outIdx++] = -100;
         else
            outInteger[outIdx++] = 0;
         BodyLongPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-2] - inLow[i-2] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-2] - ( inClose[i-2] >= inOpen[i-2] ? inClose[i-2] : inOpen[i-2] ) ) + ( ( inClose[i-2] >= inOpen[i-2] ? inOpen[i-2] : inClose[i-2] ) - inLow[i-2] ) : 0 ) ) ) - ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[BodyLongTrailingIdx] - inOpen[BodyLongTrailingIdx] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[BodyLongTrailingIdx] - inLow[BodyLongTrailingIdx] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[BodyLongTrailingIdx] - ( inClose[BodyLongTrailingIdx] >= inOpen[BodyLongTrailingIdx] ? inClose[BodyLongTrailingIdx] : inOpen[BodyLongTrailingIdx] ) ) + ( ( inClose[BodyLongTrailingIdx] >= inOpen[BodyLongTrailingIdx] ? inOpen[BodyLongTrailingIdx] : inClose[BodyLongTrailingIdx] ) - inLow[BodyLongTrailingIdx] ) : 0 ) ) ) ;
         i++;
         BodyLongTrailingIdx++;
      } while( i <= endIdx );
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   public int cdl2CrowsStateInit( struct TA_cdl2Crows_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct cdl2Crows ));
      _state.value .value .mem_index = 0;
      _state.value .value .mem_size = cdl2CrowsLookback ();
      if ( _state.value .value .mem_size > 0)
         _state.value .value .memory = TA_Calloc( _state.value .value .mem_size , sizeof(struct TA_CDL2CROWS_Data));
      else
         _state.value .value .memory = NULL;
      return RetCode.Success ;
   }
   public int cdl2CrowsState( struct TA_cdl2Crows_State* _state,
      double inOpen,
      double inHigh,
      double inLow,
      double inClose,
      int *outInteger )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      size_t _cur_idx = _state.value .mem_index++;
      if ( _state.value .mem_size > 0) _cur_idx %= _state.value .mem_size ;
      if ( _state.value .mem_size > _state.value .mem_index - 1 ) {
         ( _state.value .memory+_cur_idx).value .inOpen = inOpen ;
         ( _state.value .memory+_cur_idx).value .inHigh = inHigh ;
         ( _state.value .memory+_cur_idx).value .inLow = inLow ;
         ( _state.value .memory+_cur_idx).value .inClose = inClose ;
         return RetCode.NeedMoreData ; }
      return RetCode.Success ;
   }
   public int cdl2CrowsStateFree( struct TA_cdl2Crows_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if ( _state.value != NULL) {
         if ( _state.value .value .memory != NULL) TA_Free( _state.value .value .memory );
         TA_Free( _state.value ); _state.value = NULL;}
      return RetCode.Success ;
   }
   public RetCode cdl2Crows( int startIdx,
      int endIdx,
      float inOpen[],
      float inHigh[],
      float inLow[],
      float inClose[],
      MInteger outBegIdx,
      MInteger outNBElement,
      int outInteger[] )
   {
      double BodyLongPeriodTotal;
      int i, outIdx, BodyLongTrailingIdx, lookbackTotal;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      lookbackTotal = cdl2CrowsLookback ();
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      BodyLongPeriodTotal = 0;
      BodyLongTrailingIdx = startIdx -2 - (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) ;
      i = BodyLongTrailingIdx;
      while( i < startIdx-2 ) {
         BodyLongPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      i = startIdx;
      outIdx = 0;
      do
      {
         if( ( inClose[i-2] >= inOpen[i-2] ? 1 : -1 ) == 1 &&
            ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) > ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) != 0.0? BodyLongPeriodTotal / (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-2] - inLow[i-2] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-2] - ( inClose[i-2] >= inOpen[i-2] ? inClose[i-2] : inOpen[i-2] ) ) + ( ( inClose[i-2] >= inOpen[i-2] ? inOpen[i-2] : inClose[i-2] ) - inLow[i-2] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( inClose[i-1] >= inOpen[i-1] ? 1 : -1 ) == -1 &&
            ( (((inOpen[i-1]) < (inClose[i-1])) ? (inOpen[i-1]) : (inClose[i-1])) > (((inOpen[i-2]) > (inClose[i-2])) ? (inOpen[i-2]) : (inClose[i-2])) ) &&
            ( inClose[i] >= inOpen[i] ? 1 : -1 ) == -1 &&
            inOpen[i] < inOpen[i-1] && inOpen[i] > inClose[i-1] &&
            inClose[i] > inOpen[i-2] && inClose[i] < inClose[i-2]
            )
            outInteger[outIdx++] = -100;
         else
            outInteger[outIdx++] = 0;
         BodyLongPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-2] - inLow[i-2] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-2] - ( inClose[i-2] >= inOpen[i-2] ? inClose[i-2] : inOpen[i-2] ) ) + ( ( inClose[i-2] >= inOpen[i-2] ? inOpen[i-2] : inClose[i-2] ) - inLow[i-2] ) : 0 ) ) ) - ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[BodyLongTrailingIdx] - inOpen[BodyLongTrailingIdx] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[BodyLongTrailingIdx] - inLow[BodyLongTrailingIdx] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[BodyLongTrailingIdx] - ( inClose[BodyLongTrailingIdx] >= inOpen[BodyLongTrailingIdx] ? inClose[BodyLongTrailingIdx] : inOpen[BodyLongTrailingIdx] ) ) + ( ( inClose[BodyLongTrailingIdx] >= inOpen[BodyLongTrailingIdx] ? inOpen[BodyLongTrailingIdx] : inClose[BodyLongTrailingIdx] ) - inLow[BodyLongTrailingIdx] ) : 0 ) ) ) ;
         i++;
         BodyLongTrailingIdx++;
      } while( i <= endIdx );
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   /* Generated */
   public int cdl3BlackCrowsLookback( )
   {
      return (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) + 3;
   }
   public RetCode cdl3BlackCrows( int startIdx,
      int endIdx,
      double inOpen[],
      double inHigh[],
      double inLow[],
      double inClose[],
      MInteger outBegIdx,
      MInteger outNBElement,
      int outInteger[] )
   {
      double []ShadowVeryShortPeriodTotal = new double[3] ;
      int i, outIdx, totIdx, ShadowVeryShortTrailingIdx, lookbackTotal;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      lookbackTotal = cdl3BlackCrowsLookback ();
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      ShadowVeryShortPeriodTotal[2] = 0;
      ShadowVeryShortPeriodTotal[1] = 0;
      ShadowVeryShortPeriodTotal[0] = 0;
      ShadowVeryShortTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) ;
      i = ShadowVeryShortTrailingIdx;
      while( i < startIdx ) {
         ShadowVeryShortPeriodTotal[2] += ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-2] - inLow[i-2] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-2] - ( inClose[i-2] >= inOpen[i-2] ? inClose[i-2] : inOpen[i-2] ) ) + ( ( inClose[i-2] >= inOpen[i-2] ? inOpen[i-2] : inClose[i-2] ) - inLow[i-2] ) : 0 ) ) ) ;
         ShadowVeryShortPeriodTotal[1] += ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ;
         ShadowVeryShortPeriodTotal[0] += ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      i = startIdx;
      outIdx = 0;
      do
      {
         if( ( inClose[i-3] >= inOpen[i-3] ? 1 : -1 ) == 1 &&
            ( inClose[i-2] >= inOpen[i-2] ? 1 : -1 ) == -1 &&
            ( ( inClose[i-2] >= inOpen[i-2] ? inOpen[i-2] : inClose[i-2] ) - inLow[i-2] ) < ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) != 0.0? ShadowVeryShortPeriodTotal[2] / (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-2] - inLow[i-2] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-2] - ( inClose[i-2] >= inOpen[i-2] ? inClose[i-2] : inOpen[i-2] ) ) + ( ( inClose[i-2] >= inOpen[i-2] ? inOpen[i-2] : inClose[i-2] ) - inLow[i-2] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( inClose[i-1] >= inOpen[i-1] ? 1 : -1 ) == -1 &&
            ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) < ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) != 0.0? ShadowVeryShortPeriodTotal[1] / (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( inClose[i] >= inOpen[i] ? 1 : -1 ) == -1 &&
            ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) < ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) != 0.0? ShadowVeryShortPeriodTotal[0] / (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            inOpen[i-1] < inOpen[i-2] && inOpen[i-1] > inClose[i-2] &&
            inOpen[i] < inOpen[i-1] && inOpen[i] > inClose[i-1] &&
            inHigh[i-3] > inClose[i-2] &&
            inClose[i-2] > inClose[i-1] &&
            inClose[i-1] > inClose[i]
            )
            outInteger[outIdx++] = -100;
         else
            outInteger[outIdx++] = 0;
         for (totIdx = 2; totIdx >= 0; --totIdx)
            ShadowVeryShortPeriodTotal[totIdx] += ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-totIdx] - inOpen[i-totIdx] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-totIdx] - inLow[i-totIdx] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-totIdx] - ( inClose[i-totIdx] >= inOpen[i-totIdx] ? inClose[i-totIdx] : inOpen[i-totIdx] ) ) + ( ( inClose[i-totIdx] >= inOpen[i-totIdx] ? inOpen[i-totIdx] : inClose[i-totIdx] ) - inLow[i-totIdx] ) : 0 ) ) )
            - ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[ShadowVeryShortTrailingIdx-totIdx] - inOpen[ShadowVeryShortTrailingIdx-totIdx] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[ShadowVeryShortTrailingIdx-totIdx] - inLow[ShadowVeryShortTrailingIdx-totIdx] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[ShadowVeryShortTrailingIdx-totIdx] - ( inClose[ShadowVeryShortTrailingIdx-totIdx] >= inOpen[ShadowVeryShortTrailingIdx-totIdx] ? inClose[ShadowVeryShortTrailingIdx-totIdx] : inOpen[ShadowVeryShortTrailingIdx-totIdx] ) ) + ( ( inClose[ShadowVeryShortTrailingIdx-totIdx] >= inOpen[ShadowVeryShortTrailingIdx-totIdx] ? inOpen[ShadowVeryShortTrailingIdx-totIdx] : inClose[ShadowVeryShortTrailingIdx-totIdx] ) - inLow[ShadowVeryShortTrailingIdx-totIdx] ) : 0 ) ) ) ;
         i++;
         ShadowVeryShortTrailingIdx++;
      } while( i <= endIdx );
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   public int cdl3BlackCrowsStateInit( struct TA_cdl3BlackCrows_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct cdl3BlackCrows ));
      _state.value .value .mem_index = 0;
      _state.value .value .mem_size = cdl3BlackCrowsLookback ();
      if ( _state.value .value .mem_size > 0)
         _state.value .value .memory = TA_Calloc( _state.value .value .mem_size , sizeof(struct TA_CDL3BLACKCROWS_Data));
      else
         _state.value .value .memory = NULL;
      return RetCode.Success ;
   }
   public int cdl3BlackCrowsState( struct TA_cdl3BlackCrows_State* _state,
      double inOpen,
      double inHigh,
      double inLow,
      double inClose,
      int *outInteger )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      size_t _cur_idx = _state.value .mem_index++;
      if ( _state.value .mem_size > 0) _cur_idx %= _state.value .mem_size ;
      if ( _state.value .mem_size > _state.value .mem_index - 1 ) {
         ( _state.value .memory+_cur_idx).value .inOpen = inOpen ;
         ( _state.value .memory+_cur_idx).value .inHigh = inHigh ;
         ( _state.value .memory+_cur_idx).value .inLow = inLow ;
         ( _state.value .memory+_cur_idx).value .inClose = inClose ;
         return RetCode.NeedMoreData ; }
      return RetCode.Success ;
   }
   public int cdl3BlackCrowsStateFree( struct TA_cdl3BlackCrows_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if ( _state.value != NULL) {
         if ( _state.value .value .memory != NULL) TA_Free( _state.value .value .memory );
         TA_Free( _state.value ); _state.value = NULL;}
      return RetCode.Success ;
   }
   public RetCode cdl3BlackCrows( int startIdx,
      int endIdx,
      float inOpen[],
      float inHigh[],
      float inLow[],
      float inClose[],
      MInteger outBegIdx,
      MInteger outNBElement,
      int outInteger[] )
   {
      double []ShadowVeryShortPeriodTotal = new double[3] ;
      int i, outIdx, totIdx, ShadowVeryShortTrailingIdx, lookbackTotal;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      lookbackTotal = cdl3BlackCrowsLookback ();
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      ShadowVeryShortPeriodTotal[2] = 0;
      ShadowVeryShortPeriodTotal[1] = 0;
      ShadowVeryShortPeriodTotal[0] = 0;
      ShadowVeryShortTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) ;
      i = ShadowVeryShortTrailingIdx;
      while( i < startIdx ) {
         ShadowVeryShortPeriodTotal[2] += ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-2] - inLow[i-2] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-2] - ( inClose[i-2] >= inOpen[i-2] ? inClose[i-2] : inOpen[i-2] ) ) + ( ( inClose[i-2] >= inOpen[i-2] ? inOpen[i-2] : inClose[i-2] ) - inLow[i-2] ) : 0 ) ) ) ;
         ShadowVeryShortPeriodTotal[1] += ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ;
         ShadowVeryShortPeriodTotal[0] += ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      i = startIdx;
      outIdx = 0;
      do
      {
         if( ( inClose[i-3] >= inOpen[i-3] ? 1 : -1 ) == 1 &&
            ( inClose[i-2] >= inOpen[i-2] ? 1 : -1 ) == -1 &&
            ( ( inClose[i-2] >= inOpen[i-2] ? inOpen[i-2] : inClose[i-2] ) - inLow[i-2] ) < ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) != 0.0? ShadowVeryShortPeriodTotal[2] / (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-2] - inLow[i-2] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-2] - ( inClose[i-2] >= inOpen[i-2] ? inClose[i-2] : inOpen[i-2] ) ) + ( ( inClose[i-2] >= inOpen[i-2] ? inOpen[i-2] : inClose[i-2] ) - inLow[i-2] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( inClose[i-1] >= inOpen[i-1] ? 1 : -1 ) == -1 &&
            ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) < ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) != 0.0? ShadowVeryShortPeriodTotal[1] / (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( inClose[i] >= inOpen[i] ? 1 : -1 ) == -1 &&
            ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) < ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) != 0.0? ShadowVeryShortPeriodTotal[0] / (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            inOpen[i-1] < inOpen[i-2] && inOpen[i-1] > inClose[i-2] &&
            inOpen[i] < inOpen[i-1] && inOpen[i] > inClose[i-1] &&
            inHigh[i-3] > inClose[i-2] &&
            inClose[i-2] > inClose[i-1] &&
            inClose[i-1] > inClose[i]
            )
            outInteger[outIdx++] = -100;
         else
            outInteger[outIdx++] = 0;
         for (totIdx = 2; totIdx >= 0; --totIdx)
            ShadowVeryShortPeriodTotal[totIdx] += ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-totIdx] - inOpen[i-totIdx] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-totIdx] - inLow[i-totIdx] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-totIdx] - ( inClose[i-totIdx] >= inOpen[i-totIdx] ? inClose[i-totIdx] : inOpen[i-totIdx] ) ) + ( ( inClose[i-totIdx] >= inOpen[i-totIdx] ? inOpen[i-totIdx] : inClose[i-totIdx] ) - inLow[i-totIdx] ) : 0 ) ) )
            - ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[ShadowVeryShortTrailingIdx-totIdx] - inOpen[ShadowVeryShortTrailingIdx-totIdx] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[ShadowVeryShortTrailingIdx-totIdx] - inLow[ShadowVeryShortTrailingIdx-totIdx] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[ShadowVeryShortTrailingIdx-totIdx] - ( inClose[ShadowVeryShortTrailingIdx-totIdx] >= inOpen[ShadowVeryShortTrailingIdx-totIdx] ? inClose[ShadowVeryShortTrailingIdx-totIdx] : inOpen[ShadowVeryShortTrailingIdx-totIdx] ) ) + ( ( inClose[ShadowVeryShortTrailingIdx-totIdx] >= inOpen[ShadowVeryShortTrailingIdx-totIdx] ? inOpen[ShadowVeryShortTrailingIdx-totIdx] : inClose[ShadowVeryShortTrailingIdx-totIdx] ) - inLow[ShadowVeryShortTrailingIdx-totIdx] ) : 0 ) ) ) ;
         i++;
         ShadowVeryShortTrailingIdx++;
      } while( i <= endIdx );
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   /* Generated */
   public int cdl3InsideLookback( )
   {
      return ((( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) ) > ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) )) ? ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) )) + 2;
   }
   public RetCode cdl3Inside( int startIdx,
      int endIdx,
      double inOpen[],
      double inHigh[],
      double inLow[],
      double inClose[],
      MInteger outBegIdx,
      MInteger outNBElement,
      int outInteger[] )
   {
      double BodyShortPeriodTotal, BodyLongPeriodTotal;
      int i, outIdx, BodyShortTrailingIdx, BodyLongTrailingIdx, lookbackTotal;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      lookbackTotal = cdl3InsideLookback ();
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      BodyLongPeriodTotal = 0;
      BodyShortPeriodTotal = 0;
      BodyLongTrailingIdx = startIdx -2 - (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) ;
      BodyShortTrailingIdx = startIdx -1 - (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) ;
      i = BodyLongTrailingIdx;
      while( i < startIdx-2 ) {
         BodyLongPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      i = BodyShortTrailingIdx;
      while( i < startIdx-1 ) {
         BodyShortPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      i = startIdx;
      outIdx = 0;
      do
      {
         if( ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) > ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) != 0.0? BodyLongPeriodTotal / (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-2] - inLow[i-2] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-2] - ( inClose[i-2] >= inOpen[i-2] ? inClose[i-2] : inOpen[i-2] ) ) + ( ( inClose[i-2] >= inOpen[i-2] ? inOpen[i-2] : inClose[i-2] ) - inLow[i-2] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) <= ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) != 0.0? BodyShortPeriodTotal / (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            (((inClose[i-1]) > (inOpen[i-1])) ? (inClose[i-1]) : (inOpen[i-1])) < (((inClose[i-2]) > (inOpen[i-2])) ? (inClose[i-2]) : (inOpen[i-2])) &&
            (((inClose[i-1]) < (inOpen[i-1])) ? (inClose[i-1]) : (inOpen[i-1])) > (((inClose[i-2]) < (inOpen[i-2])) ? (inClose[i-2]) : (inOpen[i-2])) &&
            ( ( ( inClose[i-2] >= inOpen[i-2] ? 1 : -1 ) == 1 && ( inClose[i] >= inOpen[i] ? 1 : -1 ) == -1 && inClose[i] < inOpen[i-2] )
            ||
            ( ( inClose[i-2] >= inOpen[i-2] ? 1 : -1 ) == -1 && ( inClose[i] >= inOpen[i] ? 1 : -1 ) == 1 && inClose[i] > inOpen[i-2] )
            )
            )
            outInteger[outIdx++] = - ( inClose[i-2] >= inOpen[i-2] ? 1 : -1 ) * 100;
         else
            outInteger[outIdx++] = 0;
         BodyLongPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-2] - inLow[i-2] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-2] - ( inClose[i-2] >= inOpen[i-2] ? inClose[i-2] : inOpen[i-2] ) ) + ( ( inClose[i-2] >= inOpen[i-2] ? inOpen[i-2] : inClose[i-2] ) - inLow[i-2] ) : 0 ) ) ) - ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[BodyLongTrailingIdx] - inOpen[BodyLongTrailingIdx] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[BodyLongTrailingIdx] - inLow[BodyLongTrailingIdx] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[BodyLongTrailingIdx] - ( inClose[BodyLongTrailingIdx] >= inOpen[BodyLongTrailingIdx] ? inClose[BodyLongTrailingIdx] : inOpen[BodyLongTrailingIdx] ) ) + ( ( inClose[BodyLongTrailingIdx] >= inOpen[BodyLongTrailingIdx] ? inOpen[BodyLongTrailingIdx] : inClose[BodyLongTrailingIdx] ) - inLow[BodyLongTrailingIdx] ) : 0 ) ) ) ;
         BodyShortPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) - ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[BodyShortTrailingIdx] - inOpen[BodyShortTrailingIdx] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[BodyShortTrailingIdx] - inLow[BodyShortTrailingIdx] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[BodyShortTrailingIdx] - ( inClose[BodyShortTrailingIdx] >= inOpen[BodyShortTrailingIdx] ? inClose[BodyShortTrailingIdx] : inOpen[BodyShortTrailingIdx] ) ) + ( ( inClose[BodyShortTrailingIdx] >= inOpen[BodyShortTrailingIdx] ? inOpen[BodyShortTrailingIdx] : inClose[BodyShortTrailingIdx] ) - inLow[BodyShortTrailingIdx] ) : 0 ) ) ) ;
         i++;
         BodyLongTrailingIdx++;
         BodyShortTrailingIdx++;
      } while( i <= endIdx );
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   public int cdl3InsideStateInit( struct TA_cdl3Inside_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct cdl3Inside ));
      _state.value .value .mem_index = 0;
      _state.value .value .mem_size = cdl3InsideLookback ();
      if ( _state.value .value .mem_size > 0)
         _state.value .value .memory = TA_Calloc( _state.value .value .mem_size , sizeof(struct TA_CDL3INSIDE_Data));
      else
         _state.value .value .memory = NULL;
      return RetCode.Success ;
   }
   public int cdl3InsideState( struct TA_cdl3Inside_State* _state,
      double inOpen,
      double inHigh,
      double inLow,
      double inClose,
      int *outInteger )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      size_t _cur_idx = _state.value .mem_index++;
      if ( _state.value .mem_size > 0) _cur_idx %= _state.value .mem_size ;
      if ( _state.value .mem_size > _state.value .mem_index - 1 ) {
         ( _state.value .memory+_cur_idx).value .inOpen = inOpen ;
         ( _state.value .memory+_cur_idx).value .inHigh = inHigh ;
         ( _state.value .memory+_cur_idx).value .inLow = inLow ;
         ( _state.value .memory+_cur_idx).value .inClose = inClose ;
         return RetCode.NeedMoreData ; }
      return RetCode.Success ;
   }
   public int cdl3InsideStateFree( struct TA_cdl3Inside_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if ( _state.value != NULL) {
         if ( _state.value .value .memory != NULL) TA_Free( _state.value .value .memory );
         TA_Free( _state.value ); _state.value = NULL;}
      return RetCode.Success ;
   }
   public RetCode cdl3Inside( int startIdx,
      int endIdx,
      float inOpen[],
      float inHigh[],
      float inLow[],
      float inClose[],
      MInteger outBegIdx,
      MInteger outNBElement,
      int outInteger[] )
   {
      double BodyShortPeriodTotal, BodyLongPeriodTotal;
      int i, outIdx, BodyShortTrailingIdx, BodyLongTrailingIdx, lookbackTotal;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      lookbackTotal = cdl3InsideLookback ();
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      BodyLongPeriodTotal = 0;
      BodyShortPeriodTotal = 0;
      BodyLongTrailingIdx = startIdx -2 - (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) ;
      BodyShortTrailingIdx = startIdx -1 - (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) ;
      i = BodyLongTrailingIdx;
      while( i < startIdx-2 ) {
         BodyLongPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      i = BodyShortTrailingIdx;
      while( i < startIdx-1 ) {
         BodyShortPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      i = startIdx;
      outIdx = 0;
      do
      {
         if( ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) > ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) != 0.0? BodyLongPeriodTotal / (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-2] - inLow[i-2] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-2] - ( inClose[i-2] >= inOpen[i-2] ? inClose[i-2] : inOpen[i-2] ) ) + ( ( inClose[i-2] >= inOpen[i-2] ? inOpen[i-2] : inClose[i-2] ) - inLow[i-2] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) <= ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) != 0.0? BodyShortPeriodTotal / (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            (((inClose[i-1]) > (inOpen[i-1])) ? (inClose[i-1]) : (inOpen[i-1])) < (((inClose[i-2]) > (inOpen[i-2])) ? (inClose[i-2]) : (inOpen[i-2])) &&
            (((inClose[i-1]) < (inOpen[i-1])) ? (inClose[i-1]) : (inOpen[i-1])) > (((inClose[i-2]) < (inOpen[i-2])) ? (inClose[i-2]) : (inOpen[i-2])) &&
            ( ( ( inClose[i-2] >= inOpen[i-2] ? 1 : -1 ) == 1 && ( inClose[i] >= inOpen[i] ? 1 : -1 ) == -1 && inClose[i] < inOpen[i-2] )
            ||
            ( ( inClose[i-2] >= inOpen[i-2] ? 1 : -1 ) == -1 && ( inClose[i] >= inOpen[i] ? 1 : -1 ) == 1 && inClose[i] > inOpen[i-2] )
            )
            )
            outInteger[outIdx++] = - ( inClose[i-2] >= inOpen[i-2] ? 1 : -1 ) * 100;
         else
            outInteger[outIdx++] = 0;
         BodyLongPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-2] - inLow[i-2] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-2] - ( inClose[i-2] >= inOpen[i-2] ? inClose[i-2] : inOpen[i-2] ) ) + ( ( inClose[i-2] >= inOpen[i-2] ? inOpen[i-2] : inClose[i-2] ) - inLow[i-2] ) : 0 ) ) ) - ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[BodyLongTrailingIdx] - inOpen[BodyLongTrailingIdx] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[BodyLongTrailingIdx] - inLow[BodyLongTrailingIdx] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[BodyLongTrailingIdx] - ( inClose[BodyLongTrailingIdx] >= inOpen[BodyLongTrailingIdx] ? inClose[BodyLongTrailingIdx] : inOpen[BodyLongTrailingIdx] ) ) + ( ( inClose[BodyLongTrailingIdx] >= inOpen[BodyLongTrailingIdx] ? inOpen[BodyLongTrailingIdx] : inClose[BodyLongTrailingIdx] ) - inLow[BodyLongTrailingIdx] ) : 0 ) ) ) ;
         BodyShortPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) - ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[BodyShortTrailingIdx] - inOpen[BodyShortTrailingIdx] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[BodyShortTrailingIdx] - inLow[BodyShortTrailingIdx] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[BodyShortTrailingIdx] - ( inClose[BodyShortTrailingIdx] >= inOpen[BodyShortTrailingIdx] ? inClose[BodyShortTrailingIdx] : inOpen[BodyShortTrailingIdx] ) ) + ( ( inClose[BodyShortTrailingIdx] >= inOpen[BodyShortTrailingIdx] ? inOpen[BodyShortTrailingIdx] : inClose[BodyShortTrailingIdx] ) - inLow[BodyShortTrailingIdx] ) : 0 ) ) ) ;
         i++;
         BodyLongTrailingIdx++;
         BodyShortTrailingIdx++;
      } while( i <= endIdx );
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   /* Generated */
   public int cdl3LineStrikeLookback( )
   {
      return (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) + 3;
   }
   public RetCode cdl3LineStrike( int startIdx,
      int endIdx,
      double inOpen[],
      double inHigh[],
      double inLow[],
      double inClose[],
      MInteger outBegIdx,
      MInteger outNBElement,
      int outInteger[] )
   {
      double []NearPeriodTotal = new double[4] ;
      int i, outIdx, totIdx, NearTrailingIdx, lookbackTotal;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      lookbackTotal = cdl3LineStrikeLookback ();
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      NearPeriodTotal[3] = 0;
      NearPeriodTotal[2] = 0;
      NearTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) ;
      i = NearTrailingIdx;
      while( i < startIdx ) {
         NearPeriodTotal[3] += ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-3] - inOpen[i-3] ) ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-3] - inLow[i-3] ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-3] - ( inClose[i-3] >= inOpen[i-3] ? inClose[i-3] : inOpen[i-3] ) ) + ( ( inClose[i-3] >= inOpen[i-3] ? inOpen[i-3] : inClose[i-3] ) - inLow[i-3] ) : 0 ) ) ) ;
         NearPeriodTotal[2] += ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-2] - inLow[i-2] ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-2] - ( inClose[i-2] >= inOpen[i-2] ? inClose[i-2] : inOpen[i-2] ) ) + ( ( inClose[i-2] >= inOpen[i-2] ? inOpen[i-2] : inClose[i-2] ) - inLow[i-2] ) : 0 ) ) ) ;
         i++;
      }
      i = startIdx;
      outIdx = 0;
      do
      {
         if( ( inClose[i-3] >= inOpen[i-3] ? 1 : -1 ) == ( inClose[i-2] >= inOpen[i-2] ? 1 : -1 ) &&
            ( inClose[i-2] >= inOpen[i-2] ? 1 : -1 ) == ( inClose[i-1] >= inOpen[i-1] ? 1 : -1 ) &&
            ( inClose[i] >= inOpen[i] ? 1 : -1 ) == - ( inClose[i-1] >= inOpen[i-1] ? 1 : -1 ) &&
            inOpen[i-2] >= (((inOpen[i-3]) < (inClose[i-3])) ? (inOpen[i-3]) : (inClose[i-3])) - ( (this.candleSettings[CandleSettingType.Near.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) != 0.0? NearPeriodTotal[3] / (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-3] - inOpen[i-3] ) ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-3] - inLow[i-3] ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-3] - ( inClose[i-3] >= inOpen[i-3] ? inClose[i-3] : inOpen[i-3] ) ) + ( ( inClose[i-3] >= inOpen[i-3] ? inOpen[i-3] : inClose[i-3] ) - inLow[i-3] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            inOpen[i-2] <= (((inOpen[i-3]) > (inClose[i-3])) ? (inOpen[i-3]) : (inClose[i-3])) + ( (this.candleSettings[CandleSettingType.Near.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) != 0.0? NearPeriodTotal[3] / (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-3] - inOpen[i-3] ) ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-3] - inLow[i-3] ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-3] - ( inClose[i-3] >= inOpen[i-3] ? inClose[i-3] : inOpen[i-3] ) ) + ( ( inClose[i-3] >= inOpen[i-3] ? inOpen[i-3] : inClose[i-3] ) - inLow[i-3] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            inOpen[i-1] >= (((inOpen[i-2]) < (inClose[i-2])) ? (inOpen[i-2]) : (inClose[i-2])) - ( (this.candleSettings[CandleSettingType.Near.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) != 0.0? NearPeriodTotal[2] / (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-2] - inLow[i-2] ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-2] - ( inClose[i-2] >= inOpen[i-2] ? inClose[i-2] : inOpen[i-2] ) ) + ( ( inClose[i-2] >= inOpen[i-2] ? inOpen[i-2] : inClose[i-2] ) - inLow[i-2] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            inOpen[i-1] <= (((inOpen[i-2]) > (inClose[i-2])) ? (inOpen[i-2]) : (inClose[i-2])) + ( (this.candleSettings[CandleSettingType.Near.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) != 0.0? NearPeriodTotal[2] / (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-2] - inLow[i-2] ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-2] - ( inClose[i-2] >= inOpen[i-2] ? inClose[i-2] : inOpen[i-2] ) ) + ( ( inClose[i-2] >= inOpen[i-2] ? inOpen[i-2] : inClose[i-2] ) - inLow[i-2] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            (
            (
            ( inClose[i-1] >= inOpen[i-1] ? 1 : -1 ) == 1 &&
            inClose[i-1] > inClose[i-2] && inClose[i-2] > inClose[i-3] &&
            inOpen[i] > inClose[i-1] &&
            inClose[i] < inOpen[i-3]
            ) ||
            (
            ( inClose[i-1] >= inOpen[i-1] ? 1 : -1 ) == -1 &&
            inClose[i-1] < inClose[i-2] && inClose[i-2] < inClose[i-3] &&
            inOpen[i] < inClose[i-1] &&
            inClose[i] > inOpen[i-3]
            )
            )
            )
            outInteger[outIdx++] = ( inClose[i-1] >= inOpen[i-1] ? 1 : -1 ) * 100;
         else
            outInteger[outIdx++] = 0;
         for (totIdx = 3; totIdx >= 2; --totIdx)
            NearPeriodTotal[totIdx] += ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-totIdx] - inOpen[i-totIdx] ) ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-totIdx] - inLow[i-totIdx] ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-totIdx] - ( inClose[i-totIdx] >= inOpen[i-totIdx] ? inClose[i-totIdx] : inOpen[i-totIdx] ) ) + ( ( inClose[i-totIdx] >= inOpen[i-totIdx] ? inOpen[i-totIdx] : inClose[i-totIdx] ) - inLow[i-totIdx] ) : 0 ) ) )
            - ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[NearTrailingIdx-totIdx] - inOpen[NearTrailingIdx-totIdx] ) ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[NearTrailingIdx-totIdx] - inLow[NearTrailingIdx-totIdx] ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[NearTrailingIdx-totIdx] - ( inClose[NearTrailingIdx-totIdx] >= inOpen[NearTrailingIdx-totIdx] ? inClose[NearTrailingIdx-totIdx] : inOpen[NearTrailingIdx-totIdx] ) ) + ( ( inClose[NearTrailingIdx-totIdx] >= inOpen[NearTrailingIdx-totIdx] ? inOpen[NearTrailingIdx-totIdx] : inClose[NearTrailingIdx-totIdx] ) - inLow[NearTrailingIdx-totIdx] ) : 0 ) ) ) ;
         i++;
         NearTrailingIdx++;
      } while( i <= endIdx );
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   public int cdl3LineStrikeStateInit( struct TA_cdl3LineStrike_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct cdl3LineStrike ));
      _state.value .value .mem_index = 0;
      _state.value .value .mem_size = cdl3LineStrikeLookback ();
      if ( _state.value .value .mem_size > 0)
         _state.value .value .memory = TA_Calloc( _state.value .value .mem_size , sizeof(struct TA_CDL3LINESTRIKE_Data));
      else
         _state.value .value .memory = NULL;
      return RetCode.Success ;
   }
   public int cdl3LineStrikeState( struct TA_cdl3LineStrike_State* _state,
      double inOpen,
      double inHigh,
      double inLow,
      double inClose,
      int *outInteger )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      size_t _cur_idx = _state.value .mem_index++;
      if ( _state.value .mem_size > 0) _cur_idx %= _state.value .mem_size ;
      if ( _state.value .mem_size > _state.value .mem_index - 1 ) {
         ( _state.value .memory+_cur_idx).value .inOpen = inOpen ;
         ( _state.value .memory+_cur_idx).value .inHigh = inHigh ;
         ( _state.value .memory+_cur_idx).value .inLow = inLow ;
         ( _state.value .memory+_cur_idx).value .inClose = inClose ;
         return RetCode.NeedMoreData ; }
      return RetCode.Success ;
   }
   public int cdl3LineStrikeStateFree( struct TA_cdl3LineStrike_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if ( _state.value != NULL) {
         if ( _state.value .value .memory != NULL) TA_Free( _state.value .value .memory );
         TA_Free( _state.value ); _state.value = NULL;}
      return RetCode.Success ;
   }
   public RetCode cdl3LineStrike( int startIdx,
      int endIdx,
      float inOpen[],
      float inHigh[],
      float inLow[],
      float inClose[],
      MInteger outBegIdx,
      MInteger outNBElement,
      int outInteger[] )
   {
      double []NearPeriodTotal = new double[4] ;
      int i, outIdx, totIdx, NearTrailingIdx, lookbackTotal;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      lookbackTotal = cdl3LineStrikeLookback ();
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      NearPeriodTotal[3] = 0;
      NearPeriodTotal[2] = 0;
      NearTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) ;
      i = NearTrailingIdx;
      while( i < startIdx ) {
         NearPeriodTotal[3] += ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-3] - inOpen[i-3] ) ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-3] - inLow[i-3] ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-3] - ( inClose[i-3] >= inOpen[i-3] ? inClose[i-3] : inOpen[i-3] ) ) + ( ( inClose[i-3] >= inOpen[i-3] ? inOpen[i-3] : inClose[i-3] ) - inLow[i-3] ) : 0 ) ) ) ;
         NearPeriodTotal[2] += ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-2] - inLow[i-2] ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-2] - ( inClose[i-2] >= inOpen[i-2] ? inClose[i-2] : inOpen[i-2] ) ) + ( ( inClose[i-2] >= inOpen[i-2] ? inOpen[i-2] : inClose[i-2] ) - inLow[i-2] ) : 0 ) ) ) ;
         i++;
      }
      i = startIdx;
      outIdx = 0;
      do
      {
         if( ( inClose[i-3] >= inOpen[i-3] ? 1 : -1 ) == ( inClose[i-2] >= inOpen[i-2] ? 1 : -1 ) &&
            ( inClose[i-2] >= inOpen[i-2] ? 1 : -1 ) == ( inClose[i-1] >= inOpen[i-1] ? 1 : -1 ) &&
            ( inClose[i] >= inOpen[i] ? 1 : -1 ) == - ( inClose[i-1] >= inOpen[i-1] ? 1 : -1 ) &&
            inOpen[i-2] >= (((inOpen[i-3]) < (inClose[i-3])) ? (inOpen[i-3]) : (inClose[i-3])) - ( (this.candleSettings[CandleSettingType.Near.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) != 0.0? NearPeriodTotal[3] / (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-3] - inOpen[i-3] ) ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-3] - inLow[i-3] ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-3] - ( inClose[i-3] >= inOpen[i-3] ? inClose[i-3] : inOpen[i-3] ) ) + ( ( inClose[i-3] >= inOpen[i-3] ? inOpen[i-3] : inClose[i-3] ) - inLow[i-3] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            inOpen[i-2] <= (((inOpen[i-3]) > (inClose[i-3])) ? (inOpen[i-3]) : (inClose[i-3])) + ( (this.candleSettings[CandleSettingType.Near.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) != 0.0? NearPeriodTotal[3] / (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-3] - inOpen[i-3] ) ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-3] - inLow[i-3] ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-3] - ( inClose[i-3] >= inOpen[i-3] ? inClose[i-3] : inOpen[i-3] ) ) + ( ( inClose[i-3] >= inOpen[i-3] ? inOpen[i-3] : inClose[i-3] ) - inLow[i-3] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            inOpen[i-1] >= (((inOpen[i-2]) < (inClose[i-2])) ? (inOpen[i-2]) : (inClose[i-2])) - ( (this.candleSettings[CandleSettingType.Near.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) != 0.0? NearPeriodTotal[2] / (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-2] - inLow[i-2] ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-2] - ( inClose[i-2] >= inOpen[i-2] ? inClose[i-2] : inOpen[i-2] ) ) + ( ( inClose[i-2] >= inOpen[i-2] ? inOpen[i-2] : inClose[i-2] ) - inLow[i-2] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            inOpen[i-1] <= (((inOpen[i-2]) > (inClose[i-2])) ? (inOpen[i-2]) : (inClose[i-2])) + ( (this.candleSettings[CandleSettingType.Near.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) != 0.0? NearPeriodTotal[2] / (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-2] - inLow[i-2] ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-2] - ( inClose[i-2] >= inOpen[i-2] ? inClose[i-2] : inOpen[i-2] ) ) + ( ( inClose[i-2] >= inOpen[i-2] ? inOpen[i-2] : inClose[i-2] ) - inLow[i-2] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            (
            (
            ( inClose[i-1] >= inOpen[i-1] ? 1 : -1 ) == 1 &&
            inClose[i-1] > inClose[i-2] && inClose[i-2] > inClose[i-3] &&
            inOpen[i] > inClose[i-1] &&
            inClose[i] < inOpen[i-3]
            ) ||
            (
            ( inClose[i-1] >= inOpen[i-1] ? 1 : -1 ) == -1 &&
            inClose[i-1] < inClose[i-2] && inClose[i-2] < inClose[i-3] &&
            inOpen[i] < inClose[i-1] &&
            inClose[i] > inOpen[i-3]
            )
            )
            )
            outInteger[outIdx++] = ( inClose[i-1] >= inOpen[i-1] ? 1 : -1 ) * 100;
         else
            outInteger[outIdx++] = 0;
         for (totIdx = 3; totIdx >= 2; --totIdx)
            NearPeriodTotal[totIdx] += ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-totIdx] - inOpen[i-totIdx] ) ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-totIdx] - inLow[i-totIdx] ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-totIdx] - ( inClose[i-totIdx] >= inOpen[i-totIdx] ? inClose[i-totIdx] : inOpen[i-totIdx] ) ) + ( ( inClose[i-totIdx] >= inOpen[i-totIdx] ? inOpen[i-totIdx] : inClose[i-totIdx] ) - inLow[i-totIdx] ) : 0 ) ) )
            - ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[NearTrailingIdx-totIdx] - inOpen[NearTrailingIdx-totIdx] ) ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[NearTrailingIdx-totIdx] - inLow[NearTrailingIdx-totIdx] ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[NearTrailingIdx-totIdx] - ( inClose[NearTrailingIdx-totIdx] >= inOpen[NearTrailingIdx-totIdx] ? inClose[NearTrailingIdx-totIdx] : inOpen[NearTrailingIdx-totIdx] ) ) + ( ( inClose[NearTrailingIdx-totIdx] >= inOpen[NearTrailingIdx-totIdx] ? inOpen[NearTrailingIdx-totIdx] : inClose[NearTrailingIdx-totIdx] ) - inLow[NearTrailingIdx-totIdx] ) : 0 ) ) ) ;
         i++;
         NearTrailingIdx++;
      } while( i <= endIdx );
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   /* Generated */
   public int cdl3OutsideLookback( )
   {
      return 3;
   }
   public RetCode cdl3Outside( int startIdx,
      int endIdx,
      double inOpen[],
      double inHigh[],
      double inLow[],
      double inClose[],
      MInteger outBegIdx,
      MInteger outNBElement,
      int outInteger[] )
   {
      int i, outIdx, lookbackTotal;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      lookbackTotal = cdl3OutsideLookback ();
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      i = startIdx;
      outIdx = 0;
      do
      {
         if( ( ( inClose[i-1] >= inOpen[i-1] ? 1 : -1 ) == 1 && ( inClose[i-2] >= inOpen[i-2] ? 1 : -1 ) == -1 &&
            inClose[i-1] > inOpen[i-2] && inOpen[i-1] < inClose[i-2] &&
            inClose[i] > inClose[i-1]
            )
            ||
            ( ( inClose[i-1] >= inOpen[i-1] ? 1 : -1 ) == -1 && ( inClose[i-2] >= inOpen[i-2] ? 1 : -1 ) == 1 &&
            inOpen[i-1] > inClose[i-2] && inClose[i-1] < inOpen[i-2] &&
            inClose[i] < inClose[i-1]
            )
            )
         {
            outInteger[outIdx++] = ( inClose[i-1] >= inOpen[i-1] ? 1 : -1 ) * 100;
         }
         else
            outInteger[outIdx++] = 0;
         i++;
      } while( i <= endIdx );
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   public int cdl3OutsideStateInit( struct TA_cdl3Outside_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct cdl3Outside ));
      _state.value .value .mem_index = 0;
      _state.value .value .mem_size = cdl3OutsideLookback ();
      if ( _state.value .value .mem_size > 0)
         _state.value .value .memory = TA_Calloc( _state.value .value .mem_size , sizeof(struct TA_CDL3OUTSIDE_Data));
      else
         _state.value .value .memory = NULL;
      return RetCode.Success ;
   }
   public int cdl3OutsideState( struct TA_cdl3Outside_State* _state,
      double inOpen,
      double inHigh,
      double inLow,
      double inClose,
      int *outInteger )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      size_t _cur_idx = _state.value .mem_index++;
      if ( _state.value .mem_size > 0) _cur_idx %= _state.value .mem_size ;
      if ( _state.value .mem_size > _state.value .mem_index - 1 ) {
         ( _state.value .memory+_cur_idx).value .inOpen = inOpen ;
         ( _state.value .memory+_cur_idx).value .inHigh = inHigh ;
         ( _state.value .memory+_cur_idx).value .inLow = inLow ;
         ( _state.value .memory+_cur_idx).value .inClose = inClose ;
         return RetCode.NeedMoreData ; }
      return RetCode.Success ;
   }
   public int cdl3OutsideStateFree( struct TA_cdl3Outside_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if ( _state.value != NULL) {
         if ( _state.value .value .memory != NULL) TA_Free( _state.value .value .memory );
         TA_Free( _state.value ); _state.value = NULL;}
      return RetCode.Success ;
   }
   public RetCode cdl3Outside( int startIdx,
      int endIdx,
      float inOpen[],
      float inHigh[],
      float inLow[],
      float inClose[],
      MInteger outBegIdx,
      MInteger outNBElement,
      int outInteger[] )
   {
      int i, outIdx, lookbackTotal;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      lookbackTotal = cdl3OutsideLookback ();
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      i = startIdx;
      outIdx = 0;
      do
      {
         if( ( ( inClose[i-1] >= inOpen[i-1] ? 1 : -1 ) == 1 && ( inClose[i-2] >= inOpen[i-2] ? 1 : -1 ) == -1 &&
            inClose[i-1] > inOpen[i-2] && inOpen[i-1] < inClose[i-2] &&
            inClose[i] > inClose[i-1]
            )
            ||
            ( ( inClose[i-1] >= inOpen[i-1] ? 1 : -1 ) == -1 && ( inClose[i-2] >= inOpen[i-2] ? 1 : -1 ) == 1 &&
            inOpen[i-1] > inClose[i-2] && inClose[i-1] < inOpen[i-2] &&
            inClose[i] < inClose[i-1]
            )
            )
         {
            outInteger[outIdx++] = ( inClose[i-1] >= inOpen[i-1] ? 1 : -1 ) * 100;
         }
         else
            outInteger[outIdx++] = 0;
         i++;
      } while( i <= endIdx );
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   /* Generated */
   public int cdl3StarsInSouthLookback( )
   {
      return ((( ((( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) ) > ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].avgPeriod) )) ? ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].avgPeriod) )) ) > ( ((( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) ) > ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) )) ? ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) )) )) ? ( ((( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) ) > ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].avgPeriod) )) ? ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].avgPeriod) )) ) : ( ((( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) ) > ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) )) ? ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) )) )) +
         2;
   }
   public RetCode cdl3StarsInSouth( int startIdx,
      int endIdx,
      double inOpen[],
      double inHigh[],
      double inLow[],
      double inClose[],
      MInteger outBegIdx,
      MInteger outNBElement,
      int outInteger[] )
   {
      double BodyLongPeriodTotal, BodyShortPeriodTotal, ShadowLongPeriodTotal;
      double []ShadowVeryShortPeriodTotal = new double[2] ;
      int i, outIdx, totIdx, BodyLongTrailingIdx, BodyShortTrailingIdx, ShadowLongTrailingIdx, ShadowVeryShortTrailingIdx,
         lookbackTotal;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      lookbackTotal = cdl3StarsInSouthLookback ();
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      BodyLongPeriodTotal = 0;
      BodyLongTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) ;
      ShadowLongPeriodTotal = 0;
      ShadowLongTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].avgPeriod) ;
      ShadowVeryShortPeriodTotal[1] = 0;
      ShadowVeryShortPeriodTotal[0] = 0;
      ShadowVeryShortTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) ;
      BodyShortPeriodTotal = 0;
      BodyShortTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) ;
      i = BodyLongTrailingIdx;
      while( i < startIdx ) {
         BodyLongPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-2] - inLow[i-2] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-2] - ( inClose[i-2] >= inOpen[i-2] ? inClose[i-2] : inOpen[i-2] ) ) + ( ( inClose[i-2] >= inOpen[i-2] ? inOpen[i-2] : inClose[i-2] ) - inLow[i-2] ) : 0 ) ) ) ;
         i++;
      }
      i = ShadowLongTrailingIdx;
      while( i < startIdx ) {
         ShadowLongPeriodTotal += ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-2] - inLow[i-2] ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-2] - ( inClose[i-2] >= inOpen[i-2] ? inClose[i-2] : inOpen[i-2] ) ) + ( ( inClose[i-2] >= inOpen[i-2] ? inOpen[i-2] : inClose[i-2] ) - inLow[i-2] ) : 0 ) ) ) ;
         i++;
      }
      i = ShadowVeryShortTrailingIdx;
      while( i < startIdx ) {
         ShadowVeryShortPeriodTotal[1] += ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ;
         ShadowVeryShortPeriodTotal[0] += ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      i = BodyShortTrailingIdx;
      while( i < startIdx ) {
         BodyShortPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      i = startIdx;
      outIdx = 0;
      do
      {
         if( ( inClose[i-2] >= inOpen[i-2] ? 1 : -1 ) == -1 &&
            ( inClose[i-1] >= inOpen[i-1] ? 1 : -1 ) == -1 &&
            ( inClose[i] >= inOpen[i] ? 1 : -1 ) == -1 &&
            ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) > ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) != 0.0? BodyLongPeriodTotal / (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-2] - inLow[i-2] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-2] - ( inClose[i-2] >= inOpen[i-2] ? inClose[i-2] : inOpen[i-2] ) ) + ( ( inClose[i-2] >= inOpen[i-2] ? inOpen[i-2] : inClose[i-2] ) - inLow[i-2] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( ( inClose[i-2] >= inOpen[i-2] ? inOpen[i-2] : inClose[i-2] ) - inLow[i-2] ) > ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].avgPeriod) != 0.0? ShadowLongPeriodTotal / (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-2] - inLow[i-2] ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-2] - ( inClose[i-2] >= inOpen[i-2] ? inClose[i-2] : inOpen[i-2] ) ) + ( ( inClose[i-2] >= inOpen[i-2] ? inOpen[i-2] : inClose[i-2] ) - inLow[i-2] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) < ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) &&
            inOpen[i-1] > inClose[i-2] && inOpen[i-1] <= inHigh[i-2] &&
            inLow[i-1] < inClose[i-2] &&
            inLow[i-1] >= inLow[i-2] &&
            ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) > ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) != 0.0? ShadowVeryShortPeriodTotal[1] / (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( Math.abs ( inClose[i] - inOpen[i] ) ) < ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) != 0.0? BodyShortPeriodTotal / (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) < ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) != 0.0? ShadowVeryShortPeriodTotal[0] / (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) < ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) != 0.0? ShadowVeryShortPeriodTotal[0] / (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            inLow[i] > inLow[i-1] && inHigh[i] < inHigh[i-1]
            )
            outInteger[outIdx++] = 100;
         else
            outInteger[outIdx++] = 0;
         BodyLongPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-2] - inLow[i-2] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-2] - ( inClose[i-2] >= inOpen[i-2] ? inClose[i-2] : inOpen[i-2] ) ) + ( ( inClose[i-2] >= inOpen[i-2] ? inOpen[i-2] : inClose[i-2] ) - inLow[i-2] ) : 0 ) ) )
            - ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[BodyLongTrailingIdx-2] - inOpen[BodyLongTrailingIdx-2] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[BodyLongTrailingIdx-2] - inLow[BodyLongTrailingIdx-2] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[BodyLongTrailingIdx-2] - ( inClose[BodyLongTrailingIdx-2] >= inOpen[BodyLongTrailingIdx-2] ? inClose[BodyLongTrailingIdx-2] : inOpen[BodyLongTrailingIdx-2] ) ) + ( ( inClose[BodyLongTrailingIdx-2] >= inOpen[BodyLongTrailingIdx-2] ? inOpen[BodyLongTrailingIdx-2] : inClose[BodyLongTrailingIdx-2] ) - inLow[BodyLongTrailingIdx-2] ) : 0 ) ) ) ;
         ShadowLongPeriodTotal += ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-2] - inLow[i-2] ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-2] - ( inClose[i-2] >= inOpen[i-2] ? inClose[i-2] : inOpen[i-2] ) ) + ( ( inClose[i-2] >= inOpen[i-2] ? inOpen[i-2] : inClose[i-2] ) - inLow[i-2] ) : 0 ) ) )
            - ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[ShadowLongTrailingIdx-2] - inOpen[ShadowLongTrailingIdx-2] ) ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[ShadowLongTrailingIdx-2] - inLow[ShadowLongTrailingIdx-2] ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[ShadowLongTrailingIdx-2] - ( inClose[ShadowLongTrailingIdx-2] >= inOpen[ShadowLongTrailingIdx-2] ? inClose[ShadowLongTrailingIdx-2] : inOpen[ShadowLongTrailingIdx-2] ) ) + ( ( inClose[ShadowLongTrailingIdx-2] >= inOpen[ShadowLongTrailingIdx-2] ? inOpen[ShadowLongTrailingIdx-2] : inClose[ShadowLongTrailingIdx-2] ) - inLow[ShadowLongTrailingIdx-2] ) : 0 ) ) ) ;
         for (totIdx = 1; totIdx >= 0; --totIdx)
            ShadowVeryShortPeriodTotal[totIdx] += ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-totIdx] - inOpen[i-totIdx] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-totIdx] - inLow[i-totIdx] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-totIdx] - ( inClose[i-totIdx] >= inOpen[i-totIdx] ? inClose[i-totIdx] : inOpen[i-totIdx] ) ) + ( ( inClose[i-totIdx] >= inOpen[i-totIdx] ? inOpen[i-totIdx] : inClose[i-totIdx] ) - inLow[i-totIdx] ) : 0 ) ) )
            - ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[ShadowVeryShortTrailingIdx-totIdx] - inOpen[ShadowVeryShortTrailingIdx-totIdx] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[ShadowVeryShortTrailingIdx-totIdx] - inLow[ShadowVeryShortTrailingIdx-totIdx] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[ShadowVeryShortTrailingIdx-totIdx] - ( inClose[ShadowVeryShortTrailingIdx-totIdx] >= inOpen[ShadowVeryShortTrailingIdx-totIdx] ? inClose[ShadowVeryShortTrailingIdx-totIdx] : inOpen[ShadowVeryShortTrailingIdx-totIdx] ) ) + ( ( inClose[ShadowVeryShortTrailingIdx-totIdx] >= inOpen[ShadowVeryShortTrailingIdx-totIdx] ? inOpen[ShadowVeryShortTrailingIdx-totIdx] : inClose[ShadowVeryShortTrailingIdx-totIdx] ) - inLow[ShadowVeryShortTrailingIdx-totIdx] ) : 0 ) ) ) ;
         BodyShortPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) )
            - ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[BodyShortTrailingIdx] - inOpen[BodyShortTrailingIdx] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[BodyShortTrailingIdx] - inLow[BodyShortTrailingIdx] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[BodyShortTrailingIdx] - ( inClose[BodyShortTrailingIdx] >= inOpen[BodyShortTrailingIdx] ? inClose[BodyShortTrailingIdx] : inOpen[BodyShortTrailingIdx] ) ) + ( ( inClose[BodyShortTrailingIdx] >= inOpen[BodyShortTrailingIdx] ? inOpen[BodyShortTrailingIdx] : inClose[BodyShortTrailingIdx] ) - inLow[BodyShortTrailingIdx] ) : 0 ) ) ) ;
         i++;
         BodyLongTrailingIdx++;
         ShadowLongTrailingIdx++;
         ShadowVeryShortTrailingIdx++;
         BodyShortTrailingIdx++;
      } while( i <= endIdx );
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   public int cdl3StarsInSouthStateInit( struct TA_cdl3StarsInSouth_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct cdl3StarsInSouth ));
      _state.value .value .mem_index = 0;
      _state.value .value .mem_size = cdl3StarsInSouthLookback ();
      if ( _state.value .value .mem_size > 0)
         _state.value .value .memory = TA_Calloc( _state.value .value .mem_size , sizeof(struct TA_CDL3STARSINSOUTH_Data));
      else
         _state.value .value .memory = NULL;
      return RetCode.Success ;
   }
   public int cdl3StarsInSouthState( struct TA_cdl3StarsInSouth_State* _state,
      double inOpen,
      double inHigh,
      double inLow,
      double inClose,
      int *outInteger )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      size_t _cur_idx = _state.value .mem_index++;
      if ( _state.value .mem_size > 0) _cur_idx %= _state.value .mem_size ;
      if ( _state.value .mem_size > _state.value .mem_index - 1 ) {
         ( _state.value .memory+_cur_idx).value .inOpen = inOpen ;
         ( _state.value .memory+_cur_idx).value .inHigh = inHigh ;
         ( _state.value .memory+_cur_idx).value .inLow = inLow ;
         ( _state.value .memory+_cur_idx).value .inClose = inClose ;
         return RetCode.NeedMoreData ; }
      return RetCode.Success ;
   }
   public int cdl3StarsInSouthStateFree( struct TA_cdl3StarsInSouth_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if ( _state.value != NULL) {
         if ( _state.value .value .memory != NULL) TA_Free( _state.value .value .memory );
         TA_Free( _state.value ); _state.value = NULL;}
      return RetCode.Success ;
   }
   public RetCode cdl3StarsInSouth( int startIdx,
      int endIdx,
      float inOpen[],
      float inHigh[],
      float inLow[],
      float inClose[],
      MInteger outBegIdx,
      MInteger outNBElement,
      int outInteger[] )
   {
      double BodyLongPeriodTotal, BodyShortPeriodTotal, ShadowLongPeriodTotal;
      double []ShadowVeryShortPeriodTotal = new double[2] ;
      int i, outIdx, totIdx, BodyLongTrailingIdx, BodyShortTrailingIdx, ShadowLongTrailingIdx, ShadowVeryShortTrailingIdx,
         lookbackTotal;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      lookbackTotal = cdl3StarsInSouthLookback ();
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      BodyLongPeriodTotal = 0;
      BodyLongTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) ;
      ShadowLongPeriodTotal = 0;
      ShadowLongTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].avgPeriod) ;
      ShadowVeryShortPeriodTotal[1] = 0;
      ShadowVeryShortPeriodTotal[0] = 0;
      ShadowVeryShortTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) ;
      BodyShortPeriodTotal = 0;
      BodyShortTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) ;
      i = BodyLongTrailingIdx;
      while( i < startIdx ) {
         BodyLongPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-2] - inLow[i-2] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-2] - ( inClose[i-2] >= inOpen[i-2] ? inClose[i-2] : inOpen[i-2] ) ) + ( ( inClose[i-2] >= inOpen[i-2] ? inOpen[i-2] : inClose[i-2] ) - inLow[i-2] ) : 0 ) ) ) ;
         i++;
      }
      i = ShadowLongTrailingIdx;
      while( i < startIdx ) {
         ShadowLongPeriodTotal += ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-2] - inLow[i-2] ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-2] - ( inClose[i-2] >= inOpen[i-2] ? inClose[i-2] : inOpen[i-2] ) ) + ( ( inClose[i-2] >= inOpen[i-2] ? inOpen[i-2] : inClose[i-2] ) - inLow[i-2] ) : 0 ) ) ) ;
         i++;
      }
      i = ShadowVeryShortTrailingIdx;
      while( i < startIdx ) {
         ShadowVeryShortPeriodTotal[1] += ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ;
         ShadowVeryShortPeriodTotal[0] += ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      i = BodyShortTrailingIdx;
      while( i < startIdx ) {
         BodyShortPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      i = startIdx;
      outIdx = 0;
      do
      {
         if( ( inClose[i-2] >= inOpen[i-2] ? 1 : -1 ) == -1 &&
            ( inClose[i-1] >= inOpen[i-1] ? 1 : -1 ) == -1 &&
            ( inClose[i] >= inOpen[i] ? 1 : -1 ) == -1 &&
            ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) > ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) != 0.0? BodyLongPeriodTotal / (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-2] - inLow[i-2] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-2] - ( inClose[i-2] >= inOpen[i-2] ? inClose[i-2] : inOpen[i-2] ) ) + ( ( inClose[i-2] >= inOpen[i-2] ? inOpen[i-2] : inClose[i-2] ) - inLow[i-2] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( ( inClose[i-2] >= inOpen[i-2] ? inOpen[i-2] : inClose[i-2] ) - inLow[i-2] ) > ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].avgPeriod) != 0.0? ShadowLongPeriodTotal / (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-2] - inLow[i-2] ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-2] - ( inClose[i-2] >= inOpen[i-2] ? inClose[i-2] : inOpen[i-2] ) ) + ( ( inClose[i-2] >= inOpen[i-2] ? inOpen[i-2] : inClose[i-2] ) - inLow[i-2] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) < ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) &&
            inOpen[i-1] > inClose[i-2] && inOpen[i-1] <= inHigh[i-2] &&
            inLow[i-1] < inClose[i-2] &&
            inLow[i-1] >= inLow[i-2] &&
            ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) > ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) != 0.0? ShadowVeryShortPeriodTotal[1] / (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( Math.abs ( inClose[i] - inOpen[i] ) ) < ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) != 0.0? BodyShortPeriodTotal / (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) < ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) != 0.0? ShadowVeryShortPeriodTotal[0] / (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) < ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) != 0.0? ShadowVeryShortPeriodTotal[0] / (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            inLow[i] > inLow[i-1] && inHigh[i] < inHigh[i-1]
            )
            outInteger[outIdx++] = 100;
         else
            outInteger[outIdx++] = 0;
         BodyLongPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-2] - inLow[i-2] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-2] - ( inClose[i-2] >= inOpen[i-2] ? inClose[i-2] : inOpen[i-2] ) ) + ( ( inClose[i-2] >= inOpen[i-2] ? inOpen[i-2] : inClose[i-2] ) - inLow[i-2] ) : 0 ) ) )
            - ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[BodyLongTrailingIdx-2] - inOpen[BodyLongTrailingIdx-2] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[BodyLongTrailingIdx-2] - inLow[BodyLongTrailingIdx-2] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[BodyLongTrailingIdx-2] - ( inClose[BodyLongTrailingIdx-2] >= inOpen[BodyLongTrailingIdx-2] ? inClose[BodyLongTrailingIdx-2] : inOpen[BodyLongTrailingIdx-2] ) ) + ( ( inClose[BodyLongTrailingIdx-2] >= inOpen[BodyLongTrailingIdx-2] ? inOpen[BodyLongTrailingIdx-2] : inClose[BodyLongTrailingIdx-2] ) - inLow[BodyLongTrailingIdx-2] ) : 0 ) ) ) ;
         ShadowLongPeriodTotal += ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-2] - inLow[i-2] ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-2] - ( inClose[i-2] >= inOpen[i-2] ? inClose[i-2] : inOpen[i-2] ) ) + ( ( inClose[i-2] >= inOpen[i-2] ? inOpen[i-2] : inClose[i-2] ) - inLow[i-2] ) : 0 ) ) )
            - ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[ShadowLongTrailingIdx-2] - inOpen[ShadowLongTrailingIdx-2] ) ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[ShadowLongTrailingIdx-2] - inLow[ShadowLongTrailingIdx-2] ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[ShadowLongTrailingIdx-2] - ( inClose[ShadowLongTrailingIdx-2] >= inOpen[ShadowLongTrailingIdx-2] ? inClose[ShadowLongTrailingIdx-2] : inOpen[ShadowLongTrailingIdx-2] ) ) + ( ( inClose[ShadowLongTrailingIdx-2] >= inOpen[ShadowLongTrailingIdx-2] ? inOpen[ShadowLongTrailingIdx-2] : inClose[ShadowLongTrailingIdx-2] ) - inLow[ShadowLongTrailingIdx-2] ) : 0 ) ) ) ;
         for (totIdx = 1; totIdx >= 0; --totIdx)
            ShadowVeryShortPeriodTotal[totIdx] += ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-totIdx] - inOpen[i-totIdx] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-totIdx] - inLow[i-totIdx] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-totIdx] - ( inClose[i-totIdx] >= inOpen[i-totIdx] ? inClose[i-totIdx] : inOpen[i-totIdx] ) ) + ( ( inClose[i-totIdx] >= inOpen[i-totIdx] ? inOpen[i-totIdx] : inClose[i-totIdx] ) - inLow[i-totIdx] ) : 0 ) ) )
            - ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[ShadowVeryShortTrailingIdx-totIdx] - inOpen[ShadowVeryShortTrailingIdx-totIdx] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[ShadowVeryShortTrailingIdx-totIdx] - inLow[ShadowVeryShortTrailingIdx-totIdx] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[ShadowVeryShortTrailingIdx-totIdx] - ( inClose[ShadowVeryShortTrailingIdx-totIdx] >= inOpen[ShadowVeryShortTrailingIdx-totIdx] ? inClose[ShadowVeryShortTrailingIdx-totIdx] : inOpen[ShadowVeryShortTrailingIdx-totIdx] ) ) + ( ( inClose[ShadowVeryShortTrailingIdx-totIdx] >= inOpen[ShadowVeryShortTrailingIdx-totIdx] ? inOpen[ShadowVeryShortTrailingIdx-totIdx] : inClose[ShadowVeryShortTrailingIdx-totIdx] ) - inLow[ShadowVeryShortTrailingIdx-totIdx] ) : 0 ) ) ) ;
         BodyShortPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) )
            - ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[BodyShortTrailingIdx] - inOpen[BodyShortTrailingIdx] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[BodyShortTrailingIdx] - inLow[BodyShortTrailingIdx] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[BodyShortTrailingIdx] - ( inClose[BodyShortTrailingIdx] >= inOpen[BodyShortTrailingIdx] ? inClose[BodyShortTrailingIdx] : inOpen[BodyShortTrailingIdx] ) ) + ( ( inClose[BodyShortTrailingIdx] >= inOpen[BodyShortTrailingIdx] ? inOpen[BodyShortTrailingIdx] : inClose[BodyShortTrailingIdx] ) - inLow[BodyShortTrailingIdx] ) : 0 ) ) ) ;
         i++;
         BodyLongTrailingIdx++;
         ShadowLongTrailingIdx++;
         ShadowVeryShortTrailingIdx++;
         BodyShortTrailingIdx++;
      } while( i <= endIdx );
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   /* Generated */
   public int cdl3WhiteSoldiersLookback( )
   {
      return ((( ((( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) ) > ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) )) ? ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) )) ) > ( ((( (this.candleSettings[CandleSettingType.Far.ordinal()].avgPeriod) ) > ( (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) )) ? ( (this.candleSettings[CandleSettingType.Far.ordinal()].avgPeriod) ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) )) )) ? ( ((( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) ) > ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) )) ? ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) )) ) : ( ((( (this.candleSettings[CandleSettingType.Far.ordinal()].avgPeriod) ) > ( (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) )) ? ( (this.candleSettings[CandleSettingType.Far.ordinal()].avgPeriod) ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) )) )) +
         2;
   }
   public RetCode cdl3WhiteSoldiers( int startIdx,
      int endIdx,
      double inOpen[],
      double inHigh[],
      double inLow[],
      double inClose[],
      MInteger outBegIdx,
      MInteger outNBElement,
      int outInteger[] )
   {
      double []ShadowVeryShortPeriodTotal = new double[3] ;
      double []NearPeriodTotal = new double[3] ;
      double []FarPeriodTotal = new double[3] ;
      double BodyShortPeriodTotal;
      int i, outIdx, totIdx, ShadowVeryShortTrailingIdx, NearTrailingIdx, FarTrailingIdx, BodyShortTrailingIdx, lookbackTotal;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      lookbackTotal = cdl3WhiteSoldiersLookback ();
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      ShadowVeryShortPeriodTotal[2] = 0;
      ShadowVeryShortPeriodTotal[1] = 0;
      ShadowVeryShortPeriodTotal[0] = 0;
      ShadowVeryShortTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) ;
      NearPeriodTotal[2] = 0;
      NearPeriodTotal[1] = 0;
      NearPeriodTotal[0] = 0;
      NearTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) ;
      FarPeriodTotal[2] = 0;
      FarPeriodTotal[1] = 0;
      FarPeriodTotal[0] = 0;
      FarTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.Far.ordinal()].avgPeriod) ;
      BodyShortPeriodTotal = 0;
      BodyShortTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) ;
      i = ShadowVeryShortTrailingIdx;
      while( i < startIdx ) {
         ShadowVeryShortPeriodTotal[2] += ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-2] - inLow[i-2] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-2] - ( inClose[i-2] >= inOpen[i-2] ? inClose[i-2] : inOpen[i-2] ) ) + ( ( inClose[i-2] >= inOpen[i-2] ? inOpen[i-2] : inClose[i-2] ) - inLow[i-2] ) : 0 ) ) ) ;
         ShadowVeryShortPeriodTotal[1] += ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ;
         ShadowVeryShortPeriodTotal[0] += ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      i = NearTrailingIdx;
      while( i < startIdx ) {
         NearPeriodTotal[2] += ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-2] - inLow[i-2] ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-2] - ( inClose[i-2] >= inOpen[i-2] ? inClose[i-2] : inOpen[i-2] ) ) + ( ( inClose[i-2] >= inOpen[i-2] ? inOpen[i-2] : inClose[i-2] ) - inLow[i-2] ) : 0 ) ) ) ;
         NearPeriodTotal[1] += ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ;
         i++;
      }
      i = FarTrailingIdx;
      while( i < startIdx ) {
         FarPeriodTotal[2] += ( (this.candleSettings[CandleSettingType.Far.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) : ( (this.candleSettings[CandleSettingType.Far.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-2] - inLow[i-2] ) : ( (this.candleSettings[CandleSettingType.Far.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-2] - ( inClose[i-2] >= inOpen[i-2] ? inClose[i-2] : inOpen[i-2] ) ) + ( ( inClose[i-2] >= inOpen[i-2] ? inOpen[i-2] : inClose[i-2] ) - inLow[i-2] ) : 0 ) ) ) ;
         FarPeriodTotal[1] += ( (this.candleSettings[CandleSettingType.Far.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.Far.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.Far.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ;
         i++;
      }
      i = BodyShortTrailingIdx;
      while( i < startIdx ) {
         BodyShortPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      i = startIdx;
      outIdx = 0;
      do
      {
         if( ( inClose[i-2] >= inOpen[i-2] ? 1 : -1 ) == 1 &&
            ( inHigh[i-2] - ( inClose[i-2] >= inOpen[i-2] ? inClose[i-2] : inOpen[i-2] ) ) < ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) != 0.0? ShadowVeryShortPeriodTotal[2] / (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-2] - inLow[i-2] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-2] - ( inClose[i-2] >= inOpen[i-2] ? inClose[i-2] : inOpen[i-2] ) ) + ( ( inClose[i-2] >= inOpen[i-2] ? inOpen[i-2] : inClose[i-2] ) - inLow[i-2] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( inClose[i-1] >= inOpen[i-1] ? 1 : -1 ) == 1 &&
            ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) < ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) != 0.0? ShadowVeryShortPeriodTotal[1] / (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( inClose[i] >= inOpen[i] ? 1 : -1 ) == 1 &&
            ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) < ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) != 0.0? ShadowVeryShortPeriodTotal[0] / (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            inClose[i] > inClose[i-1] && inClose[i-1] > inClose[i-2] &&
            inOpen[i-1] > inOpen[i-2] &&
            inOpen[i-1] <= inClose[i-2] + ( (this.candleSettings[CandleSettingType.Near.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) != 0.0? NearPeriodTotal[2] / (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-2] - inLow[i-2] ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-2] - ( inClose[i-2] >= inOpen[i-2] ? inClose[i-2] : inOpen[i-2] ) ) + ( ( inClose[i-2] >= inOpen[i-2] ? inOpen[i-2] : inClose[i-2] ) - inLow[i-2] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            inOpen[i] > inOpen[i-1] &&
            inOpen[i] <= inClose[i-1] + ( (this.candleSettings[CandleSettingType.Near.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) != 0.0? NearPeriodTotal[1] / (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) > ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) - ( (this.candleSettings[CandleSettingType.Far.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.Far.ordinal()].avgPeriod) != 0.0? FarPeriodTotal[2] / (this.candleSettings[CandleSettingType.Far.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.Far.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) : ( (this.candleSettings[CandleSettingType.Far.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-2] - inLow[i-2] ) : ( (this.candleSettings[CandleSettingType.Far.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-2] - ( inClose[i-2] >= inOpen[i-2] ? inClose[i-2] : inOpen[i-2] ) ) + ( ( inClose[i-2] >= inOpen[i-2] ? inOpen[i-2] : inClose[i-2] ) - inLow[i-2] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.Far.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( Math.abs ( inClose[i] - inOpen[i] ) ) > ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) - ( (this.candleSettings[CandleSettingType.Far.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.Far.ordinal()].avgPeriod) != 0.0? FarPeriodTotal[1] / (this.candleSettings[CandleSettingType.Far.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.Far.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.Far.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.Far.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.Far.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( Math.abs ( inClose[i] - inOpen[i] ) ) > ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) != 0.0? BodyShortPeriodTotal / (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) )
            )
            outInteger[outIdx++] = 100;
         else
            outInteger[outIdx++] = 0;
         for (totIdx = 2; totIdx >= 0; --totIdx)
            ShadowVeryShortPeriodTotal[totIdx] += ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-totIdx] - inOpen[i-totIdx] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-totIdx] - inLow[i-totIdx] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-totIdx] - ( inClose[i-totIdx] >= inOpen[i-totIdx] ? inClose[i-totIdx] : inOpen[i-totIdx] ) ) + ( ( inClose[i-totIdx] >= inOpen[i-totIdx] ? inOpen[i-totIdx] : inClose[i-totIdx] ) - inLow[i-totIdx] ) : 0 ) ) )
            - ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[ShadowVeryShortTrailingIdx-totIdx] - inOpen[ShadowVeryShortTrailingIdx-totIdx] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[ShadowVeryShortTrailingIdx-totIdx] - inLow[ShadowVeryShortTrailingIdx-totIdx] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[ShadowVeryShortTrailingIdx-totIdx] - ( inClose[ShadowVeryShortTrailingIdx-totIdx] >= inOpen[ShadowVeryShortTrailingIdx-totIdx] ? inClose[ShadowVeryShortTrailingIdx-totIdx] : inOpen[ShadowVeryShortTrailingIdx-totIdx] ) ) + ( ( inClose[ShadowVeryShortTrailingIdx-totIdx] >= inOpen[ShadowVeryShortTrailingIdx-totIdx] ? inOpen[ShadowVeryShortTrailingIdx-totIdx] : inClose[ShadowVeryShortTrailingIdx-totIdx] ) - inLow[ShadowVeryShortTrailingIdx-totIdx] ) : 0 ) ) ) ;
         for (totIdx = 2; totIdx >= 1; --totIdx) {
            FarPeriodTotal[totIdx] += ( (this.candleSettings[CandleSettingType.Far.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-totIdx] - inOpen[i-totIdx] ) ) : ( (this.candleSettings[CandleSettingType.Far.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-totIdx] - inLow[i-totIdx] ) : ( (this.candleSettings[CandleSettingType.Far.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-totIdx] - ( inClose[i-totIdx] >= inOpen[i-totIdx] ? inClose[i-totIdx] : inOpen[i-totIdx] ) ) + ( ( inClose[i-totIdx] >= inOpen[i-totIdx] ? inOpen[i-totIdx] : inClose[i-totIdx] ) - inLow[i-totIdx] ) : 0 ) ) )
               - ( (this.candleSettings[CandleSettingType.Far.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[FarTrailingIdx-totIdx] - inOpen[FarTrailingIdx-totIdx] ) ) : ( (this.candleSettings[CandleSettingType.Far.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[FarTrailingIdx-totIdx] - inLow[FarTrailingIdx-totIdx] ) : ( (this.candleSettings[CandleSettingType.Far.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[FarTrailingIdx-totIdx] - ( inClose[FarTrailingIdx-totIdx] >= inOpen[FarTrailingIdx-totIdx] ? inClose[FarTrailingIdx-totIdx] : inOpen[FarTrailingIdx-totIdx] ) ) + ( ( inClose[FarTrailingIdx-totIdx] >= inOpen[FarTrailingIdx-totIdx] ? inOpen[FarTrailingIdx-totIdx] : inClose[FarTrailingIdx-totIdx] ) - inLow[FarTrailingIdx-totIdx] ) : 0 ) ) ) ;
            NearPeriodTotal[totIdx] += ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-totIdx] - inOpen[i-totIdx] ) ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-totIdx] - inLow[i-totIdx] ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-totIdx] - ( inClose[i-totIdx] >= inOpen[i-totIdx] ? inClose[i-totIdx] : inOpen[i-totIdx] ) ) + ( ( inClose[i-totIdx] >= inOpen[i-totIdx] ? inOpen[i-totIdx] : inClose[i-totIdx] ) - inLow[i-totIdx] ) : 0 ) ) )
               - ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[NearTrailingIdx-totIdx] - inOpen[NearTrailingIdx-totIdx] ) ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[NearTrailingIdx-totIdx] - inLow[NearTrailingIdx-totIdx] ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[NearTrailingIdx-totIdx] - ( inClose[NearTrailingIdx-totIdx] >= inOpen[NearTrailingIdx-totIdx] ? inClose[NearTrailingIdx-totIdx] : inOpen[NearTrailingIdx-totIdx] ) ) + ( ( inClose[NearTrailingIdx-totIdx] >= inOpen[NearTrailingIdx-totIdx] ? inOpen[NearTrailingIdx-totIdx] : inClose[NearTrailingIdx-totIdx] ) - inLow[NearTrailingIdx-totIdx] ) : 0 ) ) ) ;
         }
         BodyShortPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) - ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[BodyShortTrailingIdx] - inOpen[BodyShortTrailingIdx] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[BodyShortTrailingIdx] - inLow[BodyShortTrailingIdx] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[BodyShortTrailingIdx] - ( inClose[BodyShortTrailingIdx] >= inOpen[BodyShortTrailingIdx] ? inClose[BodyShortTrailingIdx] : inOpen[BodyShortTrailingIdx] ) ) + ( ( inClose[BodyShortTrailingIdx] >= inOpen[BodyShortTrailingIdx] ? inOpen[BodyShortTrailingIdx] : inClose[BodyShortTrailingIdx] ) - inLow[BodyShortTrailingIdx] ) : 0 ) ) ) ;
         i++;
         ShadowVeryShortTrailingIdx++;
         NearTrailingIdx++;
         FarTrailingIdx++;
         BodyShortTrailingIdx++;
      } while( i <= endIdx );
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   public int cdl3WhiteSoldiersStateInit( struct TA_cdl3WhiteSoldiers_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct cdl3WhiteSoldiers ));
      _state.value .value .mem_index = 0;
      _state.value .value .mem_size = cdl3WhiteSoldiersLookback ();
      if ( _state.value .value .mem_size > 0)
         _state.value .value .memory = TA_Calloc( _state.value .value .mem_size , sizeof(struct TA_CDL3WHITESOLDIERS_Data));
      else
         _state.value .value .memory = NULL;
      return RetCode.Success ;
   }
   public int cdl3WhiteSoldiersState( struct TA_cdl3WhiteSoldiers_State* _state,
      double inOpen,
      double inHigh,
      double inLow,
      double inClose,
      int *outInteger )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      size_t _cur_idx = _state.value .mem_index++;
      if ( _state.value .mem_size > 0) _cur_idx %= _state.value .mem_size ;
      if ( _state.value .mem_size > _state.value .mem_index - 1 ) {
         ( _state.value .memory+_cur_idx).value .inOpen = inOpen ;
         ( _state.value .memory+_cur_idx).value .inHigh = inHigh ;
         ( _state.value .memory+_cur_idx).value .inLow = inLow ;
         ( _state.value .memory+_cur_idx).value .inClose = inClose ;
         return RetCode.NeedMoreData ; }
      return RetCode.Success ;
   }
   public int cdl3WhiteSoldiersStateFree( struct TA_cdl3WhiteSoldiers_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if ( _state.value != NULL) {
         if ( _state.value .value .memory != NULL) TA_Free( _state.value .value .memory );
         TA_Free( _state.value ); _state.value = NULL;}
      return RetCode.Success ;
   }
   public RetCode cdl3WhiteSoldiers( int startIdx,
      int endIdx,
      float inOpen[],
      float inHigh[],
      float inLow[],
      float inClose[],
      MInteger outBegIdx,
      MInteger outNBElement,
      int outInteger[] )
   {
      double []ShadowVeryShortPeriodTotal = new double[3] ;
      double []NearPeriodTotal = new double[3] ;
      double []FarPeriodTotal = new double[3] ;
      double BodyShortPeriodTotal;
      int i, outIdx, totIdx, ShadowVeryShortTrailingIdx, NearTrailingIdx, FarTrailingIdx, BodyShortTrailingIdx, lookbackTotal;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      lookbackTotal = cdl3WhiteSoldiersLookback ();
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      ShadowVeryShortPeriodTotal[2] = 0;
      ShadowVeryShortPeriodTotal[1] = 0;
      ShadowVeryShortPeriodTotal[0] = 0;
      ShadowVeryShortTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) ;
      NearPeriodTotal[2] = 0;
      NearPeriodTotal[1] = 0;
      NearPeriodTotal[0] = 0;
      NearTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) ;
      FarPeriodTotal[2] = 0;
      FarPeriodTotal[1] = 0;
      FarPeriodTotal[0] = 0;
      FarTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.Far.ordinal()].avgPeriod) ;
      BodyShortPeriodTotal = 0;
      BodyShortTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) ;
      i = ShadowVeryShortTrailingIdx;
      while( i < startIdx ) {
         ShadowVeryShortPeriodTotal[2] += ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-2] - inLow[i-2] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-2] - ( inClose[i-2] >= inOpen[i-2] ? inClose[i-2] : inOpen[i-2] ) ) + ( ( inClose[i-2] >= inOpen[i-2] ? inOpen[i-2] : inClose[i-2] ) - inLow[i-2] ) : 0 ) ) ) ;
         ShadowVeryShortPeriodTotal[1] += ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ;
         ShadowVeryShortPeriodTotal[0] += ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      i = NearTrailingIdx;
      while( i < startIdx ) {
         NearPeriodTotal[2] += ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-2] - inLow[i-2] ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-2] - ( inClose[i-2] >= inOpen[i-2] ? inClose[i-2] : inOpen[i-2] ) ) + ( ( inClose[i-2] >= inOpen[i-2] ? inOpen[i-2] : inClose[i-2] ) - inLow[i-2] ) : 0 ) ) ) ;
         NearPeriodTotal[1] += ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ;
         i++;
      }
      i = FarTrailingIdx;
      while( i < startIdx ) {
         FarPeriodTotal[2] += ( (this.candleSettings[CandleSettingType.Far.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) : ( (this.candleSettings[CandleSettingType.Far.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-2] - inLow[i-2] ) : ( (this.candleSettings[CandleSettingType.Far.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-2] - ( inClose[i-2] >= inOpen[i-2] ? inClose[i-2] : inOpen[i-2] ) ) + ( ( inClose[i-2] >= inOpen[i-2] ? inOpen[i-2] : inClose[i-2] ) - inLow[i-2] ) : 0 ) ) ) ;
         FarPeriodTotal[1] += ( (this.candleSettings[CandleSettingType.Far.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.Far.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.Far.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ;
         i++;
      }
      i = BodyShortTrailingIdx;
      while( i < startIdx ) {
         BodyShortPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      i = startIdx;
      outIdx = 0;
      do
      {
         if( ( inClose[i-2] >= inOpen[i-2] ? 1 : -1 ) == 1 &&
            ( inHigh[i-2] - ( inClose[i-2] >= inOpen[i-2] ? inClose[i-2] : inOpen[i-2] ) ) < ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) != 0.0? ShadowVeryShortPeriodTotal[2] / (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-2] - inLow[i-2] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-2] - ( inClose[i-2] >= inOpen[i-2] ? inClose[i-2] : inOpen[i-2] ) ) + ( ( inClose[i-2] >= inOpen[i-2] ? inOpen[i-2] : inClose[i-2] ) - inLow[i-2] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( inClose[i-1] >= inOpen[i-1] ? 1 : -1 ) == 1 &&
            ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) < ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) != 0.0? ShadowVeryShortPeriodTotal[1] / (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( inClose[i] >= inOpen[i] ? 1 : -1 ) == 1 &&
            ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) < ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) != 0.0? ShadowVeryShortPeriodTotal[0] / (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            inClose[i] > inClose[i-1] && inClose[i-1] > inClose[i-2] &&
            inOpen[i-1] > inOpen[i-2] &&
            inOpen[i-1] <= inClose[i-2] + ( (this.candleSettings[CandleSettingType.Near.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) != 0.0? NearPeriodTotal[2] / (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-2] - inLow[i-2] ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-2] - ( inClose[i-2] >= inOpen[i-2] ? inClose[i-2] : inOpen[i-2] ) ) + ( ( inClose[i-2] >= inOpen[i-2] ? inOpen[i-2] : inClose[i-2] ) - inLow[i-2] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            inOpen[i] > inOpen[i-1] &&
            inOpen[i] <= inClose[i-1] + ( (this.candleSettings[CandleSettingType.Near.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) != 0.0? NearPeriodTotal[1] / (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) > ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) - ( (this.candleSettings[CandleSettingType.Far.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.Far.ordinal()].avgPeriod) != 0.0? FarPeriodTotal[2] / (this.candleSettings[CandleSettingType.Far.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.Far.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) : ( (this.candleSettings[CandleSettingType.Far.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-2] - inLow[i-2] ) : ( (this.candleSettings[CandleSettingType.Far.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-2] - ( inClose[i-2] >= inOpen[i-2] ? inClose[i-2] : inOpen[i-2] ) ) + ( ( inClose[i-2] >= inOpen[i-2] ? inOpen[i-2] : inClose[i-2] ) - inLow[i-2] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.Far.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( Math.abs ( inClose[i] - inOpen[i] ) ) > ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) - ( (this.candleSettings[CandleSettingType.Far.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.Far.ordinal()].avgPeriod) != 0.0? FarPeriodTotal[1] / (this.candleSettings[CandleSettingType.Far.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.Far.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.Far.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.Far.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.Far.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( Math.abs ( inClose[i] - inOpen[i] ) ) > ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) != 0.0? BodyShortPeriodTotal / (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) )
            )
            outInteger[outIdx++] = 100;
         else
            outInteger[outIdx++] = 0;
         for (totIdx = 2; totIdx >= 0; --totIdx)
            ShadowVeryShortPeriodTotal[totIdx] += ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-totIdx] - inOpen[i-totIdx] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-totIdx] - inLow[i-totIdx] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-totIdx] - ( inClose[i-totIdx] >= inOpen[i-totIdx] ? inClose[i-totIdx] : inOpen[i-totIdx] ) ) + ( ( inClose[i-totIdx] >= inOpen[i-totIdx] ? inOpen[i-totIdx] : inClose[i-totIdx] ) - inLow[i-totIdx] ) : 0 ) ) )
            - ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[ShadowVeryShortTrailingIdx-totIdx] - inOpen[ShadowVeryShortTrailingIdx-totIdx] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[ShadowVeryShortTrailingIdx-totIdx] - inLow[ShadowVeryShortTrailingIdx-totIdx] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[ShadowVeryShortTrailingIdx-totIdx] - ( inClose[ShadowVeryShortTrailingIdx-totIdx] >= inOpen[ShadowVeryShortTrailingIdx-totIdx] ? inClose[ShadowVeryShortTrailingIdx-totIdx] : inOpen[ShadowVeryShortTrailingIdx-totIdx] ) ) + ( ( inClose[ShadowVeryShortTrailingIdx-totIdx] >= inOpen[ShadowVeryShortTrailingIdx-totIdx] ? inOpen[ShadowVeryShortTrailingIdx-totIdx] : inClose[ShadowVeryShortTrailingIdx-totIdx] ) - inLow[ShadowVeryShortTrailingIdx-totIdx] ) : 0 ) ) ) ;
         for (totIdx = 2; totIdx >= 1; --totIdx) {
            FarPeriodTotal[totIdx] += ( (this.candleSettings[CandleSettingType.Far.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-totIdx] - inOpen[i-totIdx] ) ) : ( (this.candleSettings[CandleSettingType.Far.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-totIdx] - inLow[i-totIdx] ) : ( (this.candleSettings[CandleSettingType.Far.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-totIdx] - ( inClose[i-totIdx] >= inOpen[i-totIdx] ? inClose[i-totIdx] : inOpen[i-totIdx] ) ) + ( ( inClose[i-totIdx] >= inOpen[i-totIdx] ? inOpen[i-totIdx] : inClose[i-totIdx] ) - inLow[i-totIdx] ) : 0 ) ) )
               - ( (this.candleSettings[CandleSettingType.Far.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[FarTrailingIdx-totIdx] - inOpen[FarTrailingIdx-totIdx] ) ) : ( (this.candleSettings[CandleSettingType.Far.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[FarTrailingIdx-totIdx] - inLow[FarTrailingIdx-totIdx] ) : ( (this.candleSettings[CandleSettingType.Far.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[FarTrailingIdx-totIdx] - ( inClose[FarTrailingIdx-totIdx] >= inOpen[FarTrailingIdx-totIdx] ? inClose[FarTrailingIdx-totIdx] : inOpen[FarTrailingIdx-totIdx] ) ) + ( ( inClose[FarTrailingIdx-totIdx] >= inOpen[FarTrailingIdx-totIdx] ? inOpen[FarTrailingIdx-totIdx] : inClose[FarTrailingIdx-totIdx] ) - inLow[FarTrailingIdx-totIdx] ) : 0 ) ) ) ;
            NearPeriodTotal[totIdx] += ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-totIdx] - inOpen[i-totIdx] ) ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-totIdx] - inLow[i-totIdx] ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-totIdx] - ( inClose[i-totIdx] >= inOpen[i-totIdx] ? inClose[i-totIdx] : inOpen[i-totIdx] ) ) + ( ( inClose[i-totIdx] >= inOpen[i-totIdx] ? inOpen[i-totIdx] : inClose[i-totIdx] ) - inLow[i-totIdx] ) : 0 ) ) )
               - ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[NearTrailingIdx-totIdx] - inOpen[NearTrailingIdx-totIdx] ) ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[NearTrailingIdx-totIdx] - inLow[NearTrailingIdx-totIdx] ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[NearTrailingIdx-totIdx] - ( inClose[NearTrailingIdx-totIdx] >= inOpen[NearTrailingIdx-totIdx] ? inClose[NearTrailingIdx-totIdx] : inOpen[NearTrailingIdx-totIdx] ) ) + ( ( inClose[NearTrailingIdx-totIdx] >= inOpen[NearTrailingIdx-totIdx] ? inOpen[NearTrailingIdx-totIdx] : inClose[NearTrailingIdx-totIdx] ) - inLow[NearTrailingIdx-totIdx] ) : 0 ) ) ) ;
         }
         BodyShortPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) - ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[BodyShortTrailingIdx] - inOpen[BodyShortTrailingIdx] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[BodyShortTrailingIdx] - inLow[BodyShortTrailingIdx] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[BodyShortTrailingIdx] - ( inClose[BodyShortTrailingIdx] >= inOpen[BodyShortTrailingIdx] ? inClose[BodyShortTrailingIdx] : inOpen[BodyShortTrailingIdx] ) ) + ( ( inClose[BodyShortTrailingIdx] >= inOpen[BodyShortTrailingIdx] ? inOpen[BodyShortTrailingIdx] : inClose[BodyShortTrailingIdx] ) - inLow[BodyShortTrailingIdx] ) : 0 ) ) ) ;
         i++;
         ShadowVeryShortTrailingIdx++;
         NearTrailingIdx++;
         FarTrailingIdx++;
         BodyShortTrailingIdx++;
      } while( i <= endIdx );
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   /* Generated */
   public int cdlAbandonedBabyLookback( double optInPenetration )
   {
      if( optInPenetration == (-4e+37) )
         optInPenetration = 3.000000e-1;
      else if( (optInPenetration < 0.000000e+0) || (optInPenetration > 3.000000e+37) )
         return -1;
      return ((( ((( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].avgPeriod) ) > ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) )) ? ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].avgPeriod) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) )) ) > ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) )) ? ( ((( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].avgPeriod) ) > ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) )) ? ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].avgPeriod) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) )) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) )) +
         2;
   }
   public RetCode cdlAbandonedBaby( int startIdx,
      int endIdx,
      double inOpen[],
      double inHigh[],
      double inLow[],
      double inClose[],
      double optInPenetration,
      MInteger outBegIdx,
      MInteger outNBElement,
      int outInteger[] )
   {
      double BodyDojiPeriodTotal, BodyLongPeriodTotal, BodyShortPeriodTotal;
      int i, outIdx, BodyDojiTrailingIdx, BodyLongTrailingIdx, BodyShortTrailingIdx, lookbackTotal;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      if( optInPenetration == (-4e+37) )
         optInPenetration = 3.000000e-1;
      else if( (optInPenetration < 0.000000e+0) || (optInPenetration > 3.000000e+37) )
         return RetCode.BadParam ;
      lookbackTotal = cdlAbandonedBabyLookback (optInPenetration);
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      BodyLongPeriodTotal = 0;
      BodyDojiPeriodTotal = 0;
      BodyShortPeriodTotal = 0;
      BodyLongTrailingIdx = startIdx -2 - (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) ;
      BodyDojiTrailingIdx = startIdx -1 - (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].avgPeriod) ;
      BodyShortTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) ;
      i = BodyLongTrailingIdx;
      while( i < startIdx-2 ) {
         BodyLongPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      i = BodyDojiTrailingIdx;
      while( i < startIdx-1 ) {
         BodyDojiPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      i = BodyShortTrailingIdx;
      while( i < startIdx ) {
         BodyShortPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      i = startIdx;
      outIdx = 0;
      do
      {
         if( ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) > ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) != 0.0? BodyLongPeriodTotal / (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-2] - inLow[i-2] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-2] - ( inClose[i-2] >= inOpen[i-2] ? inClose[i-2] : inOpen[i-2] ) ) + ( ( inClose[i-2] >= inOpen[i-2] ? inOpen[i-2] : inClose[i-2] ) - inLow[i-2] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) <= ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].avgPeriod) != 0.0? BodyDojiPeriodTotal / (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( Math.abs ( inClose[i] - inOpen[i] ) ) > ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) != 0.0? BodyShortPeriodTotal / (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( ( ( inClose[i-2] >= inOpen[i-2] ? 1 : -1 ) == 1 &&
            ( inClose[i] >= inOpen[i] ? 1 : -1 ) == -1 &&
            inClose[i] < inClose[i-2] - ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) * optInPenetration &&
            ( inLow[i-1] > inHigh[i-2] ) &&
            ( inHigh[i] < inLow[i-1] )
            )
            ||
            (
            ( inClose[i-2] >= inOpen[i-2] ? 1 : -1 ) == -1 &&
            ( inClose[i] >= inOpen[i] ? 1 : -1 ) == 1 &&
            inClose[i] > inClose[i-2] + ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) * optInPenetration &&
            ( inHigh[i-1] < inLow[i-2] ) &&
            ( inLow[i] > inHigh[i-1] )
            )
            )
            )
         {
            outInteger[outIdx++] = ( inClose[i] >= inOpen[i] ? 1 : -1 ) * 100;
         }
         else
         {
            outInteger[outIdx++] = 0;
         }
         BodyLongPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-2] - inLow[i-2] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-2] - ( inClose[i-2] >= inOpen[i-2] ? inClose[i-2] : inOpen[i-2] ) ) + ( ( inClose[i-2] >= inOpen[i-2] ? inOpen[i-2] : inClose[i-2] ) - inLow[i-2] ) : 0 ) ) ) - ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[BodyLongTrailingIdx] - inOpen[BodyLongTrailingIdx] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[BodyLongTrailingIdx] - inLow[BodyLongTrailingIdx] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[BodyLongTrailingIdx] - ( inClose[BodyLongTrailingIdx] >= inOpen[BodyLongTrailingIdx] ? inClose[BodyLongTrailingIdx] : inOpen[BodyLongTrailingIdx] ) ) + ( ( inClose[BodyLongTrailingIdx] >= inOpen[BodyLongTrailingIdx] ? inOpen[BodyLongTrailingIdx] : inClose[BodyLongTrailingIdx] ) - inLow[BodyLongTrailingIdx] ) : 0 ) ) ) ;
         BodyDojiPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) - ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[BodyDojiTrailingIdx] - inOpen[BodyDojiTrailingIdx] ) ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[BodyDojiTrailingIdx] - inLow[BodyDojiTrailingIdx] ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[BodyDojiTrailingIdx] - ( inClose[BodyDojiTrailingIdx] >= inOpen[BodyDojiTrailingIdx] ? inClose[BodyDojiTrailingIdx] : inOpen[BodyDojiTrailingIdx] ) ) + ( ( inClose[BodyDojiTrailingIdx] >= inOpen[BodyDojiTrailingIdx] ? inOpen[BodyDojiTrailingIdx] : inClose[BodyDojiTrailingIdx] ) - inLow[BodyDojiTrailingIdx] ) : 0 ) ) ) ;
         BodyShortPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) - ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[BodyShortTrailingIdx] - inOpen[BodyShortTrailingIdx] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[BodyShortTrailingIdx] - inLow[BodyShortTrailingIdx] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[BodyShortTrailingIdx] - ( inClose[BodyShortTrailingIdx] >= inOpen[BodyShortTrailingIdx] ? inClose[BodyShortTrailingIdx] : inOpen[BodyShortTrailingIdx] ) ) + ( ( inClose[BodyShortTrailingIdx] >= inOpen[BodyShortTrailingIdx] ? inOpen[BodyShortTrailingIdx] : inClose[BodyShortTrailingIdx] ) - inLow[BodyShortTrailingIdx] ) : 0 ) ) ) ;
         i++;
         BodyLongTrailingIdx++;
         BodyDojiTrailingIdx++;
         BodyShortTrailingIdx++;
      } while( i <= endIdx );
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   public int cdlAbandonedBabyStateInit( struct TA_cdlAbandonedBaby_State** _state,
      double optInPenetration )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if( optInPenetration == (-4e+37) )
         optInPenetration = 3.000000e-1;
      else if( (optInPenetration < 0.000000e+0) || (optInPenetration > 3.000000e+37) )
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct cdlAbandonedBaby ));
      _state.value .value .mem_index = 0;
      _state.value .value .optInPenetration = optInPenetration;
      _state.value .value .mem_size = cdlAbandonedBabyLookback (optInPenetration );
      if ( _state.value .value .mem_size > 0)
         _state.value .value .memory = TA_Calloc( _state.value .value .mem_size , sizeof(struct TA_CDLABANDONEDBABY_Data));
      else
         _state.value .value .memory = NULL;
      return RetCode.Success ;
   }
   public int cdlAbandonedBabyState( struct TA_cdlAbandonedBaby_State* _state,
      double inOpen,
      double inHigh,
      double inLow,
      double inClose,
      int *outInteger )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      size_t _cur_idx = _state.value .mem_index++;
      if ( _state.value .mem_size > 0) _cur_idx %= _state.value .mem_size ;
      if ( _state.value .mem_size > _state.value .mem_index - 1 ) {
         ( _state.value .memory+_cur_idx).value .inOpen = inOpen ;
         ( _state.value .memory+_cur_idx).value .inHigh = inHigh ;
         ( _state.value .memory+_cur_idx).value .inLow = inLow ;
         ( _state.value .memory+_cur_idx).value .inClose = inClose ;
         return RetCode.NeedMoreData ; }
      return RetCode.Success ;
   }
   public int cdlAbandonedBabyStateFree( struct TA_cdlAbandonedBaby_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if ( _state.value != NULL) {
         if ( _state.value .value .memory != NULL) TA_Free( _state.value .value .memory );
         TA_Free( _state.value ); _state.value = NULL;}
      return RetCode.Success ;
   }
   public RetCode cdlAbandonedBaby( int startIdx,
      int endIdx,
      float inOpen[],
      float inHigh[],
      float inLow[],
      float inClose[],
      double optInPenetration,
      MInteger outBegIdx,
      MInteger outNBElement,
      int outInteger[] )
   {
      double BodyDojiPeriodTotal, BodyLongPeriodTotal, BodyShortPeriodTotal;
      int i, outIdx, BodyDojiTrailingIdx, BodyLongTrailingIdx, BodyShortTrailingIdx, lookbackTotal;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      if( optInPenetration == (-4e+37) )
         optInPenetration = 3.000000e-1;
      else if( (optInPenetration < 0.000000e+0) || (optInPenetration > 3.000000e+37) )
         return RetCode.BadParam ;
      lookbackTotal = cdlAbandonedBabyLookback (optInPenetration);
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      BodyLongPeriodTotal = 0;
      BodyDojiPeriodTotal = 0;
      BodyShortPeriodTotal = 0;
      BodyLongTrailingIdx = startIdx -2 - (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) ;
      BodyDojiTrailingIdx = startIdx -1 - (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].avgPeriod) ;
      BodyShortTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) ;
      i = BodyLongTrailingIdx;
      while( i < startIdx-2 ) {
         BodyLongPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      i = BodyDojiTrailingIdx;
      while( i < startIdx-1 ) {
         BodyDojiPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      i = BodyShortTrailingIdx;
      while( i < startIdx ) {
         BodyShortPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      i = startIdx;
      outIdx = 0;
      do
      {
         if( ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) > ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) != 0.0? BodyLongPeriodTotal / (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-2] - inLow[i-2] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-2] - ( inClose[i-2] >= inOpen[i-2] ? inClose[i-2] : inOpen[i-2] ) ) + ( ( inClose[i-2] >= inOpen[i-2] ? inOpen[i-2] : inClose[i-2] ) - inLow[i-2] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) <= ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].avgPeriod) != 0.0? BodyDojiPeriodTotal / (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( Math.abs ( inClose[i] - inOpen[i] ) ) > ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) != 0.0? BodyShortPeriodTotal / (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( ( ( inClose[i-2] >= inOpen[i-2] ? 1 : -1 ) == 1 &&
            ( inClose[i] >= inOpen[i] ? 1 : -1 ) == -1 &&
            inClose[i] < inClose[i-2] - ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) * optInPenetration &&
            ( inLow[i-1] > inHigh[i-2] ) &&
            ( inHigh[i] < inLow[i-1] )
            )
            ||
            (
            ( inClose[i-2] >= inOpen[i-2] ? 1 : -1 ) == -1 &&
            ( inClose[i] >= inOpen[i] ? 1 : -1 ) == 1 &&
            inClose[i] > inClose[i-2] + ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) * optInPenetration &&
            ( inHigh[i-1] < inLow[i-2] ) &&
            ( inLow[i] > inHigh[i-1] )
            )
            )
            )
         {
            outInteger[outIdx++] = ( inClose[i] >= inOpen[i] ? 1 : -1 ) * 100;
         }
         else
         {
            outInteger[outIdx++] = 0;
         }
         BodyLongPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-2] - inLow[i-2] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-2] - ( inClose[i-2] >= inOpen[i-2] ? inClose[i-2] : inOpen[i-2] ) ) + ( ( inClose[i-2] >= inOpen[i-2] ? inOpen[i-2] : inClose[i-2] ) - inLow[i-2] ) : 0 ) ) ) - ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[BodyLongTrailingIdx] - inOpen[BodyLongTrailingIdx] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[BodyLongTrailingIdx] - inLow[BodyLongTrailingIdx] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[BodyLongTrailingIdx] - ( inClose[BodyLongTrailingIdx] >= inOpen[BodyLongTrailingIdx] ? inClose[BodyLongTrailingIdx] : inOpen[BodyLongTrailingIdx] ) ) + ( ( inClose[BodyLongTrailingIdx] >= inOpen[BodyLongTrailingIdx] ? inOpen[BodyLongTrailingIdx] : inClose[BodyLongTrailingIdx] ) - inLow[BodyLongTrailingIdx] ) : 0 ) ) ) ;
         BodyDojiPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) - ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[BodyDojiTrailingIdx] - inOpen[BodyDojiTrailingIdx] ) ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[BodyDojiTrailingIdx] - inLow[BodyDojiTrailingIdx] ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[BodyDojiTrailingIdx] - ( inClose[BodyDojiTrailingIdx] >= inOpen[BodyDojiTrailingIdx] ? inClose[BodyDojiTrailingIdx] : inOpen[BodyDojiTrailingIdx] ) ) + ( ( inClose[BodyDojiTrailingIdx] >= inOpen[BodyDojiTrailingIdx] ? inOpen[BodyDojiTrailingIdx] : inClose[BodyDojiTrailingIdx] ) - inLow[BodyDojiTrailingIdx] ) : 0 ) ) ) ;
         BodyShortPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) - ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[BodyShortTrailingIdx] - inOpen[BodyShortTrailingIdx] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[BodyShortTrailingIdx] - inLow[BodyShortTrailingIdx] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[BodyShortTrailingIdx] - ( inClose[BodyShortTrailingIdx] >= inOpen[BodyShortTrailingIdx] ? inClose[BodyShortTrailingIdx] : inOpen[BodyShortTrailingIdx] ) ) + ( ( inClose[BodyShortTrailingIdx] >= inOpen[BodyShortTrailingIdx] ? inOpen[BodyShortTrailingIdx] : inClose[BodyShortTrailingIdx] ) - inLow[BodyShortTrailingIdx] ) : 0 ) ) ) ;
         i++;
         BodyLongTrailingIdx++;
         BodyDojiTrailingIdx++;
         BodyShortTrailingIdx++;
      } while( i <= endIdx );
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   /* Generated */
   public int cdlAdvanceBlockLookback( )
   {
      return ((( ((( ((( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].avgPeriod) ) > ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].avgPeriod) )) ? ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].avgPeriod) ) : ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].avgPeriod) )) ) > ( ((( (this.candleSettings[CandleSettingType.Far.ordinal()].avgPeriod) ) > ( (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) )) ? ( (this.candleSettings[CandleSettingType.Far.ordinal()].avgPeriod) ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) )) )) ? ( ((( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].avgPeriod) ) > ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].avgPeriod) )) ? ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].avgPeriod) ) : ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].avgPeriod) )) ) : ( ((( (this.candleSettings[CandleSettingType.Far.ordinal()].avgPeriod) ) > ( (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) )) ? ( (this.candleSettings[CandleSettingType.Far.ordinal()].avgPeriod) ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) )) )) ) > ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) )) ? ( ((( ((( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].avgPeriod) ) > ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].avgPeriod) )) ? ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].avgPeriod) ) : ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].avgPeriod) )) ) > ( ((( (this.candleSettings[CandleSettingType.Far.ordinal()].avgPeriod) ) > ( (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) )) ? ( (this.candleSettings[CandleSettingType.Far.ordinal()].avgPeriod) ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) )) )) ? ( ((( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].avgPeriod) ) > ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].avgPeriod) )) ? ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].avgPeriod) ) : ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].avgPeriod) )) ) : ( ((( (this.candleSettings[CandleSettingType.Far.ordinal()].avgPeriod) ) > ( (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) )) ? ( (this.candleSettings[CandleSettingType.Far.ordinal()].avgPeriod) ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) )) )) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) )) +
         2;
   }
   public RetCode cdlAdvanceBlock( int startIdx,
      int endIdx,
      double inOpen[],
      double inHigh[],
      double inLow[],
      double inClose[],
      MInteger outBegIdx,
      MInteger outNBElement,
      int outInteger[] )
   {
      double []ShadowShortPeriodTotal = new double[3] ;
      double []ShadowLongPeriodTotal = new double[2] ;
      double []NearPeriodTotal = new double[3] ;
      double []FarPeriodTotal = new double[3] ;
      double BodyLongPeriodTotal;
      int i, outIdx, totIdx, BodyLongTrailingIdx, ShadowShortTrailingIdx, ShadowLongTrailingIdx, NearTrailingIdx,
         FarTrailingIdx, lookbackTotal;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      lookbackTotal = cdlAdvanceBlockLookback ();
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      ShadowShortPeriodTotal[2] = 0;
      ShadowShortPeriodTotal[1] = 0;
      ShadowShortPeriodTotal[0] = 0;
      ShadowShortTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].avgPeriod) ;
      ShadowLongPeriodTotal[1] = 0;
      ShadowLongPeriodTotal[0] = 0;
      ShadowLongTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].avgPeriod) ;
      NearPeriodTotal[2] = 0;
      NearPeriodTotal[1] = 0;
      NearPeriodTotal[0] = 0;
      NearTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) ;
      FarPeriodTotal[2] = 0;
      FarPeriodTotal[1] = 0;
      FarPeriodTotal[0] = 0;
      FarTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.Far.ordinal()].avgPeriod) ;
      BodyLongPeriodTotal = 0;
      BodyLongTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) ;
      i = ShadowShortTrailingIdx;
      while( i < startIdx ) {
         ShadowShortPeriodTotal[2] += ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) : ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-2] - inLow[i-2] ) : ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-2] - ( inClose[i-2] >= inOpen[i-2] ? inClose[i-2] : inOpen[i-2] ) ) + ( ( inClose[i-2] >= inOpen[i-2] ? inOpen[i-2] : inClose[i-2] ) - inLow[i-2] ) : 0 ) ) ) ;
         ShadowShortPeriodTotal[1] += ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ;
         ShadowShortPeriodTotal[0] += ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      i = ShadowLongTrailingIdx;
      while( i < startIdx ) {
         ShadowLongPeriodTotal[1] += ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ;
         ShadowLongPeriodTotal[0] += ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      i = NearTrailingIdx;
      while( i < startIdx ) {
         NearPeriodTotal[2] += ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-2] - inLow[i-2] ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-2] - ( inClose[i-2] >= inOpen[i-2] ? inClose[i-2] : inOpen[i-2] ) ) + ( ( inClose[i-2] >= inOpen[i-2] ? inOpen[i-2] : inClose[i-2] ) - inLow[i-2] ) : 0 ) ) ) ;
         NearPeriodTotal[1] += ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ;
         i++;
      }
      i = FarTrailingIdx;
      while( i < startIdx ) {
         FarPeriodTotal[2] += ( (this.candleSettings[CandleSettingType.Far.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) : ( (this.candleSettings[CandleSettingType.Far.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-2] - inLow[i-2] ) : ( (this.candleSettings[CandleSettingType.Far.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-2] - ( inClose[i-2] >= inOpen[i-2] ? inClose[i-2] : inOpen[i-2] ) ) + ( ( inClose[i-2] >= inOpen[i-2] ? inOpen[i-2] : inClose[i-2] ) - inLow[i-2] ) : 0 ) ) ) ;
         FarPeriodTotal[1] += ( (this.candleSettings[CandleSettingType.Far.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.Far.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.Far.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ;
         i++;
      }
      i = BodyLongTrailingIdx;
      while( i < startIdx ) {
         BodyLongPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-2] - inLow[i-2] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-2] - ( inClose[i-2] >= inOpen[i-2] ? inClose[i-2] : inOpen[i-2] ) ) + ( ( inClose[i-2] >= inOpen[i-2] ? inOpen[i-2] : inClose[i-2] ) - inLow[i-2] ) : 0 ) ) ) ;
         i++;
      }
      i = startIdx;
      outIdx = 0;
      do
      {
         if( ( inClose[i-2] >= inOpen[i-2] ? 1 : -1 ) == 1 &&
            ( inClose[i-1] >= inOpen[i-1] ? 1 : -1 ) == 1 &&
            ( inClose[i] >= inOpen[i] ? 1 : -1 ) == 1 &&
            inClose[i] > inClose[i-1] && inClose[i-1] > inClose[i-2] &&
            inOpen[i-1] > inOpen[i-2] &&
            inOpen[i-1] <= inClose[i-2] + ( (this.candleSettings[CandleSettingType.Near.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) != 0.0? NearPeriodTotal[2] / (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-2] - inLow[i-2] ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-2] - ( inClose[i-2] >= inOpen[i-2] ? inClose[i-2] : inOpen[i-2] ) ) + ( ( inClose[i-2] >= inOpen[i-2] ? inOpen[i-2] : inClose[i-2] ) - inLow[i-2] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            inOpen[i] > inOpen[i-1] &&
            inOpen[i] <= inClose[i-1] + ( (this.candleSettings[CandleSettingType.Near.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) != 0.0? NearPeriodTotal[1] / (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) > ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) != 0.0? BodyLongPeriodTotal / (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-2] - inLow[i-2] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-2] - ( inClose[i-2] >= inOpen[i-2] ? inClose[i-2] : inOpen[i-2] ) ) + ( ( inClose[i-2] >= inOpen[i-2] ? inOpen[i-2] : inClose[i-2] ) - inLow[i-2] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( inHigh[i-2] - ( inClose[i-2] >= inOpen[i-2] ? inClose[i-2] : inOpen[i-2] ) ) < ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].avgPeriod) != 0.0? ShadowShortPeriodTotal[2] / (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) : ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-2] - inLow[i-2] ) : ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-2] - ( inClose[i-2] >= inOpen[i-2] ? inClose[i-2] : inOpen[i-2] ) ) + ( ( inClose[i-2] >= inOpen[i-2] ? inOpen[i-2] : inClose[i-2] ) - inLow[i-2] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            (
            (
            ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) < ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) - ( (this.candleSettings[CandleSettingType.Far.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.Far.ordinal()].avgPeriod) != 0.0? FarPeriodTotal[2] / (this.candleSettings[CandleSettingType.Far.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.Far.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) : ( (this.candleSettings[CandleSettingType.Far.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-2] - inLow[i-2] ) : ( (this.candleSettings[CandleSettingType.Far.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-2] - ( inClose[i-2] >= inOpen[i-2] ? inClose[i-2] : inOpen[i-2] ) ) + ( ( inClose[i-2] >= inOpen[i-2] ? inOpen[i-2] : inClose[i-2] ) - inLow[i-2] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.Far.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( Math.abs ( inClose[i] - inOpen[i] ) ) < ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) + ( (this.candleSettings[CandleSettingType.Near.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) != 0.0? NearPeriodTotal[1] / (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) )
            ) ||
            (
            ( Math.abs ( inClose[i] - inOpen[i] ) ) < ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) - ( (this.candleSettings[CandleSettingType.Far.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.Far.ordinal()].avgPeriod) != 0.0? FarPeriodTotal[1] / (this.candleSettings[CandleSettingType.Far.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.Far.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.Far.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.Far.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.Far.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) )
            ) ||
            (
            ( Math.abs ( inClose[i] - inOpen[i] ) ) < ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) &&
            ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) < ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) &&
            (
            ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) > ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].avgPeriod) != 0.0? ShadowShortPeriodTotal[0] / (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) ||
            ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) > ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].avgPeriod) != 0.0? ShadowShortPeriodTotal[1] / (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) )
            )
            ) ||
            (
            ( Math.abs ( inClose[i] - inOpen[i] ) ) < ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) &&
            ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) > ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].avgPeriod) != 0.0? ShadowLongPeriodTotal[0] / (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) )
            )
            )
            )
            outInteger[outIdx++] = -100;
         else
            outInteger[outIdx++] = 0;
         for (totIdx = 2; totIdx >= 0; --totIdx)
            ShadowShortPeriodTotal[totIdx] += ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-totIdx] - inOpen[i-totIdx] ) ) : ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-totIdx] - inLow[i-totIdx] ) : ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-totIdx] - ( inClose[i-totIdx] >= inOpen[i-totIdx] ? inClose[i-totIdx] : inOpen[i-totIdx] ) ) + ( ( inClose[i-totIdx] >= inOpen[i-totIdx] ? inOpen[i-totIdx] : inClose[i-totIdx] ) - inLow[i-totIdx] ) : 0 ) ) )
            - ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[ShadowShortTrailingIdx-totIdx] - inOpen[ShadowShortTrailingIdx-totIdx] ) ) : ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[ShadowShortTrailingIdx-totIdx] - inLow[ShadowShortTrailingIdx-totIdx] ) : ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[ShadowShortTrailingIdx-totIdx] - ( inClose[ShadowShortTrailingIdx-totIdx] >= inOpen[ShadowShortTrailingIdx-totIdx] ? inClose[ShadowShortTrailingIdx-totIdx] : inOpen[ShadowShortTrailingIdx-totIdx] ) ) + ( ( inClose[ShadowShortTrailingIdx-totIdx] >= inOpen[ShadowShortTrailingIdx-totIdx] ? inOpen[ShadowShortTrailingIdx-totIdx] : inClose[ShadowShortTrailingIdx-totIdx] ) - inLow[ShadowShortTrailingIdx-totIdx] ) : 0 ) ) ) ;
         for (totIdx = 1; totIdx >= 0; --totIdx)
            ShadowLongPeriodTotal[totIdx] += ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-totIdx] - inOpen[i-totIdx] ) ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-totIdx] - inLow[i-totIdx] ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-totIdx] - ( inClose[i-totIdx] >= inOpen[i-totIdx] ? inClose[i-totIdx] : inOpen[i-totIdx] ) ) + ( ( inClose[i-totIdx] >= inOpen[i-totIdx] ? inOpen[i-totIdx] : inClose[i-totIdx] ) - inLow[i-totIdx] ) : 0 ) ) )
            - ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[ShadowLongTrailingIdx-totIdx] - inOpen[ShadowLongTrailingIdx-totIdx] ) ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[ShadowLongTrailingIdx-totIdx] - inLow[ShadowLongTrailingIdx-totIdx] ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[ShadowLongTrailingIdx-totIdx] - ( inClose[ShadowLongTrailingIdx-totIdx] >= inOpen[ShadowLongTrailingIdx-totIdx] ? inClose[ShadowLongTrailingIdx-totIdx] : inOpen[ShadowLongTrailingIdx-totIdx] ) ) + ( ( inClose[ShadowLongTrailingIdx-totIdx] >= inOpen[ShadowLongTrailingIdx-totIdx] ? inOpen[ShadowLongTrailingIdx-totIdx] : inClose[ShadowLongTrailingIdx-totIdx] ) - inLow[ShadowLongTrailingIdx-totIdx] ) : 0 ) ) ) ;
         for (totIdx = 2; totIdx >= 1; --totIdx) {
            FarPeriodTotal[totIdx] += ( (this.candleSettings[CandleSettingType.Far.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-totIdx] - inOpen[i-totIdx] ) ) : ( (this.candleSettings[CandleSettingType.Far.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-totIdx] - inLow[i-totIdx] ) : ( (this.candleSettings[CandleSettingType.Far.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-totIdx] - ( inClose[i-totIdx] >= inOpen[i-totIdx] ? inClose[i-totIdx] : inOpen[i-totIdx] ) ) + ( ( inClose[i-totIdx] >= inOpen[i-totIdx] ? inOpen[i-totIdx] : inClose[i-totIdx] ) - inLow[i-totIdx] ) : 0 ) ) )
               - ( (this.candleSettings[CandleSettingType.Far.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[FarTrailingIdx-totIdx] - inOpen[FarTrailingIdx-totIdx] ) ) : ( (this.candleSettings[CandleSettingType.Far.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[FarTrailingIdx-totIdx] - inLow[FarTrailingIdx-totIdx] ) : ( (this.candleSettings[CandleSettingType.Far.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[FarTrailingIdx-totIdx] - ( inClose[FarTrailingIdx-totIdx] >= inOpen[FarTrailingIdx-totIdx] ? inClose[FarTrailingIdx-totIdx] : inOpen[FarTrailingIdx-totIdx] ) ) + ( ( inClose[FarTrailingIdx-totIdx] >= inOpen[FarTrailingIdx-totIdx] ? inOpen[FarTrailingIdx-totIdx] : inClose[FarTrailingIdx-totIdx] ) - inLow[FarTrailingIdx-totIdx] ) : 0 ) ) ) ;
            NearPeriodTotal[totIdx] += ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-totIdx] - inOpen[i-totIdx] ) ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-totIdx] - inLow[i-totIdx] ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-totIdx] - ( inClose[i-totIdx] >= inOpen[i-totIdx] ? inClose[i-totIdx] : inOpen[i-totIdx] ) ) + ( ( inClose[i-totIdx] >= inOpen[i-totIdx] ? inOpen[i-totIdx] : inClose[i-totIdx] ) - inLow[i-totIdx] ) : 0 ) ) )
               - ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[NearTrailingIdx-totIdx] - inOpen[NearTrailingIdx-totIdx] ) ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[NearTrailingIdx-totIdx] - inLow[NearTrailingIdx-totIdx] ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[NearTrailingIdx-totIdx] - ( inClose[NearTrailingIdx-totIdx] >= inOpen[NearTrailingIdx-totIdx] ? inClose[NearTrailingIdx-totIdx] : inOpen[NearTrailingIdx-totIdx] ) ) + ( ( inClose[NearTrailingIdx-totIdx] >= inOpen[NearTrailingIdx-totIdx] ? inOpen[NearTrailingIdx-totIdx] : inClose[NearTrailingIdx-totIdx] ) - inLow[NearTrailingIdx-totIdx] ) : 0 ) ) ) ;
         }
         BodyLongPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-2] - inLow[i-2] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-2] - ( inClose[i-2] >= inOpen[i-2] ? inClose[i-2] : inOpen[i-2] ) ) + ( ( inClose[i-2] >= inOpen[i-2] ? inOpen[i-2] : inClose[i-2] ) - inLow[i-2] ) : 0 ) ) ) - ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[BodyLongTrailingIdx-2] - inOpen[BodyLongTrailingIdx-2] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[BodyLongTrailingIdx-2] - inLow[BodyLongTrailingIdx-2] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[BodyLongTrailingIdx-2] - ( inClose[BodyLongTrailingIdx-2] >= inOpen[BodyLongTrailingIdx-2] ? inClose[BodyLongTrailingIdx-2] : inOpen[BodyLongTrailingIdx-2] ) ) + ( ( inClose[BodyLongTrailingIdx-2] >= inOpen[BodyLongTrailingIdx-2] ? inOpen[BodyLongTrailingIdx-2] : inClose[BodyLongTrailingIdx-2] ) - inLow[BodyLongTrailingIdx-2] ) : 0 ) ) ) ;
         i++;
         ShadowShortTrailingIdx++;
         ShadowLongTrailingIdx++;
         NearTrailingIdx++;
         FarTrailingIdx++;
         BodyLongTrailingIdx++;
      } while( i <= endIdx );
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   public int cdlAdvanceBlockStateInit( struct TA_cdlAdvanceBlock_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct cdlAdvanceBlock ));
      _state.value .value .mem_index = 0;
      _state.value .value .mem_size = cdlAdvanceBlockLookback ();
      if ( _state.value .value .mem_size > 0)
         _state.value .value .memory = TA_Calloc( _state.value .value .mem_size , sizeof(struct TA_CDLADVANCEBLOCK_Data));
      else
         _state.value .value .memory = NULL;
      return RetCode.Success ;
   }
   public int cdlAdvanceBlockState( struct TA_cdlAdvanceBlock_State* _state,
      double inOpen,
      double inHigh,
      double inLow,
      double inClose,
      int *outInteger )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      size_t _cur_idx = _state.value .mem_index++;
      if ( _state.value .mem_size > 0) _cur_idx %= _state.value .mem_size ;
      if ( _state.value .mem_size > _state.value .mem_index - 1 ) {
         ( _state.value .memory+_cur_idx).value .inOpen = inOpen ;
         ( _state.value .memory+_cur_idx).value .inHigh = inHigh ;
         ( _state.value .memory+_cur_idx).value .inLow = inLow ;
         ( _state.value .memory+_cur_idx).value .inClose = inClose ;
         return RetCode.NeedMoreData ; }
      return RetCode.Success ;
   }
   public int cdlAdvanceBlockStateFree( struct TA_cdlAdvanceBlock_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if ( _state.value != NULL) {
         if ( _state.value .value .memory != NULL) TA_Free( _state.value .value .memory );
         TA_Free( _state.value ); _state.value = NULL;}
      return RetCode.Success ;
   }
   public RetCode cdlAdvanceBlock( int startIdx,
      int endIdx,
      float inOpen[],
      float inHigh[],
      float inLow[],
      float inClose[],
      MInteger outBegIdx,
      MInteger outNBElement,
      int outInteger[] )
   {
      double []ShadowShortPeriodTotal = new double[3] ;
      double []ShadowLongPeriodTotal = new double[2] ;
      double []NearPeriodTotal = new double[3] ;
      double []FarPeriodTotal = new double[3] ;
      double BodyLongPeriodTotal;
      int i, outIdx, totIdx, BodyLongTrailingIdx, ShadowShortTrailingIdx, ShadowLongTrailingIdx, NearTrailingIdx,
         FarTrailingIdx, lookbackTotal;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      lookbackTotal = cdlAdvanceBlockLookback ();
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      ShadowShortPeriodTotal[2] = 0;
      ShadowShortPeriodTotal[1] = 0;
      ShadowShortPeriodTotal[0] = 0;
      ShadowShortTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].avgPeriod) ;
      ShadowLongPeriodTotal[1] = 0;
      ShadowLongPeriodTotal[0] = 0;
      ShadowLongTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].avgPeriod) ;
      NearPeriodTotal[2] = 0;
      NearPeriodTotal[1] = 0;
      NearPeriodTotal[0] = 0;
      NearTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) ;
      FarPeriodTotal[2] = 0;
      FarPeriodTotal[1] = 0;
      FarPeriodTotal[0] = 0;
      FarTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.Far.ordinal()].avgPeriod) ;
      BodyLongPeriodTotal = 0;
      BodyLongTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) ;
      i = ShadowShortTrailingIdx;
      while( i < startIdx ) {
         ShadowShortPeriodTotal[2] += ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) : ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-2] - inLow[i-2] ) : ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-2] - ( inClose[i-2] >= inOpen[i-2] ? inClose[i-2] : inOpen[i-2] ) ) + ( ( inClose[i-2] >= inOpen[i-2] ? inOpen[i-2] : inClose[i-2] ) - inLow[i-2] ) : 0 ) ) ) ;
         ShadowShortPeriodTotal[1] += ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ;
         ShadowShortPeriodTotal[0] += ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      i = ShadowLongTrailingIdx;
      while( i < startIdx ) {
         ShadowLongPeriodTotal[1] += ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ;
         ShadowLongPeriodTotal[0] += ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      i = NearTrailingIdx;
      while( i < startIdx ) {
         NearPeriodTotal[2] += ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-2] - inLow[i-2] ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-2] - ( inClose[i-2] >= inOpen[i-2] ? inClose[i-2] : inOpen[i-2] ) ) + ( ( inClose[i-2] >= inOpen[i-2] ? inOpen[i-2] : inClose[i-2] ) - inLow[i-2] ) : 0 ) ) ) ;
         NearPeriodTotal[1] += ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ;
         i++;
      }
      i = FarTrailingIdx;
      while( i < startIdx ) {
         FarPeriodTotal[2] += ( (this.candleSettings[CandleSettingType.Far.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) : ( (this.candleSettings[CandleSettingType.Far.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-2] - inLow[i-2] ) : ( (this.candleSettings[CandleSettingType.Far.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-2] - ( inClose[i-2] >= inOpen[i-2] ? inClose[i-2] : inOpen[i-2] ) ) + ( ( inClose[i-2] >= inOpen[i-2] ? inOpen[i-2] : inClose[i-2] ) - inLow[i-2] ) : 0 ) ) ) ;
         FarPeriodTotal[1] += ( (this.candleSettings[CandleSettingType.Far.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.Far.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.Far.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ;
         i++;
      }
      i = BodyLongTrailingIdx;
      while( i < startIdx ) {
         BodyLongPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-2] - inLow[i-2] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-2] - ( inClose[i-2] >= inOpen[i-2] ? inClose[i-2] : inOpen[i-2] ) ) + ( ( inClose[i-2] >= inOpen[i-2] ? inOpen[i-2] : inClose[i-2] ) - inLow[i-2] ) : 0 ) ) ) ;
         i++;
      }
      i = startIdx;
      outIdx = 0;
      do
      {
         if( ( inClose[i-2] >= inOpen[i-2] ? 1 : -1 ) == 1 &&
            ( inClose[i-1] >= inOpen[i-1] ? 1 : -1 ) == 1 &&
            ( inClose[i] >= inOpen[i] ? 1 : -1 ) == 1 &&
            inClose[i] > inClose[i-1] && inClose[i-1] > inClose[i-2] &&
            inOpen[i-1] > inOpen[i-2] &&
            inOpen[i-1] <= inClose[i-2] + ( (this.candleSettings[CandleSettingType.Near.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) != 0.0? NearPeriodTotal[2] / (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-2] - inLow[i-2] ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-2] - ( inClose[i-2] >= inOpen[i-2] ? inClose[i-2] : inOpen[i-2] ) ) + ( ( inClose[i-2] >= inOpen[i-2] ? inOpen[i-2] : inClose[i-2] ) - inLow[i-2] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            inOpen[i] > inOpen[i-1] &&
            inOpen[i] <= inClose[i-1] + ( (this.candleSettings[CandleSettingType.Near.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) != 0.0? NearPeriodTotal[1] / (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) > ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) != 0.0? BodyLongPeriodTotal / (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-2] - inLow[i-2] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-2] - ( inClose[i-2] >= inOpen[i-2] ? inClose[i-2] : inOpen[i-2] ) ) + ( ( inClose[i-2] >= inOpen[i-2] ? inOpen[i-2] : inClose[i-2] ) - inLow[i-2] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( inHigh[i-2] - ( inClose[i-2] >= inOpen[i-2] ? inClose[i-2] : inOpen[i-2] ) ) < ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].avgPeriod) != 0.0? ShadowShortPeriodTotal[2] / (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) : ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-2] - inLow[i-2] ) : ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-2] - ( inClose[i-2] >= inOpen[i-2] ? inClose[i-2] : inOpen[i-2] ) ) + ( ( inClose[i-2] >= inOpen[i-2] ? inOpen[i-2] : inClose[i-2] ) - inLow[i-2] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            (
            (
            ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) < ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) - ( (this.candleSettings[CandleSettingType.Far.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.Far.ordinal()].avgPeriod) != 0.0? FarPeriodTotal[2] / (this.candleSettings[CandleSettingType.Far.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.Far.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) : ( (this.candleSettings[CandleSettingType.Far.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-2] - inLow[i-2] ) : ( (this.candleSettings[CandleSettingType.Far.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-2] - ( inClose[i-2] >= inOpen[i-2] ? inClose[i-2] : inOpen[i-2] ) ) + ( ( inClose[i-2] >= inOpen[i-2] ? inOpen[i-2] : inClose[i-2] ) - inLow[i-2] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.Far.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( Math.abs ( inClose[i] - inOpen[i] ) ) < ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) + ( (this.candleSettings[CandleSettingType.Near.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) != 0.0? NearPeriodTotal[1] / (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) )
            ) ||
            (
            ( Math.abs ( inClose[i] - inOpen[i] ) ) < ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) - ( (this.candleSettings[CandleSettingType.Far.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.Far.ordinal()].avgPeriod) != 0.0? FarPeriodTotal[1] / (this.candleSettings[CandleSettingType.Far.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.Far.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.Far.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.Far.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.Far.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) )
            ) ||
            (
            ( Math.abs ( inClose[i] - inOpen[i] ) ) < ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) &&
            ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) < ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) &&
            (
            ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) > ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].avgPeriod) != 0.0? ShadowShortPeriodTotal[0] / (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) ||
            ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) > ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].avgPeriod) != 0.0? ShadowShortPeriodTotal[1] / (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) )
            )
            ) ||
            (
            ( Math.abs ( inClose[i] - inOpen[i] ) ) < ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) &&
            ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) > ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].avgPeriod) != 0.0? ShadowLongPeriodTotal[0] / (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) )
            )
            )
            )
            outInteger[outIdx++] = -100;
         else
            outInteger[outIdx++] = 0;
         for (totIdx = 2; totIdx >= 0; --totIdx)
            ShadowShortPeriodTotal[totIdx] += ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-totIdx] - inOpen[i-totIdx] ) ) : ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-totIdx] - inLow[i-totIdx] ) : ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-totIdx] - ( inClose[i-totIdx] >= inOpen[i-totIdx] ? inClose[i-totIdx] : inOpen[i-totIdx] ) ) + ( ( inClose[i-totIdx] >= inOpen[i-totIdx] ? inOpen[i-totIdx] : inClose[i-totIdx] ) - inLow[i-totIdx] ) : 0 ) ) )
            - ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[ShadowShortTrailingIdx-totIdx] - inOpen[ShadowShortTrailingIdx-totIdx] ) ) : ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[ShadowShortTrailingIdx-totIdx] - inLow[ShadowShortTrailingIdx-totIdx] ) : ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[ShadowShortTrailingIdx-totIdx] - ( inClose[ShadowShortTrailingIdx-totIdx] >= inOpen[ShadowShortTrailingIdx-totIdx] ? inClose[ShadowShortTrailingIdx-totIdx] : inOpen[ShadowShortTrailingIdx-totIdx] ) ) + ( ( inClose[ShadowShortTrailingIdx-totIdx] >= inOpen[ShadowShortTrailingIdx-totIdx] ? inOpen[ShadowShortTrailingIdx-totIdx] : inClose[ShadowShortTrailingIdx-totIdx] ) - inLow[ShadowShortTrailingIdx-totIdx] ) : 0 ) ) ) ;
         for (totIdx = 1; totIdx >= 0; --totIdx)
            ShadowLongPeriodTotal[totIdx] += ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-totIdx] - inOpen[i-totIdx] ) ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-totIdx] - inLow[i-totIdx] ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-totIdx] - ( inClose[i-totIdx] >= inOpen[i-totIdx] ? inClose[i-totIdx] : inOpen[i-totIdx] ) ) + ( ( inClose[i-totIdx] >= inOpen[i-totIdx] ? inOpen[i-totIdx] : inClose[i-totIdx] ) - inLow[i-totIdx] ) : 0 ) ) )
            - ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[ShadowLongTrailingIdx-totIdx] - inOpen[ShadowLongTrailingIdx-totIdx] ) ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[ShadowLongTrailingIdx-totIdx] - inLow[ShadowLongTrailingIdx-totIdx] ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[ShadowLongTrailingIdx-totIdx] - ( inClose[ShadowLongTrailingIdx-totIdx] >= inOpen[ShadowLongTrailingIdx-totIdx] ? inClose[ShadowLongTrailingIdx-totIdx] : inOpen[ShadowLongTrailingIdx-totIdx] ) ) + ( ( inClose[ShadowLongTrailingIdx-totIdx] >= inOpen[ShadowLongTrailingIdx-totIdx] ? inOpen[ShadowLongTrailingIdx-totIdx] : inClose[ShadowLongTrailingIdx-totIdx] ) - inLow[ShadowLongTrailingIdx-totIdx] ) : 0 ) ) ) ;
         for (totIdx = 2; totIdx >= 1; --totIdx) {
            FarPeriodTotal[totIdx] += ( (this.candleSettings[CandleSettingType.Far.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-totIdx] - inOpen[i-totIdx] ) ) : ( (this.candleSettings[CandleSettingType.Far.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-totIdx] - inLow[i-totIdx] ) : ( (this.candleSettings[CandleSettingType.Far.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-totIdx] - ( inClose[i-totIdx] >= inOpen[i-totIdx] ? inClose[i-totIdx] : inOpen[i-totIdx] ) ) + ( ( inClose[i-totIdx] >= inOpen[i-totIdx] ? inOpen[i-totIdx] : inClose[i-totIdx] ) - inLow[i-totIdx] ) : 0 ) ) )
               - ( (this.candleSettings[CandleSettingType.Far.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[FarTrailingIdx-totIdx] - inOpen[FarTrailingIdx-totIdx] ) ) : ( (this.candleSettings[CandleSettingType.Far.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[FarTrailingIdx-totIdx] - inLow[FarTrailingIdx-totIdx] ) : ( (this.candleSettings[CandleSettingType.Far.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[FarTrailingIdx-totIdx] - ( inClose[FarTrailingIdx-totIdx] >= inOpen[FarTrailingIdx-totIdx] ? inClose[FarTrailingIdx-totIdx] : inOpen[FarTrailingIdx-totIdx] ) ) + ( ( inClose[FarTrailingIdx-totIdx] >= inOpen[FarTrailingIdx-totIdx] ? inOpen[FarTrailingIdx-totIdx] : inClose[FarTrailingIdx-totIdx] ) - inLow[FarTrailingIdx-totIdx] ) : 0 ) ) ) ;
            NearPeriodTotal[totIdx] += ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-totIdx] - inOpen[i-totIdx] ) ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-totIdx] - inLow[i-totIdx] ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-totIdx] - ( inClose[i-totIdx] >= inOpen[i-totIdx] ? inClose[i-totIdx] : inOpen[i-totIdx] ) ) + ( ( inClose[i-totIdx] >= inOpen[i-totIdx] ? inOpen[i-totIdx] : inClose[i-totIdx] ) - inLow[i-totIdx] ) : 0 ) ) )
               - ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[NearTrailingIdx-totIdx] - inOpen[NearTrailingIdx-totIdx] ) ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[NearTrailingIdx-totIdx] - inLow[NearTrailingIdx-totIdx] ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[NearTrailingIdx-totIdx] - ( inClose[NearTrailingIdx-totIdx] >= inOpen[NearTrailingIdx-totIdx] ? inClose[NearTrailingIdx-totIdx] : inOpen[NearTrailingIdx-totIdx] ) ) + ( ( inClose[NearTrailingIdx-totIdx] >= inOpen[NearTrailingIdx-totIdx] ? inOpen[NearTrailingIdx-totIdx] : inClose[NearTrailingIdx-totIdx] ) - inLow[NearTrailingIdx-totIdx] ) : 0 ) ) ) ;
         }
         BodyLongPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-2] - inLow[i-2] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-2] - ( inClose[i-2] >= inOpen[i-2] ? inClose[i-2] : inOpen[i-2] ) ) + ( ( inClose[i-2] >= inOpen[i-2] ? inOpen[i-2] : inClose[i-2] ) - inLow[i-2] ) : 0 ) ) ) - ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[BodyLongTrailingIdx-2] - inOpen[BodyLongTrailingIdx-2] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[BodyLongTrailingIdx-2] - inLow[BodyLongTrailingIdx-2] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[BodyLongTrailingIdx-2] - ( inClose[BodyLongTrailingIdx-2] >= inOpen[BodyLongTrailingIdx-2] ? inClose[BodyLongTrailingIdx-2] : inOpen[BodyLongTrailingIdx-2] ) ) + ( ( inClose[BodyLongTrailingIdx-2] >= inOpen[BodyLongTrailingIdx-2] ? inOpen[BodyLongTrailingIdx-2] : inClose[BodyLongTrailingIdx-2] ) - inLow[BodyLongTrailingIdx-2] ) : 0 ) ) ) ;
         i++;
         ShadowShortTrailingIdx++;
         ShadowLongTrailingIdx++;
         NearTrailingIdx++;
         FarTrailingIdx++;
         BodyLongTrailingIdx++;
      } while( i <= endIdx );
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   /* Generated */
   public int cdlBeltHoldLookback( )
   {
      return ((( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) ) > ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) )) ? ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) )) ;
   }
   public RetCode cdlBeltHold( int startIdx,
      int endIdx,
      double inOpen[],
      double inHigh[],
      double inLow[],
      double inClose[],
      MInteger outBegIdx,
      MInteger outNBElement,
      int outInteger[] )
   {
      double BodyLongPeriodTotal, ShadowVeryShortPeriodTotal;
      int i, outIdx, BodyLongTrailingIdx, ShadowVeryShortTrailingIdx, lookbackTotal;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      lookbackTotal = cdlBeltHoldLookback ();
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      BodyLongPeriodTotal = 0;
      BodyLongTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) ;
      ShadowVeryShortPeriodTotal = 0;
      ShadowVeryShortTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) ;
      i = BodyLongTrailingIdx;
      while( i < startIdx ) {
         BodyLongPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      i = ShadowVeryShortTrailingIdx;
      while( i < startIdx ) {
         ShadowVeryShortPeriodTotal += ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      outIdx = 0;
      do
      {
         if( ( Math.abs ( inClose[i] - inOpen[i] ) ) > ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) != 0.0? BodyLongPeriodTotal / (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            (
            (
            ( inClose[i] >= inOpen[i] ? 1 : -1 ) == 1 &&
            ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) < ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) != 0.0? ShadowVeryShortPeriodTotal / (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) )
            ) ||
            (
            ( inClose[i] >= inOpen[i] ? 1 : -1 ) == -1 &&
            ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) < ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) != 0.0? ShadowVeryShortPeriodTotal / (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) )
            )
            ) )
            outInteger[outIdx++] = ( inClose[i] >= inOpen[i] ? 1 : -1 ) * 100;
         else
            outInteger[outIdx++] = 0;
         BodyLongPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) - ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[BodyLongTrailingIdx] - inOpen[BodyLongTrailingIdx] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[BodyLongTrailingIdx] - inLow[BodyLongTrailingIdx] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[BodyLongTrailingIdx] - ( inClose[BodyLongTrailingIdx] >= inOpen[BodyLongTrailingIdx] ? inClose[BodyLongTrailingIdx] : inOpen[BodyLongTrailingIdx] ) ) + ( ( inClose[BodyLongTrailingIdx] >= inOpen[BodyLongTrailingIdx] ? inOpen[BodyLongTrailingIdx] : inClose[BodyLongTrailingIdx] ) - inLow[BodyLongTrailingIdx] ) : 0 ) ) ) ;
         ShadowVeryShortPeriodTotal += ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) )
            - ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[ShadowVeryShortTrailingIdx] - inOpen[ShadowVeryShortTrailingIdx] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[ShadowVeryShortTrailingIdx] - inLow[ShadowVeryShortTrailingIdx] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[ShadowVeryShortTrailingIdx] - ( inClose[ShadowVeryShortTrailingIdx] >= inOpen[ShadowVeryShortTrailingIdx] ? inClose[ShadowVeryShortTrailingIdx] : inOpen[ShadowVeryShortTrailingIdx] ) ) + ( ( inClose[ShadowVeryShortTrailingIdx] >= inOpen[ShadowVeryShortTrailingIdx] ? inOpen[ShadowVeryShortTrailingIdx] : inClose[ShadowVeryShortTrailingIdx] ) - inLow[ShadowVeryShortTrailingIdx] ) : 0 ) ) ) ;
         i++;
         BodyLongTrailingIdx++;
         ShadowVeryShortTrailingIdx++;
      } while( i <= endIdx );
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   public int cdlBeltHoldStateInit( struct TA_cdlBeltHold_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct cdlBeltHold ));
      _state.value .value .mem_index = 0;
      _state.value .value .mem_size = cdlBeltHoldLookback ();
      if ( _state.value .value .mem_size > 0)
         _state.value .value .memory = TA_Calloc( _state.value .value .mem_size , sizeof(struct TA_CDLBELTHOLD_Data));
      else
         _state.value .value .memory = NULL;
      return RetCode.Success ;
   }
   public int cdlBeltHoldState( struct TA_cdlBeltHold_State* _state,
      double inOpen,
      double inHigh,
      double inLow,
      double inClose,
      int *outInteger )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      size_t _cur_idx = _state.value .mem_index++;
      if ( _state.value .mem_size > 0) _cur_idx %= _state.value .mem_size ;
      if ( _state.value .mem_size > _state.value .mem_index - 1 ) {
         ( _state.value .memory+_cur_idx).value .inOpen = inOpen ;
         ( _state.value .memory+_cur_idx).value .inHigh = inHigh ;
         ( _state.value .memory+_cur_idx).value .inLow = inLow ;
         ( _state.value .memory+_cur_idx).value .inClose = inClose ;
         return RetCode.NeedMoreData ; }
      return RetCode.Success ;
   }
   public int cdlBeltHoldStateFree( struct TA_cdlBeltHold_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if ( _state.value != NULL) {
         if ( _state.value .value .memory != NULL) TA_Free( _state.value .value .memory );
         TA_Free( _state.value ); _state.value = NULL;}
      return RetCode.Success ;
   }
   public RetCode cdlBeltHold( int startIdx,
      int endIdx,
      float inOpen[],
      float inHigh[],
      float inLow[],
      float inClose[],
      MInteger outBegIdx,
      MInteger outNBElement,
      int outInteger[] )
   {
      double BodyLongPeriodTotal, ShadowVeryShortPeriodTotal;
      int i, outIdx, BodyLongTrailingIdx, ShadowVeryShortTrailingIdx, lookbackTotal;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      lookbackTotal = cdlBeltHoldLookback ();
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      BodyLongPeriodTotal = 0;
      BodyLongTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) ;
      ShadowVeryShortPeriodTotal = 0;
      ShadowVeryShortTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) ;
      i = BodyLongTrailingIdx;
      while( i < startIdx ) {
         BodyLongPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      i = ShadowVeryShortTrailingIdx;
      while( i < startIdx ) {
         ShadowVeryShortPeriodTotal += ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      outIdx = 0;
      do
      {
         if( ( Math.abs ( inClose[i] - inOpen[i] ) ) > ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) != 0.0? BodyLongPeriodTotal / (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            (
            (
            ( inClose[i] >= inOpen[i] ? 1 : -1 ) == 1 &&
            ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) < ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) != 0.0? ShadowVeryShortPeriodTotal / (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) )
            ) ||
            (
            ( inClose[i] >= inOpen[i] ? 1 : -1 ) == -1 &&
            ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) < ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) != 0.0? ShadowVeryShortPeriodTotal / (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) )
            )
            ) )
            outInteger[outIdx++] = ( inClose[i] >= inOpen[i] ? 1 : -1 ) * 100;
         else
            outInteger[outIdx++] = 0;
         BodyLongPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) - ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[BodyLongTrailingIdx] - inOpen[BodyLongTrailingIdx] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[BodyLongTrailingIdx] - inLow[BodyLongTrailingIdx] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[BodyLongTrailingIdx] - ( inClose[BodyLongTrailingIdx] >= inOpen[BodyLongTrailingIdx] ? inClose[BodyLongTrailingIdx] : inOpen[BodyLongTrailingIdx] ) ) + ( ( inClose[BodyLongTrailingIdx] >= inOpen[BodyLongTrailingIdx] ? inOpen[BodyLongTrailingIdx] : inClose[BodyLongTrailingIdx] ) - inLow[BodyLongTrailingIdx] ) : 0 ) ) ) ;
         ShadowVeryShortPeriodTotal += ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) )
            - ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[ShadowVeryShortTrailingIdx] - inOpen[ShadowVeryShortTrailingIdx] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[ShadowVeryShortTrailingIdx] - inLow[ShadowVeryShortTrailingIdx] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[ShadowVeryShortTrailingIdx] - ( inClose[ShadowVeryShortTrailingIdx] >= inOpen[ShadowVeryShortTrailingIdx] ? inClose[ShadowVeryShortTrailingIdx] : inOpen[ShadowVeryShortTrailingIdx] ) ) + ( ( inClose[ShadowVeryShortTrailingIdx] >= inOpen[ShadowVeryShortTrailingIdx] ? inOpen[ShadowVeryShortTrailingIdx] : inClose[ShadowVeryShortTrailingIdx] ) - inLow[ShadowVeryShortTrailingIdx] ) : 0 ) ) ) ;
         i++;
         BodyLongTrailingIdx++;
         ShadowVeryShortTrailingIdx++;
      } while( i <= endIdx );
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   /* Generated */
   public int cdlBreakawayLookback( )
   {
      return (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) + 4;
   }
   public RetCode cdlBreakaway( int startIdx,
      int endIdx,
      double inOpen[],
      double inHigh[],
      double inLow[],
      double inClose[],
      MInteger outBegIdx,
      MInteger outNBElement,
      int outInteger[] )
   {
      double BodyLongPeriodTotal;
      int i, outIdx, BodyLongTrailingIdx, lookbackTotal;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      lookbackTotal = cdlBreakawayLookback ();
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      BodyLongPeriodTotal = 0;
      BodyLongTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) ;
      i = BodyLongTrailingIdx;
      while( i < startIdx ) {
         BodyLongPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-4] - inOpen[i-4] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-4] - inLow[i-4] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-4] - ( inClose[i-4] >= inOpen[i-4] ? inClose[i-4] : inOpen[i-4] ) ) + ( ( inClose[i-4] >= inOpen[i-4] ? inOpen[i-4] : inClose[i-4] ) - inLow[i-4] ) : 0 ) ) ) ;
         i++;
      }
      i = startIdx;
      outIdx = 0;
      do
      {
         if( ( Math.abs ( inClose[i-4] - inOpen[i-4] ) ) > ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) != 0.0? BodyLongPeriodTotal / (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-4] - inOpen[i-4] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-4] - inLow[i-4] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-4] - ( inClose[i-4] >= inOpen[i-4] ? inClose[i-4] : inOpen[i-4] ) ) + ( ( inClose[i-4] >= inOpen[i-4] ? inOpen[i-4] : inClose[i-4] ) - inLow[i-4] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( inClose[i-4] >= inOpen[i-4] ? 1 : -1 ) == ( inClose[i-3] >= inOpen[i-3] ? 1 : -1 ) &&
            ( inClose[i-3] >= inOpen[i-3] ? 1 : -1 ) == ( inClose[i-1] >= inOpen[i-1] ? 1 : -1 ) &&
            ( inClose[i-1] >= inOpen[i-1] ? 1 : -1 ) == - ( inClose[i] >= inOpen[i] ? 1 : -1 ) &&
            (
            ( ( inClose[i-4] >= inOpen[i-4] ? 1 : -1 ) == -1 &&
            ( (((inOpen[i-3]) > (inClose[i-3])) ? (inOpen[i-3]) : (inClose[i-3])) < (((inOpen[i-4]) < (inClose[i-4])) ? (inOpen[i-4]) : (inClose[i-4])) ) &&
            inHigh[i-2] < inHigh[i-3] && inLow[i-2] < inLow[i-3] &&
            inHigh[i-1] < inHigh[i-2] && inLow[i-1] < inLow[i-2] &&
            inClose[i] > inOpen[i-3] && inClose[i] < inClose[i-4]
            )
            ||
            ( ( inClose[i-4] >= inOpen[i-4] ? 1 : -1 ) == 1 &&
            ( (((inOpen[i-3]) < (inClose[i-3])) ? (inOpen[i-3]) : (inClose[i-3])) > (((inOpen[i-4]) > (inClose[i-4])) ? (inOpen[i-4]) : (inClose[i-4])) ) &&
            inHigh[i-2] > inHigh[i-3] && inLow[i-2] > inLow[i-3] &&
            inHigh[i-1] > inHigh[i-2] && inLow[i-1] > inLow[i-2] &&
            inClose[i] < inOpen[i-3] && inClose[i] > inClose[i-4]
            )
            )
            )
            outInteger[outIdx++] = ( inClose[i] >= inOpen[i] ? 1 : -1 ) * 100;
         else
            outInteger[outIdx++] = 0;
         BodyLongPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-4] - inOpen[i-4] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-4] - inLow[i-4] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-4] - ( inClose[i-4] >= inOpen[i-4] ? inClose[i-4] : inOpen[i-4] ) ) + ( ( inClose[i-4] >= inOpen[i-4] ? inOpen[i-4] : inClose[i-4] ) - inLow[i-4] ) : 0 ) ) )
            - ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[BodyLongTrailingIdx-4] - inOpen[BodyLongTrailingIdx-4] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[BodyLongTrailingIdx-4] - inLow[BodyLongTrailingIdx-4] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[BodyLongTrailingIdx-4] - ( inClose[BodyLongTrailingIdx-4] >= inOpen[BodyLongTrailingIdx-4] ? inClose[BodyLongTrailingIdx-4] : inOpen[BodyLongTrailingIdx-4] ) ) + ( ( inClose[BodyLongTrailingIdx-4] >= inOpen[BodyLongTrailingIdx-4] ? inOpen[BodyLongTrailingIdx-4] : inClose[BodyLongTrailingIdx-4] ) - inLow[BodyLongTrailingIdx-4] ) : 0 ) ) ) ;
         i++;
         BodyLongTrailingIdx++;
      } while( i <= endIdx );
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   public int cdlBreakawayStateInit( struct TA_cdlBreakaway_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct cdlBreakaway ));
      _state.value .value .mem_index = 0;
      _state.value .value .mem_size = cdlBreakawayLookback ();
      if ( _state.value .value .mem_size > 0)
         _state.value .value .memory = TA_Calloc( _state.value .value .mem_size , sizeof(struct TA_CDLBREAKAWAY_Data));
      else
         _state.value .value .memory = NULL;
      return RetCode.Success ;
   }
   public int cdlBreakawayState( struct TA_cdlBreakaway_State* _state,
      double inOpen,
      double inHigh,
      double inLow,
      double inClose,
      int *outInteger )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      size_t _cur_idx = _state.value .mem_index++;
      if ( _state.value .mem_size > 0) _cur_idx %= _state.value .mem_size ;
      if ( _state.value .mem_size > _state.value .mem_index - 1 ) {
         ( _state.value .memory+_cur_idx).value .inOpen = inOpen ;
         ( _state.value .memory+_cur_idx).value .inHigh = inHigh ;
         ( _state.value .memory+_cur_idx).value .inLow = inLow ;
         ( _state.value .memory+_cur_idx).value .inClose = inClose ;
         return RetCode.NeedMoreData ; }
      return RetCode.Success ;
   }
   public int cdlBreakawayStateFree( struct TA_cdlBreakaway_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if ( _state.value != NULL) {
         if ( _state.value .value .memory != NULL) TA_Free( _state.value .value .memory );
         TA_Free( _state.value ); _state.value = NULL;}
      return RetCode.Success ;
   }
   public RetCode cdlBreakaway( int startIdx,
      int endIdx,
      float inOpen[],
      float inHigh[],
      float inLow[],
      float inClose[],
      MInteger outBegIdx,
      MInteger outNBElement,
      int outInteger[] )
   {
      double BodyLongPeriodTotal;
      int i, outIdx, BodyLongTrailingIdx, lookbackTotal;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      lookbackTotal = cdlBreakawayLookback ();
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      BodyLongPeriodTotal = 0;
      BodyLongTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) ;
      i = BodyLongTrailingIdx;
      while( i < startIdx ) {
         BodyLongPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-4] - inOpen[i-4] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-4] - inLow[i-4] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-4] - ( inClose[i-4] >= inOpen[i-4] ? inClose[i-4] : inOpen[i-4] ) ) + ( ( inClose[i-4] >= inOpen[i-4] ? inOpen[i-4] : inClose[i-4] ) - inLow[i-4] ) : 0 ) ) ) ;
         i++;
      }
      i = startIdx;
      outIdx = 0;
      do
      {
         if( ( Math.abs ( inClose[i-4] - inOpen[i-4] ) ) > ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) != 0.0? BodyLongPeriodTotal / (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-4] - inOpen[i-4] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-4] - inLow[i-4] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-4] - ( inClose[i-4] >= inOpen[i-4] ? inClose[i-4] : inOpen[i-4] ) ) + ( ( inClose[i-4] >= inOpen[i-4] ? inOpen[i-4] : inClose[i-4] ) - inLow[i-4] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( inClose[i-4] >= inOpen[i-4] ? 1 : -1 ) == ( inClose[i-3] >= inOpen[i-3] ? 1 : -1 ) &&
            ( inClose[i-3] >= inOpen[i-3] ? 1 : -1 ) == ( inClose[i-1] >= inOpen[i-1] ? 1 : -1 ) &&
            ( inClose[i-1] >= inOpen[i-1] ? 1 : -1 ) == - ( inClose[i] >= inOpen[i] ? 1 : -1 ) &&
            (
            ( ( inClose[i-4] >= inOpen[i-4] ? 1 : -1 ) == -1 &&
            ( (((inOpen[i-3]) > (inClose[i-3])) ? (inOpen[i-3]) : (inClose[i-3])) < (((inOpen[i-4]) < (inClose[i-4])) ? (inOpen[i-4]) : (inClose[i-4])) ) &&
            inHigh[i-2] < inHigh[i-3] && inLow[i-2] < inLow[i-3] &&
            inHigh[i-1] < inHigh[i-2] && inLow[i-1] < inLow[i-2] &&
            inClose[i] > inOpen[i-3] && inClose[i] < inClose[i-4]
            )
            ||
            ( ( inClose[i-4] >= inOpen[i-4] ? 1 : -1 ) == 1 &&
            ( (((inOpen[i-3]) < (inClose[i-3])) ? (inOpen[i-3]) : (inClose[i-3])) > (((inOpen[i-4]) > (inClose[i-4])) ? (inOpen[i-4]) : (inClose[i-4])) ) &&
            inHigh[i-2] > inHigh[i-3] && inLow[i-2] > inLow[i-3] &&
            inHigh[i-1] > inHigh[i-2] && inLow[i-1] > inLow[i-2] &&
            inClose[i] < inOpen[i-3] && inClose[i] > inClose[i-4]
            )
            )
            )
            outInteger[outIdx++] = ( inClose[i] >= inOpen[i] ? 1 : -1 ) * 100;
         else
            outInteger[outIdx++] = 0;
         BodyLongPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-4] - inOpen[i-4] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-4] - inLow[i-4] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-4] - ( inClose[i-4] >= inOpen[i-4] ? inClose[i-4] : inOpen[i-4] ) ) + ( ( inClose[i-4] >= inOpen[i-4] ? inOpen[i-4] : inClose[i-4] ) - inLow[i-4] ) : 0 ) ) )
            - ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[BodyLongTrailingIdx-4] - inOpen[BodyLongTrailingIdx-4] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[BodyLongTrailingIdx-4] - inLow[BodyLongTrailingIdx-4] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[BodyLongTrailingIdx-4] - ( inClose[BodyLongTrailingIdx-4] >= inOpen[BodyLongTrailingIdx-4] ? inClose[BodyLongTrailingIdx-4] : inOpen[BodyLongTrailingIdx-4] ) ) + ( ( inClose[BodyLongTrailingIdx-4] >= inOpen[BodyLongTrailingIdx-4] ? inOpen[BodyLongTrailingIdx-4] : inClose[BodyLongTrailingIdx-4] ) - inLow[BodyLongTrailingIdx-4] ) : 0 ) ) ) ;
         i++;
         BodyLongTrailingIdx++;
      } while( i <= endIdx );
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   /* Generated */
   public int cdlClosingMarubozuLookback( )
   {
      return ((( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) ) > ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) )) ? ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) )) ;
   }
   public RetCode cdlClosingMarubozu( int startIdx,
      int endIdx,
      double inOpen[],
      double inHigh[],
      double inLow[],
      double inClose[],
      MInteger outBegIdx,
      MInteger outNBElement,
      int outInteger[] )
   {
      double BodyLongPeriodTotal, ShadowVeryShortPeriodTotal;
      int i, outIdx, BodyLongTrailingIdx, ShadowVeryShortTrailingIdx, lookbackTotal;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      lookbackTotal = cdlClosingMarubozuLookback ();
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      BodyLongPeriodTotal = 0;
      BodyLongTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) ;
      ShadowVeryShortPeriodTotal = 0;
      ShadowVeryShortTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) ;
      i = BodyLongTrailingIdx;
      while( i < startIdx ) {
         BodyLongPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      i = ShadowVeryShortTrailingIdx;
      while( i < startIdx ) {
         ShadowVeryShortPeriodTotal += ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      outIdx = 0;
      do
      {
         if( ( Math.abs ( inClose[i] - inOpen[i] ) ) > ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) != 0.0? BodyLongPeriodTotal / (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            (
            (
            ( inClose[i] >= inOpen[i] ? 1 : -1 ) == 1 &&
            ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) < ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) != 0.0? ShadowVeryShortPeriodTotal / (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) )
            ) ||
            (
            ( inClose[i] >= inOpen[i] ? 1 : -1 ) == -1 &&
            ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) < ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) != 0.0? ShadowVeryShortPeriodTotal / (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) )
            )
            ) )
            outInteger[outIdx++] = ( inClose[i] >= inOpen[i] ? 1 : -1 ) * 100;
         else
            outInteger[outIdx++] = 0;
         BodyLongPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) - ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[BodyLongTrailingIdx] - inOpen[BodyLongTrailingIdx] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[BodyLongTrailingIdx] - inLow[BodyLongTrailingIdx] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[BodyLongTrailingIdx] - ( inClose[BodyLongTrailingIdx] >= inOpen[BodyLongTrailingIdx] ? inClose[BodyLongTrailingIdx] : inOpen[BodyLongTrailingIdx] ) ) + ( ( inClose[BodyLongTrailingIdx] >= inOpen[BodyLongTrailingIdx] ? inOpen[BodyLongTrailingIdx] : inClose[BodyLongTrailingIdx] ) - inLow[BodyLongTrailingIdx] ) : 0 ) ) ) ;
         ShadowVeryShortPeriodTotal += ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) )
            - ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[ShadowVeryShortTrailingIdx] - inOpen[ShadowVeryShortTrailingIdx] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[ShadowVeryShortTrailingIdx] - inLow[ShadowVeryShortTrailingIdx] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[ShadowVeryShortTrailingIdx] - ( inClose[ShadowVeryShortTrailingIdx] >= inOpen[ShadowVeryShortTrailingIdx] ? inClose[ShadowVeryShortTrailingIdx] : inOpen[ShadowVeryShortTrailingIdx] ) ) + ( ( inClose[ShadowVeryShortTrailingIdx] >= inOpen[ShadowVeryShortTrailingIdx] ? inOpen[ShadowVeryShortTrailingIdx] : inClose[ShadowVeryShortTrailingIdx] ) - inLow[ShadowVeryShortTrailingIdx] ) : 0 ) ) ) ;
         i++;
         BodyLongTrailingIdx++;
         ShadowVeryShortTrailingIdx++;
      } while( i <= endIdx );
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   public int cdlClosingMarubozuStateInit( struct TA_cdlClosingMarubozu_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct cdlClosingMarubozu ));
      _state.value .value .mem_index = 0;
      _state.value .value .mem_size = cdlClosingMarubozuLookback ();
      if ( _state.value .value .mem_size > 0)
         _state.value .value .memory = TA_Calloc( _state.value .value .mem_size , sizeof(struct TA_CDLCLOSINGMARUBOZU_Data));
      else
         _state.value .value .memory = NULL;
      return RetCode.Success ;
   }
   public int cdlClosingMarubozuState( struct TA_cdlClosingMarubozu_State* _state,
      double inOpen,
      double inHigh,
      double inLow,
      double inClose,
      int *outInteger )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      size_t _cur_idx = _state.value .mem_index++;
      if ( _state.value .mem_size > 0) _cur_idx %= _state.value .mem_size ;
      if ( _state.value .mem_size > _state.value .mem_index - 1 ) {
         ( _state.value .memory+_cur_idx).value .inOpen = inOpen ;
         ( _state.value .memory+_cur_idx).value .inHigh = inHigh ;
         ( _state.value .memory+_cur_idx).value .inLow = inLow ;
         ( _state.value .memory+_cur_idx).value .inClose = inClose ;
         return RetCode.NeedMoreData ; }
      return RetCode.Success ;
   }
   public int cdlClosingMarubozuStateFree( struct TA_cdlClosingMarubozu_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if ( _state.value != NULL) {
         if ( _state.value .value .memory != NULL) TA_Free( _state.value .value .memory );
         TA_Free( _state.value ); _state.value = NULL;}
      return RetCode.Success ;
   }
   public RetCode cdlClosingMarubozu( int startIdx,
      int endIdx,
      float inOpen[],
      float inHigh[],
      float inLow[],
      float inClose[],
      MInteger outBegIdx,
      MInteger outNBElement,
      int outInteger[] )
   {
      double BodyLongPeriodTotal, ShadowVeryShortPeriodTotal;
      int i, outIdx, BodyLongTrailingIdx, ShadowVeryShortTrailingIdx, lookbackTotal;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      lookbackTotal = cdlClosingMarubozuLookback ();
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      BodyLongPeriodTotal = 0;
      BodyLongTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) ;
      ShadowVeryShortPeriodTotal = 0;
      ShadowVeryShortTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) ;
      i = BodyLongTrailingIdx;
      while( i < startIdx ) {
         BodyLongPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      i = ShadowVeryShortTrailingIdx;
      while( i < startIdx ) {
         ShadowVeryShortPeriodTotal += ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      outIdx = 0;
      do
      {
         if( ( Math.abs ( inClose[i] - inOpen[i] ) ) > ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) != 0.0? BodyLongPeriodTotal / (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            (
            (
            ( inClose[i] >= inOpen[i] ? 1 : -1 ) == 1 &&
            ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) < ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) != 0.0? ShadowVeryShortPeriodTotal / (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) )
            ) ||
            (
            ( inClose[i] >= inOpen[i] ? 1 : -1 ) == -1 &&
            ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) < ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) != 0.0? ShadowVeryShortPeriodTotal / (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) )
            )
            ) )
            outInteger[outIdx++] = ( inClose[i] >= inOpen[i] ? 1 : -1 ) * 100;
         else
            outInteger[outIdx++] = 0;
         BodyLongPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) - ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[BodyLongTrailingIdx] - inOpen[BodyLongTrailingIdx] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[BodyLongTrailingIdx] - inLow[BodyLongTrailingIdx] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[BodyLongTrailingIdx] - ( inClose[BodyLongTrailingIdx] >= inOpen[BodyLongTrailingIdx] ? inClose[BodyLongTrailingIdx] : inOpen[BodyLongTrailingIdx] ) ) + ( ( inClose[BodyLongTrailingIdx] >= inOpen[BodyLongTrailingIdx] ? inOpen[BodyLongTrailingIdx] : inClose[BodyLongTrailingIdx] ) - inLow[BodyLongTrailingIdx] ) : 0 ) ) ) ;
         ShadowVeryShortPeriodTotal += ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) )
            - ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[ShadowVeryShortTrailingIdx] - inOpen[ShadowVeryShortTrailingIdx] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[ShadowVeryShortTrailingIdx] - inLow[ShadowVeryShortTrailingIdx] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[ShadowVeryShortTrailingIdx] - ( inClose[ShadowVeryShortTrailingIdx] >= inOpen[ShadowVeryShortTrailingIdx] ? inClose[ShadowVeryShortTrailingIdx] : inOpen[ShadowVeryShortTrailingIdx] ) ) + ( ( inClose[ShadowVeryShortTrailingIdx] >= inOpen[ShadowVeryShortTrailingIdx] ? inOpen[ShadowVeryShortTrailingIdx] : inClose[ShadowVeryShortTrailingIdx] ) - inLow[ShadowVeryShortTrailingIdx] ) : 0 ) ) ) ;
         i++;
         BodyLongTrailingIdx++;
         ShadowVeryShortTrailingIdx++;
      } while( i <= endIdx );
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   /* Generated */
   public int cdlConcealBabysWallLookback( )
   {
      return (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) + 3;
   }
   public RetCode cdlConcealBabysWall( int startIdx,
      int endIdx,
      double inOpen[],
      double inHigh[],
      double inLow[],
      double inClose[],
      MInteger outBegIdx,
      MInteger outNBElement,
      int outInteger[] )
   {
      double []ShadowVeryShortPeriodTotal = new double[4] ;
      int i, outIdx, totIdx, ShadowVeryShortTrailingIdx, lookbackTotal;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      lookbackTotal = cdlConcealBabysWallLookback ();
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      ShadowVeryShortPeriodTotal[3] = 0;
      ShadowVeryShortPeriodTotal[2] = 0;
      ShadowVeryShortPeriodTotal[1] = 0;
      ShadowVeryShortTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) ;
      i = ShadowVeryShortTrailingIdx;
      while( i < startIdx ) {
         ShadowVeryShortPeriodTotal[3] += ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-3] - inOpen[i-3] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-3] - inLow[i-3] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-3] - ( inClose[i-3] >= inOpen[i-3] ? inClose[i-3] : inOpen[i-3] ) ) + ( ( inClose[i-3] >= inOpen[i-3] ? inOpen[i-3] : inClose[i-3] ) - inLow[i-3] ) : 0 ) ) ) ;
         ShadowVeryShortPeriodTotal[2] += ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-2] - inLow[i-2] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-2] - ( inClose[i-2] >= inOpen[i-2] ? inClose[i-2] : inOpen[i-2] ) ) + ( ( inClose[i-2] >= inOpen[i-2] ? inOpen[i-2] : inClose[i-2] ) - inLow[i-2] ) : 0 ) ) ) ;
         ShadowVeryShortPeriodTotal[1] += ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ;
         i++;
      }
      i = startIdx;
      outIdx = 0;
      do
      {
         if( ( inClose[i-3] >= inOpen[i-3] ? 1 : -1 ) == -1 &&
            ( inClose[i-2] >= inOpen[i-2] ? 1 : -1 ) == -1 &&
            ( inClose[i-1] >= inOpen[i-1] ? 1 : -1 ) == -1 &&
            ( inClose[i] >= inOpen[i] ? 1 : -1 ) == -1 &&
            ( ( inClose[i-3] >= inOpen[i-3] ? inOpen[i-3] : inClose[i-3] ) - inLow[i-3] ) < ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) != 0.0? ShadowVeryShortPeriodTotal[3] / (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-3] - inOpen[i-3] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-3] - inLow[i-3] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-3] - ( inClose[i-3] >= inOpen[i-3] ? inClose[i-3] : inOpen[i-3] ) ) + ( ( inClose[i-3] >= inOpen[i-3] ? inOpen[i-3] : inClose[i-3] ) - inLow[i-3] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( inHigh[i-3] - ( inClose[i-3] >= inOpen[i-3] ? inClose[i-3] : inOpen[i-3] ) ) < ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) != 0.0? ShadowVeryShortPeriodTotal[3] / (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-3] - inOpen[i-3] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-3] - inLow[i-3] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-3] - ( inClose[i-3] >= inOpen[i-3] ? inClose[i-3] : inOpen[i-3] ) ) + ( ( inClose[i-3] >= inOpen[i-3] ? inOpen[i-3] : inClose[i-3] ) - inLow[i-3] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( ( inClose[i-2] >= inOpen[i-2] ? inOpen[i-2] : inClose[i-2] ) - inLow[i-2] ) < ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) != 0.0? ShadowVeryShortPeriodTotal[2] / (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-2] - inLow[i-2] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-2] - ( inClose[i-2] >= inOpen[i-2] ? inClose[i-2] : inOpen[i-2] ) ) + ( ( inClose[i-2] >= inOpen[i-2] ? inOpen[i-2] : inClose[i-2] ) - inLow[i-2] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( inHigh[i-2] - ( inClose[i-2] >= inOpen[i-2] ? inClose[i-2] : inOpen[i-2] ) ) < ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) != 0.0? ShadowVeryShortPeriodTotal[2] / (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-2] - inLow[i-2] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-2] - ( inClose[i-2] >= inOpen[i-2] ? inClose[i-2] : inOpen[i-2] ) ) + ( ( inClose[i-2] >= inOpen[i-2] ? inOpen[i-2] : inClose[i-2] ) - inLow[i-2] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( (((inOpen[i-1]) > (inClose[i-1])) ? (inOpen[i-1]) : (inClose[i-1])) < (((inOpen[i-2]) < (inClose[i-2])) ? (inOpen[i-2]) : (inClose[i-2])) ) &&
            ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) > ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) != 0.0? ShadowVeryShortPeriodTotal[1] / (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            inHigh[i-1] > inClose[i-2] &&
            inHigh[i] > inHigh[i-1] && inLow[i] < inLow[i-1]
            )
            outInteger[outIdx++] = 100;
         else
            outInteger[outIdx++] = 0;
         for (totIdx = 3; totIdx >= 1; --totIdx)
            ShadowVeryShortPeriodTotal[totIdx] += ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-totIdx] - inOpen[i-totIdx] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-totIdx] - inLow[i-totIdx] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-totIdx] - ( inClose[i-totIdx] >= inOpen[i-totIdx] ? inClose[i-totIdx] : inOpen[i-totIdx] ) ) + ( ( inClose[i-totIdx] >= inOpen[i-totIdx] ? inOpen[i-totIdx] : inClose[i-totIdx] ) - inLow[i-totIdx] ) : 0 ) ) )
            - ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[ShadowVeryShortTrailingIdx-totIdx] - inOpen[ShadowVeryShortTrailingIdx-totIdx] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[ShadowVeryShortTrailingIdx-totIdx] - inLow[ShadowVeryShortTrailingIdx-totIdx] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[ShadowVeryShortTrailingIdx-totIdx] - ( inClose[ShadowVeryShortTrailingIdx-totIdx] >= inOpen[ShadowVeryShortTrailingIdx-totIdx] ? inClose[ShadowVeryShortTrailingIdx-totIdx] : inOpen[ShadowVeryShortTrailingIdx-totIdx] ) ) + ( ( inClose[ShadowVeryShortTrailingIdx-totIdx] >= inOpen[ShadowVeryShortTrailingIdx-totIdx] ? inOpen[ShadowVeryShortTrailingIdx-totIdx] : inClose[ShadowVeryShortTrailingIdx-totIdx] ) - inLow[ShadowVeryShortTrailingIdx-totIdx] ) : 0 ) ) ) ;
         i++;
         ShadowVeryShortTrailingIdx++;
      } while( i <= endIdx );
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   public int cdlConcealBabysWallStateInit( struct TA_cdlConcealBabysWall_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct cdlConcealBabysWall ));
      _state.value .value .mem_index = 0;
      _state.value .value .mem_size = cdlConcealBabysWallLookback ();
      if ( _state.value .value .mem_size > 0)
         _state.value .value .memory = TA_Calloc( _state.value .value .mem_size , sizeof(struct TA_CDLCONCEALBABYSWALL_Data));
      else
         _state.value .value .memory = NULL;
      return RetCode.Success ;
   }
   public int cdlConcealBabysWallState( struct TA_cdlConcealBabysWall_State* _state,
      double inOpen,
      double inHigh,
      double inLow,
      double inClose,
      int *outInteger )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      size_t _cur_idx = _state.value .mem_index++;
      if ( _state.value .mem_size > 0) _cur_idx %= _state.value .mem_size ;
      if ( _state.value .mem_size > _state.value .mem_index - 1 ) {
         ( _state.value .memory+_cur_idx).value .inOpen = inOpen ;
         ( _state.value .memory+_cur_idx).value .inHigh = inHigh ;
         ( _state.value .memory+_cur_idx).value .inLow = inLow ;
         ( _state.value .memory+_cur_idx).value .inClose = inClose ;
         return RetCode.NeedMoreData ; }
      return RetCode.Success ;
   }
   public int cdlConcealBabysWallStateFree( struct TA_cdlConcealBabysWall_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if ( _state.value != NULL) {
         if ( _state.value .value .memory != NULL) TA_Free( _state.value .value .memory );
         TA_Free( _state.value ); _state.value = NULL;}
      return RetCode.Success ;
   }
   public RetCode cdlConcealBabysWall( int startIdx,
      int endIdx,
      float inOpen[],
      float inHigh[],
      float inLow[],
      float inClose[],
      MInteger outBegIdx,
      MInteger outNBElement,
      int outInteger[] )
   {
      double []ShadowVeryShortPeriodTotal = new double[4] ;
      int i, outIdx, totIdx, ShadowVeryShortTrailingIdx, lookbackTotal;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      lookbackTotal = cdlConcealBabysWallLookback ();
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      ShadowVeryShortPeriodTotal[3] = 0;
      ShadowVeryShortPeriodTotal[2] = 0;
      ShadowVeryShortPeriodTotal[1] = 0;
      ShadowVeryShortTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) ;
      i = ShadowVeryShortTrailingIdx;
      while( i < startIdx ) {
         ShadowVeryShortPeriodTotal[3] += ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-3] - inOpen[i-3] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-3] - inLow[i-3] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-3] - ( inClose[i-3] >= inOpen[i-3] ? inClose[i-3] : inOpen[i-3] ) ) + ( ( inClose[i-3] >= inOpen[i-3] ? inOpen[i-3] : inClose[i-3] ) - inLow[i-3] ) : 0 ) ) ) ;
         ShadowVeryShortPeriodTotal[2] += ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-2] - inLow[i-2] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-2] - ( inClose[i-2] >= inOpen[i-2] ? inClose[i-2] : inOpen[i-2] ) ) + ( ( inClose[i-2] >= inOpen[i-2] ? inOpen[i-2] : inClose[i-2] ) - inLow[i-2] ) : 0 ) ) ) ;
         ShadowVeryShortPeriodTotal[1] += ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ;
         i++;
      }
      i = startIdx;
      outIdx = 0;
      do
      {
         if( ( inClose[i-3] >= inOpen[i-3] ? 1 : -1 ) == -1 &&
            ( inClose[i-2] >= inOpen[i-2] ? 1 : -1 ) == -1 &&
            ( inClose[i-1] >= inOpen[i-1] ? 1 : -1 ) == -1 &&
            ( inClose[i] >= inOpen[i] ? 1 : -1 ) == -1 &&
            ( ( inClose[i-3] >= inOpen[i-3] ? inOpen[i-3] : inClose[i-3] ) - inLow[i-3] ) < ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) != 0.0? ShadowVeryShortPeriodTotal[3] / (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-3] - inOpen[i-3] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-3] - inLow[i-3] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-3] - ( inClose[i-3] >= inOpen[i-3] ? inClose[i-3] : inOpen[i-3] ) ) + ( ( inClose[i-3] >= inOpen[i-3] ? inOpen[i-3] : inClose[i-3] ) - inLow[i-3] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( inHigh[i-3] - ( inClose[i-3] >= inOpen[i-3] ? inClose[i-3] : inOpen[i-3] ) ) < ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) != 0.0? ShadowVeryShortPeriodTotal[3] / (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-3] - inOpen[i-3] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-3] - inLow[i-3] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-3] - ( inClose[i-3] >= inOpen[i-3] ? inClose[i-3] : inOpen[i-3] ) ) + ( ( inClose[i-3] >= inOpen[i-3] ? inOpen[i-3] : inClose[i-3] ) - inLow[i-3] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( ( inClose[i-2] >= inOpen[i-2] ? inOpen[i-2] : inClose[i-2] ) - inLow[i-2] ) < ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) != 0.0? ShadowVeryShortPeriodTotal[2] / (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-2] - inLow[i-2] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-2] - ( inClose[i-2] >= inOpen[i-2] ? inClose[i-2] : inOpen[i-2] ) ) + ( ( inClose[i-2] >= inOpen[i-2] ? inOpen[i-2] : inClose[i-2] ) - inLow[i-2] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( inHigh[i-2] - ( inClose[i-2] >= inOpen[i-2] ? inClose[i-2] : inOpen[i-2] ) ) < ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) != 0.0? ShadowVeryShortPeriodTotal[2] / (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-2] - inLow[i-2] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-2] - ( inClose[i-2] >= inOpen[i-2] ? inClose[i-2] : inOpen[i-2] ) ) + ( ( inClose[i-2] >= inOpen[i-2] ? inOpen[i-2] : inClose[i-2] ) - inLow[i-2] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( (((inOpen[i-1]) > (inClose[i-1])) ? (inOpen[i-1]) : (inClose[i-1])) < (((inOpen[i-2]) < (inClose[i-2])) ? (inOpen[i-2]) : (inClose[i-2])) ) &&
            ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) > ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) != 0.0? ShadowVeryShortPeriodTotal[1] / (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            inHigh[i-1] > inClose[i-2] &&
            inHigh[i] > inHigh[i-1] && inLow[i] < inLow[i-1]
            )
            outInteger[outIdx++] = 100;
         else
            outInteger[outIdx++] = 0;
         for (totIdx = 3; totIdx >= 1; --totIdx)
            ShadowVeryShortPeriodTotal[totIdx] += ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-totIdx] - inOpen[i-totIdx] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-totIdx] - inLow[i-totIdx] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-totIdx] - ( inClose[i-totIdx] >= inOpen[i-totIdx] ? inClose[i-totIdx] : inOpen[i-totIdx] ) ) + ( ( inClose[i-totIdx] >= inOpen[i-totIdx] ? inOpen[i-totIdx] : inClose[i-totIdx] ) - inLow[i-totIdx] ) : 0 ) ) )
            - ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[ShadowVeryShortTrailingIdx-totIdx] - inOpen[ShadowVeryShortTrailingIdx-totIdx] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[ShadowVeryShortTrailingIdx-totIdx] - inLow[ShadowVeryShortTrailingIdx-totIdx] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[ShadowVeryShortTrailingIdx-totIdx] - ( inClose[ShadowVeryShortTrailingIdx-totIdx] >= inOpen[ShadowVeryShortTrailingIdx-totIdx] ? inClose[ShadowVeryShortTrailingIdx-totIdx] : inOpen[ShadowVeryShortTrailingIdx-totIdx] ) ) + ( ( inClose[ShadowVeryShortTrailingIdx-totIdx] >= inOpen[ShadowVeryShortTrailingIdx-totIdx] ? inOpen[ShadowVeryShortTrailingIdx-totIdx] : inClose[ShadowVeryShortTrailingIdx-totIdx] ) - inLow[ShadowVeryShortTrailingIdx-totIdx] ) : 0 ) ) ) ;
         i++;
         ShadowVeryShortTrailingIdx++;
      } while( i <= endIdx );
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   /* Generated */
   public int cdlCounterAttackLookback( )
   {
      return ((( (this.candleSettings[CandleSettingType.Equal.ordinal()].avgPeriod) ) > ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) )) ? ( (this.candleSettings[CandleSettingType.Equal.ordinal()].avgPeriod) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) )) +
         1;
   }
   public RetCode cdlCounterAttack( int startIdx,
      int endIdx,
      double inOpen[],
      double inHigh[],
      double inLow[],
      double inClose[],
      MInteger outBegIdx,
      MInteger outNBElement,
      int outInteger[] )
   {
      double EqualPeriodTotal;
      double []BodyLongPeriodTotal = new double[2] ;
      int i, outIdx, totIdx, EqualTrailingIdx, BodyLongTrailingIdx, lookbackTotal;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      lookbackTotal = cdlCounterAttackLookback ();
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      EqualPeriodTotal = 0;
      EqualTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.Equal.ordinal()].avgPeriod) ;
      BodyLongPeriodTotal[1] = 0;
      BodyLongPeriodTotal[0] = 0;
      BodyLongTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) ;
      i = EqualTrailingIdx;
      while( i < startIdx ) {
         EqualPeriodTotal += ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ;
         i++;
      }
      i = BodyLongTrailingIdx;
      while( i < startIdx ) {
         BodyLongPeriodTotal[1] += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ;
         BodyLongPeriodTotal[0] += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      i = startIdx;
      outIdx = 0;
      do
      {
         if( ( inClose[i-1] >= inOpen[i-1] ? 1 : -1 ) == - ( inClose[i] >= inOpen[i] ? 1 : -1 ) &&
            ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) > ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) != 0.0? BodyLongPeriodTotal[1] / (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( Math.abs ( inClose[i] - inOpen[i] ) ) > ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) != 0.0? BodyLongPeriodTotal[0] / (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            inClose[i] <= inClose[i-1] + ( (this.candleSettings[CandleSettingType.Equal.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.Equal.ordinal()].avgPeriod) != 0.0? EqualPeriodTotal / (this.candleSettings[CandleSettingType.Equal.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            inClose[i] >= inClose[i-1] - ( (this.candleSettings[CandleSettingType.Equal.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.Equal.ordinal()].avgPeriod) != 0.0? EqualPeriodTotal / (this.candleSettings[CandleSettingType.Equal.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) )
            )
            outInteger[outIdx++] = ( inClose[i] >= inOpen[i] ? 1 : -1 ) * 100;
         else
            outInteger[outIdx++] = 0;
         EqualPeriodTotal += ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) - ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[EqualTrailingIdx-1] - inOpen[EqualTrailingIdx-1] ) ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[EqualTrailingIdx-1] - inLow[EqualTrailingIdx-1] ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[EqualTrailingIdx-1] - ( inClose[EqualTrailingIdx-1] >= inOpen[EqualTrailingIdx-1] ? inClose[EqualTrailingIdx-1] : inOpen[EqualTrailingIdx-1] ) ) + ( ( inClose[EqualTrailingIdx-1] >= inOpen[EqualTrailingIdx-1] ? inOpen[EqualTrailingIdx-1] : inClose[EqualTrailingIdx-1] ) - inLow[EqualTrailingIdx-1] ) : 0 ) ) ) ;
         for (totIdx = 1; totIdx >= 0; --totIdx)
            BodyLongPeriodTotal[totIdx] += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-totIdx] - inOpen[i-totIdx] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-totIdx] - inLow[i-totIdx] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-totIdx] - ( inClose[i-totIdx] >= inOpen[i-totIdx] ? inClose[i-totIdx] : inOpen[i-totIdx] ) ) + ( ( inClose[i-totIdx] >= inOpen[i-totIdx] ? inOpen[i-totIdx] : inClose[i-totIdx] ) - inLow[i-totIdx] ) : 0 ) ) )
            - ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[BodyLongTrailingIdx-totIdx] - inOpen[BodyLongTrailingIdx-totIdx] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[BodyLongTrailingIdx-totIdx] - inLow[BodyLongTrailingIdx-totIdx] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[BodyLongTrailingIdx-totIdx] - ( inClose[BodyLongTrailingIdx-totIdx] >= inOpen[BodyLongTrailingIdx-totIdx] ? inClose[BodyLongTrailingIdx-totIdx] : inOpen[BodyLongTrailingIdx-totIdx] ) ) + ( ( inClose[BodyLongTrailingIdx-totIdx] >= inOpen[BodyLongTrailingIdx-totIdx] ? inOpen[BodyLongTrailingIdx-totIdx] : inClose[BodyLongTrailingIdx-totIdx] ) - inLow[BodyLongTrailingIdx-totIdx] ) : 0 ) ) ) ;
         i++;
         EqualTrailingIdx++;
         BodyLongTrailingIdx++;
      } while( i <= endIdx );
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   public int cdlCounterAttackStateInit( struct TA_cdlCounterAttack_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct cdlCounterAttack ));
      _state.value .value .mem_index = 0;
      _state.value .value .mem_size = cdlCounterAttackLookback ();
      if ( _state.value .value .mem_size > 0)
         _state.value .value .memory = TA_Calloc( _state.value .value .mem_size , sizeof(struct TA_CDLCOUNTERATTACK_Data));
      else
         _state.value .value .memory = NULL;
      return RetCode.Success ;
   }
   public int cdlCounterAttackState( struct TA_cdlCounterAttack_State* _state,
      double inOpen,
      double inHigh,
      double inLow,
      double inClose,
      int *outInteger )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      size_t _cur_idx = _state.value .mem_index++;
      if ( _state.value .mem_size > 0) _cur_idx %= _state.value .mem_size ;
      if ( _state.value .mem_size > _state.value .mem_index - 1 ) {
         ( _state.value .memory+_cur_idx).value .inOpen = inOpen ;
         ( _state.value .memory+_cur_idx).value .inHigh = inHigh ;
         ( _state.value .memory+_cur_idx).value .inLow = inLow ;
         ( _state.value .memory+_cur_idx).value .inClose = inClose ;
         return RetCode.NeedMoreData ; }
      return RetCode.Success ;
   }
   public int cdlCounterAttackStateFree( struct TA_cdlCounterAttack_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if ( _state.value != NULL) {
         if ( _state.value .value .memory != NULL) TA_Free( _state.value .value .memory );
         TA_Free( _state.value ); _state.value = NULL;}
      return RetCode.Success ;
   }
   public RetCode cdlCounterAttack( int startIdx,
      int endIdx,
      float inOpen[],
      float inHigh[],
      float inLow[],
      float inClose[],
      MInteger outBegIdx,
      MInteger outNBElement,
      int outInteger[] )
   {
      double EqualPeriodTotal;
      double []BodyLongPeriodTotal = new double[2] ;
      int i, outIdx, totIdx, EqualTrailingIdx, BodyLongTrailingIdx, lookbackTotal;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      lookbackTotal = cdlCounterAttackLookback ();
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      EqualPeriodTotal = 0;
      EqualTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.Equal.ordinal()].avgPeriod) ;
      BodyLongPeriodTotal[1] = 0;
      BodyLongPeriodTotal[0] = 0;
      BodyLongTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) ;
      i = EqualTrailingIdx;
      while( i < startIdx ) {
         EqualPeriodTotal += ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ;
         i++;
      }
      i = BodyLongTrailingIdx;
      while( i < startIdx ) {
         BodyLongPeriodTotal[1] += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ;
         BodyLongPeriodTotal[0] += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      i = startIdx;
      outIdx = 0;
      do
      {
         if( ( inClose[i-1] >= inOpen[i-1] ? 1 : -1 ) == - ( inClose[i] >= inOpen[i] ? 1 : -1 ) &&
            ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) > ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) != 0.0? BodyLongPeriodTotal[1] / (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( Math.abs ( inClose[i] - inOpen[i] ) ) > ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) != 0.0? BodyLongPeriodTotal[0] / (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            inClose[i] <= inClose[i-1] + ( (this.candleSettings[CandleSettingType.Equal.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.Equal.ordinal()].avgPeriod) != 0.0? EqualPeriodTotal / (this.candleSettings[CandleSettingType.Equal.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            inClose[i] >= inClose[i-1] - ( (this.candleSettings[CandleSettingType.Equal.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.Equal.ordinal()].avgPeriod) != 0.0? EqualPeriodTotal / (this.candleSettings[CandleSettingType.Equal.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) )
            )
            outInteger[outIdx++] = ( inClose[i] >= inOpen[i] ? 1 : -1 ) * 100;
         else
            outInteger[outIdx++] = 0;
         EqualPeriodTotal += ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) - ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[EqualTrailingIdx-1] - inOpen[EqualTrailingIdx-1] ) ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[EqualTrailingIdx-1] - inLow[EqualTrailingIdx-1] ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[EqualTrailingIdx-1] - ( inClose[EqualTrailingIdx-1] >= inOpen[EqualTrailingIdx-1] ? inClose[EqualTrailingIdx-1] : inOpen[EqualTrailingIdx-1] ) ) + ( ( inClose[EqualTrailingIdx-1] >= inOpen[EqualTrailingIdx-1] ? inOpen[EqualTrailingIdx-1] : inClose[EqualTrailingIdx-1] ) - inLow[EqualTrailingIdx-1] ) : 0 ) ) ) ;
         for (totIdx = 1; totIdx >= 0; --totIdx)
            BodyLongPeriodTotal[totIdx] += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-totIdx] - inOpen[i-totIdx] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-totIdx] - inLow[i-totIdx] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-totIdx] - ( inClose[i-totIdx] >= inOpen[i-totIdx] ? inClose[i-totIdx] : inOpen[i-totIdx] ) ) + ( ( inClose[i-totIdx] >= inOpen[i-totIdx] ? inOpen[i-totIdx] : inClose[i-totIdx] ) - inLow[i-totIdx] ) : 0 ) ) )
            - ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[BodyLongTrailingIdx-totIdx] - inOpen[BodyLongTrailingIdx-totIdx] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[BodyLongTrailingIdx-totIdx] - inLow[BodyLongTrailingIdx-totIdx] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[BodyLongTrailingIdx-totIdx] - ( inClose[BodyLongTrailingIdx-totIdx] >= inOpen[BodyLongTrailingIdx-totIdx] ? inClose[BodyLongTrailingIdx-totIdx] : inOpen[BodyLongTrailingIdx-totIdx] ) ) + ( ( inClose[BodyLongTrailingIdx-totIdx] >= inOpen[BodyLongTrailingIdx-totIdx] ? inOpen[BodyLongTrailingIdx-totIdx] : inClose[BodyLongTrailingIdx-totIdx] ) - inLow[BodyLongTrailingIdx-totIdx] ) : 0 ) ) ) ;
         i++;
         EqualTrailingIdx++;
         BodyLongTrailingIdx++;
      } while( i <= endIdx );
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   /* Generated */
   public int cdlDarkCloudCoverLookback( double optInPenetration )
   {
      if( optInPenetration == (-4e+37) )
         optInPenetration = 5.000000e-1;
      else if( (optInPenetration < 0.000000e+0) || (optInPenetration > 3.000000e+37) )
         return -1;
      return (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) + 1;
   }
   public RetCode cdlDarkCloudCover( int startIdx,
      int endIdx,
      double inOpen[],
      double inHigh[],
      double inLow[],
      double inClose[],
      double optInPenetration,
      MInteger outBegIdx,
      MInteger outNBElement,
      int outInteger[] )
   {
      double BodyLongPeriodTotal;
      int i, outIdx, BodyLongTrailingIdx, lookbackTotal;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      if( optInPenetration == (-4e+37) )
         optInPenetration = 5.000000e-1;
      else if( (optInPenetration < 0.000000e+0) || (optInPenetration > 3.000000e+37) )
         return RetCode.BadParam ;
      lookbackTotal = cdlDarkCloudCoverLookback (optInPenetration);
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      BodyLongPeriodTotal = 0;
      BodyLongTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) ;
      i = BodyLongTrailingIdx;
      while( i < startIdx ) {
         BodyLongPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ;
         i++;
      }
      i = startIdx;
      outIdx = 0;
      do
      {
         if( ( inClose[i-1] >= inOpen[i-1] ? 1 : -1 ) == 1 &&
            ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) > ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) != 0.0? BodyLongPeriodTotal / (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( inClose[i] >= inOpen[i] ? 1 : -1 ) == -1 &&
            inOpen[i] > inHigh[i-1] &&
            inClose[i] > inOpen[i-1] &&
            inClose[i] < inClose[i-1] - ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) * optInPenetration
            )
            outInteger[outIdx++] = -100;
         else
            outInteger[outIdx++] = 0;
         BodyLongPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) - ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[BodyLongTrailingIdx-1] - inOpen[BodyLongTrailingIdx-1] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[BodyLongTrailingIdx-1] - inLow[BodyLongTrailingIdx-1] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[BodyLongTrailingIdx-1] - ( inClose[BodyLongTrailingIdx-1] >= inOpen[BodyLongTrailingIdx-1] ? inClose[BodyLongTrailingIdx-1] : inOpen[BodyLongTrailingIdx-1] ) ) + ( ( inClose[BodyLongTrailingIdx-1] >= inOpen[BodyLongTrailingIdx-1] ? inOpen[BodyLongTrailingIdx-1] : inClose[BodyLongTrailingIdx-1] ) - inLow[BodyLongTrailingIdx-1] ) : 0 ) ) ) ;
         i++;
         BodyLongTrailingIdx++;
      } while( i <= endIdx );
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   public int cdlDarkCloudCoverStateInit( struct TA_cdlDarkCloudCover_State** _state,
      double optInPenetration )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if( optInPenetration == (-4e+37) )
         optInPenetration = 5.000000e-1;
      else if( (optInPenetration < 0.000000e+0) || (optInPenetration > 3.000000e+37) )
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct cdlDarkCloudCover ));
      _state.value .value .mem_index = 0;
      _state.value .value .optInPenetration = optInPenetration;
      _state.value .value .mem_size = cdlDarkCloudCoverLookback (optInPenetration );
      if ( _state.value .value .mem_size > 0)
         _state.value .value .memory = TA_Calloc( _state.value .value .mem_size , sizeof(struct TA_CDLDARKCLOUDCOVER_Data));
      else
         _state.value .value .memory = NULL;
      return RetCode.Success ;
   }
   public int cdlDarkCloudCoverState( struct TA_cdlDarkCloudCover_State* _state,
      double inOpen,
      double inHigh,
      double inLow,
      double inClose,
      int *outInteger )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      size_t _cur_idx = _state.value .mem_index++;
      if ( _state.value .mem_size > 0) _cur_idx %= _state.value .mem_size ;
      if ( _state.value .mem_size > _state.value .mem_index - 1 ) {
         ( _state.value .memory+_cur_idx).value .inOpen = inOpen ;
         ( _state.value .memory+_cur_idx).value .inHigh = inHigh ;
         ( _state.value .memory+_cur_idx).value .inLow = inLow ;
         ( _state.value .memory+_cur_idx).value .inClose = inClose ;
         return RetCode.NeedMoreData ; }
      return RetCode.Success ;
   }
   public int cdlDarkCloudCoverStateFree( struct TA_cdlDarkCloudCover_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if ( _state.value != NULL) {
         if ( _state.value .value .memory != NULL) TA_Free( _state.value .value .memory );
         TA_Free( _state.value ); _state.value = NULL;}
      return RetCode.Success ;
   }
   public RetCode cdlDarkCloudCover( int startIdx,
      int endIdx,
      float inOpen[],
      float inHigh[],
      float inLow[],
      float inClose[],
      double optInPenetration,
      MInteger outBegIdx,
      MInteger outNBElement,
      int outInteger[] )
   {
      double BodyLongPeriodTotal;
      int i, outIdx, BodyLongTrailingIdx, lookbackTotal;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      if( optInPenetration == (-4e+37) )
         optInPenetration = 5.000000e-1;
      else if( (optInPenetration < 0.000000e+0) || (optInPenetration > 3.000000e+37) )
         return RetCode.BadParam ;
      lookbackTotal = cdlDarkCloudCoverLookback (optInPenetration);
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      BodyLongPeriodTotal = 0;
      BodyLongTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) ;
      i = BodyLongTrailingIdx;
      while( i < startIdx ) {
         BodyLongPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ;
         i++;
      }
      i = startIdx;
      outIdx = 0;
      do
      {
         if( ( inClose[i-1] >= inOpen[i-1] ? 1 : -1 ) == 1 &&
            ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) > ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) != 0.0? BodyLongPeriodTotal / (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( inClose[i] >= inOpen[i] ? 1 : -1 ) == -1 &&
            inOpen[i] > inHigh[i-1] &&
            inClose[i] > inOpen[i-1] &&
            inClose[i] < inClose[i-1] - ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) * optInPenetration
            )
            outInteger[outIdx++] = -100;
         else
            outInteger[outIdx++] = 0;
         BodyLongPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) - ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[BodyLongTrailingIdx-1] - inOpen[BodyLongTrailingIdx-1] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[BodyLongTrailingIdx-1] - inLow[BodyLongTrailingIdx-1] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[BodyLongTrailingIdx-1] - ( inClose[BodyLongTrailingIdx-1] >= inOpen[BodyLongTrailingIdx-1] ? inClose[BodyLongTrailingIdx-1] : inOpen[BodyLongTrailingIdx-1] ) ) + ( ( inClose[BodyLongTrailingIdx-1] >= inOpen[BodyLongTrailingIdx-1] ? inOpen[BodyLongTrailingIdx-1] : inClose[BodyLongTrailingIdx-1] ) - inLow[BodyLongTrailingIdx-1] ) : 0 ) ) ) ;
         i++;
         BodyLongTrailingIdx++;
      } while( i <= endIdx );
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   /* Generated */
   public int cdlDojiLookback( )
   {
      return (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].avgPeriod) ;
   }
   public RetCode cdlDoji( int startIdx,
      int endIdx,
      double inOpen[],
      double inHigh[],
      double inLow[],
      double inClose[],
      MInteger outBegIdx,
      MInteger outNBElement,
      int outInteger[] )
   {
      double BodyDojiPeriodTotal;
      int i, outIdx, BodyDojiTrailingIdx, lookbackTotal;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      lookbackTotal = cdlDojiLookback ();
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      BodyDojiPeriodTotal = 0;
      BodyDojiTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].avgPeriod) ;
      i = BodyDojiTrailingIdx;
      while( i < startIdx ) {
         BodyDojiPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      outIdx = 0;
      do
      {
         if( ( Math.abs ( inClose[i] - inOpen[i] ) ) <= ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].avgPeriod) != 0.0? BodyDojiPeriodTotal / (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) )
            outInteger[outIdx++] = 100;
         else
            outInteger[outIdx++] = 0;
         BodyDojiPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) - ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[BodyDojiTrailingIdx] - inOpen[BodyDojiTrailingIdx] ) ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[BodyDojiTrailingIdx] - inLow[BodyDojiTrailingIdx] ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[BodyDojiTrailingIdx] - ( inClose[BodyDojiTrailingIdx] >= inOpen[BodyDojiTrailingIdx] ? inClose[BodyDojiTrailingIdx] : inOpen[BodyDojiTrailingIdx] ) ) + ( ( inClose[BodyDojiTrailingIdx] >= inOpen[BodyDojiTrailingIdx] ? inOpen[BodyDojiTrailingIdx] : inClose[BodyDojiTrailingIdx] ) - inLow[BodyDojiTrailingIdx] ) : 0 ) ) ) ;
         i++;
         BodyDojiTrailingIdx++;
      } while( i <= endIdx );
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   public int cdlDojiStateInit( struct TA_cdlDoji_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct cdlDoji ));
      _state.value .value .mem_index = 0;
      _state.value .value .mem_size = cdlDojiLookback ();
      if ( _state.value .value .mem_size > 0)
         _state.value .value .memory = TA_Calloc( _state.value .value .mem_size , sizeof(struct TA_CDLDOJI_Data));
      else
         _state.value .value .memory = NULL;
      return RetCode.Success ;
   }
   public int cdlDojiState( struct TA_cdlDoji_State* _state,
      double inOpen,
      double inHigh,
      double inLow,
      double inClose,
      int *outInteger )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      size_t _cur_idx = _state.value .mem_index++;
      if ( _state.value .mem_size > 0) _cur_idx %= _state.value .mem_size ;
      if ( _state.value .mem_size > _state.value .mem_index - 1 ) {
         ( _state.value .memory+_cur_idx).value .inOpen = inOpen ;
         ( _state.value .memory+_cur_idx).value .inHigh = inHigh ;
         ( _state.value .memory+_cur_idx).value .inLow = inLow ;
         ( _state.value .memory+_cur_idx).value .inClose = inClose ;
         return RetCode.NeedMoreData ; }
      return RetCode.Success ;
   }
   public int cdlDojiStateFree( struct TA_cdlDoji_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if ( _state.value != NULL) {
         if ( _state.value .value .memory != NULL) TA_Free( _state.value .value .memory );
         TA_Free( _state.value ); _state.value = NULL;}
      return RetCode.Success ;
   }
   public RetCode cdlDoji( int startIdx,
      int endIdx,
      float inOpen[],
      float inHigh[],
      float inLow[],
      float inClose[],
      MInteger outBegIdx,
      MInteger outNBElement,
      int outInteger[] )
   {
      double BodyDojiPeriodTotal;
      int i, outIdx, BodyDojiTrailingIdx, lookbackTotal;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      lookbackTotal = cdlDojiLookback ();
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      BodyDojiPeriodTotal = 0;
      BodyDojiTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].avgPeriod) ;
      i = BodyDojiTrailingIdx;
      while( i < startIdx ) {
         BodyDojiPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      outIdx = 0;
      do
      {
         if( ( Math.abs ( inClose[i] - inOpen[i] ) ) <= ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].avgPeriod) != 0.0? BodyDojiPeriodTotal / (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) )
            outInteger[outIdx++] = 100;
         else
            outInteger[outIdx++] = 0;
         BodyDojiPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) - ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[BodyDojiTrailingIdx] - inOpen[BodyDojiTrailingIdx] ) ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[BodyDojiTrailingIdx] - inLow[BodyDojiTrailingIdx] ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[BodyDojiTrailingIdx] - ( inClose[BodyDojiTrailingIdx] >= inOpen[BodyDojiTrailingIdx] ? inClose[BodyDojiTrailingIdx] : inOpen[BodyDojiTrailingIdx] ) ) + ( ( inClose[BodyDojiTrailingIdx] >= inOpen[BodyDojiTrailingIdx] ? inOpen[BodyDojiTrailingIdx] : inClose[BodyDojiTrailingIdx] ) - inLow[BodyDojiTrailingIdx] ) : 0 ) ) ) ;
         i++;
         BodyDojiTrailingIdx++;
      } while( i <= endIdx );
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   /* Generated */
   public int cdlDojiStarLookback( )
   {
      return ((( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].avgPeriod) ) > ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) )) ? ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].avgPeriod) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) )) + 1;
   }
   public RetCode cdlDojiStar( int startIdx,
      int endIdx,
      double inOpen[],
      double inHigh[],
      double inLow[],
      double inClose[],
      MInteger outBegIdx,
      MInteger outNBElement,
      int outInteger[] )
   {
      double BodyDojiPeriodTotal, BodyLongPeriodTotal;
      int i, outIdx, BodyDojiTrailingIdx, BodyLongTrailingIdx, lookbackTotal;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      lookbackTotal = cdlDojiStarLookback ();
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      BodyLongPeriodTotal = 0;
      BodyDojiPeriodTotal = 0;
      BodyLongTrailingIdx = startIdx -1 - (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) ;
      BodyDojiTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].avgPeriod) ;
      i = BodyLongTrailingIdx;
      while( i < startIdx-1 ) {
         BodyLongPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      i = BodyDojiTrailingIdx;
      while( i < startIdx ) {
         BodyDojiPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      outIdx = 0;
      do
      {
         if( ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) > ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) != 0.0? BodyLongPeriodTotal / (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( Math.abs ( inClose[i] - inOpen[i] ) ) <= ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].avgPeriod) != 0.0? BodyDojiPeriodTotal / (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( ( ( inClose[i-1] >= inOpen[i-1] ? 1 : -1 ) == 1 && ( (((inOpen[i]) < (inClose[i])) ? (inOpen[i]) : (inClose[i])) > (((inOpen[i-1]) > (inClose[i-1])) ? (inOpen[i-1]) : (inClose[i-1])) ) )
            ||
            ( ( inClose[i-1] >= inOpen[i-1] ? 1 : -1 ) == -1 && ( (((inOpen[i]) > (inClose[i])) ? (inOpen[i]) : (inClose[i])) < (((inOpen[i-1]) < (inClose[i-1])) ? (inOpen[i-1]) : (inClose[i-1])) ) )
            ) )
            outInteger[outIdx++] = - ( inClose[i-1] >= inOpen[i-1] ? 1 : -1 ) * 100;
         else
            outInteger[outIdx++] = 0;
         BodyLongPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) - ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[BodyLongTrailingIdx] - inOpen[BodyLongTrailingIdx] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[BodyLongTrailingIdx] - inLow[BodyLongTrailingIdx] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[BodyLongTrailingIdx] - ( inClose[BodyLongTrailingIdx] >= inOpen[BodyLongTrailingIdx] ? inClose[BodyLongTrailingIdx] : inOpen[BodyLongTrailingIdx] ) ) + ( ( inClose[BodyLongTrailingIdx] >= inOpen[BodyLongTrailingIdx] ? inOpen[BodyLongTrailingIdx] : inClose[BodyLongTrailingIdx] ) - inLow[BodyLongTrailingIdx] ) : 0 ) ) ) ;
         BodyDojiPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) - ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[BodyDojiTrailingIdx] - inOpen[BodyDojiTrailingIdx] ) ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[BodyDojiTrailingIdx] - inLow[BodyDojiTrailingIdx] ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[BodyDojiTrailingIdx] - ( inClose[BodyDojiTrailingIdx] >= inOpen[BodyDojiTrailingIdx] ? inClose[BodyDojiTrailingIdx] : inOpen[BodyDojiTrailingIdx] ) ) + ( ( inClose[BodyDojiTrailingIdx] >= inOpen[BodyDojiTrailingIdx] ? inOpen[BodyDojiTrailingIdx] : inClose[BodyDojiTrailingIdx] ) - inLow[BodyDojiTrailingIdx] ) : 0 ) ) ) ;
         i++;
         BodyLongTrailingIdx++;
         BodyDojiTrailingIdx++;
      } while( i <= endIdx );
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   public int cdlDojiStarStateInit( struct TA_cdlDojiStar_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct cdlDojiStar ));
      _state.value .value .mem_index = 0;
      _state.value .value .mem_size = cdlDojiStarLookback ();
      if ( _state.value .value .mem_size > 0)
         _state.value .value .memory = TA_Calloc( _state.value .value .mem_size , sizeof(struct TA_CDLDOJISTAR_Data));
      else
         _state.value .value .memory = NULL;
      return RetCode.Success ;
   }
   public int cdlDojiStarState( struct TA_cdlDojiStar_State* _state,
      double inOpen,
      double inHigh,
      double inLow,
      double inClose,
      int *outInteger )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      size_t _cur_idx = _state.value .mem_index++;
      if ( _state.value .mem_size > 0) _cur_idx %= _state.value .mem_size ;
      if ( _state.value .mem_size > _state.value .mem_index - 1 ) {
         ( _state.value .memory+_cur_idx).value .inOpen = inOpen ;
         ( _state.value .memory+_cur_idx).value .inHigh = inHigh ;
         ( _state.value .memory+_cur_idx).value .inLow = inLow ;
         ( _state.value .memory+_cur_idx).value .inClose = inClose ;
         return RetCode.NeedMoreData ; }
      return RetCode.Success ;
   }
   public int cdlDojiStarStateFree( struct TA_cdlDojiStar_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if ( _state.value != NULL) {
         if ( _state.value .value .memory != NULL) TA_Free( _state.value .value .memory );
         TA_Free( _state.value ); _state.value = NULL;}
      return RetCode.Success ;
   }
   public RetCode cdlDojiStar( int startIdx,
      int endIdx,
      float inOpen[],
      float inHigh[],
      float inLow[],
      float inClose[],
      MInteger outBegIdx,
      MInteger outNBElement,
      int outInteger[] )
   {
      double BodyDojiPeriodTotal, BodyLongPeriodTotal;
      int i, outIdx, BodyDojiTrailingIdx, BodyLongTrailingIdx, lookbackTotal;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      lookbackTotal = cdlDojiStarLookback ();
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      BodyLongPeriodTotal = 0;
      BodyDojiPeriodTotal = 0;
      BodyLongTrailingIdx = startIdx -1 - (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) ;
      BodyDojiTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].avgPeriod) ;
      i = BodyLongTrailingIdx;
      while( i < startIdx-1 ) {
         BodyLongPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      i = BodyDojiTrailingIdx;
      while( i < startIdx ) {
         BodyDojiPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      outIdx = 0;
      do
      {
         if( ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) > ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) != 0.0? BodyLongPeriodTotal / (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( Math.abs ( inClose[i] - inOpen[i] ) ) <= ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].avgPeriod) != 0.0? BodyDojiPeriodTotal / (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( ( ( inClose[i-1] >= inOpen[i-1] ? 1 : -1 ) == 1 && ( (((inOpen[i]) < (inClose[i])) ? (inOpen[i]) : (inClose[i])) > (((inOpen[i-1]) > (inClose[i-1])) ? (inOpen[i-1]) : (inClose[i-1])) ) )
            ||
            ( ( inClose[i-1] >= inOpen[i-1] ? 1 : -1 ) == -1 && ( (((inOpen[i]) > (inClose[i])) ? (inOpen[i]) : (inClose[i])) < (((inOpen[i-1]) < (inClose[i-1])) ? (inOpen[i-1]) : (inClose[i-1])) ) )
            ) )
            outInteger[outIdx++] = - ( inClose[i-1] >= inOpen[i-1] ? 1 : -1 ) * 100;
         else
            outInteger[outIdx++] = 0;
         BodyLongPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) - ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[BodyLongTrailingIdx] - inOpen[BodyLongTrailingIdx] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[BodyLongTrailingIdx] - inLow[BodyLongTrailingIdx] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[BodyLongTrailingIdx] - ( inClose[BodyLongTrailingIdx] >= inOpen[BodyLongTrailingIdx] ? inClose[BodyLongTrailingIdx] : inOpen[BodyLongTrailingIdx] ) ) + ( ( inClose[BodyLongTrailingIdx] >= inOpen[BodyLongTrailingIdx] ? inOpen[BodyLongTrailingIdx] : inClose[BodyLongTrailingIdx] ) - inLow[BodyLongTrailingIdx] ) : 0 ) ) ) ;
         BodyDojiPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) - ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[BodyDojiTrailingIdx] - inOpen[BodyDojiTrailingIdx] ) ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[BodyDojiTrailingIdx] - inLow[BodyDojiTrailingIdx] ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[BodyDojiTrailingIdx] - ( inClose[BodyDojiTrailingIdx] >= inOpen[BodyDojiTrailingIdx] ? inClose[BodyDojiTrailingIdx] : inOpen[BodyDojiTrailingIdx] ) ) + ( ( inClose[BodyDojiTrailingIdx] >= inOpen[BodyDojiTrailingIdx] ? inOpen[BodyDojiTrailingIdx] : inClose[BodyDojiTrailingIdx] ) - inLow[BodyDojiTrailingIdx] ) : 0 ) ) ) ;
         i++;
         BodyLongTrailingIdx++;
         BodyDojiTrailingIdx++;
      } while( i <= endIdx );
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   /* Generated */
   public int cdlDragonflyDojiLookback( )
   {
      return ((( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].avgPeriod) ) > ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) )) ? ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].avgPeriod) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) )) ;
   }
   public RetCode cdlDragonflyDoji( int startIdx,
      int endIdx,
      double inOpen[],
      double inHigh[],
      double inLow[],
      double inClose[],
      MInteger outBegIdx,
      MInteger outNBElement,
      int outInteger[] )
   {
      double BodyDojiPeriodTotal, ShadowVeryShortPeriodTotal;
      int i, outIdx, BodyDojiTrailingIdx, ShadowVeryShortTrailingIdx, lookbackTotal;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      lookbackTotal = cdlDragonflyDojiLookback ();
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      BodyDojiPeriodTotal = 0;
      BodyDojiTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].avgPeriod) ;
      ShadowVeryShortPeriodTotal = 0;
      ShadowVeryShortTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) ;
      i = BodyDojiTrailingIdx;
      while( i < startIdx ) {
         BodyDojiPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      i = ShadowVeryShortTrailingIdx;
      while( i < startIdx ) {
         ShadowVeryShortPeriodTotal += ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      outIdx = 0;
      do
      {
         if( ( Math.abs ( inClose[i] - inOpen[i] ) ) <= ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].avgPeriod) != 0.0? BodyDojiPeriodTotal / (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) < ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) != 0.0? ShadowVeryShortPeriodTotal / (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) > ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) != 0.0? ShadowVeryShortPeriodTotal / (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) )
            )
            outInteger[outIdx++] = 100;
         else
            outInteger[outIdx++] = 0;
         BodyDojiPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) - ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[BodyDojiTrailingIdx] - inOpen[BodyDojiTrailingIdx] ) ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[BodyDojiTrailingIdx] - inLow[BodyDojiTrailingIdx] ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[BodyDojiTrailingIdx] - ( inClose[BodyDojiTrailingIdx] >= inOpen[BodyDojiTrailingIdx] ? inClose[BodyDojiTrailingIdx] : inOpen[BodyDojiTrailingIdx] ) ) + ( ( inClose[BodyDojiTrailingIdx] >= inOpen[BodyDojiTrailingIdx] ? inOpen[BodyDojiTrailingIdx] : inClose[BodyDojiTrailingIdx] ) - inLow[BodyDojiTrailingIdx] ) : 0 ) ) ) ;
         ShadowVeryShortPeriodTotal += ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) )
            - ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[ShadowVeryShortTrailingIdx] - inOpen[ShadowVeryShortTrailingIdx] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[ShadowVeryShortTrailingIdx] - inLow[ShadowVeryShortTrailingIdx] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[ShadowVeryShortTrailingIdx] - ( inClose[ShadowVeryShortTrailingIdx] >= inOpen[ShadowVeryShortTrailingIdx] ? inClose[ShadowVeryShortTrailingIdx] : inOpen[ShadowVeryShortTrailingIdx] ) ) + ( ( inClose[ShadowVeryShortTrailingIdx] >= inOpen[ShadowVeryShortTrailingIdx] ? inOpen[ShadowVeryShortTrailingIdx] : inClose[ShadowVeryShortTrailingIdx] ) - inLow[ShadowVeryShortTrailingIdx] ) : 0 ) ) ) ;
         i++;
         BodyDojiTrailingIdx++;
         ShadowVeryShortTrailingIdx++;
      } while( i <= endIdx );
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   public int cdlDragonflyDojiStateInit( struct TA_cdlDragonflyDoji_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct cdlDragonflyDoji ));
      _state.value .value .mem_index = 0;
      _state.value .value .mem_size = cdlDragonflyDojiLookback ();
      if ( _state.value .value .mem_size > 0)
         _state.value .value .memory = TA_Calloc( _state.value .value .mem_size , sizeof(struct TA_CDLDRAGONFLYDOJI_Data));
      else
         _state.value .value .memory = NULL;
      return RetCode.Success ;
   }
   public int cdlDragonflyDojiState( struct TA_cdlDragonflyDoji_State* _state,
      double inOpen,
      double inHigh,
      double inLow,
      double inClose,
      int *outInteger )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      size_t _cur_idx = _state.value .mem_index++;
      if ( _state.value .mem_size > 0) _cur_idx %= _state.value .mem_size ;
      if ( _state.value .mem_size > _state.value .mem_index - 1 ) {
         ( _state.value .memory+_cur_idx).value .inOpen = inOpen ;
         ( _state.value .memory+_cur_idx).value .inHigh = inHigh ;
         ( _state.value .memory+_cur_idx).value .inLow = inLow ;
         ( _state.value .memory+_cur_idx).value .inClose = inClose ;
         return RetCode.NeedMoreData ; }
      return RetCode.Success ;
   }
   public int cdlDragonflyDojiStateFree( struct TA_cdlDragonflyDoji_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if ( _state.value != NULL) {
         if ( _state.value .value .memory != NULL) TA_Free( _state.value .value .memory );
         TA_Free( _state.value ); _state.value = NULL;}
      return RetCode.Success ;
   }
   public RetCode cdlDragonflyDoji( int startIdx,
      int endIdx,
      float inOpen[],
      float inHigh[],
      float inLow[],
      float inClose[],
      MInteger outBegIdx,
      MInteger outNBElement,
      int outInteger[] )
   {
      double BodyDojiPeriodTotal, ShadowVeryShortPeriodTotal;
      int i, outIdx, BodyDojiTrailingIdx, ShadowVeryShortTrailingIdx, lookbackTotal;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      lookbackTotal = cdlDragonflyDojiLookback ();
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      BodyDojiPeriodTotal = 0;
      BodyDojiTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].avgPeriod) ;
      ShadowVeryShortPeriodTotal = 0;
      ShadowVeryShortTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) ;
      i = BodyDojiTrailingIdx;
      while( i < startIdx ) {
         BodyDojiPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      i = ShadowVeryShortTrailingIdx;
      while( i < startIdx ) {
         ShadowVeryShortPeriodTotal += ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      outIdx = 0;
      do
      {
         if( ( Math.abs ( inClose[i] - inOpen[i] ) ) <= ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].avgPeriod) != 0.0? BodyDojiPeriodTotal / (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) < ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) != 0.0? ShadowVeryShortPeriodTotal / (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) > ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) != 0.0? ShadowVeryShortPeriodTotal / (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) )
            )
            outInteger[outIdx++] = 100;
         else
            outInteger[outIdx++] = 0;
         BodyDojiPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) - ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[BodyDojiTrailingIdx] - inOpen[BodyDojiTrailingIdx] ) ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[BodyDojiTrailingIdx] - inLow[BodyDojiTrailingIdx] ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[BodyDojiTrailingIdx] - ( inClose[BodyDojiTrailingIdx] >= inOpen[BodyDojiTrailingIdx] ? inClose[BodyDojiTrailingIdx] : inOpen[BodyDojiTrailingIdx] ) ) + ( ( inClose[BodyDojiTrailingIdx] >= inOpen[BodyDojiTrailingIdx] ? inOpen[BodyDojiTrailingIdx] : inClose[BodyDojiTrailingIdx] ) - inLow[BodyDojiTrailingIdx] ) : 0 ) ) ) ;
         ShadowVeryShortPeriodTotal += ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) )
            - ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[ShadowVeryShortTrailingIdx] - inOpen[ShadowVeryShortTrailingIdx] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[ShadowVeryShortTrailingIdx] - inLow[ShadowVeryShortTrailingIdx] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[ShadowVeryShortTrailingIdx] - ( inClose[ShadowVeryShortTrailingIdx] >= inOpen[ShadowVeryShortTrailingIdx] ? inClose[ShadowVeryShortTrailingIdx] : inOpen[ShadowVeryShortTrailingIdx] ) ) + ( ( inClose[ShadowVeryShortTrailingIdx] >= inOpen[ShadowVeryShortTrailingIdx] ? inOpen[ShadowVeryShortTrailingIdx] : inClose[ShadowVeryShortTrailingIdx] ) - inLow[ShadowVeryShortTrailingIdx] ) : 0 ) ) ) ;
         i++;
         BodyDojiTrailingIdx++;
         ShadowVeryShortTrailingIdx++;
      } while( i <= endIdx );
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   /* Generated */
   public int cdlEngulfingLookback( )
   {
      return 2;
   }
   public RetCode cdlEngulfing( int startIdx,
      int endIdx,
      double inOpen[],
      double inHigh[],
      double inLow[],
      double inClose[],
      MInteger outBegIdx,
      MInteger outNBElement,
      int outInteger[] )
   {
      int i, outIdx, lookbackTotal;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      lookbackTotal = cdlEngulfingLookback ();
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      i = startIdx;
      outIdx = 0;
      do
      {
         if( ( ( inClose[i] >= inOpen[i] ? 1 : -1 ) == 1 && ( inClose[i-1] >= inOpen[i-1] ? 1 : -1 ) == -1 &&
            ( ( inClose[i] >= inOpen[i-1] && inOpen[i] < inClose[i-1] ) ||
            ( inClose[i] > inOpen[i-1] && inOpen[i] <= inClose[i-1] )
            )
            )
            ||
            ( ( inClose[i] >= inOpen[i] ? 1 : -1 ) == -1 && ( inClose[i-1] >= inOpen[i-1] ? 1 : -1 ) == 1 &&
            ( ( inOpen[i] >= inClose[i-1] && inClose[i] < inOpen[i-1] ) ||
            ( inOpen[i] > inClose[i-1] && inClose[i] <= inOpen[i-1] )
            )
            )
            )
            if( inOpen[i] != inClose[i-1] && inClose[i] != inOpen[i-1] )
            outInteger[outIdx++] = ( inClose[i] >= inOpen[i] ? 1 : -1 ) * 100;
         else
            outInteger[outIdx++] = ( inClose[i] >= inOpen[i] ? 1 : -1 ) * 80;
         else
            outInteger[outIdx++] = 0;
         i++;
      } while( i <= endIdx );
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   public int cdlEngulfingStateInit( struct TA_cdlEngulfing_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct cdlEngulfing ));
      _state.value .value .mem_index = 0;
      _state.value .value .mem_size = cdlEngulfingLookback ();
      if ( _state.value .value .mem_size > 0)
         _state.value .value .memory = TA_Calloc( _state.value .value .mem_size , sizeof(struct TA_CDLENGULFING_Data));
      else
         _state.value .value .memory = NULL;
      return RetCode.Success ;
   }
   public int cdlEngulfingState( struct TA_cdlEngulfing_State* _state,
      double inOpen,
      double inHigh,
      double inLow,
      double inClose,
      int *outInteger )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      size_t _cur_idx = _state.value .mem_index++;
      if ( _state.value .mem_size > 0) _cur_idx %= _state.value .mem_size ;
      if ( _state.value .mem_size > _state.value .mem_index - 1 ) {
         ( _state.value .memory+_cur_idx).value .inOpen = inOpen ;
         ( _state.value .memory+_cur_idx).value .inHigh = inHigh ;
         ( _state.value .memory+_cur_idx).value .inLow = inLow ;
         ( _state.value .memory+_cur_idx).value .inClose = inClose ;
         return RetCode.NeedMoreData ; }
      return RetCode.Success ;
   }
   public int cdlEngulfingStateFree( struct TA_cdlEngulfing_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if ( _state.value != NULL) {
         if ( _state.value .value .memory != NULL) TA_Free( _state.value .value .memory );
         TA_Free( _state.value ); _state.value = NULL;}
      return RetCode.Success ;
   }
   public RetCode cdlEngulfing( int startIdx,
      int endIdx,
      float inOpen[],
      float inHigh[],
      float inLow[],
      float inClose[],
      MInteger outBegIdx,
      MInteger outNBElement,
      int outInteger[] )
   {
      int i, outIdx, lookbackTotal;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      lookbackTotal = cdlEngulfingLookback ();
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      i = startIdx;
      outIdx = 0;
      do
      {
         if( ( ( inClose[i] >= inOpen[i] ? 1 : -1 ) == 1 && ( inClose[i-1] >= inOpen[i-1] ? 1 : -1 ) == -1 &&
            ( ( inClose[i] >= inOpen[i-1] && inOpen[i] < inClose[i-1] ) ||
            ( inClose[i] > inOpen[i-1] && inOpen[i] <= inClose[i-1] )
            )
            )
            ||
            ( ( inClose[i] >= inOpen[i] ? 1 : -1 ) == -1 && ( inClose[i-1] >= inOpen[i-1] ? 1 : -1 ) == 1 &&
            ( ( inOpen[i] >= inClose[i-1] && inClose[i] < inOpen[i-1] ) ||
            ( inOpen[i] > inClose[i-1] && inClose[i] <= inOpen[i-1] )
            )
            )
            )
            if( inOpen[i] != inClose[i-1] && inClose[i] != inOpen[i-1] )
            outInteger[outIdx++] = ( inClose[i] >= inOpen[i] ? 1 : -1 ) * 100;
         else
            outInteger[outIdx++] = ( inClose[i] >= inOpen[i] ? 1 : -1 ) * 80;
         else
            outInteger[outIdx++] = 0;
         i++;
      } while( i <= endIdx );
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   /* Generated */
   public int cdlEveningDojiStarLookback( double optInPenetration )
   {
      if( optInPenetration == (-4e+37) )
         optInPenetration = 3.000000e-1;
      else if( (optInPenetration < 0.000000e+0) || (optInPenetration > 3.000000e+37) )
         return -1;
      return ((( ((( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].avgPeriod) ) > ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) )) ? ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].avgPeriod) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) )) ) > ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) )) ? ( ((( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].avgPeriod) ) > ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) )) ? ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].avgPeriod) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) )) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) )) +
         2;
   }
   public RetCode cdlEveningDojiStar( int startIdx,
      int endIdx,
      double inOpen[],
      double inHigh[],
      double inLow[],
      double inClose[],
      double optInPenetration,
      MInteger outBegIdx,
      MInteger outNBElement,
      int outInteger[] )
   {
      double BodyDojiPeriodTotal, BodyLongPeriodTotal, BodyShortPeriodTotal;
      int i, outIdx, BodyDojiTrailingIdx, BodyLongTrailingIdx, BodyShortTrailingIdx, lookbackTotal;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      if( optInPenetration == (-4e+37) )
         optInPenetration = 3.000000e-1;
      else if( (optInPenetration < 0.000000e+0) || (optInPenetration > 3.000000e+37) )
         return RetCode.BadParam ;
      lookbackTotal = cdlEveningDojiStarLookback (optInPenetration);
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      BodyLongPeriodTotal = 0;
      BodyDojiPeriodTotal = 0;
      BodyShortPeriodTotal = 0;
      BodyLongTrailingIdx = startIdx -2 - (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) ;
      BodyDojiTrailingIdx = startIdx -1 - (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].avgPeriod) ;
      BodyShortTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) ;
      i = BodyLongTrailingIdx;
      while( i < startIdx-2 ) {
         BodyLongPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      i = BodyDojiTrailingIdx;
      while( i < startIdx-1 ) {
         BodyDojiPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      i = BodyShortTrailingIdx;
      while( i < startIdx ) {
         BodyShortPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      i = startIdx;
      outIdx = 0;
      do
      {
         if( ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) > ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) != 0.0? BodyLongPeriodTotal / (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-2] - inLow[i-2] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-2] - ( inClose[i-2] >= inOpen[i-2] ? inClose[i-2] : inOpen[i-2] ) ) + ( ( inClose[i-2] >= inOpen[i-2] ? inOpen[i-2] : inClose[i-2] ) - inLow[i-2] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( inClose[i-2] >= inOpen[i-2] ? 1 : -1 ) == 1 &&
            ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) <= ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].avgPeriod) != 0.0? BodyDojiPeriodTotal / (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( (((inOpen[i-1]) < (inClose[i-1])) ? (inOpen[i-1]) : (inClose[i-1])) > (((inOpen[i-2]) > (inClose[i-2])) ? (inOpen[i-2]) : (inClose[i-2])) ) &&
            ( Math.abs ( inClose[i] - inOpen[i] ) ) > ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) != 0.0? BodyShortPeriodTotal / (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( inClose[i] >= inOpen[i] ? 1 : -1 ) == -1 &&
            inClose[i] < inClose[i-2] - ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) * optInPenetration
            )
            outInteger[outIdx++] = -100;
         else
            outInteger[outIdx++] = 0;
         BodyLongPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-2] - inLow[i-2] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-2] - ( inClose[i-2] >= inOpen[i-2] ? inClose[i-2] : inOpen[i-2] ) ) + ( ( inClose[i-2] >= inOpen[i-2] ? inOpen[i-2] : inClose[i-2] ) - inLow[i-2] ) : 0 ) ) ) - ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[BodyLongTrailingIdx] - inOpen[BodyLongTrailingIdx] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[BodyLongTrailingIdx] - inLow[BodyLongTrailingIdx] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[BodyLongTrailingIdx] - ( inClose[BodyLongTrailingIdx] >= inOpen[BodyLongTrailingIdx] ? inClose[BodyLongTrailingIdx] : inOpen[BodyLongTrailingIdx] ) ) + ( ( inClose[BodyLongTrailingIdx] >= inOpen[BodyLongTrailingIdx] ? inOpen[BodyLongTrailingIdx] : inClose[BodyLongTrailingIdx] ) - inLow[BodyLongTrailingIdx] ) : 0 ) ) ) ;
         BodyDojiPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) - ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[BodyDojiTrailingIdx] - inOpen[BodyDojiTrailingIdx] ) ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[BodyDojiTrailingIdx] - inLow[BodyDojiTrailingIdx] ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[BodyDojiTrailingIdx] - ( inClose[BodyDojiTrailingIdx] >= inOpen[BodyDojiTrailingIdx] ? inClose[BodyDojiTrailingIdx] : inOpen[BodyDojiTrailingIdx] ) ) + ( ( inClose[BodyDojiTrailingIdx] >= inOpen[BodyDojiTrailingIdx] ? inOpen[BodyDojiTrailingIdx] : inClose[BodyDojiTrailingIdx] ) - inLow[BodyDojiTrailingIdx] ) : 0 ) ) ) ;
         BodyShortPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) - ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[BodyShortTrailingIdx] - inOpen[BodyShortTrailingIdx] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[BodyShortTrailingIdx] - inLow[BodyShortTrailingIdx] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[BodyShortTrailingIdx] - ( inClose[BodyShortTrailingIdx] >= inOpen[BodyShortTrailingIdx] ? inClose[BodyShortTrailingIdx] : inOpen[BodyShortTrailingIdx] ) ) + ( ( inClose[BodyShortTrailingIdx] >= inOpen[BodyShortTrailingIdx] ? inOpen[BodyShortTrailingIdx] : inClose[BodyShortTrailingIdx] ) - inLow[BodyShortTrailingIdx] ) : 0 ) ) ) ;
         i++;
         BodyLongTrailingIdx++;
         BodyDojiTrailingIdx++;
         BodyShortTrailingIdx++;
      } while( i <= endIdx );
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   public int cdlEveningDojiStarStateInit( struct TA_cdlEveningDojiStar_State** _state,
      double optInPenetration )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if( optInPenetration == (-4e+37) )
         optInPenetration = 3.000000e-1;
      else if( (optInPenetration < 0.000000e+0) || (optInPenetration > 3.000000e+37) )
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct cdlEveningDojiStar ));
      _state.value .value .mem_index = 0;
      _state.value .value .optInPenetration = optInPenetration;
      _state.value .value .mem_size = cdlEveningDojiStarLookback (optInPenetration );
      if ( _state.value .value .mem_size > 0)
         _state.value .value .memory = TA_Calloc( _state.value .value .mem_size , sizeof(struct TA_CDLEVENINGDOJISTAR_Data));
      else
         _state.value .value .memory = NULL;
      return RetCode.Success ;
   }
   public int cdlEveningDojiStarState( struct TA_cdlEveningDojiStar_State* _state,
      double inOpen,
      double inHigh,
      double inLow,
      double inClose,
      int *outInteger )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      size_t _cur_idx = _state.value .mem_index++;
      if ( _state.value .mem_size > 0) _cur_idx %= _state.value .mem_size ;
      if ( _state.value .mem_size > _state.value .mem_index - 1 ) {
         ( _state.value .memory+_cur_idx).value .inOpen = inOpen ;
         ( _state.value .memory+_cur_idx).value .inHigh = inHigh ;
         ( _state.value .memory+_cur_idx).value .inLow = inLow ;
         ( _state.value .memory+_cur_idx).value .inClose = inClose ;
         return RetCode.NeedMoreData ; }
      return RetCode.Success ;
   }
   public int cdlEveningDojiStarStateFree( struct TA_cdlEveningDojiStar_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if ( _state.value != NULL) {
         if ( _state.value .value .memory != NULL) TA_Free( _state.value .value .memory );
         TA_Free( _state.value ); _state.value = NULL;}
      return RetCode.Success ;
   }
   public RetCode cdlEveningDojiStar( int startIdx,
      int endIdx,
      float inOpen[],
      float inHigh[],
      float inLow[],
      float inClose[],
      double optInPenetration,
      MInteger outBegIdx,
      MInteger outNBElement,
      int outInteger[] )
   {
      double BodyDojiPeriodTotal, BodyLongPeriodTotal, BodyShortPeriodTotal;
      int i, outIdx, BodyDojiTrailingIdx, BodyLongTrailingIdx, BodyShortTrailingIdx, lookbackTotal;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      if( optInPenetration == (-4e+37) )
         optInPenetration = 3.000000e-1;
      else if( (optInPenetration < 0.000000e+0) || (optInPenetration > 3.000000e+37) )
         return RetCode.BadParam ;
      lookbackTotal = cdlEveningDojiStarLookback (optInPenetration);
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      BodyLongPeriodTotal = 0;
      BodyDojiPeriodTotal = 0;
      BodyShortPeriodTotal = 0;
      BodyLongTrailingIdx = startIdx -2 - (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) ;
      BodyDojiTrailingIdx = startIdx -1 - (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].avgPeriod) ;
      BodyShortTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) ;
      i = BodyLongTrailingIdx;
      while( i < startIdx-2 ) {
         BodyLongPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      i = BodyDojiTrailingIdx;
      while( i < startIdx-1 ) {
         BodyDojiPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      i = BodyShortTrailingIdx;
      while( i < startIdx ) {
         BodyShortPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      i = startIdx;
      outIdx = 0;
      do
      {
         if( ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) > ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) != 0.0? BodyLongPeriodTotal / (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-2] - inLow[i-2] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-2] - ( inClose[i-2] >= inOpen[i-2] ? inClose[i-2] : inOpen[i-2] ) ) + ( ( inClose[i-2] >= inOpen[i-2] ? inOpen[i-2] : inClose[i-2] ) - inLow[i-2] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( inClose[i-2] >= inOpen[i-2] ? 1 : -1 ) == 1 &&
            ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) <= ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].avgPeriod) != 0.0? BodyDojiPeriodTotal / (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( (((inOpen[i-1]) < (inClose[i-1])) ? (inOpen[i-1]) : (inClose[i-1])) > (((inOpen[i-2]) > (inClose[i-2])) ? (inOpen[i-2]) : (inClose[i-2])) ) &&
            ( Math.abs ( inClose[i] - inOpen[i] ) ) > ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) != 0.0? BodyShortPeriodTotal / (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( inClose[i] >= inOpen[i] ? 1 : -1 ) == -1 &&
            inClose[i] < inClose[i-2] - ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) * optInPenetration
            )
            outInteger[outIdx++] = -100;
         else
            outInteger[outIdx++] = 0;
         BodyLongPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-2] - inLow[i-2] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-2] - ( inClose[i-2] >= inOpen[i-2] ? inClose[i-2] : inOpen[i-2] ) ) + ( ( inClose[i-2] >= inOpen[i-2] ? inOpen[i-2] : inClose[i-2] ) - inLow[i-2] ) : 0 ) ) ) - ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[BodyLongTrailingIdx] - inOpen[BodyLongTrailingIdx] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[BodyLongTrailingIdx] - inLow[BodyLongTrailingIdx] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[BodyLongTrailingIdx] - ( inClose[BodyLongTrailingIdx] >= inOpen[BodyLongTrailingIdx] ? inClose[BodyLongTrailingIdx] : inOpen[BodyLongTrailingIdx] ) ) + ( ( inClose[BodyLongTrailingIdx] >= inOpen[BodyLongTrailingIdx] ? inOpen[BodyLongTrailingIdx] : inClose[BodyLongTrailingIdx] ) - inLow[BodyLongTrailingIdx] ) : 0 ) ) ) ;
         BodyDojiPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) - ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[BodyDojiTrailingIdx] - inOpen[BodyDojiTrailingIdx] ) ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[BodyDojiTrailingIdx] - inLow[BodyDojiTrailingIdx] ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[BodyDojiTrailingIdx] - ( inClose[BodyDojiTrailingIdx] >= inOpen[BodyDojiTrailingIdx] ? inClose[BodyDojiTrailingIdx] : inOpen[BodyDojiTrailingIdx] ) ) + ( ( inClose[BodyDojiTrailingIdx] >= inOpen[BodyDojiTrailingIdx] ? inOpen[BodyDojiTrailingIdx] : inClose[BodyDojiTrailingIdx] ) - inLow[BodyDojiTrailingIdx] ) : 0 ) ) ) ;
         BodyShortPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) - ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[BodyShortTrailingIdx] - inOpen[BodyShortTrailingIdx] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[BodyShortTrailingIdx] - inLow[BodyShortTrailingIdx] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[BodyShortTrailingIdx] - ( inClose[BodyShortTrailingIdx] >= inOpen[BodyShortTrailingIdx] ? inClose[BodyShortTrailingIdx] : inOpen[BodyShortTrailingIdx] ) ) + ( ( inClose[BodyShortTrailingIdx] >= inOpen[BodyShortTrailingIdx] ? inOpen[BodyShortTrailingIdx] : inClose[BodyShortTrailingIdx] ) - inLow[BodyShortTrailingIdx] ) : 0 ) ) ) ;
         i++;
         BodyLongTrailingIdx++;
         BodyDojiTrailingIdx++;
         BodyShortTrailingIdx++;
      } while( i <= endIdx );
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   /* Generated */
   public int cdlEveningStarLookback( double optInPenetration )
   {
      if( optInPenetration == (-4e+37) )
         optInPenetration = 3.000000e-1;
      else if( (optInPenetration < 0.000000e+0) || (optInPenetration > 3.000000e+37) )
         return -1;
      return ((( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) ) > ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) )) ? ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) )) + 2;
   }
   public RetCode cdlEveningStar( int startIdx,
      int endIdx,
      double inOpen[],
      double inHigh[],
      double inLow[],
      double inClose[],
      double optInPenetration,
      MInteger outBegIdx,
      MInteger outNBElement,
      int outInteger[] )
   {
      double BodyShortPeriodTotal, BodyLongPeriodTotal, BodyShortPeriodTotal2;
      int i, outIdx, BodyShortTrailingIdx, BodyLongTrailingIdx, lookbackTotal;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      if( optInPenetration == (-4e+37) )
         optInPenetration = 3.000000e-1;
      else if( (optInPenetration < 0.000000e+0) || (optInPenetration > 3.000000e+37) )
         return RetCode.BadParam ;
      lookbackTotal = cdlEveningStarLookback (optInPenetration);
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      BodyLongPeriodTotal = 0;
      BodyShortPeriodTotal = 0;
      BodyShortPeriodTotal2 = 0;
      BodyLongTrailingIdx = startIdx -2 - (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) ;
      BodyShortTrailingIdx = startIdx -1 - (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) ;
      i = BodyLongTrailingIdx;
      while( i < startIdx-2 ) {
         BodyLongPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      i = BodyShortTrailingIdx;
      while( i < startIdx-1 ) {
         BodyShortPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         BodyShortPeriodTotal2 += ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i+1] - inOpen[i+1] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i+1] - inLow[i+1] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i+1] - ( inClose[i+1] >= inOpen[i+1] ? inClose[i+1] : inOpen[i+1] ) ) + ( ( inClose[i+1] >= inOpen[i+1] ? inOpen[i+1] : inClose[i+1] ) - inLow[i+1] ) : 0 ) ) ) ;
         i++;
      }
      i = startIdx;
      outIdx = 0;
      do
      {
         if( ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) > ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) != 0.0? BodyLongPeriodTotal / (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-2] - inLow[i-2] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-2] - ( inClose[i-2] >= inOpen[i-2] ? inClose[i-2] : inOpen[i-2] ) ) + ( ( inClose[i-2] >= inOpen[i-2] ? inOpen[i-2] : inClose[i-2] ) - inLow[i-2] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( inClose[i-2] >= inOpen[i-2] ? 1 : -1 ) == 1 &&
            ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) <= ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) != 0.0? BodyShortPeriodTotal / (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( (((inOpen[i-1]) < (inClose[i-1])) ? (inOpen[i-1]) : (inClose[i-1])) > (((inOpen[i-2]) > (inClose[i-2])) ? (inOpen[i-2]) : (inClose[i-2])) ) &&
            ( Math.abs ( inClose[i] - inOpen[i] ) ) > ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) != 0.0? BodyShortPeriodTotal2 / (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( inClose[i] >= inOpen[i] ? 1 : -1 ) == -1 &&
            inClose[i] < inClose[i-2] - ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) * optInPenetration
            )
            outInteger[outIdx++] = -100;
         else
            outInteger[outIdx++] = 0;
         BodyLongPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-2] - inLow[i-2] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-2] - ( inClose[i-2] >= inOpen[i-2] ? inClose[i-2] : inOpen[i-2] ) ) + ( ( inClose[i-2] >= inOpen[i-2] ? inOpen[i-2] : inClose[i-2] ) - inLow[i-2] ) : 0 ) ) ) - ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[BodyLongTrailingIdx] - inOpen[BodyLongTrailingIdx] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[BodyLongTrailingIdx] - inLow[BodyLongTrailingIdx] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[BodyLongTrailingIdx] - ( inClose[BodyLongTrailingIdx] >= inOpen[BodyLongTrailingIdx] ? inClose[BodyLongTrailingIdx] : inOpen[BodyLongTrailingIdx] ) ) + ( ( inClose[BodyLongTrailingIdx] >= inOpen[BodyLongTrailingIdx] ? inOpen[BodyLongTrailingIdx] : inClose[BodyLongTrailingIdx] ) - inLow[BodyLongTrailingIdx] ) : 0 ) ) ) ;
         BodyShortPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) - ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[BodyShortTrailingIdx] - inOpen[BodyShortTrailingIdx] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[BodyShortTrailingIdx] - inLow[BodyShortTrailingIdx] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[BodyShortTrailingIdx] - ( inClose[BodyShortTrailingIdx] >= inOpen[BodyShortTrailingIdx] ? inClose[BodyShortTrailingIdx] : inOpen[BodyShortTrailingIdx] ) ) + ( ( inClose[BodyShortTrailingIdx] >= inOpen[BodyShortTrailingIdx] ? inOpen[BodyShortTrailingIdx] : inClose[BodyShortTrailingIdx] ) - inLow[BodyShortTrailingIdx] ) : 0 ) ) ) ;
         BodyShortPeriodTotal2 += ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) - ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[BodyShortTrailingIdx+1] - inOpen[BodyShortTrailingIdx+1] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[BodyShortTrailingIdx+1] - inLow[BodyShortTrailingIdx+1] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[BodyShortTrailingIdx+1] - ( inClose[BodyShortTrailingIdx+1] >= inOpen[BodyShortTrailingIdx+1] ? inClose[BodyShortTrailingIdx+1] : inOpen[BodyShortTrailingIdx+1] ) ) + ( ( inClose[BodyShortTrailingIdx+1] >= inOpen[BodyShortTrailingIdx+1] ? inOpen[BodyShortTrailingIdx+1] : inClose[BodyShortTrailingIdx+1] ) - inLow[BodyShortTrailingIdx+1] ) : 0 ) ) ) ;
         i++;
         BodyLongTrailingIdx++;
         BodyShortTrailingIdx++;
      } while( i <= endIdx );
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   public int cdlEveningStarStateInit( struct TA_cdlEveningStar_State** _state,
      double optInPenetration )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if( optInPenetration == (-4e+37) )
         optInPenetration = 3.000000e-1;
      else if( (optInPenetration < 0.000000e+0) || (optInPenetration > 3.000000e+37) )
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct cdlEveningStar ));
      _state.value .value .mem_index = 0;
      _state.value .value .optInPenetration = optInPenetration;
      _state.value .value .mem_size = cdlEveningStarLookback (optInPenetration );
      if ( _state.value .value .mem_size > 0)
         _state.value .value .memory = TA_Calloc( _state.value .value .mem_size , sizeof(struct TA_CDLEVENINGSTAR_Data));
      else
         _state.value .value .memory = NULL;
      return RetCode.Success ;
   }
   public int cdlEveningStarState( struct TA_cdlEveningStar_State* _state,
      double inOpen,
      double inHigh,
      double inLow,
      double inClose,
      int *outInteger )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      size_t _cur_idx = _state.value .mem_index++;
      if ( _state.value .mem_size > 0) _cur_idx %= _state.value .mem_size ;
      if ( _state.value .mem_size > _state.value .mem_index - 1 ) {
         ( _state.value .memory+_cur_idx).value .inOpen = inOpen ;
         ( _state.value .memory+_cur_idx).value .inHigh = inHigh ;
         ( _state.value .memory+_cur_idx).value .inLow = inLow ;
         ( _state.value .memory+_cur_idx).value .inClose = inClose ;
         return RetCode.NeedMoreData ; }
      return RetCode.Success ;
   }
   public int cdlEveningStarStateFree( struct TA_cdlEveningStar_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if ( _state.value != NULL) {
         if ( _state.value .value .memory != NULL) TA_Free( _state.value .value .memory );
         TA_Free( _state.value ); _state.value = NULL;}
      return RetCode.Success ;
   }
   public RetCode cdlEveningStar( int startIdx,
      int endIdx,
      float inOpen[],
      float inHigh[],
      float inLow[],
      float inClose[],
      double optInPenetration,
      MInteger outBegIdx,
      MInteger outNBElement,
      int outInteger[] )
   {
      double BodyShortPeriodTotal, BodyLongPeriodTotal, BodyShortPeriodTotal2;
      int i, outIdx, BodyShortTrailingIdx, BodyLongTrailingIdx, lookbackTotal;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      if( optInPenetration == (-4e+37) )
         optInPenetration = 3.000000e-1;
      else if( (optInPenetration < 0.000000e+0) || (optInPenetration > 3.000000e+37) )
         return RetCode.BadParam ;
      lookbackTotal = cdlEveningStarLookback (optInPenetration);
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      BodyLongPeriodTotal = 0;
      BodyShortPeriodTotal = 0;
      BodyShortPeriodTotal2 = 0;
      BodyLongTrailingIdx = startIdx -2 - (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) ;
      BodyShortTrailingIdx = startIdx -1 - (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) ;
      i = BodyLongTrailingIdx;
      while( i < startIdx-2 ) {
         BodyLongPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      i = BodyShortTrailingIdx;
      while( i < startIdx-1 ) {
         BodyShortPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         BodyShortPeriodTotal2 += ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i+1] - inOpen[i+1] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i+1] - inLow[i+1] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i+1] - ( inClose[i+1] >= inOpen[i+1] ? inClose[i+1] : inOpen[i+1] ) ) + ( ( inClose[i+1] >= inOpen[i+1] ? inOpen[i+1] : inClose[i+1] ) - inLow[i+1] ) : 0 ) ) ) ;
         i++;
      }
      i = startIdx;
      outIdx = 0;
      do
      {
         if( ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) > ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) != 0.0? BodyLongPeriodTotal / (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-2] - inLow[i-2] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-2] - ( inClose[i-2] >= inOpen[i-2] ? inClose[i-2] : inOpen[i-2] ) ) + ( ( inClose[i-2] >= inOpen[i-2] ? inOpen[i-2] : inClose[i-2] ) - inLow[i-2] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( inClose[i-2] >= inOpen[i-2] ? 1 : -1 ) == 1 &&
            ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) <= ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) != 0.0? BodyShortPeriodTotal / (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( (((inOpen[i-1]) < (inClose[i-1])) ? (inOpen[i-1]) : (inClose[i-1])) > (((inOpen[i-2]) > (inClose[i-2])) ? (inOpen[i-2]) : (inClose[i-2])) ) &&
            ( Math.abs ( inClose[i] - inOpen[i] ) ) > ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) != 0.0? BodyShortPeriodTotal2 / (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( inClose[i] >= inOpen[i] ? 1 : -1 ) == -1 &&
            inClose[i] < inClose[i-2] - ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) * optInPenetration
            )
            outInteger[outIdx++] = -100;
         else
            outInteger[outIdx++] = 0;
         BodyLongPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-2] - inLow[i-2] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-2] - ( inClose[i-2] >= inOpen[i-2] ? inClose[i-2] : inOpen[i-2] ) ) + ( ( inClose[i-2] >= inOpen[i-2] ? inOpen[i-2] : inClose[i-2] ) - inLow[i-2] ) : 0 ) ) ) - ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[BodyLongTrailingIdx] - inOpen[BodyLongTrailingIdx] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[BodyLongTrailingIdx] - inLow[BodyLongTrailingIdx] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[BodyLongTrailingIdx] - ( inClose[BodyLongTrailingIdx] >= inOpen[BodyLongTrailingIdx] ? inClose[BodyLongTrailingIdx] : inOpen[BodyLongTrailingIdx] ) ) + ( ( inClose[BodyLongTrailingIdx] >= inOpen[BodyLongTrailingIdx] ? inOpen[BodyLongTrailingIdx] : inClose[BodyLongTrailingIdx] ) - inLow[BodyLongTrailingIdx] ) : 0 ) ) ) ;
         BodyShortPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) - ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[BodyShortTrailingIdx] - inOpen[BodyShortTrailingIdx] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[BodyShortTrailingIdx] - inLow[BodyShortTrailingIdx] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[BodyShortTrailingIdx] - ( inClose[BodyShortTrailingIdx] >= inOpen[BodyShortTrailingIdx] ? inClose[BodyShortTrailingIdx] : inOpen[BodyShortTrailingIdx] ) ) + ( ( inClose[BodyShortTrailingIdx] >= inOpen[BodyShortTrailingIdx] ? inOpen[BodyShortTrailingIdx] : inClose[BodyShortTrailingIdx] ) - inLow[BodyShortTrailingIdx] ) : 0 ) ) ) ;
         BodyShortPeriodTotal2 += ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) - ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[BodyShortTrailingIdx+1] - inOpen[BodyShortTrailingIdx+1] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[BodyShortTrailingIdx+1] - inLow[BodyShortTrailingIdx+1] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[BodyShortTrailingIdx+1] - ( inClose[BodyShortTrailingIdx+1] >= inOpen[BodyShortTrailingIdx+1] ? inClose[BodyShortTrailingIdx+1] : inOpen[BodyShortTrailingIdx+1] ) ) + ( ( inClose[BodyShortTrailingIdx+1] >= inOpen[BodyShortTrailingIdx+1] ? inOpen[BodyShortTrailingIdx+1] : inClose[BodyShortTrailingIdx+1] ) - inLow[BodyShortTrailingIdx+1] ) : 0 ) ) ) ;
         i++;
         BodyLongTrailingIdx++;
         BodyShortTrailingIdx++;
      } while( i <= endIdx );
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   /* Generated */
   public int cdlGapSideSideWhiteLookback( )
   {
      return ((( (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) ) > ( (this.candleSettings[CandleSettingType.Equal.ordinal()].avgPeriod) )) ? ( (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].avgPeriod) )) + 2;
   }
   public RetCode cdlGapSideSideWhite( int startIdx,
      int endIdx,
      double inOpen[],
      double inHigh[],
      double inLow[],
      double inClose[],
      MInteger outBegIdx,
      MInteger outNBElement,
      int outInteger[] )
   {
      double NearPeriodTotal, EqualPeriodTotal;
      int i, outIdx, NearTrailingIdx, EqualTrailingIdx, lookbackTotal;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      lookbackTotal = cdlGapSideSideWhiteLookback ();
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      NearPeriodTotal = 0;
      EqualPeriodTotal = 0;
      NearTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) ;
      EqualTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.Equal.ordinal()].avgPeriod) ;
      i = NearTrailingIdx;
      while( i < startIdx ) {
         NearPeriodTotal += ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ;
         i++;
      }
      i = EqualTrailingIdx;
      while( i < startIdx ) {
         EqualPeriodTotal += ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ;
         i++;
      }
      i = startIdx;
      outIdx = 0;
      do
      {
         if(
            (
            ( ( (((inOpen[i-1]) < (inClose[i-1])) ? (inOpen[i-1]) : (inClose[i-1])) > (((inOpen[i-2]) > (inClose[i-2])) ? (inOpen[i-2]) : (inClose[i-2])) ) && ( (((inOpen[i]) < (inClose[i])) ? (inOpen[i]) : (inClose[i])) > (((inOpen[i-2]) > (inClose[i-2])) ? (inOpen[i-2]) : (inClose[i-2])) ) )
            ||
            ( ( (((inOpen[i-1]) > (inClose[i-1])) ? (inOpen[i-1]) : (inClose[i-1])) < (((inOpen[i-2]) < (inClose[i-2])) ? (inOpen[i-2]) : (inClose[i-2])) ) && ( (((inOpen[i]) > (inClose[i])) ? (inOpen[i]) : (inClose[i])) < (((inOpen[i-2]) < (inClose[i-2])) ? (inOpen[i-2]) : (inClose[i-2])) ) )
            ) &&
            ( inClose[i-1] >= inOpen[i-1] ? 1 : -1 ) == 1 &&
            ( inClose[i] >= inOpen[i] ? 1 : -1 ) == 1 &&
            ( Math.abs ( inClose[i] - inOpen[i] ) ) >= ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) - ( (this.candleSettings[CandleSettingType.Near.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) != 0.0? NearPeriodTotal / (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( Math.abs ( inClose[i] - inOpen[i] ) ) <= ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) + ( (this.candleSettings[CandleSettingType.Near.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) != 0.0? NearPeriodTotal / (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            inOpen[i] >= inOpen[i-1] - ( (this.candleSettings[CandleSettingType.Equal.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.Equal.ordinal()].avgPeriod) != 0.0? EqualPeriodTotal / (this.candleSettings[CandleSettingType.Equal.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            inOpen[i] <= inOpen[i-1] + ( (this.candleSettings[CandleSettingType.Equal.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.Equal.ordinal()].avgPeriod) != 0.0? EqualPeriodTotal / (this.candleSettings[CandleSettingType.Equal.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) )
            )
            outInteger[outIdx++] = ( ( (((inOpen[i-1]) < (inClose[i-1])) ? (inOpen[i-1]) : (inClose[i-1])) > (((inOpen[i-2]) > (inClose[i-2])) ? (inOpen[i-2]) : (inClose[i-2])) ) ? 100 : -100 );
         else
            outInteger[outIdx++] = 0;
         NearPeriodTotal += ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) - ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[NearTrailingIdx-1] - inOpen[NearTrailingIdx-1] ) ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[NearTrailingIdx-1] - inLow[NearTrailingIdx-1] ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[NearTrailingIdx-1] - ( inClose[NearTrailingIdx-1] >= inOpen[NearTrailingIdx-1] ? inClose[NearTrailingIdx-1] : inOpen[NearTrailingIdx-1] ) ) + ( ( inClose[NearTrailingIdx-1] >= inOpen[NearTrailingIdx-1] ? inOpen[NearTrailingIdx-1] : inClose[NearTrailingIdx-1] ) - inLow[NearTrailingIdx-1] ) : 0 ) ) ) ;
         EqualPeriodTotal += ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) - ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[EqualTrailingIdx-1] - inOpen[EqualTrailingIdx-1] ) ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[EqualTrailingIdx-1] - inLow[EqualTrailingIdx-1] ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[EqualTrailingIdx-1] - ( inClose[EqualTrailingIdx-1] >= inOpen[EqualTrailingIdx-1] ? inClose[EqualTrailingIdx-1] : inOpen[EqualTrailingIdx-1] ) ) + ( ( inClose[EqualTrailingIdx-1] >= inOpen[EqualTrailingIdx-1] ? inOpen[EqualTrailingIdx-1] : inClose[EqualTrailingIdx-1] ) - inLow[EqualTrailingIdx-1] ) : 0 ) ) ) ;
         i++;
         NearTrailingIdx++;
         EqualTrailingIdx++;
      } while( i <= endIdx );
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   public int cdlGapSideSideWhiteStateInit( struct TA_cdlGapSideSideWhite_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct cdlGapSideSideWhite ));
      _state.value .value .mem_index = 0;
      _state.value .value .mem_size = cdlGapSideSideWhiteLookback ();
      if ( _state.value .value .mem_size > 0)
         _state.value .value .memory = TA_Calloc( _state.value .value .mem_size , sizeof(struct TA_CDLGAPSIDESIDEWHITE_Data));
      else
         _state.value .value .memory = NULL;
      return RetCode.Success ;
   }
   public int cdlGapSideSideWhiteState( struct TA_cdlGapSideSideWhite_State* _state,
      double inOpen,
      double inHigh,
      double inLow,
      double inClose,
      int *outInteger )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      size_t _cur_idx = _state.value .mem_index++;
      if ( _state.value .mem_size > 0) _cur_idx %= _state.value .mem_size ;
      if ( _state.value .mem_size > _state.value .mem_index - 1 ) {
         ( _state.value .memory+_cur_idx).value .inOpen = inOpen ;
         ( _state.value .memory+_cur_idx).value .inHigh = inHigh ;
         ( _state.value .memory+_cur_idx).value .inLow = inLow ;
         ( _state.value .memory+_cur_idx).value .inClose = inClose ;
         return RetCode.NeedMoreData ; }
      return RetCode.Success ;
   }
   public int cdlGapSideSideWhiteStateFree( struct TA_cdlGapSideSideWhite_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if ( _state.value != NULL) {
         if ( _state.value .value .memory != NULL) TA_Free( _state.value .value .memory );
         TA_Free( _state.value ); _state.value = NULL;}
      return RetCode.Success ;
   }
   public RetCode cdlGapSideSideWhite( int startIdx,
      int endIdx,
      float inOpen[],
      float inHigh[],
      float inLow[],
      float inClose[],
      MInteger outBegIdx,
      MInteger outNBElement,
      int outInteger[] )
   {
      double NearPeriodTotal, EqualPeriodTotal;
      int i, outIdx, NearTrailingIdx, EqualTrailingIdx, lookbackTotal;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      lookbackTotal = cdlGapSideSideWhiteLookback ();
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      NearPeriodTotal = 0;
      EqualPeriodTotal = 0;
      NearTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) ;
      EqualTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.Equal.ordinal()].avgPeriod) ;
      i = NearTrailingIdx;
      while( i < startIdx ) {
         NearPeriodTotal += ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ;
         i++;
      }
      i = EqualTrailingIdx;
      while( i < startIdx ) {
         EqualPeriodTotal += ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ;
         i++;
      }
      i = startIdx;
      outIdx = 0;
      do
      {
         if(
            (
            ( ( (((inOpen[i-1]) < (inClose[i-1])) ? (inOpen[i-1]) : (inClose[i-1])) > (((inOpen[i-2]) > (inClose[i-2])) ? (inOpen[i-2]) : (inClose[i-2])) ) && ( (((inOpen[i]) < (inClose[i])) ? (inOpen[i]) : (inClose[i])) > (((inOpen[i-2]) > (inClose[i-2])) ? (inOpen[i-2]) : (inClose[i-2])) ) )
            ||
            ( ( (((inOpen[i-1]) > (inClose[i-1])) ? (inOpen[i-1]) : (inClose[i-1])) < (((inOpen[i-2]) < (inClose[i-2])) ? (inOpen[i-2]) : (inClose[i-2])) ) && ( (((inOpen[i]) > (inClose[i])) ? (inOpen[i]) : (inClose[i])) < (((inOpen[i-2]) < (inClose[i-2])) ? (inOpen[i-2]) : (inClose[i-2])) ) )
            ) &&
            ( inClose[i-1] >= inOpen[i-1] ? 1 : -1 ) == 1 &&
            ( inClose[i] >= inOpen[i] ? 1 : -1 ) == 1 &&
            ( Math.abs ( inClose[i] - inOpen[i] ) ) >= ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) - ( (this.candleSettings[CandleSettingType.Near.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) != 0.0? NearPeriodTotal / (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( Math.abs ( inClose[i] - inOpen[i] ) ) <= ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) + ( (this.candleSettings[CandleSettingType.Near.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) != 0.0? NearPeriodTotal / (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            inOpen[i] >= inOpen[i-1] - ( (this.candleSettings[CandleSettingType.Equal.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.Equal.ordinal()].avgPeriod) != 0.0? EqualPeriodTotal / (this.candleSettings[CandleSettingType.Equal.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            inOpen[i] <= inOpen[i-1] + ( (this.candleSettings[CandleSettingType.Equal.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.Equal.ordinal()].avgPeriod) != 0.0? EqualPeriodTotal / (this.candleSettings[CandleSettingType.Equal.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) )
            )
            outInteger[outIdx++] = ( ( (((inOpen[i-1]) < (inClose[i-1])) ? (inOpen[i-1]) : (inClose[i-1])) > (((inOpen[i-2]) > (inClose[i-2])) ? (inOpen[i-2]) : (inClose[i-2])) ) ? 100 : -100 );
         else
            outInteger[outIdx++] = 0;
         NearPeriodTotal += ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) - ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[NearTrailingIdx-1] - inOpen[NearTrailingIdx-1] ) ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[NearTrailingIdx-1] - inLow[NearTrailingIdx-1] ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[NearTrailingIdx-1] - ( inClose[NearTrailingIdx-1] >= inOpen[NearTrailingIdx-1] ? inClose[NearTrailingIdx-1] : inOpen[NearTrailingIdx-1] ) ) + ( ( inClose[NearTrailingIdx-1] >= inOpen[NearTrailingIdx-1] ? inOpen[NearTrailingIdx-1] : inClose[NearTrailingIdx-1] ) - inLow[NearTrailingIdx-1] ) : 0 ) ) ) ;
         EqualPeriodTotal += ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) - ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[EqualTrailingIdx-1] - inOpen[EqualTrailingIdx-1] ) ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[EqualTrailingIdx-1] - inLow[EqualTrailingIdx-1] ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[EqualTrailingIdx-1] - ( inClose[EqualTrailingIdx-1] >= inOpen[EqualTrailingIdx-1] ? inClose[EqualTrailingIdx-1] : inOpen[EqualTrailingIdx-1] ) ) + ( ( inClose[EqualTrailingIdx-1] >= inOpen[EqualTrailingIdx-1] ? inOpen[EqualTrailingIdx-1] : inClose[EqualTrailingIdx-1] ) - inLow[EqualTrailingIdx-1] ) : 0 ) ) ) ;
         i++;
         NearTrailingIdx++;
         EqualTrailingIdx++;
      } while( i <= endIdx );
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   /* Generated */
   public int cdlGravestoneDojiLookback( )
   {
      return ((( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].avgPeriod) ) > ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) )) ? ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].avgPeriod) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) )) ;
   }
   public RetCode cdlGravestoneDoji( int startIdx,
      int endIdx,
      double inOpen[],
      double inHigh[],
      double inLow[],
      double inClose[],
      MInteger outBegIdx,
      MInteger outNBElement,
      int outInteger[] )
   {
      double BodyDojiPeriodTotal, ShadowVeryShortPeriodTotal;
      int i, outIdx, BodyDojiTrailingIdx, ShadowVeryShortTrailingIdx, lookbackTotal;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      lookbackTotal = cdlGravestoneDojiLookback ();
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      BodyDojiPeriodTotal = 0;
      BodyDojiTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].avgPeriod) ;
      ShadowVeryShortPeriodTotal = 0;
      ShadowVeryShortTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) ;
      i = BodyDojiTrailingIdx;
      while( i < startIdx ) {
         BodyDojiPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      i = ShadowVeryShortTrailingIdx;
      while( i < startIdx ) {
         ShadowVeryShortPeriodTotal += ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      outIdx = 0;
      do
      {
         if( ( Math.abs ( inClose[i] - inOpen[i] ) ) <= ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].avgPeriod) != 0.0? BodyDojiPeriodTotal / (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) < ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) != 0.0? ShadowVeryShortPeriodTotal / (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) > ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) != 0.0? ShadowVeryShortPeriodTotal / (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) )
            )
            outInteger[outIdx++] = 100;
         else
            outInteger[outIdx++] = 0;
         BodyDojiPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) - ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[BodyDojiTrailingIdx] - inOpen[BodyDojiTrailingIdx] ) ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[BodyDojiTrailingIdx] - inLow[BodyDojiTrailingIdx] ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[BodyDojiTrailingIdx] - ( inClose[BodyDojiTrailingIdx] >= inOpen[BodyDojiTrailingIdx] ? inClose[BodyDojiTrailingIdx] : inOpen[BodyDojiTrailingIdx] ) ) + ( ( inClose[BodyDojiTrailingIdx] >= inOpen[BodyDojiTrailingIdx] ? inOpen[BodyDojiTrailingIdx] : inClose[BodyDojiTrailingIdx] ) - inLow[BodyDojiTrailingIdx] ) : 0 ) ) ) ;
         ShadowVeryShortPeriodTotal += ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) )
            - ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[ShadowVeryShortTrailingIdx] - inOpen[ShadowVeryShortTrailingIdx] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[ShadowVeryShortTrailingIdx] - inLow[ShadowVeryShortTrailingIdx] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[ShadowVeryShortTrailingIdx] - ( inClose[ShadowVeryShortTrailingIdx] >= inOpen[ShadowVeryShortTrailingIdx] ? inClose[ShadowVeryShortTrailingIdx] : inOpen[ShadowVeryShortTrailingIdx] ) ) + ( ( inClose[ShadowVeryShortTrailingIdx] >= inOpen[ShadowVeryShortTrailingIdx] ? inOpen[ShadowVeryShortTrailingIdx] : inClose[ShadowVeryShortTrailingIdx] ) - inLow[ShadowVeryShortTrailingIdx] ) : 0 ) ) ) ;
         i++;
         BodyDojiTrailingIdx++;
         ShadowVeryShortTrailingIdx++;
      } while( i <= endIdx );
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   public int cdlGravestoneDojiStateInit( struct TA_cdlGravestoneDoji_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct cdlGravestoneDoji ));
      _state.value .value .mem_index = 0;
      _state.value .value .mem_size = cdlGravestoneDojiLookback ();
      if ( _state.value .value .mem_size > 0)
         _state.value .value .memory = TA_Calloc( _state.value .value .mem_size , sizeof(struct TA_CDLGRAVESTONEDOJI_Data));
      else
         _state.value .value .memory = NULL;
      return RetCode.Success ;
   }
   public int cdlGravestoneDojiState( struct TA_cdlGravestoneDoji_State* _state,
      double inOpen,
      double inHigh,
      double inLow,
      double inClose,
      int *outInteger )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      size_t _cur_idx = _state.value .mem_index++;
      if ( _state.value .mem_size > 0) _cur_idx %= _state.value .mem_size ;
      if ( _state.value .mem_size > _state.value .mem_index - 1 ) {
         ( _state.value .memory+_cur_idx).value .inOpen = inOpen ;
         ( _state.value .memory+_cur_idx).value .inHigh = inHigh ;
         ( _state.value .memory+_cur_idx).value .inLow = inLow ;
         ( _state.value .memory+_cur_idx).value .inClose = inClose ;
         return RetCode.NeedMoreData ; }
      return RetCode.Success ;
   }
   public int cdlGravestoneDojiStateFree( struct TA_cdlGravestoneDoji_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if ( _state.value != NULL) {
         if ( _state.value .value .memory != NULL) TA_Free( _state.value .value .memory );
         TA_Free( _state.value ); _state.value = NULL;}
      return RetCode.Success ;
   }
   public RetCode cdlGravestoneDoji( int startIdx,
      int endIdx,
      float inOpen[],
      float inHigh[],
      float inLow[],
      float inClose[],
      MInteger outBegIdx,
      MInteger outNBElement,
      int outInteger[] )
   {
      double BodyDojiPeriodTotal, ShadowVeryShortPeriodTotal;
      int i, outIdx, BodyDojiTrailingIdx, ShadowVeryShortTrailingIdx, lookbackTotal;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      lookbackTotal = cdlGravestoneDojiLookback ();
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      BodyDojiPeriodTotal = 0;
      BodyDojiTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].avgPeriod) ;
      ShadowVeryShortPeriodTotal = 0;
      ShadowVeryShortTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) ;
      i = BodyDojiTrailingIdx;
      while( i < startIdx ) {
         BodyDojiPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      i = ShadowVeryShortTrailingIdx;
      while( i < startIdx ) {
         ShadowVeryShortPeriodTotal += ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      outIdx = 0;
      do
      {
         if( ( Math.abs ( inClose[i] - inOpen[i] ) ) <= ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].avgPeriod) != 0.0? BodyDojiPeriodTotal / (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) < ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) != 0.0? ShadowVeryShortPeriodTotal / (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) > ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) != 0.0? ShadowVeryShortPeriodTotal / (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) )
            )
            outInteger[outIdx++] = 100;
         else
            outInteger[outIdx++] = 0;
         BodyDojiPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) - ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[BodyDojiTrailingIdx] - inOpen[BodyDojiTrailingIdx] ) ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[BodyDojiTrailingIdx] - inLow[BodyDojiTrailingIdx] ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[BodyDojiTrailingIdx] - ( inClose[BodyDojiTrailingIdx] >= inOpen[BodyDojiTrailingIdx] ? inClose[BodyDojiTrailingIdx] : inOpen[BodyDojiTrailingIdx] ) ) + ( ( inClose[BodyDojiTrailingIdx] >= inOpen[BodyDojiTrailingIdx] ? inOpen[BodyDojiTrailingIdx] : inClose[BodyDojiTrailingIdx] ) - inLow[BodyDojiTrailingIdx] ) : 0 ) ) ) ;
         ShadowVeryShortPeriodTotal += ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) )
            - ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[ShadowVeryShortTrailingIdx] - inOpen[ShadowVeryShortTrailingIdx] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[ShadowVeryShortTrailingIdx] - inLow[ShadowVeryShortTrailingIdx] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[ShadowVeryShortTrailingIdx] - ( inClose[ShadowVeryShortTrailingIdx] >= inOpen[ShadowVeryShortTrailingIdx] ? inClose[ShadowVeryShortTrailingIdx] : inOpen[ShadowVeryShortTrailingIdx] ) ) + ( ( inClose[ShadowVeryShortTrailingIdx] >= inOpen[ShadowVeryShortTrailingIdx] ? inOpen[ShadowVeryShortTrailingIdx] : inClose[ShadowVeryShortTrailingIdx] ) - inLow[ShadowVeryShortTrailingIdx] ) : 0 ) ) ) ;
         i++;
         BodyDojiTrailingIdx++;
         ShadowVeryShortTrailingIdx++;
      } while( i <= endIdx );
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   /* Generated */
   public int cdlHammerLookback( )
   {
      return ((( ((( ((( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) ) > ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].avgPeriod) )) ? ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].avgPeriod) )) ) > ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) )) ? ( ((( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) ) > ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].avgPeriod) )) ? ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].avgPeriod) )) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) )) ) > ( (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) )) ? ( ((( ((( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) ) > ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].avgPeriod) )) ? ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].avgPeriod) )) ) > ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) )) ? ( ((( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) ) > ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].avgPeriod) )) ? ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].avgPeriod) )) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) )) ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) )) +
         1;
   }
   public RetCode cdlHammer( int startIdx,
      int endIdx,
      double inOpen[],
      double inHigh[],
      double inLow[],
      double inClose[],
      MInteger outBegIdx,
      MInteger outNBElement,
      int outInteger[] )
   {
      double BodyPeriodTotal, ShadowLongPeriodTotal, ShadowVeryShortPeriodTotal, NearPeriodTotal;
      int i, outIdx, BodyTrailingIdx, ShadowLongTrailingIdx, ShadowVeryShortTrailingIdx, NearTrailingIdx, lookbackTotal;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      lookbackTotal = cdlHammerLookback ();
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      BodyPeriodTotal = 0;
      BodyTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) ;
      ShadowLongPeriodTotal = 0;
      ShadowLongTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].avgPeriod) ;
      ShadowVeryShortPeriodTotal = 0;
      ShadowVeryShortTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) ;
      NearPeriodTotal = 0;
      NearTrailingIdx = startIdx -1 - (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) ;
      i = BodyTrailingIdx;
      while( i < startIdx ) {
         BodyPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      i = ShadowLongTrailingIdx;
      while( i < startIdx ) {
         ShadowLongPeriodTotal += ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      i = ShadowVeryShortTrailingIdx;
      while( i < startIdx ) {
         ShadowVeryShortPeriodTotal += ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      i = NearTrailingIdx;
      while( i < startIdx-1 ) {
         NearPeriodTotal += ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      i = startIdx;
      outIdx = 0;
      do
      {
         if( ( Math.abs ( inClose[i] - inOpen[i] ) ) < ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) != 0.0? BodyPeriodTotal / (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) > ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].avgPeriod) != 0.0? ShadowLongPeriodTotal / (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) < ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) != 0.0? ShadowVeryShortPeriodTotal / (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            (((inClose[i]) < (inOpen[i])) ? (inClose[i]) : (inOpen[i])) <= inLow[i-1] + ( (this.candleSettings[CandleSettingType.Near.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) != 0.0? NearPeriodTotal / (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) )
            )
            outInteger[outIdx++] = 100;
         else
            outInteger[outIdx++] = 0;
         BodyPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) )
            - ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[BodyTrailingIdx] - inOpen[BodyTrailingIdx] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[BodyTrailingIdx] - inLow[BodyTrailingIdx] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[BodyTrailingIdx] - ( inClose[BodyTrailingIdx] >= inOpen[BodyTrailingIdx] ? inClose[BodyTrailingIdx] : inOpen[BodyTrailingIdx] ) ) + ( ( inClose[BodyTrailingIdx] >= inOpen[BodyTrailingIdx] ? inOpen[BodyTrailingIdx] : inClose[BodyTrailingIdx] ) - inLow[BodyTrailingIdx] ) : 0 ) ) ) ;
         ShadowLongPeriodTotal += ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) )
            - ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[ShadowLongTrailingIdx] - inOpen[ShadowLongTrailingIdx] ) ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[ShadowLongTrailingIdx] - inLow[ShadowLongTrailingIdx] ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[ShadowLongTrailingIdx] - ( inClose[ShadowLongTrailingIdx] >= inOpen[ShadowLongTrailingIdx] ? inClose[ShadowLongTrailingIdx] : inOpen[ShadowLongTrailingIdx] ) ) + ( ( inClose[ShadowLongTrailingIdx] >= inOpen[ShadowLongTrailingIdx] ? inOpen[ShadowLongTrailingIdx] : inClose[ShadowLongTrailingIdx] ) - inLow[ShadowLongTrailingIdx] ) : 0 ) ) ) ;
         ShadowVeryShortPeriodTotal += ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) )
            - ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[ShadowVeryShortTrailingIdx] - inOpen[ShadowVeryShortTrailingIdx] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[ShadowVeryShortTrailingIdx] - inLow[ShadowVeryShortTrailingIdx] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[ShadowVeryShortTrailingIdx] - ( inClose[ShadowVeryShortTrailingIdx] >= inOpen[ShadowVeryShortTrailingIdx] ? inClose[ShadowVeryShortTrailingIdx] : inOpen[ShadowVeryShortTrailingIdx] ) ) + ( ( inClose[ShadowVeryShortTrailingIdx] >= inOpen[ShadowVeryShortTrailingIdx] ? inOpen[ShadowVeryShortTrailingIdx] : inClose[ShadowVeryShortTrailingIdx] ) - inLow[ShadowVeryShortTrailingIdx] ) : 0 ) ) ) ;
         NearPeriodTotal += ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) )
            - ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[NearTrailingIdx] - inOpen[NearTrailingIdx] ) ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[NearTrailingIdx] - inLow[NearTrailingIdx] ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[NearTrailingIdx] - ( inClose[NearTrailingIdx] >= inOpen[NearTrailingIdx] ? inClose[NearTrailingIdx] : inOpen[NearTrailingIdx] ) ) + ( ( inClose[NearTrailingIdx] >= inOpen[NearTrailingIdx] ? inOpen[NearTrailingIdx] : inClose[NearTrailingIdx] ) - inLow[NearTrailingIdx] ) : 0 ) ) ) ;
         i++;
         BodyTrailingIdx++;
         ShadowLongTrailingIdx++;
         ShadowVeryShortTrailingIdx++;
         NearTrailingIdx++;
      } while( i <= endIdx );
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   public int cdlHammerStateInit( struct TA_cdlHammer_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct cdlHammer ));
      _state.value .value .mem_index = 0;
      _state.value .value .mem_size = cdlHammerLookback ();
      if ( _state.value .value .mem_size > 0)
         _state.value .value .memory = TA_Calloc( _state.value .value .mem_size , sizeof(struct TA_CDLHAMMER_Data));
      else
         _state.value .value .memory = NULL;
      return RetCode.Success ;
   }
   public int cdlHammerState( struct TA_cdlHammer_State* _state,
      double inOpen,
      double inHigh,
      double inLow,
      double inClose,
      int *outInteger )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      size_t _cur_idx = _state.value .mem_index++;
      if ( _state.value .mem_size > 0) _cur_idx %= _state.value .mem_size ;
      if ( _state.value .mem_size > _state.value .mem_index - 1 ) {
         ( _state.value .memory+_cur_idx).value .inOpen = inOpen ;
         ( _state.value .memory+_cur_idx).value .inHigh = inHigh ;
         ( _state.value .memory+_cur_idx).value .inLow = inLow ;
         ( _state.value .memory+_cur_idx).value .inClose = inClose ;
         return RetCode.NeedMoreData ; }
      return RetCode.Success ;
   }
   public int cdlHammerStateFree( struct TA_cdlHammer_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if ( _state.value != NULL) {
         if ( _state.value .value .memory != NULL) TA_Free( _state.value .value .memory );
         TA_Free( _state.value ); _state.value = NULL;}
      return RetCode.Success ;
   }
   public RetCode cdlHammer( int startIdx,
      int endIdx,
      float inOpen[],
      float inHigh[],
      float inLow[],
      float inClose[],
      MInteger outBegIdx,
      MInteger outNBElement,
      int outInteger[] )
   {
      double BodyPeriodTotal, ShadowLongPeriodTotal, ShadowVeryShortPeriodTotal, NearPeriodTotal;
      int i, outIdx, BodyTrailingIdx, ShadowLongTrailingIdx, ShadowVeryShortTrailingIdx, NearTrailingIdx, lookbackTotal;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      lookbackTotal = cdlHammerLookback ();
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      BodyPeriodTotal = 0;
      BodyTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) ;
      ShadowLongPeriodTotal = 0;
      ShadowLongTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].avgPeriod) ;
      ShadowVeryShortPeriodTotal = 0;
      ShadowVeryShortTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) ;
      NearPeriodTotal = 0;
      NearTrailingIdx = startIdx -1 - (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) ;
      i = BodyTrailingIdx;
      while( i < startIdx ) {
         BodyPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      i = ShadowLongTrailingIdx;
      while( i < startIdx ) {
         ShadowLongPeriodTotal += ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      i = ShadowVeryShortTrailingIdx;
      while( i < startIdx ) {
         ShadowVeryShortPeriodTotal += ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      i = NearTrailingIdx;
      while( i < startIdx-1 ) {
         NearPeriodTotal += ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      i = startIdx;
      outIdx = 0;
      do
      {
         if( ( Math.abs ( inClose[i] - inOpen[i] ) ) < ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) != 0.0? BodyPeriodTotal / (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) > ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].avgPeriod) != 0.0? ShadowLongPeriodTotal / (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) < ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) != 0.0? ShadowVeryShortPeriodTotal / (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            (((inClose[i]) < (inOpen[i])) ? (inClose[i]) : (inOpen[i])) <= inLow[i-1] + ( (this.candleSettings[CandleSettingType.Near.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) != 0.0? NearPeriodTotal / (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) )
            )
            outInteger[outIdx++] = 100;
         else
            outInteger[outIdx++] = 0;
         BodyPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) )
            - ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[BodyTrailingIdx] - inOpen[BodyTrailingIdx] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[BodyTrailingIdx] - inLow[BodyTrailingIdx] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[BodyTrailingIdx] - ( inClose[BodyTrailingIdx] >= inOpen[BodyTrailingIdx] ? inClose[BodyTrailingIdx] : inOpen[BodyTrailingIdx] ) ) + ( ( inClose[BodyTrailingIdx] >= inOpen[BodyTrailingIdx] ? inOpen[BodyTrailingIdx] : inClose[BodyTrailingIdx] ) - inLow[BodyTrailingIdx] ) : 0 ) ) ) ;
         ShadowLongPeriodTotal += ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) )
            - ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[ShadowLongTrailingIdx] - inOpen[ShadowLongTrailingIdx] ) ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[ShadowLongTrailingIdx] - inLow[ShadowLongTrailingIdx] ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[ShadowLongTrailingIdx] - ( inClose[ShadowLongTrailingIdx] >= inOpen[ShadowLongTrailingIdx] ? inClose[ShadowLongTrailingIdx] : inOpen[ShadowLongTrailingIdx] ) ) + ( ( inClose[ShadowLongTrailingIdx] >= inOpen[ShadowLongTrailingIdx] ? inOpen[ShadowLongTrailingIdx] : inClose[ShadowLongTrailingIdx] ) - inLow[ShadowLongTrailingIdx] ) : 0 ) ) ) ;
         ShadowVeryShortPeriodTotal += ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) )
            - ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[ShadowVeryShortTrailingIdx] - inOpen[ShadowVeryShortTrailingIdx] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[ShadowVeryShortTrailingIdx] - inLow[ShadowVeryShortTrailingIdx] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[ShadowVeryShortTrailingIdx] - ( inClose[ShadowVeryShortTrailingIdx] >= inOpen[ShadowVeryShortTrailingIdx] ? inClose[ShadowVeryShortTrailingIdx] : inOpen[ShadowVeryShortTrailingIdx] ) ) + ( ( inClose[ShadowVeryShortTrailingIdx] >= inOpen[ShadowVeryShortTrailingIdx] ? inOpen[ShadowVeryShortTrailingIdx] : inClose[ShadowVeryShortTrailingIdx] ) - inLow[ShadowVeryShortTrailingIdx] ) : 0 ) ) ) ;
         NearPeriodTotal += ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) )
            - ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[NearTrailingIdx] - inOpen[NearTrailingIdx] ) ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[NearTrailingIdx] - inLow[NearTrailingIdx] ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[NearTrailingIdx] - ( inClose[NearTrailingIdx] >= inOpen[NearTrailingIdx] ? inClose[NearTrailingIdx] : inOpen[NearTrailingIdx] ) ) + ( ( inClose[NearTrailingIdx] >= inOpen[NearTrailingIdx] ? inOpen[NearTrailingIdx] : inClose[NearTrailingIdx] ) - inLow[NearTrailingIdx] ) : 0 ) ) ) ;
         i++;
         BodyTrailingIdx++;
         ShadowLongTrailingIdx++;
         ShadowVeryShortTrailingIdx++;
         NearTrailingIdx++;
      } while( i <= endIdx );
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   /* Generated */
   public int cdlHangingManLookback( )
   {
      return ((( ((( ((( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) ) > ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].avgPeriod) )) ? ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].avgPeriod) )) ) > ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) )) ? ( ((( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) ) > ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].avgPeriod) )) ? ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].avgPeriod) )) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) )) ) > ( (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) )) ? ( ((( ((( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) ) > ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].avgPeriod) )) ? ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].avgPeriod) )) ) > ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) )) ? ( ((( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) ) > ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].avgPeriod) )) ? ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].avgPeriod) )) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) )) ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) )) +
         1;
   }
   public RetCode cdlHangingMan( int startIdx,
      int endIdx,
      double inOpen[],
      double inHigh[],
      double inLow[],
      double inClose[],
      MInteger outBegIdx,
      MInteger outNBElement,
      int outInteger[] )
   {
      double BodyPeriodTotal, ShadowLongPeriodTotal, ShadowVeryShortPeriodTotal, NearPeriodTotal;
      int i, outIdx, BodyTrailingIdx, ShadowLongTrailingIdx, ShadowVeryShortTrailingIdx, NearTrailingIdx, lookbackTotal;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      lookbackTotal = cdlHangingManLookback ();
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      BodyPeriodTotal = 0;
      BodyTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) ;
      ShadowLongPeriodTotal = 0;
      ShadowLongTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].avgPeriod) ;
      ShadowVeryShortPeriodTotal = 0;
      ShadowVeryShortTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) ;
      NearPeriodTotal = 0;
      NearTrailingIdx = startIdx -1 - (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) ;
      i = BodyTrailingIdx;
      while( i < startIdx ) {
         BodyPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      i = ShadowLongTrailingIdx;
      while( i < startIdx ) {
         ShadowLongPeriodTotal += ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      i = ShadowVeryShortTrailingIdx;
      while( i < startIdx ) {
         ShadowVeryShortPeriodTotal += ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      i = NearTrailingIdx;
      while( i < startIdx-1 ) {
         NearPeriodTotal += ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      i = startIdx;
      outIdx = 0;
      do
      {
         if( ( Math.abs ( inClose[i] - inOpen[i] ) ) < ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) != 0.0? BodyPeriodTotal / (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) > ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].avgPeriod) != 0.0? ShadowLongPeriodTotal / (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) < ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) != 0.0? ShadowVeryShortPeriodTotal / (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            (((inClose[i]) < (inOpen[i])) ? (inClose[i]) : (inOpen[i])) >= inHigh[i-1] - ( (this.candleSettings[CandleSettingType.Near.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) != 0.0? NearPeriodTotal / (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) )
            )
            outInteger[outIdx++] = -100;
         else
            outInteger[outIdx++] = 0;
         BodyPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) )
            - ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[BodyTrailingIdx] - inOpen[BodyTrailingIdx] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[BodyTrailingIdx] - inLow[BodyTrailingIdx] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[BodyTrailingIdx] - ( inClose[BodyTrailingIdx] >= inOpen[BodyTrailingIdx] ? inClose[BodyTrailingIdx] : inOpen[BodyTrailingIdx] ) ) + ( ( inClose[BodyTrailingIdx] >= inOpen[BodyTrailingIdx] ? inOpen[BodyTrailingIdx] : inClose[BodyTrailingIdx] ) - inLow[BodyTrailingIdx] ) : 0 ) ) ) ;
         ShadowLongPeriodTotal += ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) )
            - ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[ShadowLongTrailingIdx] - inOpen[ShadowLongTrailingIdx] ) ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[ShadowLongTrailingIdx] - inLow[ShadowLongTrailingIdx] ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[ShadowLongTrailingIdx] - ( inClose[ShadowLongTrailingIdx] >= inOpen[ShadowLongTrailingIdx] ? inClose[ShadowLongTrailingIdx] : inOpen[ShadowLongTrailingIdx] ) ) + ( ( inClose[ShadowLongTrailingIdx] >= inOpen[ShadowLongTrailingIdx] ? inOpen[ShadowLongTrailingIdx] : inClose[ShadowLongTrailingIdx] ) - inLow[ShadowLongTrailingIdx] ) : 0 ) ) ) ;
         ShadowVeryShortPeriodTotal += ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) )
            - ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[ShadowVeryShortTrailingIdx] - inOpen[ShadowVeryShortTrailingIdx] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[ShadowVeryShortTrailingIdx] - inLow[ShadowVeryShortTrailingIdx] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[ShadowVeryShortTrailingIdx] - ( inClose[ShadowVeryShortTrailingIdx] >= inOpen[ShadowVeryShortTrailingIdx] ? inClose[ShadowVeryShortTrailingIdx] : inOpen[ShadowVeryShortTrailingIdx] ) ) + ( ( inClose[ShadowVeryShortTrailingIdx] >= inOpen[ShadowVeryShortTrailingIdx] ? inOpen[ShadowVeryShortTrailingIdx] : inClose[ShadowVeryShortTrailingIdx] ) - inLow[ShadowVeryShortTrailingIdx] ) : 0 ) ) ) ;
         NearPeriodTotal += ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) )
            - ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[NearTrailingIdx] - inOpen[NearTrailingIdx] ) ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[NearTrailingIdx] - inLow[NearTrailingIdx] ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[NearTrailingIdx] - ( inClose[NearTrailingIdx] >= inOpen[NearTrailingIdx] ? inClose[NearTrailingIdx] : inOpen[NearTrailingIdx] ) ) + ( ( inClose[NearTrailingIdx] >= inOpen[NearTrailingIdx] ? inOpen[NearTrailingIdx] : inClose[NearTrailingIdx] ) - inLow[NearTrailingIdx] ) : 0 ) ) ) ;
         i++;
         BodyTrailingIdx++;
         ShadowLongTrailingIdx++;
         ShadowVeryShortTrailingIdx++;
         NearTrailingIdx++;
      } while( i <= endIdx );
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   public int cdlHangingManStateInit( struct TA_cdlHangingMan_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct cdlHangingMan ));
      _state.value .value .mem_index = 0;
      _state.value .value .mem_size = cdlHangingManLookback ();
      if ( _state.value .value .mem_size > 0)
         _state.value .value .memory = TA_Calloc( _state.value .value .mem_size , sizeof(struct TA_CDLHANGINGMAN_Data));
      else
         _state.value .value .memory = NULL;
      return RetCode.Success ;
   }
   public int cdlHangingManState( struct TA_cdlHangingMan_State* _state,
      double inOpen,
      double inHigh,
      double inLow,
      double inClose,
      int *outInteger )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      size_t _cur_idx = _state.value .mem_index++;
      if ( _state.value .mem_size > 0) _cur_idx %= _state.value .mem_size ;
      if ( _state.value .mem_size > _state.value .mem_index - 1 ) {
         ( _state.value .memory+_cur_idx).value .inOpen = inOpen ;
         ( _state.value .memory+_cur_idx).value .inHigh = inHigh ;
         ( _state.value .memory+_cur_idx).value .inLow = inLow ;
         ( _state.value .memory+_cur_idx).value .inClose = inClose ;
         return RetCode.NeedMoreData ; }
      return RetCode.Success ;
   }
   public int cdlHangingManStateFree( struct TA_cdlHangingMan_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if ( _state.value != NULL) {
         if ( _state.value .value .memory != NULL) TA_Free( _state.value .value .memory );
         TA_Free( _state.value ); _state.value = NULL;}
      return RetCode.Success ;
   }
   public RetCode cdlHangingMan( int startIdx,
      int endIdx,
      float inOpen[],
      float inHigh[],
      float inLow[],
      float inClose[],
      MInteger outBegIdx,
      MInteger outNBElement,
      int outInteger[] )
   {
      double BodyPeriodTotal, ShadowLongPeriodTotal, ShadowVeryShortPeriodTotal, NearPeriodTotal;
      int i, outIdx, BodyTrailingIdx, ShadowLongTrailingIdx, ShadowVeryShortTrailingIdx, NearTrailingIdx, lookbackTotal;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      lookbackTotal = cdlHangingManLookback ();
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      BodyPeriodTotal = 0;
      BodyTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) ;
      ShadowLongPeriodTotal = 0;
      ShadowLongTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].avgPeriod) ;
      ShadowVeryShortPeriodTotal = 0;
      ShadowVeryShortTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) ;
      NearPeriodTotal = 0;
      NearTrailingIdx = startIdx -1 - (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) ;
      i = BodyTrailingIdx;
      while( i < startIdx ) {
         BodyPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      i = ShadowLongTrailingIdx;
      while( i < startIdx ) {
         ShadowLongPeriodTotal += ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      i = ShadowVeryShortTrailingIdx;
      while( i < startIdx ) {
         ShadowVeryShortPeriodTotal += ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      i = NearTrailingIdx;
      while( i < startIdx-1 ) {
         NearPeriodTotal += ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      i = startIdx;
      outIdx = 0;
      do
      {
         if( ( Math.abs ( inClose[i] - inOpen[i] ) ) < ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) != 0.0? BodyPeriodTotal / (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) > ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].avgPeriod) != 0.0? ShadowLongPeriodTotal / (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) < ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) != 0.0? ShadowVeryShortPeriodTotal / (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            (((inClose[i]) < (inOpen[i])) ? (inClose[i]) : (inOpen[i])) >= inHigh[i-1] - ( (this.candleSettings[CandleSettingType.Near.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) != 0.0? NearPeriodTotal / (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) )
            )
            outInteger[outIdx++] = -100;
         else
            outInteger[outIdx++] = 0;
         BodyPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) )
            - ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[BodyTrailingIdx] - inOpen[BodyTrailingIdx] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[BodyTrailingIdx] - inLow[BodyTrailingIdx] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[BodyTrailingIdx] - ( inClose[BodyTrailingIdx] >= inOpen[BodyTrailingIdx] ? inClose[BodyTrailingIdx] : inOpen[BodyTrailingIdx] ) ) + ( ( inClose[BodyTrailingIdx] >= inOpen[BodyTrailingIdx] ? inOpen[BodyTrailingIdx] : inClose[BodyTrailingIdx] ) - inLow[BodyTrailingIdx] ) : 0 ) ) ) ;
         ShadowLongPeriodTotal += ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) )
            - ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[ShadowLongTrailingIdx] - inOpen[ShadowLongTrailingIdx] ) ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[ShadowLongTrailingIdx] - inLow[ShadowLongTrailingIdx] ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[ShadowLongTrailingIdx] - ( inClose[ShadowLongTrailingIdx] >= inOpen[ShadowLongTrailingIdx] ? inClose[ShadowLongTrailingIdx] : inOpen[ShadowLongTrailingIdx] ) ) + ( ( inClose[ShadowLongTrailingIdx] >= inOpen[ShadowLongTrailingIdx] ? inOpen[ShadowLongTrailingIdx] : inClose[ShadowLongTrailingIdx] ) - inLow[ShadowLongTrailingIdx] ) : 0 ) ) ) ;
         ShadowVeryShortPeriodTotal += ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) )
            - ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[ShadowVeryShortTrailingIdx] - inOpen[ShadowVeryShortTrailingIdx] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[ShadowVeryShortTrailingIdx] - inLow[ShadowVeryShortTrailingIdx] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[ShadowVeryShortTrailingIdx] - ( inClose[ShadowVeryShortTrailingIdx] >= inOpen[ShadowVeryShortTrailingIdx] ? inClose[ShadowVeryShortTrailingIdx] : inOpen[ShadowVeryShortTrailingIdx] ) ) + ( ( inClose[ShadowVeryShortTrailingIdx] >= inOpen[ShadowVeryShortTrailingIdx] ? inOpen[ShadowVeryShortTrailingIdx] : inClose[ShadowVeryShortTrailingIdx] ) - inLow[ShadowVeryShortTrailingIdx] ) : 0 ) ) ) ;
         NearPeriodTotal += ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) )
            - ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[NearTrailingIdx] - inOpen[NearTrailingIdx] ) ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[NearTrailingIdx] - inLow[NearTrailingIdx] ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[NearTrailingIdx] - ( inClose[NearTrailingIdx] >= inOpen[NearTrailingIdx] ? inClose[NearTrailingIdx] : inOpen[NearTrailingIdx] ) ) + ( ( inClose[NearTrailingIdx] >= inOpen[NearTrailingIdx] ? inOpen[NearTrailingIdx] : inClose[NearTrailingIdx] ) - inLow[NearTrailingIdx] ) : 0 ) ) ) ;
         i++;
         BodyTrailingIdx++;
         ShadowLongTrailingIdx++;
         ShadowVeryShortTrailingIdx++;
         NearTrailingIdx++;
      } while( i <= endIdx );
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   /* Generated */
   public int cdlHaramiLookback( )
   {
      return ((( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) ) > ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) )) ? ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) )) + 1;
   }
   public RetCode cdlHarami( int startIdx,
      int endIdx,
      double inOpen[],
      double inHigh[],
      double inLow[],
      double inClose[],
      MInteger outBegIdx,
      MInteger outNBElement,
      int outInteger[] )
   {
      double BodyShortPeriodTotal, BodyLongPeriodTotal;
      int i, outIdx, BodyShortTrailingIdx, BodyLongTrailingIdx, lookbackTotal;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      lookbackTotal = cdlHaramiLookback ();
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      BodyLongPeriodTotal = 0;
      BodyShortPeriodTotal = 0;
      BodyLongTrailingIdx = startIdx -1 - (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) ;
      BodyShortTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) ;
      i = BodyLongTrailingIdx;
      while( i < startIdx-1 ) {
         BodyLongPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      i = BodyShortTrailingIdx;
      while( i < startIdx ) {
         BodyShortPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      i = startIdx;
      outIdx = 0;
      do
      {
         if( ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) > ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) != 0.0? BodyLongPeriodTotal / (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( Math.abs ( inClose[i] - inOpen[i] ) ) <= ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) != 0.0? BodyShortPeriodTotal / (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) )
            )
            if ( (((inClose[i]) > (inOpen[i])) ? (inClose[i]) : (inOpen[i])) < (((inClose[i-1]) > (inOpen[i-1])) ? (inClose[i-1]) : (inOpen[i-1])) &&
            (((inClose[i]) < (inOpen[i])) ? (inClose[i]) : (inOpen[i])) > (((inClose[i-1]) < (inOpen[i-1])) ? (inClose[i-1]) : (inOpen[i-1]))
            )
            outInteger[outIdx++] = - ( inClose[i-1] >= inOpen[i-1] ? 1 : -1 ) * 100;
         else
            if ( (((inClose[i]) > (inOpen[i])) ? (inClose[i]) : (inOpen[i])) <= (((inClose[i-1]) > (inOpen[i-1])) ? (inClose[i-1]) : (inOpen[i-1])) &&
            (((inClose[i]) < (inOpen[i])) ? (inClose[i]) : (inOpen[i])) >= (((inClose[i-1]) < (inOpen[i-1])) ? (inClose[i-1]) : (inOpen[i-1]))
            )
            outInteger[outIdx++] = - ( inClose[i-1] >= inOpen[i-1] ? 1 : -1 ) * 80;
         else
            outInteger[outIdx++] = 0;
         else
            outInteger[outIdx++] = 0;
         BodyLongPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) - ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[BodyLongTrailingIdx] - inOpen[BodyLongTrailingIdx] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[BodyLongTrailingIdx] - inLow[BodyLongTrailingIdx] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[BodyLongTrailingIdx] - ( inClose[BodyLongTrailingIdx] >= inOpen[BodyLongTrailingIdx] ? inClose[BodyLongTrailingIdx] : inOpen[BodyLongTrailingIdx] ) ) + ( ( inClose[BodyLongTrailingIdx] >= inOpen[BodyLongTrailingIdx] ? inOpen[BodyLongTrailingIdx] : inClose[BodyLongTrailingIdx] ) - inLow[BodyLongTrailingIdx] ) : 0 ) ) ) ;
         BodyShortPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) - ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[BodyShortTrailingIdx] - inOpen[BodyShortTrailingIdx] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[BodyShortTrailingIdx] - inLow[BodyShortTrailingIdx] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[BodyShortTrailingIdx] - ( inClose[BodyShortTrailingIdx] >= inOpen[BodyShortTrailingIdx] ? inClose[BodyShortTrailingIdx] : inOpen[BodyShortTrailingIdx] ) ) + ( ( inClose[BodyShortTrailingIdx] >= inOpen[BodyShortTrailingIdx] ? inOpen[BodyShortTrailingIdx] : inClose[BodyShortTrailingIdx] ) - inLow[BodyShortTrailingIdx] ) : 0 ) ) ) ;
         i++;
         BodyLongTrailingIdx++;
         BodyShortTrailingIdx++;
      } while( i <= endIdx );
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   public int cdlHaramiStateInit( struct TA_cdlHarami_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct cdlHarami ));
      _state.value .value .mem_index = 0;
      _state.value .value .mem_size = cdlHaramiLookback ();
      if ( _state.value .value .mem_size > 0)
         _state.value .value .memory = TA_Calloc( _state.value .value .mem_size , sizeof(struct TA_CDLHARAMI_Data));
      else
         _state.value .value .memory = NULL;
      return RetCode.Success ;
   }
   public int cdlHaramiState( struct TA_cdlHarami_State* _state,
      double inOpen,
      double inHigh,
      double inLow,
      double inClose,
      int *outInteger )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      size_t _cur_idx = _state.value .mem_index++;
      if ( _state.value .mem_size > 0) _cur_idx %= _state.value .mem_size ;
      if ( _state.value .mem_size > _state.value .mem_index - 1 ) {
         ( _state.value .memory+_cur_idx).value .inOpen = inOpen ;
         ( _state.value .memory+_cur_idx).value .inHigh = inHigh ;
         ( _state.value .memory+_cur_idx).value .inLow = inLow ;
         ( _state.value .memory+_cur_idx).value .inClose = inClose ;
         return RetCode.NeedMoreData ; }
      return RetCode.Success ;
   }
   public int cdlHaramiStateFree( struct TA_cdlHarami_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if ( _state.value != NULL) {
         if ( _state.value .value .memory != NULL) TA_Free( _state.value .value .memory );
         TA_Free( _state.value ); _state.value = NULL;}
      return RetCode.Success ;
   }
   public RetCode cdlHarami( int startIdx,
      int endIdx,
      float inOpen[],
      float inHigh[],
      float inLow[],
      float inClose[],
      MInteger outBegIdx,
      MInteger outNBElement,
      int outInteger[] )
   {
      double BodyShortPeriodTotal, BodyLongPeriodTotal;
      int i, outIdx, BodyShortTrailingIdx, BodyLongTrailingIdx, lookbackTotal;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      lookbackTotal = cdlHaramiLookback ();
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      BodyLongPeriodTotal = 0;
      BodyShortPeriodTotal = 0;
      BodyLongTrailingIdx = startIdx -1 - (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) ;
      BodyShortTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) ;
      i = BodyLongTrailingIdx;
      while( i < startIdx-1 ) {
         BodyLongPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      i = BodyShortTrailingIdx;
      while( i < startIdx ) {
         BodyShortPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      i = startIdx;
      outIdx = 0;
      do
      {
         if( ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) > ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) != 0.0? BodyLongPeriodTotal / (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( Math.abs ( inClose[i] - inOpen[i] ) ) <= ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) != 0.0? BodyShortPeriodTotal / (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) )
            )
            if ( (((inClose[i]) > (inOpen[i])) ? (inClose[i]) : (inOpen[i])) < (((inClose[i-1]) > (inOpen[i-1])) ? (inClose[i-1]) : (inOpen[i-1])) &&
            (((inClose[i]) < (inOpen[i])) ? (inClose[i]) : (inOpen[i])) > (((inClose[i-1]) < (inOpen[i-1])) ? (inClose[i-1]) : (inOpen[i-1]))
            )
            outInteger[outIdx++] = - ( inClose[i-1] >= inOpen[i-1] ? 1 : -1 ) * 100;
         else
            if ( (((inClose[i]) > (inOpen[i])) ? (inClose[i]) : (inOpen[i])) <= (((inClose[i-1]) > (inOpen[i-1])) ? (inClose[i-1]) : (inOpen[i-1])) &&
            (((inClose[i]) < (inOpen[i])) ? (inClose[i]) : (inOpen[i])) >= (((inClose[i-1]) < (inOpen[i-1])) ? (inClose[i-1]) : (inOpen[i-1]))
            )
            outInteger[outIdx++] = - ( inClose[i-1] >= inOpen[i-1] ? 1 : -1 ) * 80;
         else
            outInteger[outIdx++] = 0;
         else
            outInteger[outIdx++] = 0;
         BodyLongPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) - ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[BodyLongTrailingIdx] - inOpen[BodyLongTrailingIdx] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[BodyLongTrailingIdx] - inLow[BodyLongTrailingIdx] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[BodyLongTrailingIdx] - ( inClose[BodyLongTrailingIdx] >= inOpen[BodyLongTrailingIdx] ? inClose[BodyLongTrailingIdx] : inOpen[BodyLongTrailingIdx] ) ) + ( ( inClose[BodyLongTrailingIdx] >= inOpen[BodyLongTrailingIdx] ? inOpen[BodyLongTrailingIdx] : inClose[BodyLongTrailingIdx] ) - inLow[BodyLongTrailingIdx] ) : 0 ) ) ) ;
         BodyShortPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) - ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[BodyShortTrailingIdx] - inOpen[BodyShortTrailingIdx] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[BodyShortTrailingIdx] - inLow[BodyShortTrailingIdx] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[BodyShortTrailingIdx] - ( inClose[BodyShortTrailingIdx] >= inOpen[BodyShortTrailingIdx] ? inClose[BodyShortTrailingIdx] : inOpen[BodyShortTrailingIdx] ) ) + ( ( inClose[BodyShortTrailingIdx] >= inOpen[BodyShortTrailingIdx] ? inOpen[BodyShortTrailingIdx] : inClose[BodyShortTrailingIdx] ) - inLow[BodyShortTrailingIdx] ) : 0 ) ) ) ;
         i++;
         BodyLongTrailingIdx++;
         BodyShortTrailingIdx++;
      } while( i <= endIdx );
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   /* Generated */
   public int cdlHaramiCrossLookback( )
   {
      return ((( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].avgPeriod) ) > ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) )) ? ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].avgPeriod) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) )) + 1;
   }
   public RetCode cdlHaramiCross( int startIdx,
      int endIdx,
      double inOpen[],
      double inHigh[],
      double inLow[],
      double inClose[],
      MInteger outBegIdx,
      MInteger outNBElement,
      int outInteger[] )
   {
      double BodyDojiPeriodTotal, BodyLongPeriodTotal;
      int i, outIdx, BodyDojiTrailingIdx, BodyLongTrailingIdx, lookbackTotal;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      lookbackTotal = cdlHaramiCrossLookback ();
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      BodyLongPeriodTotal = 0;
      BodyDojiPeriodTotal = 0;
      BodyLongTrailingIdx = startIdx -1 - (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) ;
      BodyDojiTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].avgPeriod) ;
      i = BodyLongTrailingIdx;
      while( i < startIdx-1 ) {
         BodyLongPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      i = BodyDojiTrailingIdx;
      while( i < startIdx ) {
         BodyDojiPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      i = startIdx;
      outIdx = 0;
      do
      {
         if( ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) > ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) != 0.0? BodyLongPeriodTotal / (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( Math.abs ( inClose[i] - inOpen[i] ) ) <= ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].avgPeriod) != 0.0? BodyDojiPeriodTotal / (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) )
            if ( (((inClose[i]) > (inOpen[i])) ? (inClose[i]) : (inOpen[i])) < (((inClose[i-1]) > (inOpen[i-1])) ? (inClose[i-1]) : (inOpen[i-1])) &&
            (((inClose[i]) < (inOpen[i])) ? (inClose[i]) : (inOpen[i])) > (((inClose[i-1]) < (inOpen[i-1])) ? (inClose[i-1]) : (inOpen[i-1]))
            )
            outInteger[outIdx++] = - ( inClose[i-1] >= inOpen[i-1] ? 1 : -1 ) * 100;
         else
            if ( (((inClose[i]) > (inOpen[i])) ? (inClose[i]) : (inOpen[i])) <= (((inClose[i-1]) > (inOpen[i-1])) ? (inClose[i-1]) : (inOpen[i-1])) &&
            (((inClose[i]) < (inOpen[i])) ? (inClose[i]) : (inOpen[i])) >= (((inClose[i-1]) < (inOpen[i-1])) ? (inClose[i-1]) : (inOpen[i-1]))
            )
            outInteger[outIdx++] = - ( inClose[i-1] >= inOpen[i-1] ? 1 : -1 ) * 80;
         else
            outInteger[outIdx++] = 0;
         else
            outInteger[outIdx++] = 0;
         BodyLongPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) - ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[BodyLongTrailingIdx] - inOpen[BodyLongTrailingIdx] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[BodyLongTrailingIdx] - inLow[BodyLongTrailingIdx] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[BodyLongTrailingIdx] - ( inClose[BodyLongTrailingIdx] >= inOpen[BodyLongTrailingIdx] ? inClose[BodyLongTrailingIdx] : inOpen[BodyLongTrailingIdx] ) ) + ( ( inClose[BodyLongTrailingIdx] >= inOpen[BodyLongTrailingIdx] ? inOpen[BodyLongTrailingIdx] : inClose[BodyLongTrailingIdx] ) - inLow[BodyLongTrailingIdx] ) : 0 ) ) ) ;
         BodyDojiPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) - ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[BodyDojiTrailingIdx] - inOpen[BodyDojiTrailingIdx] ) ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[BodyDojiTrailingIdx] - inLow[BodyDojiTrailingIdx] ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[BodyDojiTrailingIdx] - ( inClose[BodyDojiTrailingIdx] >= inOpen[BodyDojiTrailingIdx] ? inClose[BodyDojiTrailingIdx] : inOpen[BodyDojiTrailingIdx] ) ) + ( ( inClose[BodyDojiTrailingIdx] >= inOpen[BodyDojiTrailingIdx] ? inOpen[BodyDojiTrailingIdx] : inClose[BodyDojiTrailingIdx] ) - inLow[BodyDojiTrailingIdx] ) : 0 ) ) ) ;
         i++;
         BodyLongTrailingIdx++;
         BodyDojiTrailingIdx++;
      } while( i <= endIdx );
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   public int cdlHaramiCrossStateInit( struct TA_cdlHaramiCross_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct cdlHaramiCross ));
      _state.value .value .mem_index = 0;
      _state.value .value .mem_size = cdlHaramiCrossLookback ();
      if ( _state.value .value .mem_size > 0)
         _state.value .value .memory = TA_Calloc( _state.value .value .mem_size , sizeof(struct TA_CDLHARAMICROSS_Data));
      else
         _state.value .value .memory = NULL;
      return RetCode.Success ;
   }
   public int cdlHaramiCrossState( struct TA_cdlHaramiCross_State* _state,
      double inOpen,
      double inHigh,
      double inLow,
      double inClose,
      int *outInteger )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      size_t _cur_idx = _state.value .mem_index++;
      if ( _state.value .mem_size > 0) _cur_idx %= _state.value .mem_size ;
      if ( _state.value .mem_size > _state.value .mem_index - 1 ) {
         ( _state.value .memory+_cur_idx).value .inOpen = inOpen ;
         ( _state.value .memory+_cur_idx).value .inHigh = inHigh ;
         ( _state.value .memory+_cur_idx).value .inLow = inLow ;
         ( _state.value .memory+_cur_idx).value .inClose = inClose ;
         return RetCode.NeedMoreData ; }
      return RetCode.Success ;
   }
   public int cdlHaramiCrossStateFree( struct TA_cdlHaramiCross_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if ( _state.value != NULL) {
         if ( _state.value .value .memory != NULL) TA_Free( _state.value .value .memory );
         TA_Free( _state.value ); _state.value = NULL;}
      return RetCode.Success ;
   }
   public RetCode cdlHaramiCross( int startIdx,
      int endIdx,
      float inOpen[],
      float inHigh[],
      float inLow[],
      float inClose[],
      MInteger outBegIdx,
      MInteger outNBElement,
      int outInteger[] )
   {
      double BodyDojiPeriodTotal, BodyLongPeriodTotal;
      int i, outIdx, BodyDojiTrailingIdx, BodyLongTrailingIdx, lookbackTotal;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      lookbackTotal = cdlHaramiCrossLookback ();
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      BodyLongPeriodTotal = 0;
      BodyDojiPeriodTotal = 0;
      BodyLongTrailingIdx = startIdx -1 - (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) ;
      BodyDojiTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].avgPeriod) ;
      i = BodyLongTrailingIdx;
      while( i < startIdx-1 ) {
         BodyLongPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      i = BodyDojiTrailingIdx;
      while( i < startIdx ) {
         BodyDojiPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      i = startIdx;
      outIdx = 0;
      do
      {
         if( ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) > ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) != 0.0? BodyLongPeriodTotal / (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( Math.abs ( inClose[i] - inOpen[i] ) ) <= ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].avgPeriod) != 0.0? BodyDojiPeriodTotal / (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) )
            if ( (((inClose[i]) > (inOpen[i])) ? (inClose[i]) : (inOpen[i])) < (((inClose[i-1]) > (inOpen[i-1])) ? (inClose[i-1]) : (inOpen[i-1])) &&
            (((inClose[i]) < (inOpen[i])) ? (inClose[i]) : (inOpen[i])) > (((inClose[i-1]) < (inOpen[i-1])) ? (inClose[i-1]) : (inOpen[i-1]))
            )
            outInteger[outIdx++] = - ( inClose[i-1] >= inOpen[i-1] ? 1 : -1 ) * 100;
         else
            if ( (((inClose[i]) > (inOpen[i])) ? (inClose[i]) : (inOpen[i])) <= (((inClose[i-1]) > (inOpen[i-1])) ? (inClose[i-1]) : (inOpen[i-1])) &&
            (((inClose[i]) < (inOpen[i])) ? (inClose[i]) : (inOpen[i])) >= (((inClose[i-1]) < (inOpen[i-1])) ? (inClose[i-1]) : (inOpen[i-1]))
            )
            outInteger[outIdx++] = - ( inClose[i-1] >= inOpen[i-1] ? 1 : -1 ) * 80;
         else
            outInteger[outIdx++] = 0;
         else
            outInteger[outIdx++] = 0;
         BodyLongPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) - ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[BodyLongTrailingIdx] - inOpen[BodyLongTrailingIdx] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[BodyLongTrailingIdx] - inLow[BodyLongTrailingIdx] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[BodyLongTrailingIdx] - ( inClose[BodyLongTrailingIdx] >= inOpen[BodyLongTrailingIdx] ? inClose[BodyLongTrailingIdx] : inOpen[BodyLongTrailingIdx] ) ) + ( ( inClose[BodyLongTrailingIdx] >= inOpen[BodyLongTrailingIdx] ? inOpen[BodyLongTrailingIdx] : inClose[BodyLongTrailingIdx] ) - inLow[BodyLongTrailingIdx] ) : 0 ) ) ) ;
         BodyDojiPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) - ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[BodyDojiTrailingIdx] - inOpen[BodyDojiTrailingIdx] ) ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[BodyDojiTrailingIdx] - inLow[BodyDojiTrailingIdx] ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[BodyDojiTrailingIdx] - ( inClose[BodyDojiTrailingIdx] >= inOpen[BodyDojiTrailingIdx] ? inClose[BodyDojiTrailingIdx] : inOpen[BodyDojiTrailingIdx] ) ) + ( ( inClose[BodyDojiTrailingIdx] >= inOpen[BodyDojiTrailingIdx] ? inOpen[BodyDojiTrailingIdx] : inClose[BodyDojiTrailingIdx] ) - inLow[BodyDojiTrailingIdx] ) : 0 ) ) ) ;
         i++;
         BodyLongTrailingIdx++;
         BodyDojiTrailingIdx++;
      } while( i <= endIdx );
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   /* Generated */
   public int cdlHignWaveLookback( )
   {
      return ((( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) ) > ( (this.candleSettings[CandleSettingType.ShadowVeryLong.ordinal()].avgPeriod) )) ? ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryLong.ordinal()].avgPeriod) )) ;
   }
   public RetCode cdlHignWave( int startIdx,
      int endIdx,
      double inOpen[],
      double inHigh[],
      double inLow[],
      double inClose[],
      MInteger outBegIdx,
      MInteger outNBElement,
      int outInteger[] )
   {
      double BodyPeriodTotal, ShadowPeriodTotal;
      int i, outIdx, BodyTrailingIdx, ShadowTrailingIdx, lookbackTotal;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      lookbackTotal = cdlHignWaveLookback ();
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      BodyPeriodTotal = 0;
      BodyTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) ;
      ShadowPeriodTotal = 0;
      ShadowTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.ShadowVeryLong.ordinal()].avgPeriod) ;
      i = BodyTrailingIdx;
      while( i < startIdx ) {
         BodyPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      i = ShadowTrailingIdx;
      while( i < startIdx ) {
         ShadowPeriodTotal += ( (this.candleSettings[CandleSettingType.ShadowVeryLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      outIdx = 0;
      do
      {
         if( ( Math.abs ( inClose[i] - inOpen[i] ) ) < ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) != 0.0? BodyPeriodTotal / (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) > ( (this.candleSettings[CandleSettingType.ShadowVeryLong.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.ShadowVeryLong.ordinal()].avgPeriod) != 0.0? ShadowPeriodTotal / (this.candleSettings[CandleSettingType.ShadowVeryLong.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.ShadowVeryLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.ShadowVeryLong.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) > ( (this.candleSettings[CandleSettingType.ShadowVeryLong.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.ShadowVeryLong.ordinal()].avgPeriod) != 0.0? ShadowPeriodTotal / (this.candleSettings[CandleSettingType.ShadowVeryLong.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.ShadowVeryLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.ShadowVeryLong.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) )
            outInteger[outIdx++] = ( inClose[i] >= inOpen[i] ? 1 : -1 ) * 100;
         else
            outInteger[outIdx++] = 0;
         BodyPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) - ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[BodyTrailingIdx] - inOpen[BodyTrailingIdx] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[BodyTrailingIdx] - inLow[BodyTrailingIdx] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[BodyTrailingIdx] - ( inClose[BodyTrailingIdx] >= inOpen[BodyTrailingIdx] ? inClose[BodyTrailingIdx] : inOpen[BodyTrailingIdx] ) ) + ( ( inClose[BodyTrailingIdx] >= inOpen[BodyTrailingIdx] ? inOpen[BodyTrailingIdx] : inClose[BodyTrailingIdx] ) - inLow[BodyTrailingIdx] ) : 0 ) ) ) ;
         ShadowPeriodTotal += ( (this.candleSettings[CandleSettingType.ShadowVeryLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) - ( (this.candleSettings[CandleSettingType.ShadowVeryLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[ShadowTrailingIdx] - inOpen[ShadowTrailingIdx] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[ShadowTrailingIdx] - inLow[ShadowTrailingIdx] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[ShadowTrailingIdx] - ( inClose[ShadowTrailingIdx] >= inOpen[ShadowTrailingIdx] ? inClose[ShadowTrailingIdx] : inOpen[ShadowTrailingIdx] ) ) + ( ( inClose[ShadowTrailingIdx] >= inOpen[ShadowTrailingIdx] ? inOpen[ShadowTrailingIdx] : inClose[ShadowTrailingIdx] ) - inLow[ShadowTrailingIdx] ) : 0 ) ) ) ;
         i++;
         BodyTrailingIdx++;
         ShadowTrailingIdx++;
      } while( i <= endIdx );
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   public int cdlHignWaveStateInit( struct TA_cdlHignWave_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct cdlHignWave ));
      _state.value .value .mem_index = 0;
      _state.value .value .mem_size = cdlHignWaveLookback ();
      if ( _state.value .value .mem_size > 0)
         _state.value .value .memory = TA_Calloc( _state.value .value .mem_size , sizeof(struct TA_CDLHIGHWAVE_Data));
      else
         _state.value .value .memory = NULL;
      return RetCode.Success ;
   }
   public int cdlHignWaveState( struct TA_cdlHignWave_State* _state,
      double inOpen,
      double inHigh,
      double inLow,
      double inClose,
      int *outInteger )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      size_t _cur_idx = _state.value .mem_index++;
      if ( _state.value .mem_size > 0) _cur_idx %= _state.value .mem_size ;
      if ( _state.value .mem_size > _state.value .mem_index - 1 ) {
         ( _state.value .memory+_cur_idx).value .inOpen = inOpen ;
         ( _state.value .memory+_cur_idx).value .inHigh = inHigh ;
         ( _state.value .memory+_cur_idx).value .inLow = inLow ;
         ( _state.value .memory+_cur_idx).value .inClose = inClose ;
         return RetCode.NeedMoreData ; }
      return RetCode.Success ;
   }
   public int cdlHignWaveStateFree( struct TA_cdlHignWave_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if ( _state.value != NULL) {
         if ( _state.value .value .memory != NULL) TA_Free( _state.value .value .memory );
         TA_Free( _state.value ); _state.value = NULL;}
      return RetCode.Success ;
   }
   public RetCode cdlHignWave( int startIdx,
      int endIdx,
      float inOpen[],
      float inHigh[],
      float inLow[],
      float inClose[],
      MInteger outBegIdx,
      MInteger outNBElement,
      int outInteger[] )
   {
      double BodyPeriodTotal, ShadowPeriodTotal;
      int i, outIdx, BodyTrailingIdx, ShadowTrailingIdx, lookbackTotal;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      lookbackTotal = cdlHignWaveLookback ();
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      BodyPeriodTotal = 0;
      BodyTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) ;
      ShadowPeriodTotal = 0;
      ShadowTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.ShadowVeryLong.ordinal()].avgPeriod) ;
      i = BodyTrailingIdx;
      while( i < startIdx ) {
         BodyPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      i = ShadowTrailingIdx;
      while( i < startIdx ) {
         ShadowPeriodTotal += ( (this.candleSettings[CandleSettingType.ShadowVeryLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      outIdx = 0;
      do
      {
         if( ( Math.abs ( inClose[i] - inOpen[i] ) ) < ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) != 0.0? BodyPeriodTotal / (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) > ( (this.candleSettings[CandleSettingType.ShadowVeryLong.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.ShadowVeryLong.ordinal()].avgPeriod) != 0.0? ShadowPeriodTotal / (this.candleSettings[CandleSettingType.ShadowVeryLong.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.ShadowVeryLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.ShadowVeryLong.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) > ( (this.candleSettings[CandleSettingType.ShadowVeryLong.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.ShadowVeryLong.ordinal()].avgPeriod) != 0.0? ShadowPeriodTotal / (this.candleSettings[CandleSettingType.ShadowVeryLong.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.ShadowVeryLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.ShadowVeryLong.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) )
            outInteger[outIdx++] = ( inClose[i] >= inOpen[i] ? 1 : -1 ) * 100;
         else
            outInteger[outIdx++] = 0;
         BodyPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) - ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[BodyTrailingIdx] - inOpen[BodyTrailingIdx] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[BodyTrailingIdx] - inLow[BodyTrailingIdx] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[BodyTrailingIdx] - ( inClose[BodyTrailingIdx] >= inOpen[BodyTrailingIdx] ? inClose[BodyTrailingIdx] : inOpen[BodyTrailingIdx] ) ) + ( ( inClose[BodyTrailingIdx] >= inOpen[BodyTrailingIdx] ? inOpen[BodyTrailingIdx] : inClose[BodyTrailingIdx] ) - inLow[BodyTrailingIdx] ) : 0 ) ) ) ;
         ShadowPeriodTotal += ( (this.candleSettings[CandleSettingType.ShadowVeryLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) - ( (this.candleSettings[CandleSettingType.ShadowVeryLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[ShadowTrailingIdx] - inOpen[ShadowTrailingIdx] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[ShadowTrailingIdx] - inLow[ShadowTrailingIdx] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[ShadowTrailingIdx] - ( inClose[ShadowTrailingIdx] >= inOpen[ShadowTrailingIdx] ? inClose[ShadowTrailingIdx] : inOpen[ShadowTrailingIdx] ) ) + ( ( inClose[ShadowTrailingIdx] >= inOpen[ShadowTrailingIdx] ? inOpen[ShadowTrailingIdx] : inClose[ShadowTrailingIdx] ) - inLow[ShadowTrailingIdx] ) : 0 ) ) ) ;
         i++;
         BodyTrailingIdx++;
         ShadowTrailingIdx++;
      } while( i <= endIdx );
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   /* Generated */
   public int cdlHikkakeLookback( )
   {
      return 5;
   }
   public RetCode cdlHikkake( int startIdx,
      int endIdx,
      double inOpen[],
      double inHigh[],
      double inLow[],
      double inClose[],
      MInteger outBegIdx,
      MInteger outNBElement,
      int outInteger[] )
   {
      int i, outIdx, lookbackTotal, patternIdx, patternResult;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      lookbackTotal = cdlHikkakeLookback ();
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      patternIdx = 0;
      patternResult = 0;
      i = startIdx - 3;
      while( i < startIdx ) {
         if( inHigh[i-1] < inHigh[i-2] && inLow[i-1] > inLow[i-2] &&
            ( ( inHigh[i] < inHigh[i-1] && inLow[i] < inLow[i-1] )
            ||
            ( inHigh[i] > inHigh[i-1] && inLow[i] > inLow[i-1] )
            )
            ) {
            patternResult = 100 * ( inHigh[i] < inHigh[i-1] ? 1 : -1 );
            patternIdx = i;
         } else
            if( i <= patternIdx+3 &&
            ( ( patternResult > 0 && inClose[i] > inHigh[patternIdx-1] )
            ||
            ( patternResult < 0 && inClose[i] < inLow[patternIdx-1] )
            )
            )
            patternIdx = 0;
         i++;
      }
      i = startIdx;
      outIdx = 0;
      do
      {
         if( inHigh[i-1] < inHigh[i-2] && inLow[i-1] > inLow[i-2] &&
            ( ( inHigh[i] < inHigh[i-1] && inLow[i] < inLow[i-1] )
            ||
            ( inHigh[i] > inHigh[i-1] && inLow[i] > inLow[i-1] )
            )
            ) {
            patternResult = 100 * ( inHigh[i] < inHigh[i-1] ? 1 : -1 );
            patternIdx = i;
            outInteger[outIdx++] = patternResult;
         } else
            if( i <= patternIdx+3 &&
            ( ( patternResult > 0 && inClose[i] > inHigh[patternIdx-1] )
            ||
            ( patternResult < 0 && inClose[i] < inLow[patternIdx-1] )
            )
            ) {
            outInteger[outIdx++] = patternResult + 100 * ( patternResult > 0 ? 1 : -1 );
            patternIdx = 0;
         } else
            outInteger[outIdx++] = 0;
         i++;
      } while( i <= endIdx );
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   public int cdlHikkakeStateInit( struct TA_cdlHikkake_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct cdlHikkake ));
      _state.value .value .mem_index = 0;
      _state.value .value .mem_size = cdlHikkakeLookback ();
      if ( _state.value .value .mem_size > 0)
         _state.value .value .memory = TA_Calloc( _state.value .value .mem_size , sizeof(struct TA_CDLHIKKAKE_Data));
      else
         _state.value .value .memory = NULL;
      return RetCode.Success ;
   }
   public int cdlHikkakeState( struct TA_cdlHikkake_State* _state,
      double inOpen,
      double inHigh,
      double inLow,
      double inClose,
      int *outInteger )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      size_t _cur_idx = _state.value .mem_index++;
      if ( _state.value .mem_size > 0) _cur_idx %= _state.value .mem_size ;
      if ( _state.value .mem_size > _state.value .mem_index - 1 ) {
         ( _state.value .memory+_cur_idx).value .inOpen = inOpen ;
         ( _state.value .memory+_cur_idx).value .inHigh = inHigh ;
         ( _state.value .memory+_cur_idx).value .inLow = inLow ;
         ( _state.value .memory+_cur_idx).value .inClose = inClose ;
         return RetCode.NeedMoreData ; }
      return RetCode.Success ;
   }
   public int cdlHikkakeStateFree( struct TA_cdlHikkake_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if ( _state.value != NULL) {
         if ( _state.value .value .memory != NULL) TA_Free( _state.value .value .memory );
         TA_Free( _state.value ); _state.value = NULL;}
      return RetCode.Success ;
   }
   public RetCode cdlHikkake( int startIdx,
      int endIdx,
      float inOpen[],
      float inHigh[],
      float inLow[],
      float inClose[],
      MInteger outBegIdx,
      MInteger outNBElement,
      int outInteger[] )
   {
      int i, outIdx, lookbackTotal, patternIdx, patternResult;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      lookbackTotal = cdlHikkakeLookback ();
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      patternIdx = 0;
      patternResult = 0;
      i = startIdx - 3;
      while( i < startIdx ) {
         if( inHigh[i-1] < inHigh[i-2] && inLow[i-1] > inLow[i-2] &&
            ( ( inHigh[i] < inHigh[i-1] && inLow[i] < inLow[i-1] )
            ||
            ( inHigh[i] > inHigh[i-1] && inLow[i] > inLow[i-1] )
            )
            ) {
            patternResult = 100 * ( inHigh[i] < inHigh[i-1] ? 1 : -1 );
            patternIdx = i;
         } else
            if( i <= patternIdx+3 &&
            ( ( patternResult > 0 && inClose[i] > inHigh[patternIdx-1] )
            ||
            ( patternResult < 0 && inClose[i] < inLow[patternIdx-1] )
            )
            )
            patternIdx = 0;
         i++;
      }
      i = startIdx;
      outIdx = 0;
      do
      {
         if( inHigh[i-1] < inHigh[i-2] && inLow[i-1] > inLow[i-2] &&
            ( ( inHigh[i] < inHigh[i-1] && inLow[i] < inLow[i-1] )
            ||
            ( inHigh[i] > inHigh[i-1] && inLow[i] > inLow[i-1] )
            )
            ) {
            patternResult = 100 * ( inHigh[i] < inHigh[i-1] ? 1 : -1 );
            patternIdx = i;
            outInteger[outIdx++] = patternResult;
         } else
            if( i <= patternIdx+3 &&
            ( ( patternResult > 0 && inClose[i] > inHigh[patternIdx-1] )
            ||
            ( patternResult < 0 && inClose[i] < inLow[patternIdx-1] )
            )
            ) {
            outInteger[outIdx++] = patternResult + 100 * ( patternResult > 0 ? 1 : -1 );
            patternIdx = 0;
         } else
            outInteger[outIdx++] = 0;
         i++;
      } while( i <= endIdx );
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   /* Generated */
   public int cdlHikkakeModLookback( )
   {
      return (((1) > ( (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) )) ? (1) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) )) + 5;
   }
   public RetCode cdlHikkakeMod( int startIdx,
      int endIdx,
      double inOpen[],
      double inHigh[],
      double inLow[],
      double inClose[],
      MInteger outBegIdx,
      MInteger outNBElement,
      int outInteger[] )
   {
      double NearPeriodTotal;
      int i, outIdx, NearTrailingIdx, lookbackTotal, patternIdx, patternResult;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      lookbackTotal = cdlHikkakeModLookback ();
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      NearPeriodTotal = 0;
      NearTrailingIdx = startIdx - 3 - (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) ;
      i = NearTrailingIdx;
      while( i < startIdx - 3 ) {
         NearPeriodTotal += ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-2] - inLow[i-2] ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-2] - ( inClose[i-2] >= inOpen[i-2] ? inClose[i-2] : inOpen[i-2] ) ) + ( ( inClose[i-2] >= inOpen[i-2] ? inOpen[i-2] : inClose[i-2] ) - inLow[i-2] ) : 0 ) ) ) ;
         i++;
      }
      patternIdx = 0;
      patternResult = 0;
      i = startIdx - 3;
      while( i < startIdx ) {
         if( inHigh[i-2] < inHigh[i-3] && inLow[i-2] > inLow[i-3] &&
            inHigh[i-1] < inHigh[i-2] && inLow[i-1] > inLow[i-2] &&
            ( ( inHigh[i] < inHigh[i-1] && inLow[i] < inLow[i-1] &&
            inClose[i-2] <= inLow[i-2] + ( (this.candleSettings[CandleSettingType.Near.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) != 0.0? NearPeriodTotal / (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-2] - inLow[i-2] ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-2] - ( inClose[i-2] >= inOpen[i-2] ? inClose[i-2] : inOpen[i-2] ) ) + ( ( inClose[i-2] >= inOpen[i-2] ? inOpen[i-2] : inClose[i-2] ) - inLow[i-2] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) )
            )
            ||
            ( inHigh[i] > inHigh[i-1] && inLow[i] > inLow[i-1] &&
            inClose[i-2] >= inHigh[i-2] - ( (this.candleSettings[CandleSettingType.Near.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) != 0.0? NearPeriodTotal / (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-2] - inLow[i-2] ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-2] - ( inClose[i-2] >= inOpen[i-2] ? inClose[i-2] : inOpen[i-2] ) ) + ( ( inClose[i-2] >= inOpen[i-2] ? inOpen[i-2] : inClose[i-2] ) - inLow[i-2] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) )
            )
            )
            ) {
            patternResult = 100 * ( inHigh[i] < inHigh[i-1] ? 1 : -1 );
            patternIdx = i;
         } else
            if( i <= patternIdx+3 &&
            ( ( patternResult > 0 && inClose[i] > inHigh[patternIdx-1] )
            ||
            ( patternResult < 0 && inClose[i] < inLow[patternIdx-1] )
            )
            )
            patternIdx = 0;
         NearPeriodTotal += ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-2] - inLow[i-2] ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-2] - ( inClose[i-2] >= inOpen[i-2] ? inClose[i-2] : inOpen[i-2] ) ) + ( ( inClose[i-2] >= inOpen[i-2] ? inOpen[i-2] : inClose[i-2] ) - inLow[i-2] ) : 0 ) ) ) - ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[NearTrailingIdx-2] - inOpen[NearTrailingIdx-2] ) ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[NearTrailingIdx-2] - inLow[NearTrailingIdx-2] ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[NearTrailingIdx-2] - ( inClose[NearTrailingIdx-2] >= inOpen[NearTrailingIdx-2] ? inClose[NearTrailingIdx-2] : inOpen[NearTrailingIdx-2] ) ) + ( ( inClose[NearTrailingIdx-2] >= inOpen[NearTrailingIdx-2] ? inOpen[NearTrailingIdx-2] : inClose[NearTrailingIdx-2] ) - inLow[NearTrailingIdx-2] ) : 0 ) ) ) ;
         NearTrailingIdx++;
         i++;
      }
      i = startIdx;
      outIdx = 0;
      do
      {
         if( inHigh[i-2] < inHigh[i-3] && inLow[i-2] > inLow[i-3] &&
            inHigh[i-1] < inHigh[i-2] && inLow[i-1] > inLow[i-2] &&
            ( ( inHigh[i] < inHigh[i-1] && inLow[i] < inLow[i-1] &&
            inClose[i-2] <= inLow[i-2] + ( (this.candleSettings[CandleSettingType.Near.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) != 0.0? NearPeriodTotal / (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-2] - inLow[i-2] ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-2] - ( inClose[i-2] >= inOpen[i-2] ? inClose[i-2] : inOpen[i-2] ) ) + ( ( inClose[i-2] >= inOpen[i-2] ? inOpen[i-2] : inClose[i-2] ) - inLow[i-2] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) )
            )
            ||
            ( inHigh[i] > inHigh[i-1] && inLow[i] > inLow[i-1] &&
            inClose[i-2] >= inHigh[i-2] - ( (this.candleSettings[CandleSettingType.Near.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) != 0.0? NearPeriodTotal / (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-2] - inLow[i-2] ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-2] - ( inClose[i-2] >= inOpen[i-2] ? inClose[i-2] : inOpen[i-2] ) ) + ( ( inClose[i-2] >= inOpen[i-2] ? inOpen[i-2] : inClose[i-2] ) - inLow[i-2] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) )
            )
            )
            ) {
            patternResult = 100 * ( inHigh[i] < inHigh[i-1] ? 1 : -1 );
            patternIdx = i;
            outInteger[outIdx++] = patternResult;
         } else
            if( i <= patternIdx+3 &&
            ( ( patternResult > 0 && inClose[i] > inHigh[patternIdx-1] )
            ||
            ( patternResult < 0 && inClose[i] < inLow[patternIdx-1] )
            )
            ) {
            outInteger[outIdx++] = patternResult + 100 * ( patternResult > 0 ? 1 : -1 );
            patternIdx = 0;
         } else
            outInteger[outIdx++] = 0;
         NearPeriodTotal += ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-2] - inLow[i-2] ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-2] - ( inClose[i-2] >= inOpen[i-2] ? inClose[i-2] : inOpen[i-2] ) ) + ( ( inClose[i-2] >= inOpen[i-2] ? inOpen[i-2] : inClose[i-2] ) - inLow[i-2] ) : 0 ) ) ) - ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[NearTrailingIdx-2] - inOpen[NearTrailingIdx-2] ) ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[NearTrailingIdx-2] - inLow[NearTrailingIdx-2] ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[NearTrailingIdx-2] - ( inClose[NearTrailingIdx-2] >= inOpen[NearTrailingIdx-2] ? inClose[NearTrailingIdx-2] : inOpen[NearTrailingIdx-2] ) ) + ( ( inClose[NearTrailingIdx-2] >= inOpen[NearTrailingIdx-2] ? inOpen[NearTrailingIdx-2] : inClose[NearTrailingIdx-2] ) - inLow[NearTrailingIdx-2] ) : 0 ) ) ) ;
         NearTrailingIdx++;
         i++;
      } while( i <= endIdx );
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   public int cdlHikkakeModStateInit( struct TA_cdlHikkakeMod_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct cdlHikkakeMod ));
      _state.value .value .mem_index = 0;
      _state.value .value .mem_size = cdlHikkakeModLookback ();
      if ( _state.value .value .mem_size > 0)
         _state.value .value .memory = TA_Calloc( _state.value .value .mem_size , sizeof(struct TA_CDLHIKKAKEMOD_Data));
      else
         _state.value .value .memory = NULL;
      return RetCode.Success ;
   }
   public int cdlHikkakeModState( struct TA_cdlHikkakeMod_State* _state,
      double inOpen,
      double inHigh,
      double inLow,
      double inClose,
      int *outInteger )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      size_t _cur_idx = _state.value .mem_index++;
      if ( _state.value .mem_size > 0) _cur_idx %= _state.value .mem_size ;
      if ( _state.value .mem_size > _state.value .mem_index - 1 ) {
         ( _state.value .memory+_cur_idx).value .inOpen = inOpen ;
         ( _state.value .memory+_cur_idx).value .inHigh = inHigh ;
         ( _state.value .memory+_cur_idx).value .inLow = inLow ;
         ( _state.value .memory+_cur_idx).value .inClose = inClose ;
         return RetCode.NeedMoreData ; }
      return RetCode.Success ;
   }
   public int cdlHikkakeModStateFree( struct TA_cdlHikkakeMod_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if ( _state.value != NULL) {
         if ( _state.value .value .memory != NULL) TA_Free( _state.value .value .memory );
         TA_Free( _state.value ); _state.value = NULL;}
      return RetCode.Success ;
   }
   public RetCode cdlHikkakeMod( int startIdx,
      int endIdx,
      float inOpen[],
      float inHigh[],
      float inLow[],
      float inClose[],
      MInteger outBegIdx,
      MInteger outNBElement,
      int outInteger[] )
   {
      double NearPeriodTotal;
      int i, outIdx, NearTrailingIdx, lookbackTotal, patternIdx, patternResult;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      lookbackTotal = cdlHikkakeModLookback ();
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      NearPeriodTotal = 0;
      NearTrailingIdx = startIdx - 3 - (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) ;
      i = NearTrailingIdx;
      while( i < startIdx - 3 ) {
         NearPeriodTotal += ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-2] - inLow[i-2] ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-2] - ( inClose[i-2] >= inOpen[i-2] ? inClose[i-2] : inOpen[i-2] ) ) + ( ( inClose[i-2] >= inOpen[i-2] ? inOpen[i-2] : inClose[i-2] ) - inLow[i-2] ) : 0 ) ) ) ;
         i++;
      }
      patternIdx = 0;
      patternResult = 0;
      i = startIdx - 3;
      while( i < startIdx ) {
         if( inHigh[i-2] < inHigh[i-3] && inLow[i-2] > inLow[i-3] &&
            inHigh[i-1] < inHigh[i-2] && inLow[i-1] > inLow[i-2] &&
            ( ( inHigh[i] < inHigh[i-1] && inLow[i] < inLow[i-1] &&
            inClose[i-2] <= inLow[i-2] + ( (this.candleSettings[CandleSettingType.Near.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) != 0.0? NearPeriodTotal / (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-2] - inLow[i-2] ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-2] - ( inClose[i-2] >= inOpen[i-2] ? inClose[i-2] : inOpen[i-2] ) ) + ( ( inClose[i-2] >= inOpen[i-2] ? inOpen[i-2] : inClose[i-2] ) - inLow[i-2] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) )
            )
            ||
            ( inHigh[i] > inHigh[i-1] && inLow[i] > inLow[i-1] &&
            inClose[i-2] >= inHigh[i-2] - ( (this.candleSettings[CandleSettingType.Near.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) != 0.0? NearPeriodTotal / (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-2] - inLow[i-2] ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-2] - ( inClose[i-2] >= inOpen[i-2] ? inClose[i-2] : inOpen[i-2] ) ) + ( ( inClose[i-2] >= inOpen[i-2] ? inOpen[i-2] : inClose[i-2] ) - inLow[i-2] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) )
            )
            )
            ) {
            patternResult = 100 * ( inHigh[i] < inHigh[i-1] ? 1 : -1 );
            patternIdx = i;
         } else
            if( i <= patternIdx+3 &&
            ( ( patternResult > 0 && inClose[i] > inHigh[patternIdx-1] )
            ||
            ( patternResult < 0 && inClose[i] < inLow[patternIdx-1] )
            )
            )
            patternIdx = 0;
         NearPeriodTotal += ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-2] - inLow[i-2] ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-2] - ( inClose[i-2] >= inOpen[i-2] ? inClose[i-2] : inOpen[i-2] ) ) + ( ( inClose[i-2] >= inOpen[i-2] ? inOpen[i-2] : inClose[i-2] ) - inLow[i-2] ) : 0 ) ) ) - ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[NearTrailingIdx-2] - inOpen[NearTrailingIdx-2] ) ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[NearTrailingIdx-2] - inLow[NearTrailingIdx-2] ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[NearTrailingIdx-2] - ( inClose[NearTrailingIdx-2] >= inOpen[NearTrailingIdx-2] ? inClose[NearTrailingIdx-2] : inOpen[NearTrailingIdx-2] ) ) + ( ( inClose[NearTrailingIdx-2] >= inOpen[NearTrailingIdx-2] ? inOpen[NearTrailingIdx-2] : inClose[NearTrailingIdx-2] ) - inLow[NearTrailingIdx-2] ) : 0 ) ) ) ;
         NearTrailingIdx++;
         i++;
      }
      i = startIdx;
      outIdx = 0;
      do
      {
         if( inHigh[i-2] < inHigh[i-3] && inLow[i-2] > inLow[i-3] &&
            inHigh[i-1] < inHigh[i-2] && inLow[i-1] > inLow[i-2] &&
            ( ( inHigh[i] < inHigh[i-1] && inLow[i] < inLow[i-1] &&
            inClose[i-2] <= inLow[i-2] + ( (this.candleSettings[CandleSettingType.Near.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) != 0.0? NearPeriodTotal / (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-2] - inLow[i-2] ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-2] - ( inClose[i-2] >= inOpen[i-2] ? inClose[i-2] : inOpen[i-2] ) ) + ( ( inClose[i-2] >= inOpen[i-2] ? inOpen[i-2] : inClose[i-2] ) - inLow[i-2] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) )
            )
            ||
            ( inHigh[i] > inHigh[i-1] && inLow[i] > inLow[i-1] &&
            inClose[i-2] >= inHigh[i-2] - ( (this.candleSettings[CandleSettingType.Near.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) != 0.0? NearPeriodTotal / (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-2] - inLow[i-2] ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-2] - ( inClose[i-2] >= inOpen[i-2] ? inClose[i-2] : inOpen[i-2] ) ) + ( ( inClose[i-2] >= inOpen[i-2] ? inOpen[i-2] : inClose[i-2] ) - inLow[i-2] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) )
            )
            )
            ) {
            patternResult = 100 * ( inHigh[i] < inHigh[i-1] ? 1 : -1 );
            patternIdx = i;
            outInteger[outIdx++] = patternResult;
         } else
            if( i <= patternIdx+3 &&
            ( ( patternResult > 0 && inClose[i] > inHigh[patternIdx-1] )
            ||
            ( patternResult < 0 && inClose[i] < inLow[patternIdx-1] )
            )
            ) {
            outInteger[outIdx++] = patternResult + 100 * ( patternResult > 0 ? 1 : -1 );
            patternIdx = 0;
         } else
            outInteger[outIdx++] = 0;
         NearPeriodTotal += ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-2] - inLow[i-2] ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-2] - ( inClose[i-2] >= inOpen[i-2] ? inClose[i-2] : inOpen[i-2] ) ) + ( ( inClose[i-2] >= inOpen[i-2] ? inOpen[i-2] : inClose[i-2] ) - inLow[i-2] ) : 0 ) ) ) - ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[NearTrailingIdx-2] - inOpen[NearTrailingIdx-2] ) ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[NearTrailingIdx-2] - inLow[NearTrailingIdx-2] ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[NearTrailingIdx-2] - ( inClose[NearTrailingIdx-2] >= inOpen[NearTrailingIdx-2] ? inClose[NearTrailingIdx-2] : inOpen[NearTrailingIdx-2] ) ) + ( ( inClose[NearTrailingIdx-2] >= inOpen[NearTrailingIdx-2] ? inOpen[NearTrailingIdx-2] : inClose[NearTrailingIdx-2] ) - inLow[NearTrailingIdx-2] ) : 0 ) ) ) ;
         NearTrailingIdx++;
         i++;
      } while( i <= endIdx );
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   /* Generated */
   public int cdlHomingPigeonLookback( )
   {
      return ((( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) ) > ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) )) ? ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) )) + 1;
   }
   public RetCode cdlHomingPigeon( int startIdx,
      int endIdx,
      double inOpen[],
      double inHigh[],
      double inLow[],
      double inClose[],
      MInteger outBegIdx,
      MInteger outNBElement,
      int outInteger[] )
   {
      double BodyShortPeriodTotal, BodyLongPeriodTotal;
      int i, outIdx, BodyShortTrailingIdx, BodyLongTrailingIdx, lookbackTotal;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      lookbackTotal = cdlHomingPigeonLookback ();
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      BodyLongPeriodTotal = 0;
      BodyShortPeriodTotal = 0;
      BodyLongTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) ;
      BodyShortTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) ;
      i = BodyLongTrailingIdx;
      while( i < startIdx ) {
         BodyLongPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ;
         i++;
      }
      i = BodyShortTrailingIdx;
      while( i < startIdx ) {
         BodyShortPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      i = startIdx;
      outIdx = 0;
      do
      {
         if( ( inClose[i-1] >= inOpen[i-1] ? 1 : -1 ) == -1 &&
            ( inClose[i] >= inOpen[i] ? 1 : -1 ) == -1 &&
            ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) > ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) != 0.0? BodyLongPeriodTotal / (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( Math.abs ( inClose[i] - inOpen[i] ) ) <= ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) != 0.0? BodyShortPeriodTotal / (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            inOpen[i] < inOpen[i-1] &&
            inClose[i] > inClose[i-1]
            )
            outInteger[outIdx++] = 100;
         else
            outInteger[outIdx++] = 0;
         BodyLongPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) - ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[BodyLongTrailingIdx-1] - inOpen[BodyLongTrailingIdx-1] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[BodyLongTrailingIdx-1] - inLow[BodyLongTrailingIdx-1] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[BodyLongTrailingIdx-1] - ( inClose[BodyLongTrailingIdx-1] >= inOpen[BodyLongTrailingIdx-1] ? inClose[BodyLongTrailingIdx-1] : inOpen[BodyLongTrailingIdx-1] ) ) + ( ( inClose[BodyLongTrailingIdx-1] >= inOpen[BodyLongTrailingIdx-1] ? inOpen[BodyLongTrailingIdx-1] : inClose[BodyLongTrailingIdx-1] ) - inLow[BodyLongTrailingIdx-1] ) : 0 ) ) ) ;
         BodyShortPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) - ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[BodyShortTrailingIdx] - inOpen[BodyShortTrailingIdx] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[BodyShortTrailingIdx] - inLow[BodyShortTrailingIdx] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[BodyShortTrailingIdx] - ( inClose[BodyShortTrailingIdx] >= inOpen[BodyShortTrailingIdx] ? inClose[BodyShortTrailingIdx] : inOpen[BodyShortTrailingIdx] ) ) + ( ( inClose[BodyShortTrailingIdx] >= inOpen[BodyShortTrailingIdx] ? inOpen[BodyShortTrailingIdx] : inClose[BodyShortTrailingIdx] ) - inLow[BodyShortTrailingIdx] ) : 0 ) ) ) ;
         i++;
         BodyLongTrailingIdx++;
         BodyShortTrailingIdx++;
      } while( i <= endIdx );
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   public int cdlHomingPigeonStateInit( struct TA_cdlHomingPigeon_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct cdlHomingPigeon ));
      _state.value .value .mem_index = 0;
      _state.value .value .mem_size = cdlHomingPigeonLookback ();
      if ( _state.value .value .mem_size > 0)
         _state.value .value .memory = TA_Calloc( _state.value .value .mem_size , sizeof(struct TA_CDLHOMINGPIGEON_Data));
      else
         _state.value .value .memory = NULL;
      return RetCode.Success ;
   }
   public int cdlHomingPigeonState( struct TA_cdlHomingPigeon_State* _state,
      double inOpen,
      double inHigh,
      double inLow,
      double inClose,
      int *outInteger )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      size_t _cur_idx = _state.value .mem_index++;
      if ( _state.value .mem_size > 0) _cur_idx %= _state.value .mem_size ;
      if ( _state.value .mem_size > _state.value .mem_index - 1 ) {
         ( _state.value .memory+_cur_idx).value .inOpen = inOpen ;
         ( _state.value .memory+_cur_idx).value .inHigh = inHigh ;
         ( _state.value .memory+_cur_idx).value .inLow = inLow ;
         ( _state.value .memory+_cur_idx).value .inClose = inClose ;
         return RetCode.NeedMoreData ; }
      return RetCode.Success ;
   }
   public int cdlHomingPigeonStateFree( struct TA_cdlHomingPigeon_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if ( _state.value != NULL) {
         if ( _state.value .value .memory != NULL) TA_Free( _state.value .value .memory );
         TA_Free( _state.value ); _state.value = NULL;}
      return RetCode.Success ;
   }
   public RetCode cdlHomingPigeon( int startIdx,
      int endIdx,
      float inOpen[],
      float inHigh[],
      float inLow[],
      float inClose[],
      MInteger outBegIdx,
      MInteger outNBElement,
      int outInteger[] )
   {
      double BodyShortPeriodTotal, BodyLongPeriodTotal;
      int i, outIdx, BodyShortTrailingIdx, BodyLongTrailingIdx, lookbackTotal;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      lookbackTotal = cdlHomingPigeonLookback ();
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      BodyLongPeriodTotal = 0;
      BodyShortPeriodTotal = 0;
      BodyLongTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) ;
      BodyShortTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) ;
      i = BodyLongTrailingIdx;
      while( i < startIdx ) {
         BodyLongPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ;
         i++;
      }
      i = BodyShortTrailingIdx;
      while( i < startIdx ) {
         BodyShortPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      i = startIdx;
      outIdx = 0;
      do
      {
         if( ( inClose[i-1] >= inOpen[i-1] ? 1 : -1 ) == -1 &&
            ( inClose[i] >= inOpen[i] ? 1 : -1 ) == -1 &&
            ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) > ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) != 0.0? BodyLongPeriodTotal / (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( Math.abs ( inClose[i] - inOpen[i] ) ) <= ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) != 0.0? BodyShortPeriodTotal / (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            inOpen[i] < inOpen[i-1] &&
            inClose[i] > inClose[i-1]
            )
            outInteger[outIdx++] = 100;
         else
            outInteger[outIdx++] = 0;
         BodyLongPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) - ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[BodyLongTrailingIdx-1] - inOpen[BodyLongTrailingIdx-1] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[BodyLongTrailingIdx-1] - inLow[BodyLongTrailingIdx-1] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[BodyLongTrailingIdx-1] - ( inClose[BodyLongTrailingIdx-1] >= inOpen[BodyLongTrailingIdx-1] ? inClose[BodyLongTrailingIdx-1] : inOpen[BodyLongTrailingIdx-1] ) ) + ( ( inClose[BodyLongTrailingIdx-1] >= inOpen[BodyLongTrailingIdx-1] ? inOpen[BodyLongTrailingIdx-1] : inClose[BodyLongTrailingIdx-1] ) - inLow[BodyLongTrailingIdx-1] ) : 0 ) ) ) ;
         BodyShortPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) - ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[BodyShortTrailingIdx] - inOpen[BodyShortTrailingIdx] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[BodyShortTrailingIdx] - inLow[BodyShortTrailingIdx] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[BodyShortTrailingIdx] - ( inClose[BodyShortTrailingIdx] >= inOpen[BodyShortTrailingIdx] ? inClose[BodyShortTrailingIdx] : inOpen[BodyShortTrailingIdx] ) ) + ( ( inClose[BodyShortTrailingIdx] >= inOpen[BodyShortTrailingIdx] ? inOpen[BodyShortTrailingIdx] : inClose[BodyShortTrailingIdx] ) - inLow[BodyShortTrailingIdx] ) : 0 ) ) ) ;
         i++;
         BodyLongTrailingIdx++;
         BodyShortTrailingIdx++;
      } while( i <= endIdx );
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   /* Generated */
   public int cdlIdentical3CrowsLookback( )
   {
      return ((( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) ) > ( (this.candleSettings[CandleSettingType.Equal.ordinal()].avgPeriod) )) ? ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].avgPeriod) )) +
         2;
   }
   public RetCode cdlIdentical3Crows( int startIdx,
      int endIdx,
      double inOpen[],
      double inHigh[],
      double inLow[],
      double inClose[],
      MInteger outBegIdx,
      MInteger outNBElement,
      int outInteger[] )
   {
      double []ShadowVeryShortPeriodTotal = new double[3] ;
      double []EqualPeriodTotal = new double[3] ;
      int i, outIdx, totIdx, ShadowVeryShortTrailingIdx, EqualTrailingIdx, lookbackTotal;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      lookbackTotal = cdlIdentical3CrowsLookback ();
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      ShadowVeryShortPeriodTotal[2] = 0;
      ShadowVeryShortPeriodTotal[1] = 0;
      ShadowVeryShortPeriodTotal[0] = 0;
      ShadowVeryShortTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) ;
      EqualPeriodTotal[2] = 0;
      EqualPeriodTotal[1] = 0;
      EqualPeriodTotal[0] = 0;
      EqualTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.Equal.ordinal()].avgPeriod) ;
      i = ShadowVeryShortTrailingIdx;
      while( i < startIdx ) {
         ShadowVeryShortPeriodTotal[2] += ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-2] - inLow[i-2] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-2] - ( inClose[i-2] >= inOpen[i-2] ? inClose[i-2] : inOpen[i-2] ) ) + ( ( inClose[i-2] >= inOpen[i-2] ? inOpen[i-2] : inClose[i-2] ) - inLow[i-2] ) : 0 ) ) ) ;
         ShadowVeryShortPeriodTotal[1] += ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ;
         ShadowVeryShortPeriodTotal[0] += ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      i = EqualTrailingIdx;
      while( i < startIdx ) {
         EqualPeriodTotal[2] += ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-2] - inLow[i-2] ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-2] - ( inClose[i-2] >= inOpen[i-2] ? inClose[i-2] : inOpen[i-2] ) ) + ( ( inClose[i-2] >= inOpen[i-2] ? inOpen[i-2] : inClose[i-2] ) - inLow[i-2] ) : 0 ) ) ) ;
         EqualPeriodTotal[1] += ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ;
         i++;
      }
      i = startIdx;
      outIdx = 0;
      do
      {
         if( ( inClose[i-2] >= inOpen[i-2] ? 1 : -1 ) == -1 &&
            ( ( inClose[i-2] >= inOpen[i-2] ? inOpen[i-2] : inClose[i-2] ) - inLow[i-2] ) < ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) != 0.0? ShadowVeryShortPeriodTotal[2] / (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-2] - inLow[i-2] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-2] - ( inClose[i-2] >= inOpen[i-2] ? inClose[i-2] : inOpen[i-2] ) ) + ( ( inClose[i-2] >= inOpen[i-2] ? inOpen[i-2] : inClose[i-2] ) - inLow[i-2] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( inClose[i-1] >= inOpen[i-1] ? 1 : -1 ) == -1 &&
            ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) < ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) != 0.0? ShadowVeryShortPeriodTotal[1] / (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( inClose[i] >= inOpen[i] ? 1 : -1 ) == -1 &&
            ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) < ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) != 0.0? ShadowVeryShortPeriodTotal[0] / (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            inClose[i-2] > inClose[i-1] &&
            inClose[i-1] > inClose[i] &&
            inOpen[i-1] <= inClose[i-2] + ( (this.candleSettings[CandleSettingType.Equal.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.Equal.ordinal()].avgPeriod) != 0.0? EqualPeriodTotal[2] / (this.candleSettings[CandleSettingType.Equal.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-2] - inLow[i-2] ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-2] - ( inClose[i-2] >= inOpen[i-2] ? inClose[i-2] : inOpen[i-2] ) ) + ( ( inClose[i-2] >= inOpen[i-2] ? inOpen[i-2] : inClose[i-2] ) - inLow[i-2] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            inOpen[i-1] >= inClose[i-2] - ( (this.candleSettings[CandleSettingType.Equal.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.Equal.ordinal()].avgPeriod) != 0.0? EqualPeriodTotal[2] / (this.candleSettings[CandleSettingType.Equal.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-2] - inLow[i-2] ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-2] - ( inClose[i-2] >= inOpen[i-2] ? inClose[i-2] : inOpen[i-2] ) ) + ( ( inClose[i-2] >= inOpen[i-2] ? inOpen[i-2] : inClose[i-2] ) - inLow[i-2] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            inOpen[i] <= inClose[i-1] + ( (this.candleSettings[CandleSettingType.Equal.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.Equal.ordinal()].avgPeriod) != 0.0? EqualPeriodTotal[1] / (this.candleSettings[CandleSettingType.Equal.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            inOpen[i] >= inClose[i-1] - ( (this.candleSettings[CandleSettingType.Equal.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.Equal.ordinal()].avgPeriod) != 0.0? EqualPeriodTotal[1] / (this.candleSettings[CandleSettingType.Equal.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) )
            )
            outInteger[outIdx++] = -100;
         else
            outInteger[outIdx++] = 0;
         for (totIdx = 2; totIdx >= 0; --totIdx)
            ShadowVeryShortPeriodTotal[totIdx] += ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-totIdx] - inOpen[i-totIdx] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-totIdx] - inLow[i-totIdx] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-totIdx] - ( inClose[i-totIdx] >= inOpen[i-totIdx] ? inClose[i-totIdx] : inOpen[i-totIdx] ) ) + ( ( inClose[i-totIdx] >= inOpen[i-totIdx] ? inOpen[i-totIdx] : inClose[i-totIdx] ) - inLow[i-totIdx] ) : 0 ) ) )
            - ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[ShadowVeryShortTrailingIdx-totIdx] - inOpen[ShadowVeryShortTrailingIdx-totIdx] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[ShadowVeryShortTrailingIdx-totIdx] - inLow[ShadowVeryShortTrailingIdx-totIdx] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[ShadowVeryShortTrailingIdx-totIdx] - ( inClose[ShadowVeryShortTrailingIdx-totIdx] >= inOpen[ShadowVeryShortTrailingIdx-totIdx] ? inClose[ShadowVeryShortTrailingIdx-totIdx] : inOpen[ShadowVeryShortTrailingIdx-totIdx] ) ) + ( ( inClose[ShadowVeryShortTrailingIdx-totIdx] >= inOpen[ShadowVeryShortTrailingIdx-totIdx] ? inOpen[ShadowVeryShortTrailingIdx-totIdx] : inClose[ShadowVeryShortTrailingIdx-totIdx] ) - inLow[ShadowVeryShortTrailingIdx-totIdx] ) : 0 ) ) ) ;
         for (totIdx = 2; totIdx >= 1; --totIdx)
            EqualPeriodTotal[totIdx] += ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-totIdx] - inOpen[i-totIdx] ) ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-totIdx] - inLow[i-totIdx] ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-totIdx] - ( inClose[i-totIdx] >= inOpen[i-totIdx] ? inClose[i-totIdx] : inOpen[i-totIdx] ) ) + ( ( inClose[i-totIdx] >= inOpen[i-totIdx] ? inOpen[i-totIdx] : inClose[i-totIdx] ) - inLow[i-totIdx] ) : 0 ) ) )
            - ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[EqualTrailingIdx-totIdx] - inOpen[EqualTrailingIdx-totIdx] ) ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[EqualTrailingIdx-totIdx] - inLow[EqualTrailingIdx-totIdx] ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[EqualTrailingIdx-totIdx] - ( inClose[EqualTrailingIdx-totIdx] >= inOpen[EqualTrailingIdx-totIdx] ? inClose[EqualTrailingIdx-totIdx] : inOpen[EqualTrailingIdx-totIdx] ) ) + ( ( inClose[EqualTrailingIdx-totIdx] >= inOpen[EqualTrailingIdx-totIdx] ? inOpen[EqualTrailingIdx-totIdx] : inClose[EqualTrailingIdx-totIdx] ) - inLow[EqualTrailingIdx-totIdx] ) : 0 ) ) ) ;
         i++;
         ShadowVeryShortTrailingIdx++;
         EqualTrailingIdx++;
      } while( i <= endIdx );
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   public int cdlIdentical3CrowsStateInit( struct TA_cdlIdentical3Crows_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct cdlIdentical3Crows ));
      _state.value .value .mem_index = 0;
      _state.value .value .mem_size = cdlIdentical3CrowsLookback ();
      if ( _state.value .value .mem_size > 0)
         _state.value .value .memory = TA_Calloc( _state.value .value .mem_size , sizeof(struct TA_CDLIDENTICAL3CROWS_Data));
      else
         _state.value .value .memory = NULL;
      return RetCode.Success ;
   }
   public int cdlIdentical3CrowsState( struct TA_cdlIdentical3Crows_State* _state,
      double inOpen,
      double inHigh,
      double inLow,
      double inClose,
      int *outInteger )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      size_t _cur_idx = _state.value .mem_index++;
      if ( _state.value .mem_size > 0) _cur_idx %= _state.value .mem_size ;
      if ( _state.value .mem_size > _state.value .mem_index - 1 ) {
         ( _state.value .memory+_cur_idx).value .inOpen = inOpen ;
         ( _state.value .memory+_cur_idx).value .inHigh = inHigh ;
         ( _state.value .memory+_cur_idx).value .inLow = inLow ;
         ( _state.value .memory+_cur_idx).value .inClose = inClose ;
         return RetCode.NeedMoreData ; }
      return RetCode.Success ;
   }
   public int cdlIdentical3CrowsStateFree( struct TA_cdlIdentical3Crows_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if ( _state.value != NULL) {
         if ( _state.value .value .memory != NULL) TA_Free( _state.value .value .memory );
         TA_Free( _state.value ); _state.value = NULL;}
      return RetCode.Success ;
   }
   public RetCode cdlIdentical3Crows( int startIdx,
      int endIdx,
      float inOpen[],
      float inHigh[],
      float inLow[],
      float inClose[],
      MInteger outBegIdx,
      MInteger outNBElement,
      int outInteger[] )
   {
      double []ShadowVeryShortPeriodTotal = new double[3] ;
      double []EqualPeriodTotal = new double[3] ;
      int i, outIdx, totIdx, ShadowVeryShortTrailingIdx, EqualTrailingIdx, lookbackTotal;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      lookbackTotal = cdlIdentical3CrowsLookback ();
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      ShadowVeryShortPeriodTotal[2] = 0;
      ShadowVeryShortPeriodTotal[1] = 0;
      ShadowVeryShortPeriodTotal[0] = 0;
      ShadowVeryShortTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) ;
      EqualPeriodTotal[2] = 0;
      EqualPeriodTotal[1] = 0;
      EqualPeriodTotal[0] = 0;
      EqualTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.Equal.ordinal()].avgPeriod) ;
      i = ShadowVeryShortTrailingIdx;
      while( i < startIdx ) {
         ShadowVeryShortPeriodTotal[2] += ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-2] - inLow[i-2] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-2] - ( inClose[i-2] >= inOpen[i-2] ? inClose[i-2] : inOpen[i-2] ) ) + ( ( inClose[i-2] >= inOpen[i-2] ? inOpen[i-2] : inClose[i-2] ) - inLow[i-2] ) : 0 ) ) ) ;
         ShadowVeryShortPeriodTotal[1] += ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ;
         ShadowVeryShortPeriodTotal[0] += ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      i = EqualTrailingIdx;
      while( i < startIdx ) {
         EqualPeriodTotal[2] += ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-2] - inLow[i-2] ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-2] - ( inClose[i-2] >= inOpen[i-2] ? inClose[i-2] : inOpen[i-2] ) ) + ( ( inClose[i-2] >= inOpen[i-2] ? inOpen[i-2] : inClose[i-2] ) - inLow[i-2] ) : 0 ) ) ) ;
         EqualPeriodTotal[1] += ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ;
         i++;
      }
      i = startIdx;
      outIdx = 0;
      do
      {
         if( ( inClose[i-2] >= inOpen[i-2] ? 1 : -1 ) == -1 &&
            ( ( inClose[i-2] >= inOpen[i-2] ? inOpen[i-2] : inClose[i-2] ) - inLow[i-2] ) < ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) != 0.0? ShadowVeryShortPeriodTotal[2] / (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-2] - inLow[i-2] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-2] - ( inClose[i-2] >= inOpen[i-2] ? inClose[i-2] : inOpen[i-2] ) ) + ( ( inClose[i-2] >= inOpen[i-2] ? inOpen[i-2] : inClose[i-2] ) - inLow[i-2] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( inClose[i-1] >= inOpen[i-1] ? 1 : -1 ) == -1 &&
            ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) < ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) != 0.0? ShadowVeryShortPeriodTotal[1] / (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( inClose[i] >= inOpen[i] ? 1 : -1 ) == -1 &&
            ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) < ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) != 0.0? ShadowVeryShortPeriodTotal[0] / (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            inClose[i-2] > inClose[i-1] &&
            inClose[i-1] > inClose[i] &&
            inOpen[i-1] <= inClose[i-2] + ( (this.candleSettings[CandleSettingType.Equal.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.Equal.ordinal()].avgPeriod) != 0.0? EqualPeriodTotal[2] / (this.candleSettings[CandleSettingType.Equal.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-2] - inLow[i-2] ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-2] - ( inClose[i-2] >= inOpen[i-2] ? inClose[i-2] : inOpen[i-2] ) ) + ( ( inClose[i-2] >= inOpen[i-2] ? inOpen[i-2] : inClose[i-2] ) - inLow[i-2] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            inOpen[i-1] >= inClose[i-2] - ( (this.candleSettings[CandleSettingType.Equal.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.Equal.ordinal()].avgPeriod) != 0.0? EqualPeriodTotal[2] / (this.candleSettings[CandleSettingType.Equal.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-2] - inLow[i-2] ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-2] - ( inClose[i-2] >= inOpen[i-2] ? inClose[i-2] : inOpen[i-2] ) ) + ( ( inClose[i-2] >= inOpen[i-2] ? inOpen[i-2] : inClose[i-2] ) - inLow[i-2] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            inOpen[i] <= inClose[i-1] + ( (this.candleSettings[CandleSettingType.Equal.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.Equal.ordinal()].avgPeriod) != 0.0? EqualPeriodTotal[1] / (this.candleSettings[CandleSettingType.Equal.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            inOpen[i] >= inClose[i-1] - ( (this.candleSettings[CandleSettingType.Equal.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.Equal.ordinal()].avgPeriod) != 0.0? EqualPeriodTotal[1] / (this.candleSettings[CandleSettingType.Equal.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) )
            )
            outInteger[outIdx++] = -100;
         else
            outInteger[outIdx++] = 0;
         for (totIdx = 2; totIdx >= 0; --totIdx)
            ShadowVeryShortPeriodTotal[totIdx] += ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-totIdx] - inOpen[i-totIdx] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-totIdx] - inLow[i-totIdx] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-totIdx] - ( inClose[i-totIdx] >= inOpen[i-totIdx] ? inClose[i-totIdx] : inOpen[i-totIdx] ) ) + ( ( inClose[i-totIdx] >= inOpen[i-totIdx] ? inOpen[i-totIdx] : inClose[i-totIdx] ) - inLow[i-totIdx] ) : 0 ) ) )
            - ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[ShadowVeryShortTrailingIdx-totIdx] - inOpen[ShadowVeryShortTrailingIdx-totIdx] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[ShadowVeryShortTrailingIdx-totIdx] - inLow[ShadowVeryShortTrailingIdx-totIdx] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[ShadowVeryShortTrailingIdx-totIdx] - ( inClose[ShadowVeryShortTrailingIdx-totIdx] >= inOpen[ShadowVeryShortTrailingIdx-totIdx] ? inClose[ShadowVeryShortTrailingIdx-totIdx] : inOpen[ShadowVeryShortTrailingIdx-totIdx] ) ) + ( ( inClose[ShadowVeryShortTrailingIdx-totIdx] >= inOpen[ShadowVeryShortTrailingIdx-totIdx] ? inOpen[ShadowVeryShortTrailingIdx-totIdx] : inClose[ShadowVeryShortTrailingIdx-totIdx] ) - inLow[ShadowVeryShortTrailingIdx-totIdx] ) : 0 ) ) ) ;
         for (totIdx = 2; totIdx >= 1; --totIdx)
            EqualPeriodTotal[totIdx] += ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-totIdx] - inOpen[i-totIdx] ) ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-totIdx] - inLow[i-totIdx] ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-totIdx] - ( inClose[i-totIdx] >= inOpen[i-totIdx] ? inClose[i-totIdx] : inOpen[i-totIdx] ) ) + ( ( inClose[i-totIdx] >= inOpen[i-totIdx] ? inOpen[i-totIdx] : inClose[i-totIdx] ) - inLow[i-totIdx] ) : 0 ) ) )
            - ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[EqualTrailingIdx-totIdx] - inOpen[EqualTrailingIdx-totIdx] ) ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[EqualTrailingIdx-totIdx] - inLow[EqualTrailingIdx-totIdx] ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[EqualTrailingIdx-totIdx] - ( inClose[EqualTrailingIdx-totIdx] >= inOpen[EqualTrailingIdx-totIdx] ? inClose[EqualTrailingIdx-totIdx] : inOpen[EqualTrailingIdx-totIdx] ) ) + ( ( inClose[EqualTrailingIdx-totIdx] >= inOpen[EqualTrailingIdx-totIdx] ? inOpen[EqualTrailingIdx-totIdx] : inClose[EqualTrailingIdx-totIdx] ) - inLow[EqualTrailingIdx-totIdx] ) : 0 ) ) ) ;
         i++;
         ShadowVeryShortTrailingIdx++;
         EqualTrailingIdx++;
      } while( i <= endIdx );
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   /* Generated */
   public int cdlInNeckLookback( )
   {
      return ((( (this.candleSettings[CandleSettingType.Equal.ordinal()].avgPeriod) ) > ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) )) ? ( (this.candleSettings[CandleSettingType.Equal.ordinal()].avgPeriod) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) )) +
         1;
   }
   public RetCode cdlInNeck( int startIdx,
      int endIdx,
      double inOpen[],
      double inHigh[],
      double inLow[],
      double inClose[],
      MInteger outBegIdx,
      MInteger outNBElement,
      int outInteger[] )
   {
      double EqualPeriodTotal, BodyLongPeriodTotal;
      int i, outIdx, EqualTrailingIdx, BodyLongTrailingIdx, lookbackTotal;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      lookbackTotal = cdlInNeckLookback ();
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      EqualPeriodTotal = 0;
      EqualTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.Equal.ordinal()].avgPeriod) ;
      BodyLongPeriodTotal = 0;
      BodyLongTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) ;
      i = EqualTrailingIdx;
      while( i < startIdx ) {
         EqualPeriodTotal += ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ;
         i++;
      }
      i = BodyLongTrailingIdx;
      while( i < startIdx ) {
         BodyLongPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ;
         i++;
      }
      i = startIdx;
      outIdx = 0;
      do
      {
         if( ( inClose[i-1] >= inOpen[i-1] ? 1 : -1 ) == -1 &&
            ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) > ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) != 0.0? BodyLongPeriodTotal / (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( inClose[i] >= inOpen[i] ? 1 : -1 ) == 1 &&
            inOpen[i] < inLow[i-1] &&
            inClose[i] <= inClose[i-1] + ( (this.candleSettings[CandleSettingType.Equal.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.Equal.ordinal()].avgPeriod) != 0.0? EqualPeriodTotal / (this.candleSettings[CandleSettingType.Equal.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            inClose[i] >= inClose[i-1]
            )
            outInteger[outIdx++] = -100;
         else
            outInteger[outIdx++] = 0;
         EqualPeriodTotal += ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) - ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[EqualTrailingIdx-1] - inOpen[EqualTrailingIdx-1] ) ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[EqualTrailingIdx-1] - inLow[EqualTrailingIdx-1] ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[EqualTrailingIdx-1] - ( inClose[EqualTrailingIdx-1] >= inOpen[EqualTrailingIdx-1] ? inClose[EqualTrailingIdx-1] : inOpen[EqualTrailingIdx-1] ) ) + ( ( inClose[EqualTrailingIdx-1] >= inOpen[EqualTrailingIdx-1] ? inOpen[EqualTrailingIdx-1] : inClose[EqualTrailingIdx-1] ) - inLow[EqualTrailingIdx-1] ) : 0 ) ) ) ;
         BodyLongPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) )
            - ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[BodyLongTrailingIdx-1] - inOpen[BodyLongTrailingIdx-1] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[BodyLongTrailingIdx-1] - inLow[BodyLongTrailingIdx-1] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[BodyLongTrailingIdx-1] - ( inClose[BodyLongTrailingIdx-1] >= inOpen[BodyLongTrailingIdx-1] ? inClose[BodyLongTrailingIdx-1] : inOpen[BodyLongTrailingIdx-1] ) ) + ( ( inClose[BodyLongTrailingIdx-1] >= inOpen[BodyLongTrailingIdx-1] ? inOpen[BodyLongTrailingIdx-1] : inClose[BodyLongTrailingIdx-1] ) - inLow[BodyLongTrailingIdx-1] ) : 0 ) ) ) ;
         i++;
         EqualTrailingIdx++;
         BodyLongTrailingIdx++;
      } while( i <= endIdx );
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   public int cdlInNeckStateInit( struct TA_cdlInNeck_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct cdlInNeck ));
      _state.value .value .mem_index = 0;
      _state.value .value .mem_size = cdlInNeckLookback ();
      if ( _state.value .value .mem_size > 0)
         _state.value .value .memory = TA_Calloc( _state.value .value .mem_size , sizeof(struct TA_CDLINNECK_Data));
      else
         _state.value .value .memory = NULL;
      return RetCode.Success ;
   }
   public int cdlInNeckState( struct TA_cdlInNeck_State* _state,
      double inOpen,
      double inHigh,
      double inLow,
      double inClose,
      int *outInteger )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      size_t _cur_idx = _state.value .mem_index++;
      if ( _state.value .mem_size > 0) _cur_idx %= _state.value .mem_size ;
      if ( _state.value .mem_size > _state.value .mem_index - 1 ) {
         ( _state.value .memory+_cur_idx).value .inOpen = inOpen ;
         ( _state.value .memory+_cur_idx).value .inHigh = inHigh ;
         ( _state.value .memory+_cur_idx).value .inLow = inLow ;
         ( _state.value .memory+_cur_idx).value .inClose = inClose ;
         return RetCode.NeedMoreData ; }
      return RetCode.Success ;
   }
   public int cdlInNeckStateFree( struct TA_cdlInNeck_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if ( _state.value != NULL) {
         if ( _state.value .value .memory != NULL) TA_Free( _state.value .value .memory );
         TA_Free( _state.value ); _state.value = NULL;}
      return RetCode.Success ;
   }
   public RetCode cdlInNeck( int startIdx,
      int endIdx,
      float inOpen[],
      float inHigh[],
      float inLow[],
      float inClose[],
      MInteger outBegIdx,
      MInteger outNBElement,
      int outInteger[] )
   {
      double EqualPeriodTotal, BodyLongPeriodTotal;
      int i, outIdx, EqualTrailingIdx, BodyLongTrailingIdx, lookbackTotal;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      lookbackTotal = cdlInNeckLookback ();
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      EqualPeriodTotal = 0;
      EqualTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.Equal.ordinal()].avgPeriod) ;
      BodyLongPeriodTotal = 0;
      BodyLongTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) ;
      i = EqualTrailingIdx;
      while( i < startIdx ) {
         EqualPeriodTotal += ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ;
         i++;
      }
      i = BodyLongTrailingIdx;
      while( i < startIdx ) {
         BodyLongPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ;
         i++;
      }
      i = startIdx;
      outIdx = 0;
      do
      {
         if( ( inClose[i-1] >= inOpen[i-1] ? 1 : -1 ) == -1 &&
            ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) > ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) != 0.0? BodyLongPeriodTotal / (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( inClose[i] >= inOpen[i] ? 1 : -1 ) == 1 &&
            inOpen[i] < inLow[i-1] &&
            inClose[i] <= inClose[i-1] + ( (this.candleSettings[CandleSettingType.Equal.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.Equal.ordinal()].avgPeriod) != 0.0? EqualPeriodTotal / (this.candleSettings[CandleSettingType.Equal.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            inClose[i] >= inClose[i-1]
            )
            outInteger[outIdx++] = -100;
         else
            outInteger[outIdx++] = 0;
         EqualPeriodTotal += ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) - ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[EqualTrailingIdx-1] - inOpen[EqualTrailingIdx-1] ) ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[EqualTrailingIdx-1] - inLow[EqualTrailingIdx-1] ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[EqualTrailingIdx-1] - ( inClose[EqualTrailingIdx-1] >= inOpen[EqualTrailingIdx-1] ? inClose[EqualTrailingIdx-1] : inOpen[EqualTrailingIdx-1] ) ) + ( ( inClose[EqualTrailingIdx-1] >= inOpen[EqualTrailingIdx-1] ? inOpen[EqualTrailingIdx-1] : inClose[EqualTrailingIdx-1] ) - inLow[EqualTrailingIdx-1] ) : 0 ) ) ) ;
         BodyLongPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) )
            - ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[BodyLongTrailingIdx-1] - inOpen[BodyLongTrailingIdx-1] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[BodyLongTrailingIdx-1] - inLow[BodyLongTrailingIdx-1] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[BodyLongTrailingIdx-1] - ( inClose[BodyLongTrailingIdx-1] >= inOpen[BodyLongTrailingIdx-1] ? inClose[BodyLongTrailingIdx-1] : inOpen[BodyLongTrailingIdx-1] ) ) + ( ( inClose[BodyLongTrailingIdx-1] >= inOpen[BodyLongTrailingIdx-1] ? inOpen[BodyLongTrailingIdx-1] : inClose[BodyLongTrailingIdx-1] ) - inLow[BodyLongTrailingIdx-1] ) : 0 ) ) ) ;
         i++;
         EqualTrailingIdx++;
         BodyLongTrailingIdx++;
      } while( i <= endIdx );
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   /* Generated */
   public int cdlInvertedHammerLookback( )
   {
      return ((( ((( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) ) > ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].avgPeriod) )) ? ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].avgPeriod) )) ) > ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) )) ? ( ((( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) ) > ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].avgPeriod) )) ? ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].avgPeriod) )) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) )) +
         1;
   }
   public RetCode cdlInvertedHammer( int startIdx,
      int endIdx,
      double inOpen[],
      double inHigh[],
      double inLow[],
      double inClose[],
      MInteger outBegIdx,
      MInteger outNBElement,
      int outInteger[] )
   {
      double BodyPeriodTotal, ShadowLongPeriodTotal, ShadowVeryShortPeriodTotal;
      int i, outIdx, BodyTrailingIdx, ShadowLongTrailingIdx, ShadowVeryShortTrailingIdx, lookbackTotal;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      lookbackTotal = cdlInvertedHammerLookback ();
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      BodyPeriodTotal = 0;
      BodyTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) ;
      ShadowLongPeriodTotal = 0;
      ShadowLongTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].avgPeriod) ;
      ShadowVeryShortPeriodTotal = 0;
      ShadowVeryShortTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) ;
      i = BodyTrailingIdx;
      while( i < startIdx ) {
         BodyPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      i = ShadowLongTrailingIdx;
      while( i < startIdx ) {
         ShadowLongPeriodTotal += ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      i = ShadowVeryShortTrailingIdx;
      while( i < startIdx ) {
         ShadowVeryShortPeriodTotal += ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      outIdx = 0;
      do
      {
         if( ( Math.abs ( inClose[i] - inOpen[i] ) ) < ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) != 0.0? BodyPeriodTotal / (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) > ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].avgPeriod) != 0.0? ShadowLongPeriodTotal / (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) < ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) != 0.0? ShadowVeryShortPeriodTotal / (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( (((inOpen[i]) > (inClose[i])) ? (inOpen[i]) : (inClose[i])) < (((inOpen[i-1]) < (inClose[i-1])) ? (inOpen[i-1]) : (inClose[i-1])) ) )
            outInteger[outIdx++] = 100;
         else
            outInteger[outIdx++] = 0;
         BodyPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) )
            - ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[BodyTrailingIdx] - inOpen[BodyTrailingIdx] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[BodyTrailingIdx] - inLow[BodyTrailingIdx] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[BodyTrailingIdx] - ( inClose[BodyTrailingIdx] >= inOpen[BodyTrailingIdx] ? inClose[BodyTrailingIdx] : inOpen[BodyTrailingIdx] ) ) + ( ( inClose[BodyTrailingIdx] >= inOpen[BodyTrailingIdx] ? inOpen[BodyTrailingIdx] : inClose[BodyTrailingIdx] ) - inLow[BodyTrailingIdx] ) : 0 ) ) ) ;
         ShadowLongPeriodTotal += ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) )
            - ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[ShadowLongTrailingIdx] - inOpen[ShadowLongTrailingIdx] ) ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[ShadowLongTrailingIdx] - inLow[ShadowLongTrailingIdx] ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[ShadowLongTrailingIdx] - ( inClose[ShadowLongTrailingIdx] >= inOpen[ShadowLongTrailingIdx] ? inClose[ShadowLongTrailingIdx] : inOpen[ShadowLongTrailingIdx] ) ) + ( ( inClose[ShadowLongTrailingIdx] >= inOpen[ShadowLongTrailingIdx] ? inOpen[ShadowLongTrailingIdx] : inClose[ShadowLongTrailingIdx] ) - inLow[ShadowLongTrailingIdx] ) : 0 ) ) ) ;
         ShadowVeryShortPeriodTotal += ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) )
            - ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[ShadowVeryShortTrailingIdx] - inOpen[ShadowVeryShortTrailingIdx] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[ShadowVeryShortTrailingIdx] - inLow[ShadowVeryShortTrailingIdx] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[ShadowVeryShortTrailingIdx] - ( inClose[ShadowVeryShortTrailingIdx] >= inOpen[ShadowVeryShortTrailingIdx] ? inClose[ShadowVeryShortTrailingIdx] : inOpen[ShadowVeryShortTrailingIdx] ) ) + ( ( inClose[ShadowVeryShortTrailingIdx] >= inOpen[ShadowVeryShortTrailingIdx] ? inOpen[ShadowVeryShortTrailingIdx] : inClose[ShadowVeryShortTrailingIdx] ) - inLow[ShadowVeryShortTrailingIdx] ) : 0 ) ) ) ;
         i++;
         BodyTrailingIdx++;
         ShadowLongTrailingIdx++;
         ShadowVeryShortTrailingIdx++;
      } while( i <= endIdx );
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   public int cdlInvertedHammerStateInit( struct TA_cdlInvertedHammer_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct cdlInvertedHammer ));
      _state.value .value .mem_index = 0;
      _state.value .value .mem_size = cdlInvertedHammerLookback ();
      if ( _state.value .value .mem_size > 0)
         _state.value .value .memory = TA_Calloc( _state.value .value .mem_size , sizeof(struct TA_CDLINVERTEDHAMMER_Data));
      else
         _state.value .value .memory = NULL;
      return RetCode.Success ;
   }
   public int cdlInvertedHammerState( struct TA_cdlInvertedHammer_State* _state,
      double inOpen,
      double inHigh,
      double inLow,
      double inClose,
      int *outInteger )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      size_t _cur_idx = _state.value .mem_index++;
      if ( _state.value .mem_size > 0) _cur_idx %= _state.value .mem_size ;
      if ( _state.value .mem_size > _state.value .mem_index - 1 ) {
         ( _state.value .memory+_cur_idx).value .inOpen = inOpen ;
         ( _state.value .memory+_cur_idx).value .inHigh = inHigh ;
         ( _state.value .memory+_cur_idx).value .inLow = inLow ;
         ( _state.value .memory+_cur_idx).value .inClose = inClose ;
         return RetCode.NeedMoreData ; }
      return RetCode.Success ;
   }
   public int cdlInvertedHammerStateFree( struct TA_cdlInvertedHammer_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if ( _state.value != NULL) {
         if ( _state.value .value .memory != NULL) TA_Free( _state.value .value .memory );
         TA_Free( _state.value ); _state.value = NULL;}
      return RetCode.Success ;
   }
   public RetCode cdlInvertedHammer( int startIdx,
      int endIdx,
      float inOpen[],
      float inHigh[],
      float inLow[],
      float inClose[],
      MInteger outBegIdx,
      MInteger outNBElement,
      int outInteger[] )
   {
      double BodyPeriodTotal, ShadowLongPeriodTotal, ShadowVeryShortPeriodTotal;
      int i, outIdx, BodyTrailingIdx, ShadowLongTrailingIdx, ShadowVeryShortTrailingIdx, lookbackTotal;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      lookbackTotal = cdlInvertedHammerLookback ();
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      BodyPeriodTotal = 0;
      BodyTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) ;
      ShadowLongPeriodTotal = 0;
      ShadowLongTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].avgPeriod) ;
      ShadowVeryShortPeriodTotal = 0;
      ShadowVeryShortTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) ;
      i = BodyTrailingIdx;
      while( i < startIdx ) {
         BodyPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      i = ShadowLongTrailingIdx;
      while( i < startIdx ) {
         ShadowLongPeriodTotal += ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      i = ShadowVeryShortTrailingIdx;
      while( i < startIdx ) {
         ShadowVeryShortPeriodTotal += ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      outIdx = 0;
      do
      {
         if( ( Math.abs ( inClose[i] - inOpen[i] ) ) < ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) != 0.0? BodyPeriodTotal / (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) > ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].avgPeriod) != 0.0? ShadowLongPeriodTotal / (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) < ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) != 0.0? ShadowVeryShortPeriodTotal / (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( (((inOpen[i]) > (inClose[i])) ? (inOpen[i]) : (inClose[i])) < (((inOpen[i-1]) < (inClose[i-1])) ? (inOpen[i-1]) : (inClose[i-1])) ) )
            outInteger[outIdx++] = 100;
         else
            outInteger[outIdx++] = 0;
         BodyPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) )
            - ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[BodyTrailingIdx] - inOpen[BodyTrailingIdx] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[BodyTrailingIdx] - inLow[BodyTrailingIdx] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[BodyTrailingIdx] - ( inClose[BodyTrailingIdx] >= inOpen[BodyTrailingIdx] ? inClose[BodyTrailingIdx] : inOpen[BodyTrailingIdx] ) ) + ( ( inClose[BodyTrailingIdx] >= inOpen[BodyTrailingIdx] ? inOpen[BodyTrailingIdx] : inClose[BodyTrailingIdx] ) - inLow[BodyTrailingIdx] ) : 0 ) ) ) ;
         ShadowLongPeriodTotal += ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) )
            - ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[ShadowLongTrailingIdx] - inOpen[ShadowLongTrailingIdx] ) ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[ShadowLongTrailingIdx] - inLow[ShadowLongTrailingIdx] ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[ShadowLongTrailingIdx] - ( inClose[ShadowLongTrailingIdx] >= inOpen[ShadowLongTrailingIdx] ? inClose[ShadowLongTrailingIdx] : inOpen[ShadowLongTrailingIdx] ) ) + ( ( inClose[ShadowLongTrailingIdx] >= inOpen[ShadowLongTrailingIdx] ? inOpen[ShadowLongTrailingIdx] : inClose[ShadowLongTrailingIdx] ) - inLow[ShadowLongTrailingIdx] ) : 0 ) ) ) ;
         ShadowVeryShortPeriodTotal += ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) )
            - ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[ShadowVeryShortTrailingIdx] - inOpen[ShadowVeryShortTrailingIdx] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[ShadowVeryShortTrailingIdx] - inLow[ShadowVeryShortTrailingIdx] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[ShadowVeryShortTrailingIdx] - ( inClose[ShadowVeryShortTrailingIdx] >= inOpen[ShadowVeryShortTrailingIdx] ? inClose[ShadowVeryShortTrailingIdx] : inOpen[ShadowVeryShortTrailingIdx] ) ) + ( ( inClose[ShadowVeryShortTrailingIdx] >= inOpen[ShadowVeryShortTrailingIdx] ? inOpen[ShadowVeryShortTrailingIdx] : inClose[ShadowVeryShortTrailingIdx] ) - inLow[ShadowVeryShortTrailingIdx] ) : 0 ) ) ) ;
         i++;
         BodyTrailingIdx++;
         ShadowLongTrailingIdx++;
         ShadowVeryShortTrailingIdx++;
      } while( i <= endIdx );
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   /* Generated */
   public int cdlKickingLookback( )
   {
      return ((( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) ) > ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) )) ? ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) )) +
         1;
   }
   public RetCode cdlKicking( int startIdx,
      int endIdx,
      double inOpen[],
      double inHigh[],
      double inLow[],
      double inClose[],
      MInteger outBegIdx,
      MInteger outNBElement,
      int outInteger[] )
   {
      double []ShadowVeryShortPeriodTotal = new double[2] ;
      double []BodyLongPeriodTotal = new double[2] ;
      int i, outIdx, totIdx, ShadowVeryShortTrailingIdx, BodyLongTrailingIdx, lookbackTotal;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      lookbackTotal = cdlKickingLookback ();
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      ShadowVeryShortPeriodTotal[1] = 0;
      ShadowVeryShortPeriodTotal[0] = 0;
      ShadowVeryShortTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) ;
      BodyLongPeriodTotal[1] = 0;
      BodyLongPeriodTotal[0] = 0;
      BodyLongTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) ;
      i = ShadowVeryShortTrailingIdx;
      while( i < startIdx ) {
         ShadowVeryShortPeriodTotal[1] += ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ;
         ShadowVeryShortPeriodTotal[0] += ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      i = BodyLongTrailingIdx;
      while( i < startIdx ) {
         BodyLongPeriodTotal[1] += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ;
         BodyLongPeriodTotal[0] += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      i = startIdx;
      outIdx = 0;
      do
      {
         if( ( inClose[i-1] >= inOpen[i-1] ? 1 : -1 ) == - ( inClose[i] >= inOpen[i] ? 1 : -1 ) &&
            ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) > ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) != 0.0? BodyLongPeriodTotal[1] / (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) < ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) != 0.0? ShadowVeryShortPeriodTotal[1] / (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) < ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) != 0.0? ShadowVeryShortPeriodTotal[1] / (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( Math.abs ( inClose[i] - inOpen[i] ) ) > ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) != 0.0? BodyLongPeriodTotal[0] / (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) < ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) != 0.0? ShadowVeryShortPeriodTotal[0] / (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) < ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) != 0.0? ShadowVeryShortPeriodTotal[0] / (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            (
            ( ( inClose[i-1] >= inOpen[i-1] ? 1 : -1 ) == -1 && ( inLow[i] > inHigh[i-1] ) )
            ||
            ( ( inClose[i-1] >= inOpen[i-1] ? 1 : -1 ) == 1 && ( inHigh[i] < inLow[i-1] ) )
            )
            )
            outInteger[outIdx++] = ( inClose[i] >= inOpen[i] ? 1 : -1 ) * 100;
         else
            outInteger[outIdx++] = 0;
         for (totIdx = 1; totIdx >= 0; --totIdx) {
            BodyLongPeriodTotal[totIdx] += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-totIdx] - inOpen[i-totIdx] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-totIdx] - inLow[i-totIdx] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-totIdx] - ( inClose[i-totIdx] >= inOpen[i-totIdx] ? inClose[i-totIdx] : inOpen[i-totIdx] ) ) + ( ( inClose[i-totIdx] >= inOpen[i-totIdx] ? inOpen[i-totIdx] : inClose[i-totIdx] ) - inLow[i-totIdx] ) : 0 ) ) )
               - ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[BodyLongTrailingIdx-totIdx] - inOpen[BodyLongTrailingIdx-totIdx] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[BodyLongTrailingIdx-totIdx] - inLow[BodyLongTrailingIdx-totIdx] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[BodyLongTrailingIdx-totIdx] - ( inClose[BodyLongTrailingIdx-totIdx] >= inOpen[BodyLongTrailingIdx-totIdx] ? inClose[BodyLongTrailingIdx-totIdx] : inOpen[BodyLongTrailingIdx-totIdx] ) ) + ( ( inClose[BodyLongTrailingIdx-totIdx] >= inOpen[BodyLongTrailingIdx-totIdx] ? inOpen[BodyLongTrailingIdx-totIdx] : inClose[BodyLongTrailingIdx-totIdx] ) - inLow[BodyLongTrailingIdx-totIdx] ) : 0 ) ) ) ;
            ShadowVeryShortPeriodTotal[totIdx] += ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-totIdx] - inOpen[i-totIdx] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-totIdx] - inLow[i-totIdx] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-totIdx] - ( inClose[i-totIdx] >= inOpen[i-totIdx] ? inClose[i-totIdx] : inOpen[i-totIdx] ) ) + ( ( inClose[i-totIdx] >= inOpen[i-totIdx] ? inOpen[i-totIdx] : inClose[i-totIdx] ) - inLow[i-totIdx] ) : 0 ) ) )
               - ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[ShadowVeryShortTrailingIdx-totIdx] - inOpen[ShadowVeryShortTrailingIdx-totIdx] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[ShadowVeryShortTrailingIdx-totIdx] - inLow[ShadowVeryShortTrailingIdx-totIdx] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[ShadowVeryShortTrailingIdx-totIdx] - ( inClose[ShadowVeryShortTrailingIdx-totIdx] >= inOpen[ShadowVeryShortTrailingIdx-totIdx] ? inClose[ShadowVeryShortTrailingIdx-totIdx] : inOpen[ShadowVeryShortTrailingIdx-totIdx] ) ) + ( ( inClose[ShadowVeryShortTrailingIdx-totIdx] >= inOpen[ShadowVeryShortTrailingIdx-totIdx] ? inOpen[ShadowVeryShortTrailingIdx-totIdx] : inClose[ShadowVeryShortTrailingIdx-totIdx] ) - inLow[ShadowVeryShortTrailingIdx-totIdx] ) : 0 ) ) ) ;
         }
         i++;
         ShadowVeryShortTrailingIdx++;
         BodyLongTrailingIdx++;
      } while( i <= endIdx );
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   public int cdlKickingStateInit( struct TA_cdlKicking_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct cdlKicking ));
      _state.value .value .mem_index = 0;
      _state.value .value .mem_size = cdlKickingLookback ();
      if ( _state.value .value .mem_size > 0)
         _state.value .value .memory = TA_Calloc( _state.value .value .mem_size , sizeof(struct TA_CDLKICKING_Data));
      else
         _state.value .value .memory = NULL;
      return RetCode.Success ;
   }
   public int cdlKickingState( struct TA_cdlKicking_State* _state,
      double inOpen,
      double inHigh,
      double inLow,
      double inClose,
      int *outInteger )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      size_t _cur_idx = _state.value .mem_index++;
      if ( _state.value .mem_size > 0) _cur_idx %= _state.value .mem_size ;
      if ( _state.value .mem_size > _state.value .mem_index - 1 ) {
         ( _state.value .memory+_cur_idx).value .inOpen = inOpen ;
         ( _state.value .memory+_cur_idx).value .inHigh = inHigh ;
         ( _state.value .memory+_cur_idx).value .inLow = inLow ;
         ( _state.value .memory+_cur_idx).value .inClose = inClose ;
         return RetCode.NeedMoreData ; }
      return RetCode.Success ;
   }
   public int cdlKickingStateFree( struct TA_cdlKicking_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if ( _state.value != NULL) {
         if ( _state.value .value .memory != NULL) TA_Free( _state.value .value .memory );
         TA_Free( _state.value ); _state.value = NULL;}
      return RetCode.Success ;
   }
   public RetCode cdlKicking( int startIdx,
      int endIdx,
      float inOpen[],
      float inHigh[],
      float inLow[],
      float inClose[],
      MInteger outBegIdx,
      MInteger outNBElement,
      int outInteger[] )
   {
      double []ShadowVeryShortPeriodTotal = new double[2] ;
      double []BodyLongPeriodTotal = new double[2] ;
      int i, outIdx, totIdx, ShadowVeryShortTrailingIdx, BodyLongTrailingIdx, lookbackTotal;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      lookbackTotal = cdlKickingLookback ();
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      ShadowVeryShortPeriodTotal[1] = 0;
      ShadowVeryShortPeriodTotal[0] = 0;
      ShadowVeryShortTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) ;
      BodyLongPeriodTotal[1] = 0;
      BodyLongPeriodTotal[0] = 0;
      BodyLongTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) ;
      i = ShadowVeryShortTrailingIdx;
      while( i < startIdx ) {
         ShadowVeryShortPeriodTotal[1] += ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ;
         ShadowVeryShortPeriodTotal[0] += ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      i = BodyLongTrailingIdx;
      while( i < startIdx ) {
         BodyLongPeriodTotal[1] += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ;
         BodyLongPeriodTotal[0] += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      i = startIdx;
      outIdx = 0;
      do
      {
         if( ( inClose[i-1] >= inOpen[i-1] ? 1 : -1 ) == - ( inClose[i] >= inOpen[i] ? 1 : -1 ) &&
            ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) > ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) != 0.0? BodyLongPeriodTotal[1] / (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) < ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) != 0.0? ShadowVeryShortPeriodTotal[1] / (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) < ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) != 0.0? ShadowVeryShortPeriodTotal[1] / (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( Math.abs ( inClose[i] - inOpen[i] ) ) > ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) != 0.0? BodyLongPeriodTotal[0] / (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) < ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) != 0.0? ShadowVeryShortPeriodTotal[0] / (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) < ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) != 0.0? ShadowVeryShortPeriodTotal[0] / (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            (
            ( ( inClose[i-1] >= inOpen[i-1] ? 1 : -1 ) == -1 && ( inLow[i] > inHigh[i-1] ) )
            ||
            ( ( inClose[i-1] >= inOpen[i-1] ? 1 : -1 ) == 1 && ( inHigh[i] < inLow[i-1] ) )
            )
            )
            outInteger[outIdx++] = ( inClose[i] >= inOpen[i] ? 1 : -1 ) * 100;
         else
            outInteger[outIdx++] = 0;
         for (totIdx = 1; totIdx >= 0; --totIdx) {
            BodyLongPeriodTotal[totIdx] += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-totIdx] - inOpen[i-totIdx] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-totIdx] - inLow[i-totIdx] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-totIdx] - ( inClose[i-totIdx] >= inOpen[i-totIdx] ? inClose[i-totIdx] : inOpen[i-totIdx] ) ) + ( ( inClose[i-totIdx] >= inOpen[i-totIdx] ? inOpen[i-totIdx] : inClose[i-totIdx] ) - inLow[i-totIdx] ) : 0 ) ) )
               - ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[BodyLongTrailingIdx-totIdx] - inOpen[BodyLongTrailingIdx-totIdx] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[BodyLongTrailingIdx-totIdx] - inLow[BodyLongTrailingIdx-totIdx] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[BodyLongTrailingIdx-totIdx] - ( inClose[BodyLongTrailingIdx-totIdx] >= inOpen[BodyLongTrailingIdx-totIdx] ? inClose[BodyLongTrailingIdx-totIdx] : inOpen[BodyLongTrailingIdx-totIdx] ) ) + ( ( inClose[BodyLongTrailingIdx-totIdx] >= inOpen[BodyLongTrailingIdx-totIdx] ? inOpen[BodyLongTrailingIdx-totIdx] : inClose[BodyLongTrailingIdx-totIdx] ) - inLow[BodyLongTrailingIdx-totIdx] ) : 0 ) ) ) ;
            ShadowVeryShortPeriodTotal[totIdx] += ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-totIdx] - inOpen[i-totIdx] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-totIdx] - inLow[i-totIdx] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-totIdx] - ( inClose[i-totIdx] >= inOpen[i-totIdx] ? inClose[i-totIdx] : inOpen[i-totIdx] ) ) + ( ( inClose[i-totIdx] >= inOpen[i-totIdx] ? inOpen[i-totIdx] : inClose[i-totIdx] ) - inLow[i-totIdx] ) : 0 ) ) )
               - ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[ShadowVeryShortTrailingIdx-totIdx] - inOpen[ShadowVeryShortTrailingIdx-totIdx] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[ShadowVeryShortTrailingIdx-totIdx] - inLow[ShadowVeryShortTrailingIdx-totIdx] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[ShadowVeryShortTrailingIdx-totIdx] - ( inClose[ShadowVeryShortTrailingIdx-totIdx] >= inOpen[ShadowVeryShortTrailingIdx-totIdx] ? inClose[ShadowVeryShortTrailingIdx-totIdx] : inOpen[ShadowVeryShortTrailingIdx-totIdx] ) ) + ( ( inClose[ShadowVeryShortTrailingIdx-totIdx] >= inOpen[ShadowVeryShortTrailingIdx-totIdx] ? inOpen[ShadowVeryShortTrailingIdx-totIdx] : inClose[ShadowVeryShortTrailingIdx-totIdx] ) - inLow[ShadowVeryShortTrailingIdx-totIdx] ) : 0 ) ) ) ;
         }
         i++;
         ShadowVeryShortTrailingIdx++;
         BodyLongTrailingIdx++;
      } while( i <= endIdx );
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   /* Generated */
   public int cdlKickingByLengthLookback( )
   {
      return ((( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) ) > ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) )) ? ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) )) +
         1;
   }
   public RetCode cdlKickingByLength( int startIdx,
      int endIdx,
      double inOpen[],
      double inHigh[],
      double inLow[],
      double inClose[],
      MInteger outBegIdx,
      MInteger outNBElement,
      int outInteger[] )
   {
      double []ShadowVeryShortPeriodTotal = new double[2] ;
      double []BodyLongPeriodTotal = new double[2] ;
      int i, outIdx, totIdx, ShadowVeryShortTrailingIdx, BodyLongTrailingIdx, lookbackTotal;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      lookbackTotal = cdlKickingByLengthLookback ();
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      ShadowVeryShortPeriodTotal[1] = 0;
      ShadowVeryShortPeriodTotal[0] = 0;
      ShadowVeryShortTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) ;
      BodyLongPeriodTotal[1] = 0;
      BodyLongPeriodTotal[0] = 0;
      BodyLongTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) ;
      i = ShadowVeryShortTrailingIdx;
      while( i < startIdx ) {
         ShadowVeryShortPeriodTotal[1] += ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ;
         ShadowVeryShortPeriodTotal[0] += ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      i = BodyLongTrailingIdx;
      while( i < startIdx ) {
         BodyLongPeriodTotal[1] += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ;
         BodyLongPeriodTotal[0] += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      i = startIdx;
      outIdx = 0;
      do
      {
         if( ( inClose[i-1] >= inOpen[i-1] ? 1 : -1 ) == - ( inClose[i] >= inOpen[i] ? 1 : -1 ) &&
            ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) > ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) != 0.0? BodyLongPeriodTotal[1] / (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) < ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) != 0.0? ShadowVeryShortPeriodTotal[1] / (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) < ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) != 0.0? ShadowVeryShortPeriodTotal[1] / (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( Math.abs ( inClose[i] - inOpen[i] ) ) > ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) != 0.0? BodyLongPeriodTotal[0] / (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) < ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) != 0.0? ShadowVeryShortPeriodTotal[0] / (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) < ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) != 0.0? ShadowVeryShortPeriodTotal[0] / (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            (
            ( ( inClose[i-1] >= inOpen[i-1] ? 1 : -1 ) == -1 && ( inLow[i] > inHigh[i-1] ) )
            ||
            ( ( inClose[i-1] >= inOpen[i-1] ? 1 : -1 ) == 1 && ( inHigh[i] < inLow[i-1] ) )
            )
            )
            outInteger[outIdx++] = ( inClose[( ( Math.abs ( inClose[i] - inOpen[i] ) ) > ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) ? i : i-1 )] >= inOpen[( ( Math.abs ( inClose[i] - inOpen[i] ) ) > ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) ? i : i-1 )] ? 1 : -1 ) * 100;
         else
            outInteger[outIdx++] = 0;
         for (totIdx = 1; totIdx >= 0; --totIdx) {
            BodyLongPeriodTotal[totIdx] += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-totIdx] - inOpen[i-totIdx] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-totIdx] - inLow[i-totIdx] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-totIdx] - ( inClose[i-totIdx] >= inOpen[i-totIdx] ? inClose[i-totIdx] : inOpen[i-totIdx] ) ) + ( ( inClose[i-totIdx] >= inOpen[i-totIdx] ? inOpen[i-totIdx] : inClose[i-totIdx] ) - inLow[i-totIdx] ) : 0 ) ) )
               - ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[BodyLongTrailingIdx-totIdx] - inOpen[BodyLongTrailingIdx-totIdx] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[BodyLongTrailingIdx-totIdx] - inLow[BodyLongTrailingIdx-totIdx] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[BodyLongTrailingIdx-totIdx] - ( inClose[BodyLongTrailingIdx-totIdx] >= inOpen[BodyLongTrailingIdx-totIdx] ? inClose[BodyLongTrailingIdx-totIdx] : inOpen[BodyLongTrailingIdx-totIdx] ) ) + ( ( inClose[BodyLongTrailingIdx-totIdx] >= inOpen[BodyLongTrailingIdx-totIdx] ? inOpen[BodyLongTrailingIdx-totIdx] : inClose[BodyLongTrailingIdx-totIdx] ) - inLow[BodyLongTrailingIdx-totIdx] ) : 0 ) ) ) ;
            ShadowVeryShortPeriodTotal[totIdx] += ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-totIdx] - inOpen[i-totIdx] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-totIdx] - inLow[i-totIdx] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-totIdx] - ( inClose[i-totIdx] >= inOpen[i-totIdx] ? inClose[i-totIdx] : inOpen[i-totIdx] ) ) + ( ( inClose[i-totIdx] >= inOpen[i-totIdx] ? inOpen[i-totIdx] : inClose[i-totIdx] ) - inLow[i-totIdx] ) : 0 ) ) )
               - ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[ShadowVeryShortTrailingIdx-totIdx] - inOpen[ShadowVeryShortTrailingIdx-totIdx] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[ShadowVeryShortTrailingIdx-totIdx] - inLow[ShadowVeryShortTrailingIdx-totIdx] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[ShadowVeryShortTrailingIdx-totIdx] - ( inClose[ShadowVeryShortTrailingIdx-totIdx] >= inOpen[ShadowVeryShortTrailingIdx-totIdx] ? inClose[ShadowVeryShortTrailingIdx-totIdx] : inOpen[ShadowVeryShortTrailingIdx-totIdx] ) ) + ( ( inClose[ShadowVeryShortTrailingIdx-totIdx] >= inOpen[ShadowVeryShortTrailingIdx-totIdx] ? inOpen[ShadowVeryShortTrailingIdx-totIdx] : inClose[ShadowVeryShortTrailingIdx-totIdx] ) - inLow[ShadowVeryShortTrailingIdx-totIdx] ) : 0 ) ) ) ;
         }
         i++;
         ShadowVeryShortTrailingIdx++;
         BodyLongTrailingIdx++;
      } while( i <= endIdx );
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   public int cdlKickingByLengthStateInit( struct TA_cdlKickingByLength_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct cdlKickingByLength ));
      _state.value .value .mem_index = 0;
      _state.value .value .mem_size = cdlKickingByLengthLookback ();
      if ( _state.value .value .mem_size > 0)
         _state.value .value .memory = TA_Calloc( _state.value .value .mem_size , sizeof(struct TA_CDLKICKINGBYLENGTH_Data));
      else
         _state.value .value .memory = NULL;
      return RetCode.Success ;
   }
   public int cdlKickingByLengthState( struct TA_cdlKickingByLength_State* _state,
      double inOpen,
      double inHigh,
      double inLow,
      double inClose,
      int *outInteger )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      size_t _cur_idx = _state.value .mem_index++;
      if ( _state.value .mem_size > 0) _cur_idx %= _state.value .mem_size ;
      if ( _state.value .mem_size > _state.value .mem_index - 1 ) {
         ( _state.value .memory+_cur_idx).value .inOpen = inOpen ;
         ( _state.value .memory+_cur_idx).value .inHigh = inHigh ;
         ( _state.value .memory+_cur_idx).value .inLow = inLow ;
         ( _state.value .memory+_cur_idx).value .inClose = inClose ;
         return RetCode.NeedMoreData ; }
      return RetCode.Success ;
   }
   public int cdlKickingByLengthStateFree( struct TA_cdlKickingByLength_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if ( _state.value != NULL) {
         if ( _state.value .value .memory != NULL) TA_Free( _state.value .value .memory );
         TA_Free( _state.value ); _state.value = NULL;}
      return RetCode.Success ;
   }
   public RetCode cdlKickingByLength( int startIdx,
      int endIdx,
      float inOpen[],
      float inHigh[],
      float inLow[],
      float inClose[],
      MInteger outBegIdx,
      MInteger outNBElement,
      int outInteger[] )
   {
      double []ShadowVeryShortPeriodTotal = new double[2] ;
      double []BodyLongPeriodTotal = new double[2] ;
      int i, outIdx, totIdx, ShadowVeryShortTrailingIdx, BodyLongTrailingIdx, lookbackTotal;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      lookbackTotal = cdlKickingByLengthLookback ();
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      ShadowVeryShortPeriodTotal[1] = 0;
      ShadowVeryShortPeriodTotal[0] = 0;
      ShadowVeryShortTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) ;
      BodyLongPeriodTotal[1] = 0;
      BodyLongPeriodTotal[0] = 0;
      BodyLongTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) ;
      i = ShadowVeryShortTrailingIdx;
      while( i < startIdx ) {
         ShadowVeryShortPeriodTotal[1] += ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ;
         ShadowVeryShortPeriodTotal[0] += ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      i = BodyLongTrailingIdx;
      while( i < startIdx ) {
         BodyLongPeriodTotal[1] += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ;
         BodyLongPeriodTotal[0] += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      i = startIdx;
      outIdx = 0;
      do
      {
         if( ( inClose[i-1] >= inOpen[i-1] ? 1 : -1 ) == - ( inClose[i] >= inOpen[i] ? 1 : -1 ) &&
            ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) > ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) != 0.0? BodyLongPeriodTotal[1] / (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) < ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) != 0.0? ShadowVeryShortPeriodTotal[1] / (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) < ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) != 0.0? ShadowVeryShortPeriodTotal[1] / (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( Math.abs ( inClose[i] - inOpen[i] ) ) > ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) != 0.0? BodyLongPeriodTotal[0] / (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) < ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) != 0.0? ShadowVeryShortPeriodTotal[0] / (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) < ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) != 0.0? ShadowVeryShortPeriodTotal[0] / (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            (
            ( ( inClose[i-1] >= inOpen[i-1] ? 1 : -1 ) == -1 && ( inLow[i] > inHigh[i-1] ) )
            ||
            ( ( inClose[i-1] >= inOpen[i-1] ? 1 : -1 ) == 1 && ( inHigh[i] < inLow[i-1] ) )
            )
            )
            outInteger[outIdx++] = ( inClose[( ( Math.abs ( inClose[i] - inOpen[i] ) ) > ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) ? i : i-1 )] >= inOpen[( ( Math.abs ( inClose[i] - inOpen[i] ) ) > ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) ? i : i-1 )] ? 1 : -1 ) * 100;
         else
            outInteger[outIdx++] = 0;
         for (totIdx = 1; totIdx >= 0; --totIdx) {
            BodyLongPeriodTotal[totIdx] += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-totIdx] - inOpen[i-totIdx] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-totIdx] - inLow[i-totIdx] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-totIdx] - ( inClose[i-totIdx] >= inOpen[i-totIdx] ? inClose[i-totIdx] : inOpen[i-totIdx] ) ) + ( ( inClose[i-totIdx] >= inOpen[i-totIdx] ? inOpen[i-totIdx] : inClose[i-totIdx] ) - inLow[i-totIdx] ) : 0 ) ) )
               - ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[BodyLongTrailingIdx-totIdx] - inOpen[BodyLongTrailingIdx-totIdx] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[BodyLongTrailingIdx-totIdx] - inLow[BodyLongTrailingIdx-totIdx] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[BodyLongTrailingIdx-totIdx] - ( inClose[BodyLongTrailingIdx-totIdx] >= inOpen[BodyLongTrailingIdx-totIdx] ? inClose[BodyLongTrailingIdx-totIdx] : inOpen[BodyLongTrailingIdx-totIdx] ) ) + ( ( inClose[BodyLongTrailingIdx-totIdx] >= inOpen[BodyLongTrailingIdx-totIdx] ? inOpen[BodyLongTrailingIdx-totIdx] : inClose[BodyLongTrailingIdx-totIdx] ) - inLow[BodyLongTrailingIdx-totIdx] ) : 0 ) ) ) ;
            ShadowVeryShortPeriodTotal[totIdx] += ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-totIdx] - inOpen[i-totIdx] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-totIdx] - inLow[i-totIdx] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-totIdx] - ( inClose[i-totIdx] >= inOpen[i-totIdx] ? inClose[i-totIdx] : inOpen[i-totIdx] ) ) + ( ( inClose[i-totIdx] >= inOpen[i-totIdx] ? inOpen[i-totIdx] : inClose[i-totIdx] ) - inLow[i-totIdx] ) : 0 ) ) )
               - ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[ShadowVeryShortTrailingIdx-totIdx] - inOpen[ShadowVeryShortTrailingIdx-totIdx] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[ShadowVeryShortTrailingIdx-totIdx] - inLow[ShadowVeryShortTrailingIdx-totIdx] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[ShadowVeryShortTrailingIdx-totIdx] - ( inClose[ShadowVeryShortTrailingIdx-totIdx] >= inOpen[ShadowVeryShortTrailingIdx-totIdx] ? inClose[ShadowVeryShortTrailingIdx-totIdx] : inOpen[ShadowVeryShortTrailingIdx-totIdx] ) ) + ( ( inClose[ShadowVeryShortTrailingIdx-totIdx] >= inOpen[ShadowVeryShortTrailingIdx-totIdx] ? inOpen[ShadowVeryShortTrailingIdx-totIdx] : inClose[ShadowVeryShortTrailingIdx-totIdx] ) - inLow[ShadowVeryShortTrailingIdx-totIdx] ) : 0 ) ) ) ;
         }
         i++;
         ShadowVeryShortTrailingIdx++;
         BodyLongTrailingIdx++;
      } while( i <= endIdx );
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   /* Generated */
   public int cdlLadderBottomLookback( )
   {
      return (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) + 4;
   }
   public RetCode cdlLadderBottom( int startIdx,
      int endIdx,
      double inOpen[],
      double inHigh[],
      double inLow[],
      double inClose[],
      MInteger outBegIdx,
      MInteger outNBElement,
      int outInteger[] )
   {
      double ShadowVeryShortPeriodTotal;
      int i, outIdx, ShadowVeryShortTrailingIdx, lookbackTotal;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      lookbackTotal = cdlLadderBottomLookback ();
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      ShadowVeryShortPeriodTotal = 0;
      ShadowVeryShortTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) ;
      i = ShadowVeryShortTrailingIdx;
      while( i < startIdx ) {
         ShadowVeryShortPeriodTotal += ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ;
         i++;
      }
      i = startIdx;
      outIdx = 0;
      do
      {
         if(
            ( inClose[i-4] >= inOpen[i-4] ? 1 : -1 ) == -1 && ( inClose[i-3] >= inOpen[i-3] ? 1 : -1 ) == -1 && ( inClose[i-2] >= inOpen[i-2] ? 1 : -1 ) == -1 &&
            inOpen[i-4] > inOpen[i-3] && inOpen[i-3] > inOpen[i-2] &&
            inClose[i-4] > inClose[i-3] && inClose[i-3] > inClose[i-2] &&
            ( inClose[i-1] >= inOpen[i-1] ? 1 : -1 ) == -1 &&
            ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) > ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) != 0.0? ShadowVeryShortPeriodTotal / (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( inClose[i] >= inOpen[i] ? 1 : -1 ) == 1 &&
            inOpen[i] > inOpen[i-1] &&
            inClose[i] > inHigh[i-1]
            )
            outInteger[outIdx++] = 100;
         else
            outInteger[outIdx++] = 0;
         ShadowVeryShortPeriodTotal += ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) )
            - ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[ShadowVeryShortTrailingIdx-1] - inOpen[ShadowVeryShortTrailingIdx-1] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[ShadowVeryShortTrailingIdx-1] - inLow[ShadowVeryShortTrailingIdx-1] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[ShadowVeryShortTrailingIdx-1] - ( inClose[ShadowVeryShortTrailingIdx-1] >= inOpen[ShadowVeryShortTrailingIdx-1] ? inClose[ShadowVeryShortTrailingIdx-1] : inOpen[ShadowVeryShortTrailingIdx-1] ) ) + ( ( inClose[ShadowVeryShortTrailingIdx-1] >= inOpen[ShadowVeryShortTrailingIdx-1] ? inOpen[ShadowVeryShortTrailingIdx-1] : inClose[ShadowVeryShortTrailingIdx-1] ) - inLow[ShadowVeryShortTrailingIdx-1] ) : 0 ) ) ) ;
         i++;
         ShadowVeryShortTrailingIdx++;
      } while( i <= endIdx );
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   public int cdlLadderBottomStateInit( struct TA_cdlLadderBottom_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct cdlLadderBottom ));
      _state.value .value .mem_index = 0;
      _state.value .value .mem_size = cdlLadderBottomLookback ();
      if ( _state.value .value .mem_size > 0)
         _state.value .value .memory = TA_Calloc( _state.value .value .mem_size , sizeof(struct TA_CDLLADDERBOTTOM_Data));
      else
         _state.value .value .memory = NULL;
      return RetCode.Success ;
   }
   public int cdlLadderBottomState( struct TA_cdlLadderBottom_State* _state,
      double inOpen,
      double inHigh,
      double inLow,
      double inClose,
      int *outInteger )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      size_t _cur_idx = _state.value .mem_index++;
      if ( _state.value .mem_size > 0) _cur_idx %= _state.value .mem_size ;
      if ( _state.value .mem_size > _state.value .mem_index - 1 ) {
         ( _state.value .memory+_cur_idx).value .inOpen = inOpen ;
         ( _state.value .memory+_cur_idx).value .inHigh = inHigh ;
         ( _state.value .memory+_cur_idx).value .inLow = inLow ;
         ( _state.value .memory+_cur_idx).value .inClose = inClose ;
         return RetCode.NeedMoreData ; }
      return RetCode.Success ;
   }
   public int cdlLadderBottomStateFree( struct TA_cdlLadderBottom_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if ( _state.value != NULL) {
         if ( _state.value .value .memory != NULL) TA_Free( _state.value .value .memory );
         TA_Free( _state.value ); _state.value = NULL;}
      return RetCode.Success ;
   }
   public RetCode cdlLadderBottom( int startIdx,
      int endIdx,
      float inOpen[],
      float inHigh[],
      float inLow[],
      float inClose[],
      MInteger outBegIdx,
      MInteger outNBElement,
      int outInteger[] )
   {
      double ShadowVeryShortPeriodTotal;
      int i, outIdx, ShadowVeryShortTrailingIdx, lookbackTotal;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      lookbackTotal = cdlLadderBottomLookback ();
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      ShadowVeryShortPeriodTotal = 0;
      ShadowVeryShortTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) ;
      i = ShadowVeryShortTrailingIdx;
      while( i < startIdx ) {
         ShadowVeryShortPeriodTotal += ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ;
         i++;
      }
      i = startIdx;
      outIdx = 0;
      do
      {
         if(
            ( inClose[i-4] >= inOpen[i-4] ? 1 : -1 ) == -1 && ( inClose[i-3] >= inOpen[i-3] ? 1 : -1 ) == -1 && ( inClose[i-2] >= inOpen[i-2] ? 1 : -1 ) == -1 &&
            inOpen[i-4] > inOpen[i-3] && inOpen[i-3] > inOpen[i-2] &&
            inClose[i-4] > inClose[i-3] && inClose[i-3] > inClose[i-2] &&
            ( inClose[i-1] >= inOpen[i-1] ? 1 : -1 ) == -1 &&
            ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) > ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) != 0.0? ShadowVeryShortPeriodTotal / (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( inClose[i] >= inOpen[i] ? 1 : -1 ) == 1 &&
            inOpen[i] > inOpen[i-1] &&
            inClose[i] > inHigh[i-1]
            )
            outInteger[outIdx++] = 100;
         else
            outInteger[outIdx++] = 0;
         ShadowVeryShortPeriodTotal += ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) )
            - ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[ShadowVeryShortTrailingIdx-1] - inOpen[ShadowVeryShortTrailingIdx-1] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[ShadowVeryShortTrailingIdx-1] - inLow[ShadowVeryShortTrailingIdx-1] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[ShadowVeryShortTrailingIdx-1] - ( inClose[ShadowVeryShortTrailingIdx-1] >= inOpen[ShadowVeryShortTrailingIdx-1] ? inClose[ShadowVeryShortTrailingIdx-1] : inOpen[ShadowVeryShortTrailingIdx-1] ) ) + ( ( inClose[ShadowVeryShortTrailingIdx-1] >= inOpen[ShadowVeryShortTrailingIdx-1] ? inOpen[ShadowVeryShortTrailingIdx-1] : inClose[ShadowVeryShortTrailingIdx-1] ) - inLow[ShadowVeryShortTrailingIdx-1] ) : 0 ) ) ) ;
         i++;
         ShadowVeryShortTrailingIdx++;
      } while( i <= endIdx );
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   /* Generated */
   public int cdlLongLeggedDojiLookback( )
   {
      return ((( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].avgPeriod) ) > ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].avgPeriod) )) ? ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].avgPeriod) ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].avgPeriod) )) ;
   }
   public RetCode cdlLongLeggedDoji( int startIdx,
      int endIdx,
      double inOpen[],
      double inHigh[],
      double inLow[],
      double inClose[],
      MInteger outBegIdx,
      MInteger outNBElement,
      int outInteger[] )
   {
      double BodyDojiPeriodTotal, ShadowLongPeriodTotal;
      int i, outIdx, BodyDojiTrailingIdx, ShadowLongTrailingIdx, lookbackTotal;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      lookbackTotal = cdlLongLeggedDojiLookback ();
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      BodyDojiPeriodTotal = 0;
      BodyDojiTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].avgPeriod) ;
      ShadowLongPeriodTotal = 0;
      ShadowLongTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].avgPeriod) ;
      i = BodyDojiTrailingIdx;
      while( i < startIdx ) {
         BodyDojiPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      i = ShadowLongTrailingIdx;
      while( i < startIdx ) {
         ShadowLongPeriodTotal += ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      outIdx = 0;
      do
      {
         if( ( Math.abs ( inClose[i] - inOpen[i] ) ) <= ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].avgPeriod) != 0.0? BodyDojiPeriodTotal / (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) > ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].avgPeriod) != 0.0? ShadowLongPeriodTotal / (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) )
            ||
            ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) > ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].avgPeriod) != 0.0? ShadowLongPeriodTotal / (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) )
            )
            )
            outInteger[outIdx++] = 100;
         else
            outInteger[outIdx++] = 0;
         BodyDojiPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) - ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[BodyDojiTrailingIdx] - inOpen[BodyDojiTrailingIdx] ) ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[BodyDojiTrailingIdx] - inLow[BodyDojiTrailingIdx] ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[BodyDojiTrailingIdx] - ( inClose[BodyDojiTrailingIdx] >= inOpen[BodyDojiTrailingIdx] ? inClose[BodyDojiTrailingIdx] : inOpen[BodyDojiTrailingIdx] ) ) + ( ( inClose[BodyDojiTrailingIdx] >= inOpen[BodyDojiTrailingIdx] ? inOpen[BodyDojiTrailingIdx] : inClose[BodyDojiTrailingIdx] ) - inLow[BodyDojiTrailingIdx] ) : 0 ) ) ) ;
         ShadowLongPeriodTotal += ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) - ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[ShadowLongTrailingIdx] - inOpen[ShadowLongTrailingIdx] ) ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[ShadowLongTrailingIdx] - inLow[ShadowLongTrailingIdx] ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[ShadowLongTrailingIdx] - ( inClose[ShadowLongTrailingIdx] >= inOpen[ShadowLongTrailingIdx] ? inClose[ShadowLongTrailingIdx] : inOpen[ShadowLongTrailingIdx] ) ) + ( ( inClose[ShadowLongTrailingIdx] >= inOpen[ShadowLongTrailingIdx] ? inOpen[ShadowLongTrailingIdx] : inClose[ShadowLongTrailingIdx] ) - inLow[ShadowLongTrailingIdx] ) : 0 ) ) ) ;
         i++;
         BodyDojiTrailingIdx++;
         ShadowLongTrailingIdx++;
      } while( i <= endIdx );
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   public int cdlLongLeggedDojiStateInit( struct TA_cdlLongLeggedDoji_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct cdlLongLeggedDoji ));
      _state.value .value .mem_index = 0;
      _state.value .value .mem_size = cdlLongLeggedDojiLookback ();
      if ( _state.value .value .mem_size > 0)
         _state.value .value .memory = TA_Calloc( _state.value .value .mem_size , sizeof(struct TA_CDLLONGLEGGEDDOJI_Data));
      else
         _state.value .value .memory = NULL;
      return RetCode.Success ;
   }
   public int cdlLongLeggedDojiState( struct TA_cdlLongLeggedDoji_State* _state,
      double inOpen,
      double inHigh,
      double inLow,
      double inClose,
      int *outInteger )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      size_t _cur_idx = _state.value .mem_index++;
      if ( _state.value .mem_size > 0) _cur_idx %= _state.value .mem_size ;
      if ( _state.value .mem_size > _state.value .mem_index - 1 ) {
         ( _state.value .memory+_cur_idx).value .inOpen = inOpen ;
         ( _state.value .memory+_cur_idx).value .inHigh = inHigh ;
         ( _state.value .memory+_cur_idx).value .inLow = inLow ;
         ( _state.value .memory+_cur_idx).value .inClose = inClose ;
         return RetCode.NeedMoreData ; }
      return RetCode.Success ;
   }
   public int cdlLongLeggedDojiStateFree( struct TA_cdlLongLeggedDoji_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if ( _state.value != NULL) {
         if ( _state.value .value .memory != NULL) TA_Free( _state.value .value .memory );
         TA_Free( _state.value ); _state.value = NULL;}
      return RetCode.Success ;
   }
   public RetCode cdlLongLeggedDoji( int startIdx,
      int endIdx,
      float inOpen[],
      float inHigh[],
      float inLow[],
      float inClose[],
      MInteger outBegIdx,
      MInteger outNBElement,
      int outInteger[] )
   {
      double BodyDojiPeriodTotal, ShadowLongPeriodTotal;
      int i, outIdx, BodyDojiTrailingIdx, ShadowLongTrailingIdx, lookbackTotal;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      lookbackTotal = cdlLongLeggedDojiLookback ();
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      BodyDojiPeriodTotal = 0;
      BodyDojiTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].avgPeriod) ;
      ShadowLongPeriodTotal = 0;
      ShadowLongTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].avgPeriod) ;
      i = BodyDojiTrailingIdx;
      while( i < startIdx ) {
         BodyDojiPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      i = ShadowLongTrailingIdx;
      while( i < startIdx ) {
         ShadowLongPeriodTotal += ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      outIdx = 0;
      do
      {
         if( ( Math.abs ( inClose[i] - inOpen[i] ) ) <= ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].avgPeriod) != 0.0? BodyDojiPeriodTotal / (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) > ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].avgPeriod) != 0.0? ShadowLongPeriodTotal / (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) )
            ||
            ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) > ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].avgPeriod) != 0.0? ShadowLongPeriodTotal / (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) )
            )
            )
            outInteger[outIdx++] = 100;
         else
            outInteger[outIdx++] = 0;
         BodyDojiPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) - ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[BodyDojiTrailingIdx] - inOpen[BodyDojiTrailingIdx] ) ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[BodyDojiTrailingIdx] - inLow[BodyDojiTrailingIdx] ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[BodyDojiTrailingIdx] - ( inClose[BodyDojiTrailingIdx] >= inOpen[BodyDojiTrailingIdx] ? inClose[BodyDojiTrailingIdx] : inOpen[BodyDojiTrailingIdx] ) ) + ( ( inClose[BodyDojiTrailingIdx] >= inOpen[BodyDojiTrailingIdx] ? inOpen[BodyDojiTrailingIdx] : inClose[BodyDojiTrailingIdx] ) - inLow[BodyDojiTrailingIdx] ) : 0 ) ) ) ;
         ShadowLongPeriodTotal += ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) - ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[ShadowLongTrailingIdx] - inOpen[ShadowLongTrailingIdx] ) ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[ShadowLongTrailingIdx] - inLow[ShadowLongTrailingIdx] ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[ShadowLongTrailingIdx] - ( inClose[ShadowLongTrailingIdx] >= inOpen[ShadowLongTrailingIdx] ? inClose[ShadowLongTrailingIdx] : inOpen[ShadowLongTrailingIdx] ) ) + ( ( inClose[ShadowLongTrailingIdx] >= inOpen[ShadowLongTrailingIdx] ? inOpen[ShadowLongTrailingIdx] : inClose[ShadowLongTrailingIdx] ) - inLow[ShadowLongTrailingIdx] ) : 0 ) ) ) ;
         i++;
         BodyDojiTrailingIdx++;
         ShadowLongTrailingIdx++;
      } while( i <= endIdx );
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   /* Generated */
   public int cdlLongLineLookback( )
   {
      return ((( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) ) > ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].avgPeriod) )) ? ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) ) : ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].avgPeriod) )) ;
   }
   public RetCode cdlLongLine( int startIdx,
      int endIdx,
      double inOpen[],
      double inHigh[],
      double inLow[],
      double inClose[],
      MInteger outBegIdx,
      MInteger outNBElement,
      int outInteger[] )
   {
      double BodyPeriodTotal, ShadowPeriodTotal;
      int i, outIdx, BodyTrailingIdx, ShadowTrailingIdx, lookbackTotal;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      lookbackTotal = cdlLongLineLookback ();
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      BodyPeriodTotal = 0;
      BodyTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) ;
      ShadowPeriodTotal = 0;
      ShadowTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].avgPeriod) ;
      i = BodyTrailingIdx;
      while( i < startIdx ) {
         BodyPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      i = ShadowTrailingIdx;
      while( i < startIdx ) {
         ShadowPeriodTotal += ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      outIdx = 0;
      do
      {
         if( ( Math.abs ( inClose[i] - inOpen[i] ) ) > ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) != 0.0? BodyPeriodTotal / (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) < ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].avgPeriod) != 0.0? ShadowPeriodTotal / (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) < ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].avgPeriod) != 0.0? ShadowPeriodTotal / (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) )
            outInteger[outIdx++] = ( inClose[i] >= inOpen[i] ? 1 : -1 ) * 100;
         else
            outInteger[outIdx++] = 0;
         BodyPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) - ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[BodyTrailingIdx] - inOpen[BodyTrailingIdx] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[BodyTrailingIdx] - inLow[BodyTrailingIdx] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[BodyTrailingIdx] - ( inClose[BodyTrailingIdx] >= inOpen[BodyTrailingIdx] ? inClose[BodyTrailingIdx] : inOpen[BodyTrailingIdx] ) ) + ( ( inClose[BodyTrailingIdx] >= inOpen[BodyTrailingIdx] ? inOpen[BodyTrailingIdx] : inClose[BodyTrailingIdx] ) - inLow[BodyTrailingIdx] ) : 0 ) ) ) ;
         ShadowPeriodTotal += ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) - ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[ShadowTrailingIdx] - inOpen[ShadowTrailingIdx] ) ) : ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[ShadowTrailingIdx] - inLow[ShadowTrailingIdx] ) : ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[ShadowTrailingIdx] - ( inClose[ShadowTrailingIdx] >= inOpen[ShadowTrailingIdx] ? inClose[ShadowTrailingIdx] : inOpen[ShadowTrailingIdx] ) ) + ( ( inClose[ShadowTrailingIdx] >= inOpen[ShadowTrailingIdx] ? inOpen[ShadowTrailingIdx] : inClose[ShadowTrailingIdx] ) - inLow[ShadowTrailingIdx] ) : 0 ) ) ) ;
         i++;
         BodyTrailingIdx++;
         ShadowTrailingIdx++;
      } while( i <= endIdx );
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   public int cdlLongLineStateInit( struct TA_cdlLongLine_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct cdlLongLine ));
      _state.value .value .mem_index = 0;
      _state.value .value .mem_size = cdlLongLineLookback ();
      if ( _state.value .value .mem_size > 0)
         _state.value .value .memory = TA_Calloc( _state.value .value .mem_size , sizeof(struct TA_CDLLONGLINE_Data));
      else
         _state.value .value .memory = NULL;
      return RetCode.Success ;
   }
   public int cdlLongLineState( struct TA_cdlLongLine_State* _state,
      double inOpen,
      double inHigh,
      double inLow,
      double inClose,
      int *outInteger )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      size_t _cur_idx = _state.value .mem_index++;
      if ( _state.value .mem_size > 0) _cur_idx %= _state.value .mem_size ;
      if ( _state.value .mem_size > _state.value .mem_index - 1 ) {
         ( _state.value .memory+_cur_idx).value .inOpen = inOpen ;
         ( _state.value .memory+_cur_idx).value .inHigh = inHigh ;
         ( _state.value .memory+_cur_idx).value .inLow = inLow ;
         ( _state.value .memory+_cur_idx).value .inClose = inClose ;
         return RetCode.NeedMoreData ; }
      return RetCode.Success ;
   }
   public int cdlLongLineStateFree( struct TA_cdlLongLine_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if ( _state.value != NULL) {
         if ( _state.value .value .memory != NULL) TA_Free( _state.value .value .memory );
         TA_Free( _state.value ); _state.value = NULL;}
      return RetCode.Success ;
   }
   public RetCode cdlLongLine( int startIdx,
      int endIdx,
      float inOpen[],
      float inHigh[],
      float inLow[],
      float inClose[],
      MInteger outBegIdx,
      MInteger outNBElement,
      int outInteger[] )
   {
      double BodyPeriodTotal, ShadowPeriodTotal;
      int i, outIdx, BodyTrailingIdx, ShadowTrailingIdx, lookbackTotal;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      lookbackTotal = cdlLongLineLookback ();
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      BodyPeriodTotal = 0;
      BodyTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) ;
      ShadowPeriodTotal = 0;
      ShadowTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].avgPeriod) ;
      i = BodyTrailingIdx;
      while( i < startIdx ) {
         BodyPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      i = ShadowTrailingIdx;
      while( i < startIdx ) {
         ShadowPeriodTotal += ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      outIdx = 0;
      do
      {
         if( ( Math.abs ( inClose[i] - inOpen[i] ) ) > ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) != 0.0? BodyPeriodTotal / (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) < ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].avgPeriod) != 0.0? ShadowPeriodTotal / (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) < ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].avgPeriod) != 0.0? ShadowPeriodTotal / (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) )
            outInteger[outIdx++] = ( inClose[i] >= inOpen[i] ? 1 : -1 ) * 100;
         else
            outInteger[outIdx++] = 0;
         BodyPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) - ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[BodyTrailingIdx] - inOpen[BodyTrailingIdx] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[BodyTrailingIdx] - inLow[BodyTrailingIdx] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[BodyTrailingIdx] - ( inClose[BodyTrailingIdx] >= inOpen[BodyTrailingIdx] ? inClose[BodyTrailingIdx] : inOpen[BodyTrailingIdx] ) ) + ( ( inClose[BodyTrailingIdx] >= inOpen[BodyTrailingIdx] ? inOpen[BodyTrailingIdx] : inClose[BodyTrailingIdx] ) - inLow[BodyTrailingIdx] ) : 0 ) ) ) ;
         ShadowPeriodTotal += ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) - ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[ShadowTrailingIdx] - inOpen[ShadowTrailingIdx] ) ) : ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[ShadowTrailingIdx] - inLow[ShadowTrailingIdx] ) : ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[ShadowTrailingIdx] - ( inClose[ShadowTrailingIdx] >= inOpen[ShadowTrailingIdx] ? inClose[ShadowTrailingIdx] : inOpen[ShadowTrailingIdx] ) ) + ( ( inClose[ShadowTrailingIdx] >= inOpen[ShadowTrailingIdx] ? inOpen[ShadowTrailingIdx] : inClose[ShadowTrailingIdx] ) - inLow[ShadowTrailingIdx] ) : 0 ) ) ) ;
         i++;
         BodyTrailingIdx++;
         ShadowTrailingIdx++;
      } while( i <= endIdx );
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   /* Generated */
   public int cdlMarubozuLookback( )
   {
      return ((( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) ) > ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) )) ? ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) )) ;
   }
   public RetCode cdlMarubozu( int startIdx,
      int endIdx,
      double inOpen[],
      double inHigh[],
      double inLow[],
      double inClose[],
      MInteger outBegIdx,
      MInteger outNBElement,
      int outInteger[] )
   {
      double BodyLongPeriodTotal, ShadowVeryShortPeriodTotal;
      int i, outIdx, BodyLongTrailingIdx, ShadowVeryShortTrailingIdx, lookbackTotal;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      lookbackTotal = cdlMarubozuLookback ();
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      BodyLongPeriodTotal = 0;
      BodyLongTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) ;
      ShadowVeryShortPeriodTotal = 0;
      ShadowVeryShortTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) ;
      i = BodyLongTrailingIdx;
      while( i < startIdx ) {
         BodyLongPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      i = ShadowVeryShortTrailingIdx;
      while( i < startIdx ) {
         ShadowVeryShortPeriodTotal += ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      outIdx = 0;
      do
      {
         if( ( Math.abs ( inClose[i] - inOpen[i] ) ) > ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) != 0.0? BodyLongPeriodTotal / (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) < ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) != 0.0? ShadowVeryShortPeriodTotal / (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) < ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) != 0.0? ShadowVeryShortPeriodTotal / (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) )
            outInteger[outIdx++] = ( inClose[i] >= inOpen[i] ? 1 : -1 ) * 100;
         else
            outInteger[outIdx++] = 0;
         BodyLongPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) - ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[BodyLongTrailingIdx] - inOpen[BodyLongTrailingIdx] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[BodyLongTrailingIdx] - inLow[BodyLongTrailingIdx] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[BodyLongTrailingIdx] - ( inClose[BodyLongTrailingIdx] >= inOpen[BodyLongTrailingIdx] ? inClose[BodyLongTrailingIdx] : inOpen[BodyLongTrailingIdx] ) ) + ( ( inClose[BodyLongTrailingIdx] >= inOpen[BodyLongTrailingIdx] ? inOpen[BodyLongTrailingIdx] : inClose[BodyLongTrailingIdx] ) - inLow[BodyLongTrailingIdx] ) : 0 ) ) ) ;
         ShadowVeryShortPeriodTotal += ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) )
            - ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[ShadowVeryShortTrailingIdx] - inOpen[ShadowVeryShortTrailingIdx] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[ShadowVeryShortTrailingIdx] - inLow[ShadowVeryShortTrailingIdx] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[ShadowVeryShortTrailingIdx] - ( inClose[ShadowVeryShortTrailingIdx] >= inOpen[ShadowVeryShortTrailingIdx] ? inClose[ShadowVeryShortTrailingIdx] : inOpen[ShadowVeryShortTrailingIdx] ) ) + ( ( inClose[ShadowVeryShortTrailingIdx] >= inOpen[ShadowVeryShortTrailingIdx] ? inOpen[ShadowVeryShortTrailingIdx] : inClose[ShadowVeryShortTrailingIdx] ) - inLow[ShadowVeryShortTrailingIdx] ) : 0 ) ) ) ;
         i++;
         BodyLongTrailingIdx++;
         ShadowVeryShortTrailingIdx++;
      } while( i <= endIdx );
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   public int cdlMarubozuStateInit( struct TA_cdlMarubozu_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct cdlMarubozu ));
      _state.value .value .mem_index = 0;
      _state.value .value .mem_size = cdlMarubozuLookback ();
      if ( _state.value .value .mem_size > 0)
         _state.value .value .memory = TA_Calloc( _state.value .value .mem_size , sizeof(struct TA_CDLMARUBOZU_Data));
      else
         _state.value .value .memory = NULL;
      return RetCode.Success ;
   }
   public int cdlMarubozuState( struct TA_cdlMarubozu_State* _state,
      double inOpen,
      double inHigh,
      double inLow,
      double inClose,
      int *outInteger )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      size_t _cur_idx = _state.value .mem_index++;
      if ( _state.value .mem_size > 0) _cur_idx %= _state.value .mem_size ;
      if ( _state.value .mem_size > _state.value .mem_index - 1 ) {
         ( _state.value .memory+_cur_idx).value .inOpen = inOpen ;
         ( _state.value .memory+_cur_idx).value .inHigh = inHigh ;
         ( _state.value .memory+_cur_idx).value .inLow = inLow ;
         ( _state.value .memory+_cur_idx).value .inClose = inClose ;
         return RetCode.NeedMoreData ; }
      return RetCode.Success ;
   }
   public int cdlMarubozuStateFree( struct TA_cdlMarubozu_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if ( _state.value != NULL) {
         if ( _state.value .value .memory != NULL) TA_Free( _state.value .value .memory );
         TA_Free( _state.value ); _state.value = NULL;}
      return RetCode.Success ;
   }
   public RetCode cdlMarubozu( int startIdx,
      int endIdx,
      float inOpen[],
      float inHigh[],
      float inLow[],
      float inClose[],
      MInteger outBegIdx,
      MInteger outNBElement,
      int outInteger[] )
   {
      double BodyLongPeriodTotal, ShadowVeryShortPeriodTotal;
      int i, outIdx, BodyLongTrailingIdx, ShadowVeryShortTrailingIdx, lookbackTotal;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      lookbackTotal = cdlMarubozuLookback ();
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      BodyLongPeriodTotal = 0;
      BodyLongTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) ;
      ShadowVeryShortPeriodTotal = 0;
      ShadowVeryShortTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) ;
      i = BodyLongTrailingIdx;
      while( i < startIdx ) {
         BodyLongPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      i = ShadowVeryShortTrailingIdx;
      while( i < startIdx ) {
         ShadowVeryShortPeriodTotal += ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      outIdx = 0;
      do
      {
         if( ( Math.abs ( inClose[i] - inOpen[i] ) ) > ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) != 0.0? BodyLongPeriodTotal / (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) < ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) != 0.0? ShadowVeryShortPeriodTotal / (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) < ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) != 0.0? ShadowVeryShortPeriodTotal / (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) )
            outInteger[outIdx++] = ( inClose[i] >= inOpen[i] ? 1 : -1 ) * 100;
         else
            outInteger[outIdx++] = 0;
         BodyLongPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) - ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[BodyLongTrailingIdx] - inOpen[BodyLongTrailingIdx] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[BodyLongTrailingIdx] - inLow[BodyLongTrailingIdx] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[BodyLongTrailingIdx] - ( inClose[BodyLongTrailingIdx] >= inOpen[BodyLongTrailingIdx] ? inClose[BodyLongTrailingIdx] : inOpen[BodyLongTrailingIdx] ) ) + ( ( inClose[BodyLongTrailingIdx] >= inOpen[BodyLongTrailingIdx] ? inOpen[BodyLongTrailingIdx] : inClose[BodyLongTrailingIdx] ) - inLow[BodyLongTrailingIdx] ) : 0 ) ) ) ;
         ShadowVeryShortPeriodTotal += ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) )
            - ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[ShadowVeryShortTrailingIdx] - inOpen[ShadowVeryShortTrailingIdx] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[ShadowVeryShortTrailingIdx] - inLow[ShadowVeryShortTrailingIdx] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[ShadowVeryShortTrailingIdx] - ( inClose[ShadowVeryShortTrailingIdx] >= inOpen[ShadowVeryShortTrailingIdx] ? inClose[ShadowVeryShortTrailingIdx] : inOpen[ShadowVeryShortTrailingIdx] ) ) + ( ( inClose[ShadowVeryShortTrailingIdx] >= inOpen[ShadowVeryShortTrailingIdx] ? inOpen[ShadowVeryShortTrailingIdx] : inClose[ShadowVeryShortTrailingIdx] ) - inLow[ShadowVeryShortTrailingIdx] ) : 0 ) ) ) ;
         i++;
         BodyLongTrailingIdx++;
         ShadowVeryShortTrailingIdx++;
      } while( i <= endIdx );
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   /* Generated */
   public int cdlMatchingLowLookback( )
   {
      return (this.candleSettings[CandleSettingType.Equal.ordinal()].avgPeriod) + 1;
   }
   public RetCode cdlMatchingLow( int startIdx,
      int endIdx,
      double inOpen[],
      double inHigh[],
      double inLow[],
      double inClose[],
      MInteger outBegIdx,
      MInteger outNBElement,
      int outInteger[] )
   {
      double EqualPeriodTotal;
      int i, outIdx, EqualTrailingIdx, lookbackTotal;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      lookbackTotal = cdlMatchingLowLookback ();
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      EqualPeriodTotal = 0;
      EqualTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.Equal.ordinal()].avgPeriod) ;
      i = EqualTrailingIdx;
      while( i < startIdx ) {
         EqualPeriodTotal += ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ;
         i++;
      }
      i = startIdx;
      outIdx = 0;
      do
      {
         if( ( inClose[i-1] >= inOpen[i-1] ? 1 : -1 ) == -1 &&
            ( inClose[i] >= inOpen[i] ? 1 : -1 ) == -1 &&
            inClose[i] <= inClose[i-1] + ( (this.candleSettings[CandleSettingType.Equal.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.Equal.ordinal()].avgPeriod) != 0.0? EqualPeriodTotal / (this.candleSettings[CandleSettingType.Equal.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            inClose[i] >= inClose[i-1] - ( (this.candleSettings[CandleSettingType.Equal.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.Equal.ordinal()].avgPeriod) != 0.0? EqualPeriodTotal / (this.candleSettings[CandleSettingType.Equal.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) )
            )
            outInteger[outIdx++] = 100;
         else
            outInteger[outIdx++] = 0;
         EqualPeriodTotal += ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) - ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[EqualTrailingIdx-1] - inOpen[EqualTrailingIdx-1] ) ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[EqualTrailingIdx-1] - inLow[EqualTrailingIdx-1] ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[EqualTrailingIdx-1] - ( inClose[EqualTrailingIdx-1] >= inOpen[EqualTrailingIdx-1] ? inClose[EqualTrailingIdx-1] : inOpen[EqualTrailingIdx-1] ) ) + ( ( inClose[EqualTrailingIdx-1] >= inOpen[EqualTrailingIdx-1] ? inOpen[EqualTrailingIdx-1] : inClose[EqualTrailingIdx-1] ) - inLow[EqualTrailingIdx-1] ) : 0 ) ) ) ;
         i++;
         EqualTrailingIdx++;
      } while( i <= endIdx );
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   public int cdlMatchingLowStateInit( struct TA_cdlMatchingLow_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct cdlMatchingLow ));
      _state.value .value .mem_index = 0;
      _state.value .value .mem_size = cdlMatchingLowLookback ();
      if ( _state.value .value .mem_size > 0)
         _state.value .value .memory = TA_Calloc( _state.value .value .mem_size , sizeof(struct TA_CDLMATCHINGLOW_Data));
      else
         _state.value .value .memory = NULL;
      return RetCode.Success ;
   }
   public int cdlMatchingLowState( struct TA_cdlMatchingLow_State* _state,
      double inOpen,
      double inHigh,
      double inLow,
      double inClose,
      int *outInteger )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      size_t _cur_idx = _state.value .mem_index++;
      if ( _state.value .mem_size > 0) _cur_idx %= _state.value .mem_size ;
      if ( _state.value .mem_size > _state.value .mem_index - 1 ) {
         ( _state.value .memory+_cur_idx).value .inOpen = inOpen ;
         ( _state.value .memory+_cur_idx).value .inHigh = inHigh ;
         ( _state.value .memory+_cur_idx).value .inLow = inLow ;
         ( _state.value .memory+_cur_idx).value .inClose = inClose ;
         return RetCode.NeedMoreData ; }
      return RetCode.Success ;
   }
   public int cdlMatchingLowStateFree( struct TA_cdlMatchingLow_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if ( _state.value != NULL) {
         if ( _state.value .value .memory != NULL) TA_Free( _state.value .value .memory );
         TA_Free( _state.value ); _state.value = NULL;}
      return RetCode.Success ;
   }
   public RetCode cdlMatchingLow( int startIdx,
      int endIdx,
      float inOpen[],
      float inHigh[],
      float inLow[],
      float inClose[],
      MInteger outBegIdx,
      MInteger outNBElement,
      int outInteger[] )
   {
      double EqualPeriodTotal;
      int i, outIdx, EqualTrailingIdx, lookbackTotal;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      lookbackTotal = cdlMatchingLowLookback ();
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      EqualPeriodTotal = 0;
      EqualTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.Equal.ordinal()].avgPeriod) ;
      i = EqualTrailingIdx;
      while( i < startIdx ) {
         EqualPeriodTotal += ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ;
         i++;
      }
      i = startIdx;
      outIdx = 0;
      do
      {
         if( ( inClose[i-1] >= inOpen[i-1] ? 1 : -1 ) == -1 &&
            ( inClose[i] >= inOpen[i] ? 1 : -1 ) == -1 &&
            inClose[i] <= inClose[i-1] + ( (this.candleSettings[CandleSettingType.Equal.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.Equal.ordinal()].avgPeriod) != 0.0? EqualPeriodTotal / (this.candleSettings[CandleSettingType.Equal.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            inClose[i] >= inClose[i-1] - ( (this.candleSettings[CandleSettingType.Equal.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.Equal.ordinal()].avgPeriod) != 0.0? EqualPeriodTotal / (this.candleSettings[CandleSettingType.Equal.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) )
            )
            outInteger[outIdx++] = 100;
         else
            outInteger[outIdx++] = 0;
         EqualPeriodTotal += ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) - ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[EqualTrailingIdx-1] - inOpen[EqualTrailingIdx-1] ) ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[EqualTrailingIdx-1] - inLow[EqualTrailingIdx-1] ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[EqualTrailingIdx-1] - ( inClose[EqualTrailingIdx-1] >= inOpen[EqualTrailingIdx-1] ? inClose[EqualTrailingIdx-1] : inOpen[EqualTrailingIdx-1] ) ) + ( ( inClose[EqualTrailingIdx-1] >= inOpen[EqualTrailingIdx-1] ? inOpen[EqualTrailingIdx-1] : inClose[EqualTrailingIdx-1] ) - inLow[EqualTrailingIdx-1] ) : 0 ) ) ) ;
         i++;
         EqualTrailingIdx++;
      } while( i <= endIdx );
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   /* Generated */
   public int cdlMatHoldLookback( double optInPenetration )
   {
      if( optInPenetration == (-4e+37) )
         optInPenetration = 5.000000e-1;
      else if( (optInPenetration < 0.000000e+0) || (optInPenetration > 3.000000e+37) )
         return -1;
      return ((( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) ) > ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) )) ? ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) )) + 4;
   }
   public RetCode cdlMatHold( int startIdx,
      int endIdx,
      double inOpen[],
      double inHigh[],
      double inLow[],
      double inClose[],
      double optInPenetration,
      MInteger outBegIdx,
      MInteger outNBElement,
      int outInteger[] )
   {
      double []BodyPeriodTotal = new double[5] ;
      int i, outIdx, totIdx, BodyShortTrailingIdx, BodyLongTrailingIdx, lookbackTotal;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      if( optInPenetration == (-4e+37) )
         optInPenetration = 5.000000e-1;
      else if( (optInPenetration < 0.000000e+0) || (optInPenetration > 3.000000e+37) )
         return RetCode.BadParam ;
      lookbackTotal = cdlMatHoldLookback (optInPenetration);
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      BodyPeriodTotal[4] = 0;
      BodyPeriodTotal[3] = 0;
      BodyPeriodTotal[2] = 0;
      BodyPeriodTotal[1] = 0;
      BodyPeriodTotal[0] = 0;
      BodyShortTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) ;
      BodyLongTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) ;
      i = BodyShortTrailingIdx;
      while( i < startIdx ) {
         BodyPeriodTotal[3] += ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-3] - inOpen[i-3] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-3] - inLow[i-3] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-3] - ( inClose[i-3] >= inOpen[i-3] ? inClose[i-3] : inOpen[i-3] ) ) + ( ( inClose[i-3] >= inOpen[i-3] ? inOpen[i-3] : inClose[i-3] ) - inLow[i-3] ) : 0 ) ) ) ;
         BodyPeriodTotal[2] += ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-2] - inLow[i-2] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-2] - ( inClose[i-2] >= inOpen[i-2] ? inClose[i-2] : inOpen[i-2] ) ) + ( ( inClose[i-2] >= inOpen[i-2] ? inOpen[i-2] : inClose[i-2] ) - inLow[i-2] ) : 0 ) ) ) ;
         BodyPeriodTotal[1] += ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ;
         i++;
      }
      i = BodyLongTrailingIdx;
      while( i < startIdx ) {
         BodyPeriodTotal[4] += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-4] - inOpen[i-4] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-4] - inLow[i-4] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-4] - ( inClose[i-4] >= inOpen[i-4] ? inClose[i-4] : inOpen[i-4] ) ) + ( ( inClose[i-4] >= inOpen[i-4] ? inOpen[i-4] : inClose[i-4] ) - inLow[i-4] ) : 0 ) ) ) ;
         i++;
      }
      i = startIdx;
      outIdx = 0;
      do
      {
         if(
            ( Math.abs ( inClose[i-4] - inOpen[i-4] ) ) > ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) != 0.0? BodyPeriodTotal[4] / (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-4] - inOpen[i-4] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-4] - inLow[i-4] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-4] - ( inClose[i-4] >= inOpen[i-4] ? inClose[i-4] : inOpen[i-4] ) ) + ( ( inClose[i-4] >= inOpen[i-4] ? inOpen[i-4] : inClose[i-4] ) - inLow[i-4] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( Math.abs ( inClose[i-3] - inOpen[i-3] ) ) < ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) != 0.0? BodyPeriodTotal[3] / (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-3] - inOpen[i-3] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-3] - inLow[i-3] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-3] - ( inClose[i-3] >= inOpen[i-3] ? inClose[i-3] : inOpen[i-3] ) ) + ( ( inClose[i-3] >= inOpen[i-3] ? inOpen[i-3] : inClose[i-3] ) - inLow[i-3] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) < ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) != 0.0? BodyPeriodTotal[2] / (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-2] - inLow[i-2] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-2] - ( inClose[i-2] >= inOpen[i-2] ? inClose[i-2] : inOpen[i-2] ) ) + ( ( inClose[i-2] >= inOpen[i-2] ? inOpen[i-2] : inClose[i-2] ) - inLow[i-2] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) < ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) != 0.0? BodyPeriodTotal[1] / (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( inClose[i-4] >= inOpen[i-4] ? 1 : -1 ) == 1 &&
            ( inClose[i-3] >= inOpen[i-3] ? 1 : -1 ) == -1 &&
            ( inClose[i] >= inOpen[i] ? 1 : -1 ) == 1 &&
            ( (((inOpen[i-3]) < (inClose[i-3])) ? (inOpen[i-3]) : (inClose[i-3])) > (((inOpen[i-4]) > (inClose[i-4])) ? (inOpen[i-4]) : (inClose[i-4])) ) &&
            (((inOpen[i-2]) < (inClose[i-2])) ? (inOpen[i-2]) : (inClose[i-2])) < inClose[i-4] &&
            (((inOpen[i-1]) < (inClose[i-1])) ? (inOpen[i-1]) : (inClose[i-1])) < inClose[i-4] &&
            (((inOpen[i-2]) < (inClose[i-2])) ? (inOpen[i-2]) : (inClose[i-2])) > inClose[i-4] - ( Math.abs ( inClose[i-4] - inOpen[i-4] ) ) * optInPenetration &&
            (((inOpen[i-1]) < (inClose[i-1])) ? (inOpen[i-1]) : (inClose[i-1])) > inClose[i-4] - ( Math.abs ( inClose[i-4] - inOpen[i-4] ) ) * optInPenetration &&
            (((inClose[i-2]) > (inOpen[i-2])) ? (inClose[i-2]) : (inOpen[i-2])) < inOpen[i-3] &&
            (((inClose[i-1]) > (inOpen[i-1])) ? (inClose[i-1]) : (inOpen[i-1])) < (((inClose[i-2]) > (inOpen[i-2])) ? (inClose[i-2]) : (inOpen[i-2])) &&
            inOpen[i] > inClose[i-1] &&
            inClose[i] > ((( (((inHigh[i-3]) > (inHigh[i-2])) ? (inHigh[i-3]) : (inHigh[i-2])) ) > (inHigh[i-1])) ? ( (((inHigh[i-3]) > (inHigh[i-2])) ? (inHigh[i-3]) : (inHigh[i-2])) ) : (inHigh[i-1]))
            )
            outInteger[outIdx++] = 100;
         else
            outInteger[outIdx++] = 0;
         BodyPeriodTotal[4] += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-4] - inOpen[i-4] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-4] - inLow[i-4] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-4] - ( inClose[i-4] >= inOpen[i-4] ? inClose[i-4] : inOpen[i-4] ) ) + ( ( inClose[i-4] >= inOpen[i-4] ? inOpen[i-4] : inClose[i-4] ) - inLow[i-4] ) : 0 ) ) ) - ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[BodyLongTrailingIdx-4] - inOpen[BodyLongTrailingIdx-4] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[BodyLongTrailingIdx-4] - inLow[BodyLongTrailingIdx-4] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[BodyLongTrailingIdx-4] - ( inClose[BodyLongTrailingIdx-4] >= inOpen[BodyLongTrailingIdx-4] ? inClose[BodyLongTrailingIdx-4] : inOpen[BodyLongTrailingIdx-4] ) ) + ( ( inClose[BodyLongTrailingIdx-4] >= inOpen[BodyLongTrailingIdx-4] ? inOpen[BodyLongTrailingIdx-4] : inClose[BodyLongTrailingIdx-4] ) - inLow[BodyLongTrailingIdx-4] ) : 0 ) ) ) ;
         for (totIdx = 3; totIdx >= 1; --totIdx)
            BodyPeriodTotal[totIdx] += ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-totIdx] - inOpen[i-totIdx] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-totIdx] - inLow[i-totIdx] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-totIdx] - ( inClose[i-totIdx] >= inOpen[i-totIdx] ? inClose[i-totIdx] : inOpen[i-totIdx] ) ) + ( ( inClose[i-totIdx] >= inOpen[i-totIdx] ? inOpen[i-totIdx] : inClose[i-totIdx] ) - inLow[i-totIdx] ) : 0 ) ) )
            - ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[BodyShortTrailingIdx-totIdx] - inOpen[BodyShortTrailingIdx-totIdx] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[BodyShortTrailingIdx-totIdx] - inLow[BodyShortTrailingIdx-totIdx] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[BodyShortTrailingIdx-totIdx] - ( inClose[BodyShortTrailingIdx-totIdx] >= inOpen[BodyShortTrailingIdx-totIdx] ? inClose[BodyShortTrailingIdx-totIdx] : inOpen[BodyShortTrailingIdx-totIdx] ) ) + ( ( inClose[BodyShortTrailingIdx-totIdx] >= inOpen[BodyShortTrailingIdx-totIdx] ? inOpen[BodyShortTrailingIdx-totIdx] : inClose[BodyShortTrailingIdx-totIdx] ) - inLow[BodyShortTrailingIdx-totIdx] ) : 0 ) ) ) ;
         i++;
         BodyShortTrailingIdx++;
         BodyLongTrailingIdx++;
      } while( i <= endIdx );
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   public int cdlMatHoldStateInit( struct TA_cdlMatHold_State** _state,
      double optInPenetration )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if( optInPenetration == (-4e+37) )
         optInPenetration = 5.000000e-1;
      else if( (optInPenetration < 0.000000e+0) || (optInPenetration > 3.000000e+37) )
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct cdlMatHold ));
      _state.value .value .mem_index = 0;
      _state.value .value .optInPenetration = optInPenetration;
      _state.value .value .mem_size = cdlMatHoldLookback (optInPenetration );
      if ( _state.value .value .mem_size > 0)
         _state.value .value .memory = TA_Calloc( _state.value .value .mem_size , sizeof(struct TA_CDLMATHOLD_Data));
      else
         _state.value .value .memory = NULL;
      return RetCode.Success ;
   }
   public int cdlMatHoldState( struct TA_cdlMatHold_State* _state,
      double inOpen,
      double inHigh,
      double inLow,
      double inClose,
      int *outInteger )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      size_t _cur_idx = _state.value .mem_index++;
      if ( _state.value .mem_size > 0) _cur_idx %= _state.value .mem_size ;
      if ( _state.value .mem_size > _state.value .mem_index - 1 ) {
         ( _state.value .memory+_cur_idx).value .inOpen = inOpen ;
         ( _state.value .memory+_cur_idx).value .inHigh = inHigh ;
         ( _state.value .memory+_cur_idx).value .inLow = inLow ;
         ( _state.value .memory+_cur_idx).value .inClose = inClose ;
         return RetCode.NeedMoreData ; }
      return RetCode.Success ;
   }
   public int cdlMatHoldStateFree( struct TA_cdlMatHold_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if ( _state.value != NULL) {
         if ( _state.value .value .memory != NULL) TA_Free( _state.value .value .memory );
         TA_Free( _state.value ); _state.value = NULL;}
      return RetCode.Success ;
   }
   public RetCode cdlMatHold( int startIdx,
      int endIdx,
      float inOpen[],
      float inHigh[],
      float inLow[],
      float inClose[],
      double optInPenetration,
      MInteger outBegIdx,
      MInteger outNBElement,
      int outInteger[] )
   {
      double []BodyPeriodTotal = new double[5] ;
      int i, outIdx, totIdx, BodyShortTrailingIdx, BodyLongTrailingIdx, lookbackTotal;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      if( optInPenetration == (-4e+37) )
         optInPenetration = 5.000000e-1;
      else if( (optInPenetration < 0.000000e+0) || (optInPenetration > 3.000000e+37) )
         return RetCode.BadParam ;
      lookbackTotal = cdlMatHoldLookback (optInPenetration);
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      BodyPeriodTotal[4] = 0;
      BodyPeriodTotal[3] = 0;
      BodyPeriodTotal[2] = 0;
      BodyPeriodTotal[1] = 0;
      BodyPeriodTotal[0] = 0;
      BodyShortTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) ;
      BodyLongTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) ;
      i = BodyShortTrailingIdx;
      while( i < startIdx ) {
         BodyPeriodTotal[3] += ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-3] - inOpen[i-3] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-3] - inLow[i-3] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-3] - ( inClose[i-3] >= inOpen[i-3] ? inClose[i-3] : inOpen[i-3] ) ) + ( ( inClose[i-3] >= inOpen[i-3] ? inOpen[i-3] : inClose[i-3] ) - inLow[i-3] ) : 0 ) ) ) ;
         BodyPeriodTotal[2] += ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-2] - inLow[i-2] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-2] - ( inClose[i-2] >= inOpen[i-2] ? inClose[i-2] : inOpen[i-2] ) ) + ( ( inClose[i-2] >= inOpen[i-2] ? inOpen[i-2] : inClose[i-2] ) - inLow[i-2] ) : 0 ) ) ) ;
         BodyPeriodTotal[1] += ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ;
         i++;
      }
      i = BodyLongTrailingIdx;
      while( i < startIdx ) {
         BodyPeriodTotal[4] += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-4] - inOpen[i-4] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-4] - inLow[i-4] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-4] - ( inClose[i-4] >= inOpen[i-4] ? inClose[i-4] : inOpen[i-4] ) ) + ( ( inClose[i-4] >= inOpen[i-4] ? inOpen[i-4] : inClose[i-4] ) - inLow[i-4] ) : 0 ) ) ) ;
         i++;
      }
      i = startIdx;
      outIdx = 0;
      do
      {
         if(
            ( Math.abs ( inClose[i-4] - inOpen[i-4] ) ) > ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) != 0.0? BodyPeriodTotal[4] / (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-4] - inOpen[i-4] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-4] - inLow[i-4] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-4] - ( inClose[i-4] >= inOpen[i-4] ? inClose[i-4] : inOpen[i-4] ) ) + ( ( inClose[i-4] >= inOpen[i-4] ? inOpen[i-4] : inClose[i-4] ) - inLow[i-4] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( Math.abs ( inClose[i-3] - inOpen[i-3] ) ) < ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) != 0.0? BodyPeriodTotal[3] / (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-3] - inOpen[i-3] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-3] - inLow[i-3] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-3] - ( inClose[i-3] >= inOpen[i-3] ? inClose[i-3] : inOpen[i-3] ) ) + ( ( inClose[i-3] >= inOpen[i-3] ? inOpen[i-3] : inClose[i-3] ) - inLow[i-3] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) < ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) != 0.0? BodyPeriodTotal[2] / (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-2] - inLow[i-2] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-2] - ( inClose[i-2] >= inOpen[i-2] ? inClose[i-2] : inOpen[i-2] ) ) + ( ( inClose[i-2] >= inOpen[i-2] ? inOpen[i-2] : inClose[i-2] ) - inLow[i-2] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) < ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) != 0.0? BodyPeriodTotal[1] / (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( inClose[i-4] >= inOpen[i-4] ? 1 : -1 ) == 1 &&
            ( inClose[i-3] >= inOpen[i-3] ? 1 : -1 ) == -1 &&
            ( inClose[i] >= inOpen[i] ? 1 : -1 ) == 1 &&
            ( (((inOpen[i-3]) < (inClose[i-3])) ? (inOpen[i-3]) : (inClose[i-3])) > (((inOpen[i-4]) > (inClose[i-4])) ? (inOpen[i-4]) : (inClose[i-4])) ) &&
            (((inOpen[i-2]) < (inClose[i-2])) ? (inOpen[i-2]) : (inClose[i-2])) < inClose[i-4] &&
            (((inOpen[i-1]) < (inClose[i-1])) ? (inOpen[i-1]) : (inClose[i-1])) < inClose[i-4] &&
            (((inOpen[i-2]) < (inClose[i-2])) ? (inOpen[i-2]) : (inClose[i-2])) > inClose[i-4] - ( Math.abs ( inClose[i-4] - inOpen[i-4] ) ) * optInPenetration &&
            (((inOpen[i-1]) < (inClose[i-1])) ? (inOpen[i-1]) : (inClose[i-1])) > inClose[i-4] - ( Math.abs ( inClose[i-4] - inOpen[i-4] ) ) * optInPenetration &&
            (((inClose[i-2]) > (inOpen[i-2])) ? (inClose[i-2]) : (inOpen[i-2])) < inOpen[i-3] &&
            (((inClose[i-1]) > (inOpen[i-1])) ? (inClose[i-1]) : (inOpen[i-1])) < (((inClose[i-2]) > (inOpen[i-2])) ? (inClose[i-2]) : (inOpen[i-2])) &&
            inOpen[i] > inClose[i-1] &&
            inClose[i] > ((( (((inHigh[i-3]) > (inHigh[i-2])) ? (inHigh[i-3]) : (inHigh[i-2])) ) > (inHigh[i-1])) ? ( (((inHigh[i-3]) > (inHigh[i-2])) ? (inHigh[i-3]) : (inHigh[i-2])) ) : (inHigh[i-1]))
            )
            outInteger[outIdx++] = 100;
         else
            outInteger[outIdx++] = 0;
         BodyPeriodTotal[4] += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-4] - inOpen[i-4] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-4] - inLow[i-4] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-4] - ( inClose[i-4] >= inOpen[i-4] ? inClose[i-4] : inOpen[i-4] ) ) + ( ( inClose[i-4] >= inOpen[i-4] ? inOpen[i-4] : inClose[i-4] ) - inLow[i-4] ) : 0 ) ) ) - ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[BodyLongTrailingIdx-4] - inOpen[BodyLongTrailingIdx-4] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[BodyLongTrailingIdx-4] - inLow[BodyLongTrailingIdx-4] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[BodyLongTrailingIdx-4] - ( inClose[BodyLongTrailingIdx-4] >= inOpen[BodyLongTrailingIdx-4] ? inClose[BodyLongTrailingIdx-4] : inOpen[BodyLongTrailingIdx-4] ) ) + ( ( inClose[BodyLongTrailingIdx-4] >= inOpen[BodyLongTrailingIdx-4] ? inOpen[BodyLongTrailingIdx-4] : inClose[BodyLongTrailingIdx-4] ) - inLow[BodyLongTrailingIdx-4] ) : 0 ) ) ) ;
         for (totIdx = 3; totIdx >= 1; --totIdx)
            BodyPeriodTotal[totIdx] += ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-totIdx] - inOpen[i-totIdx] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-totIdx] - inLow[i-totIdx] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-totIdx] - ( inClose[i-totIdx] >= inOpen[i-totIdx] ? inClose[i-totIdx] : inOpen[i-totIdx] ) ) + ( ( inClose[i-totIdx] >= inOpen[i-totIdx] ? inOpen[i-totIdx] : inClose[i-totIdx] ) - inLow[i-totIdx] ) : 0 ) ) )
            - ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[BodyShortTrailingIdx-totIdx] - inOpen[BodyShortTrailingIdx-totIdx] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[BodyShortTrailingIdx-totIdx] - inLow[BodyShortTrailingIdx-totIdx] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[BodyShortTrailingIdx-totIdx] - ( inClose[BodyShortTrailingIdx-totIdx] >= inOpen[BodyShortTrailingIdx-totIdx] ? inClose[BodyShortTrailingIdx-totIdx] : inOpen[BodyShortTrailingIdx-totIdx] ) ) + ( ( inClose[BodyShortTrailingIdx-totIdx] >= inOpen[BodyShortTrailingIdx-totIdx] ? inOpen[BodyShortTrailingIdx-totIdx] : inClose[BodyShortTrailingIdx-totIdx] ) - inLow[BodyShortTrailingIdx-totIdx] ) : 0 ) ) ) ;
         i++;
         BodyShortTrailingIdx++;
         BodyLongTrailingIdx++;
      } while( i <= endIdx );
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   /* Generated */
   public int cdlMorningDojiStarLookback( double optInPenetration )
   {
      if( optInPenetration == (-4e+37) )
         optInPenetration = 3.000000e-1;
      else if( (optInPenetration < 0.000000e+0) || (optInPenetration > 3.000000e+37) )
         return -1;
      return ((( ((( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].avgPeriod) ) > ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) )) ? ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].avgPeriod) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) )) ) > ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) )) ? ( ((( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].avgPeriod) ) > ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) )) ? ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].avgPeriod) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) )) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) )) +
         2;
   }
   public RetCode cdlMorningDojiStar( int startIdx,
      int endIdx,
      double inOpen[],
      double inHigh[],
      double inLow[],
      double inClose[],
      double optInPenetration,
      MInteger outBegIdx,
      MInteger outNBElement,
      int outInteger[] )
   {
      double BodyDojiPeriodTotal, BodyLongPeriodTotal, BodyShortPeriodTotal;
      int i, outIdx, BodyDojiTrailingIdx, BodyLongTrailingIdx, BodyShortTrailingIdx, lookbackTotal;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      if( optInPenetration == (-4e+37) )
         optInPenetration = 3.000000e-1;
      else if( (optInPenetration < 0.000000e+0) || (optInPenetration > 3.000000e+37) )
         return RetCode.BadParam ;
      lookbackTotal = cdlMorningDojiStarLookback (optInPenetration);
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      BodyLongPeriodTotal = 0;
      BodyDojiPeriodTotal = 0;
      BodyShortPeriodTotal = 0;
      BodyLongTrailingIdx = startIdx -2 - (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) ;
      BodyDojiTrailingIdx = startIdx -1 - (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].avgPeriod) ;
      BodyShortTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) ;
      i = BodyLongTrailingIdx;
      while( i < startIdx-2 ) {
         BodyLongPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      i = BodyDojiTrailingIdx;
      while( i < startIdx-1 ) {
         BodyDojiPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      i = BodyShortTrailingIdx;
      while( i < startIdx ) {
         BodyShortPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      i = startIdx;
      outIdx = 0;
      do
      {
         if( ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) > ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) != 0.0? BodyLongPeriodTotal / (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-2] - inLow[i-2] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-2] - ( inClose[i-2] >= inOpen[i-2] ? inClose[i-2] : inOpen[i-2] ) ) + ( ( inClose[i-2] >= inOpen[i-2] ? inOpen[i-2] : inClose[i-2] ) - inLow[i-2] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( inClose[i-2] >= inOpen[i-2] ? 1 : -1 ) == -1 &&
            ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) <= ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].avgPeriod) != 0.0? BodyDojiPeriodTotal / (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( (((inOpen[i-1]) > (inClose[i-1])) ? (inOpen[i-1]) : (inClose[i-1])) < (((inOpen[i-2]) < (inClose[i-2])) ? (inOpen[i-2]) : (inClose[i-2])) ) &&
            ( Math.abs ( inClose[i] - inOpen[i] ) ) > ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) != 0.0? BodyShortPeriodTotal / (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( inClose[i] >= inOpen[i] ? 1 : -1 ) == 1 &&
            inClose[i] > inClose[i-2] + ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) * optInPenetration
            )
            outInteger[outIdx++] = 100;
         else
            outInteger[outIdx++] = 0;
         BodyLongPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-2] - inLow[i-2] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-2] - ( inClose[i-2] >= inOpen[i-2] ? inClose[i-2] : inOpen[i-2] ) ) + ( ( inClose[i-2] >= inOpen[i-2] ? inOpen[i-2] : inClose[i-2] ) - inLow[i-2] ) : 0 ) ) ) - ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[BodyLongTrailingIdx] - inOpen[BodyLongTrailingIdx] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[BodyLongTrailingIdx] - inLow[BodyLongTrailingIdx] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[BodyLongTrailingIdx] - ( inClose[BodyLongTrailingIdx] >= inOpen[BodyLongTrailingIdx] ? inClose[BodyLongTrailingIdx] : inOpen[BodyLongTrailingIdx] ) ) + ( ( inClose[BodyLongTrailingIdx] >= inOpen[BodyLongTrailingIdx] ? inOpen[BodyLongTrailingIdx] : inClose[BodyLongTrailingIdx] ) - inLow[BodyLongTrailingIdx] ) : 0 ) ) ) ;
         BodyDojiPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) - ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[BodyDojiTrailingIdx] - inOpen[BodyDojiTrailingIdx] ) ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[BodyDojiTrailingIdx] - inLow[BodyDojiTrailingIdx] ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[BodyDojiTrailingIdx] - ( inClose[BodyDojiTrailingIdx] >= inOpen[BodyDojiTrailingIdx] ? inClose[BodyDojiTrailingIdx] : inOpen[BodyDojiTrailingIdx] ) ) + ( ( inClose[BodyDojiTrailingIdx] >= inOpen[BodyDojiTrailingIdx] ? inOpen[BodyDojiTrailingIdx] : inClose[BodyDojiTrailingIdx] ) - inLow[BodyDojiTrailingIdx] ) : 0 ) ) ) ;
         BodyShortPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) - ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[BodyShortTrailingIdx] - inOpen[BodyShortTrailingIdx] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[BodyShortTrailingIdx] - inLow[BodyShortTrailingIdx] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[BodyShortTrailingIdx] - ( inClose[BodyShortTrailingIdx] >= inOpen[BodyShortTrailingIdx] ? inClose[BodyShortTrailingIdx] : inOpen[BodyShortTrailingIdx] ) ) + ( ( inClose[BodyShortTrailingIdx] >= inOpen[BodyShortTrailingIdx] ? inOpen[BodyShortTrailingIdx] : inClose[BodyShortTrailingIdx] ) - inLow[BodyShortTrailingIdx] ) : 0 ) ) ) ;
         i++;
         BodyLongTrailingIdx++;
         BodyDojiTrailingIdx++;
         BodyShortTrailingIdx++;
      } while( i <= endIdx );
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   public int cdlMorningDojiStarStateInit( struct TA_cdlMorningDojiStar_State** _state,
      double optInPenetration )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if( optInPenetration == (-4e+37) )
         optInPenetration = 3.000000e-1;
      else if( (optInPenetration < 0.000000e+0) || (optInPenetration > 3.000000e+37) )
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct cdlMorningDojiStar ));
      _state.value .value .mem_index = 0;
      _state.value .value .optInPenetration = optInPenetration;
      _state.value .value .mem_size = cdlMorningDojiStarLookback (optInPenetration );
      if ( _state.value .value .mem_size > 0)
         _state.value .value .memory = TA_Calloc( _state.value .value .mem_size , sizeof(struct TA_CDLMORNINGDOJISTAR_Data));
      else
         _state.value .value .memory = NULL;
      return RetCode.Success ;
   }
   public int cdlMorningDojiStarState( struct TA_cdlMorningDojiStar_State* _state,
      double inOpen,
      double inHigh,
      double inLow,
      double inClose,
      int *outInteger )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      size_t _cur_idx = _state.value .mem_index++;
      if ( _state.value .mem_size > 0) _cur_idx %= _state.value .mem_size ;
      if ( _state.value .mem_size > _state.value .mem_index - 1 ) {
         ( _state.value .memory+_cur_idx).value .inOpen = inOpen ;
         ( _state.value .memory+_cur_idx).value .inHigh = inHigh ;
         ( _state.value .memory+_cur_idx).value .inLow = inLow ;
         ( _state.value .memory+_cur_idx).value .inClose = inClose ;
         return RetCode.NeedMoreData ; }
      return RetCode.Success ;
   }
   public int cdlMorningDojiStarStateFree( struct TA_cdlMorningDojiStar_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if ( _state.value != NULL) {
         if ( _state.value .value .memory != NULL) TA_Free( _state.value .value .memory );
         TA_Free( _state.value ); _state.value = NULL;}
      return RetCode.Success ;
   }
   public RetCode cdlMorningDojiStar( int startIdx,
      int endIdx,
      float inOpen[],
      float inHigh[],
      float inLow[],
      float inClose[],
      double optInPenetration,
      MInteger outBegIdx,
      MInteger outNBElement,
      int outInteger[] )
   {
      double BodyDojiPeriodTotal, BodyLongPeriodTotal, BodyShortPeriodTotal;
      int i, outIdx, BodyDojiTrailingIdx, BodyLongTrailingIdx, BodyShortTrailingIdx, lookbackTotal;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      if( optInPenetration == (-4e+37) )
         optInPenetration = 3.000000e-1;
      else if( (optInPenetration < 0.000000e+0) || (optInPenetration > 3.000000e+37) )
         return RetCode.BadParam ;
      lookbackTotal = cdlMorningDojiStarLookback (optInPenetration);
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      BodyLongPeriodTotal = 0;
      BodyDojiPeriodTotal = 0;
      BodyShortPeriodTotal = 0;
      BodyLongTrailingIdx = startIdx -2 - (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) ;
      BodyDojiTrailingIdx = startIdx -1 - (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].avgPeriod) ;
      BodyShortTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) ;
      i = BodyLongTrailingIdx;
      while( i < startIdx-2 ) {
         BodyLongPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      i = BodyDojiTrailingIdx;
      while( i < startIdx-1 ) {
         BodyDojiPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      i = BodyShortTrailingIdx;
      while( i < startIdx ) {
         BodyShortPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      i = startIdx;
      outIdx = 0;
      do
      {
         if( ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) > ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) != 0.0? BodyLongPeriodTotal / (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-2] - inLow[i-2] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-2] - ( inClose[i-2] >= inOpen[i-2] ? inClose[i-2] : inOpen[i-2] ) ) + ( ( inClose[i-2] >= inOpen[i-2] ? inOpen[i-2] : inClose[i-2] ) - inLow[i-2] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( inClose[i-2] >= inOpen[i-2] ? 1 : -1 ) == -1 &&
            ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) <= ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].avgPeriod) != 0.0? BodyDojiPeriodTotal / (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( (((inOpen[i-1]) > (inClose[i-1])) ? (inOpen[i-1]) : (inClose[i-1])) < (((inOpen[i-2]) < (inClose[i-2])) ? (inOpen[i-2]) : (inClose[i-2])) ) &&
            ( Math.abs ( inClose[i] - inOpen[i] ) ) > ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) != 0.0? BodyShortPeriodTotal / (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( inClose[i] >= inOpen[i] ? 1 : -1 ) == 1 &&
            inClose[i] > inClose[i-2] + ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) * optInPenetration
            )
            outInteger[outIdx++] = 100;
         else
            outInteger[outIdx++] = 0;
         BodyLongPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-2] - inLow[i-2] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-2] - ( inClose[i-2] >= inOpen[i-2] ? inClose[i-2] : inOpen[i-2] ) ) + ( ( inClose[i-2] >= inOpen[i-2] ? inOpen[i-2] : inClose[i-2] ) - inLow[i-2] ) : 0 ) ) ) - ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[BodyLongTrailingIdx] - inOpen[BodyLongTrailingIdx] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[BodyLongTrailingIdx] - inLow[BodyLongTrailingIdx] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[BodyLongTrailingIdx] - ( inClose[BodyLongTrailingIdx] >= inOpen[BodyLongTrailingIdx] ? inClose[BodyLongTrailingIdx] : inOpen[BodyLongTrailingIdx] ) ) + ( ( inClose[BodyLongTrailingIdx] >= inOpen[BodyLongTrailingIdx] ? inOpen[BodyLongTrailingIdx] : inClose[BodyLongTrailingIdx] ) - inLow[BodyLongTrailingIdx] ) : 0 ) ) ) ;
         BodyDojiPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) - ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[BodyDojiTrailingIdx] - inOpen[BodyDojiTrailingIdx] ) ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[BodyDojiTrailingIdx] - inLow[BodyDojiTrailingIdx] ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[BodyDojiTrailingIdx] - ( inClose[BodyDojiTrailingIdx] >= inOpen[BodyDojiTrailingIdx] ? inClose[BodyDojiTrailingIdx] : inOpen[BodyDojiTrailingIdx] ) ) + ( ( inClose[BodyDojiTrailingIdx] >= inOpen[BodyDojiTrailingIdx] ? inOpen[BodyDojiTrailingIdx] : inClose[BodyDojiTrailingIdx] ) - inLow[BodyDojiTrailingIdx] ) : 0 ) ) ) ;
         BodyShortPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) - ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[BodyShortTrailingIdx] - inOpen[BodyShortTrailingIdx] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[BodyShortTrailingIdx] - inLow[BodyShortTrailingIdx] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[BodyShortTrailingIdx] - ( inClose[BodyShortTrailingIdx] >= inOpen[BodyShortTrailingIdx] ? inClose[BodyShortTrailingIdx] : inOpen[BodyShortTrailingIdx] ) ) + ( ( inClose[BodyShortTrailingIdx] >= inOpen[BodyShortTrailingIdx] ? inOpen[BodyShortTrailingIdx] : inClose[BodyShortTrailingIdx] ) - inLow[BodyShortTrailingIdx] ) : 0 ) ) ) ;
         i++;
         BodyLongTrailingIdx++;
         BodyDojiTrailingIdx++;
         BodyShortTrailingIdx++;
      } while( i <= endIdx );
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   /* Generated */
   public int cdlMorningStarLookback( double optInPenetration )
   {
      if( optInPenetration == (-4e+37) )
         optInPenetration = 3.000000e-1;
      else if( (optInPenetration < 0.000000e+0) || (optInPenetration > 3.000000e+37) )
         return -1;
      return ((( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) ) > ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) )) ? ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) )) + 2;
   }
   public RetCode cdlMorningStar( int startIdx,
      int endIdx,
      double inOpen[],
      double inHigh[],
      double inLow[],
      double inClose[],
      double optInPenetration,
      MInteger outBegIdx,
      MInteger outNBElement,
      int outInteger[] )
   {
      double BodyShortPeriodTotal, BodyLongPeriodTotal, BodyShortPeriodTotal2;
      int i, outIdx, BodyShortTrailingIdx, BodyLongTrailingIdx, lookbackTotal;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      if( optInPenetration == (-4e+37) )
         optInPenetration = 3.000000e-1;
      else if( (optInPenetration < 0.000000e+0) || (optInPenetration > 3.000000e+37) )
         return RetCode.BadParam ;
      lookbackTotal = cdlMorningStarLookback (optInPenetration);
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      BodyLongPeriodTotal = 0;
      BodyShortPeriodTotal = 0;
      BodyShortPeriodTotal2 = 0;
      BodyLongTrailingIdx = startIdx -2 - (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) ;
      BodyShortTrailingIdx = startIdx -1 - (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) ;
      i = BodyLongTrailingIdx;
      while( i < startIdx-2 ) {
         BodyLongPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      i = BodyShortTrailingIdx;
      while( i < startIdx-1 ) {
         BodyShortPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         BodyShortPeriodTotal2 += ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i+1] - inOpen[i+1] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i+1] - inLow[i+1] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i+1] - ( inClose[i+1] >= inOpen[i+1] ? inClose[i+1] : inOpen[i+1] ) ) + ( ( inClose[i+1] >= inOpen[i+1] ? inOpen[i+1] : inClose[i+1] ) - inLow[i+1] ) : 0 ) ) ) ;
         i++;
      }
      i = startIdx;
      outIdx = 0;
      do
      {
         if( ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) > ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) != 0.0? BodyLongPeriodTotal / (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-2] - inLow[i-2] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-2] - ( inClose[i-2] >= inOpen[i-2] ? inClose[i-2] : inOpen[i-2] ) ) + ( ( inClose[i-2] >= inOpen[i-2] ? inOpen[i-2] : inClose[i-2] ) - inLow[i-2] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( inClose[i-2] >= inOpen[i-2] ? 1 : -1 ) == -1 &&
            ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) <= ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) != 0.0? BodyShortPeriodTotal / (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( (((inOpen[i-1]) > (inClose[i-1])) ? (inOpen[i-1]) : (inClose[i-1])) < (((inOpen[i-2]) < (inClose[i-2])) ? (inOpen[i-2]) : (inClose[i-2])) ) &&
            ( Math.abs ( inClose[i] - inOpen[i] ) ) > ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) != 0.0? BodyShortPeriodTotal2 / (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( inClose[i] >= inOpen[i] ? 1 : -1 ) == 1 &&
            inClose[i] > inClose[i-2] + ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) * optInPenetration
            )
            outInteger[outIdx++] = 100;
         else
            outInteger[outIdx++] = 0;
         BodyLongPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-2] - inLow[i-2] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-2] - ( inClose[i-2] >= inOpen[i-2] ? inClose[i-2] : inOpen[i-2] ) ) + ( ( inClose[i-2] >= inOpen[i-2] ? inOpen[i-2] : inClose[i-2] ) - inLow[i-2] ) : 0 ) ) ) - ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[BodyLongTrailingIdx] - inOpen[BodyLongTrailingIdx] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[BodyLongTrailingIdx] - inLow[BodyLongTrailingIdx] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[BodyLongTrailingIdx] - ( inClose[BodyLongTrailingIdx] >= inOpen[BodyLongTrailingIdx] ? inClose[BodyLongTrailingIdx] : inOpen[BodyLongTrailingIdx] ) ) + ( ( inClose[BodyLongTrailingIdx] >= inOpen[BodyLongTrailingIdx] ? inOpen[BodyLongTrailingIdx] : inClose[BodyLongTrailingIdx] ) - inLow[BodyLongTrailingIdx] ) : 0 ) ) ) ;
         BodyShortPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) - ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[BodyShortTrailingIdx] - inOpen[BodyShortTrailingIdx] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[BodyShortTrailingIdx] - inLow[BodyShortTrailingIdx] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[BodyShortTrailingIdx] - ( inClose[BodyShortTrailingIdx] >= inOpen[BodyShortTrailingIdx] ? inClose[BodyShortTrailingIdx] : inOpen[BodyShortTrailingIdx] ) ) + ( ( inClose[BodyShortTrailingIdx] >= inOpen[BodyShortTrailingIdx] ? inOpen[BodyShortTrailingIdx] : inClose[BodyShortTrailingIdx] ) - inLow[BodyShortTrailingIdx] ) : 0 ) ) ) ;
         BodyShortPeriodTotal2 += ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) - ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[BodyShortTrailingIdx+1] - inOpen[BodyShortTrailingIdx+1] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[BodyShortTrailingIdx+1] - inLow[BodyShortTrailingIdx+1] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[BodyShortTrailingIdx+1] - ( inClose[BodyShortTrailingIdx+1] >= inOpen[BodyShortTrailingIdx+1] ? inClose[BodyShortTrailingIdx+1] : inOpen[BodyShortTrailingIdx+1] ) ) + ( ( inClose[BodyShortTrailingIdx+1] >= inOpen[BodyShortTrailingIdx+1] ? inOpen[BodyShortTrailingIdx+1] : inClose[BodyShortTrailingIdx+1] ) - inLow[BodyShortTrailingIdx+1] ) : 0 ) ) ) ;
         i++;
         BodyLongTrailingIdx++;
         BodyShortTrailingIdx++;
      } while( i <= endIdx );
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   public int cdlMorningStarStateInit( struct TA_cdlMorningStar_State** _state,
      double optInPenetration )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if( optInPenetration == (-4e+37) )
         optInPenetration = 3.000000e-1;
      else if( (optInPenetration < 0.000000e+0) || (optInPenetration > 3.000000e+37) )
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct cdlMorningStar ));
      _state.value .value .mem_index = 0;
      _state.value .value .optInPenetration = optInPenetration;
      _state.value .value .mem_size = cdlMorningStarLookback (optInPenetration );
      if ( _state.value .value .mem_size > 0)
         _state.value .value .memory = TA_Calloc( _state.value .value .mem_size , sizeof(struct TA_CDLMORNINGSTAR_Data));
      else
         _state.value .value .memory = NULL;
      return RetCode.Success ;
   }
   public int cdlMorningStarState( struct TA_cdlMorningStar_State* _state,
      double inOpen,
      double inHigh,
      double inLow,
      double inClose,
      int *outInteger )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      size_t _cur_idx = _state.value .mem_index++;
      if ( _state.value .mem_size > 0) _cur_idx %= _state.value .mem_size ;
      if ( _state.value .mem_size > _state.value .mem_index - 1 ) {
         ( _state.value .memory+_cur_idx).value .inOpen = inOpen ;
         ( _state.value .memory+_cur_idx).value .inHigh = inHigh ;
         ( _state.value .memory+_cur_idx).value .inLow = inLow ;
         ( _state.value .memory+_cur_idx).value .inClose = inClose ;
         return RetCode.NeedMoreData ; }
      return RetCode.Success ;
   }
   public int cdlMorningStarStateFree( struct TA_cdlMorningStar_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if ( _state.value != NULL) {
         if ( _state.value .value .memory != NULL) TA_Free( _state.value .value .memory );
         TA_Free( _state.value ); _state.value = NULL;}
      return RetCode.Success ;
   }
   public RetCode cdlMorningStar( int startIdx,
      int endIdx,
      float inOpen[],
      float inHigh[],
      float inLow[],
      float inClose[],
      double optInPenetration,
      MInteger outBegIdx,
      MInteger outNBElement,
      int outInteger[] )
   {
      double BodyShortPeriodTotal, BodyLongPeriodTotal, BodyShortPeriodTotal2;
      int i, outIdx, BodyShortTrailingIdx, BodyLongTrailingIdx, lookbackTotal;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      if( optInPenetration == (-4e+37) )
         optInPenetration = 3.000000e-1;
      else if( (optInPenetration < 0.000000e+0) || (optInPenetration > 3.000000e+37) )
         return RetCode.BadParam ;
      lookbackTotal = cdlMorningStarLookback (optInPenetration);
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      BodyLongPeriodTotal = 0;
      BodyShortPeriodTotal = 0;
      BodyShortPeriodTotal2 = 0;
      BodyLongTrailingIdx = startIdx -2 - (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) ;
      BodyShortTrailingIdx = startIdx -1 - (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) ;
      i = BodyLongTrailingIdx;
      while( i < startIdx-2 ) {
         BodyLongPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      i = BodyShortTrailingIdx;
      while( i < startIdx-1 ) {
         BodyShortPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         BodyShortPeriodTotal2 += ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i+1] - inOpen[i+1] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i+1] - inLow[i+1] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i+1] - ( inClose[i+1] >= inOpen[i+1] ? inClose[i+1] : inOpen[i+1] ) ) + ( ( inClose[i+1] >= inOpen[i+1] ? inOpen[i+1] : inClose[i+1] ) - inLow[i+1] ) : 0 ) ) ) ;
         i++;
      }
      i = startIdx;
      outIdx = 0;
      do
      {
         if( ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) > ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) != 0.0? BodyLongPeriodTotal / (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-2] - inLow[i-2] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-2] - ( inClose[i-2] >= inOpen[i-2] ? inClose[i-2] : inOpen[i-2] ) ) + ( ( inClose[i-2] >= inOpen[i-2] ? inOpen[i-2] : inClose[i-2] ) - inLow[i-2] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( inClose[i-2] >= inOpen[i-2] ? 1 : -1 ) == -1 &&
            ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) <= ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) != 0.0? BodyShortPeriodTotal / (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( (((inOpen[i-1]) > (inClose[i-1])) ? (inOpen[i-1]) : (inClose[i-1])) < (((inOpen[i-2]) < (inClose[i-2])) ? (inOpen[i-2]) : (inClose[i-2])) ) &&
            ( Math.abs ( inClose[i] - inOpen[i] ) ) > ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) != 0.0? BodyShortPeriodTotal2 / (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( inClose[i] >= inOpen[i] ? 1 : -1 ) == 1 &&
            inClose[i] > inClose[i-2] + ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) * optInPenetration
            )
            outInteger[outIdx++] = 100;
         else
            outInteger[outIdx++] = 0;
         BodyLongPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-2] - inLow[i-2] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-2] - ( inClose[i-2] >= inOpen[i-2] ? inClose[i-2] : inOpen[i-2] ) ) + ( ( inClose[i-2] >= inOpen[i-2] ? inOpen[i-2] : inClose[i-2] ) - inLow[i-2] ) : 0 ) ) ) - ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[BodyLongTrailingIdx] - inOpen[BodyLongTrailingIdx] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[BodyLongTrailingIdx] - inLow[BodyLongTrailingIdx] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[BodyLongTrailingIdx] - ( inClose[BodyLongTrailingIdx] >= inOpen[BodyLongTrailingIdx] ? inClose[BodyLongTrailingIdx] : inOpen[BodyLongTrailingIdx] ) ) + ( ( inClose[BodyLongTrailingIdx] >= inOpen[BodyLongTrailingIdx] ? inOpen[BodyLongTrailingIdx] : inClose[BodyLongTrailingIdx] ) - inLow[BodyLongTrailingIdx] ) : 0 ) ) ) ;
         BodyShortPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) - ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[BodyShortTrailingIdx] - inOpen[BodyShortTrailingIdx] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[BodyShortTrailingIdx] - inLow[BodyShortTrailingIdx] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[BodyShortTrailingIdx] - ( inClose[BodyShortTrailingIdx] >= inOpen[BodyShortTrailingIdx] ? inClose[BodyShortTrailingIdx] : inOpen[BodyShortTrailingIdx] ) ) + ( ( inClose[BodyShortTrailingIdx] >= inOpen[BodyShortTrailingIdx] ? inOpen[BodyShortTrailingIdx] : inClose[BodyShortTrailingIdx] ) - inLow[BodyShortTrailingIdx] ) : 0 ) ) ) ;
         BodyShortPeriodTotal2 += ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) - ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[BodyShortTrailingIdx+1] - inOpen[BodyShortTrailingIdx+1] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[BodyShortTrailingIdx+1] - inLow[BodyShortTrailingIdx+1] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[BodyShortTrailingIdx+1] - ( inClose[BodyShortTrailingIdx+1] >= inOpen[BodyShortTrailingIdx+1] ? inClose[BodyShortTrailingIdx+1] : inOpen[BodyShortTrailingIdx+1] ) ) + ( ( inClose[BodyShortTrailingIdx+1] >= inOpen[BodyShortTrailingIdx+1] ? inOpen[BodyShortTrailingIdx+1] : inClose[BodyShortTrailingIdx+1] ) - inLow[BodyShortTrailingIdx+1] ) : 0 ) ) ) ;
         i++;
         BodyLongTrailingIdx++;
         BodyShortTrailingIdx++;
      } while( i <= endIdx );
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   /* Generated */
   public int cdlOnNeckLookback( )
   {
      return ((( (this.candleSettings[CandleSettingType.Equal.ordinal()].avgPeriod) ) > ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) )) ? ( (this.candleSettings[CandleSettingType.Equal.ordinal()].avgPeriod) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) )) +
         1;
   }
   public RetCode cdlOnNeck( int startIdx,
      int endIdx,
      double inOpen[],
      double inHigh[],
      double inLow[],
      double inClose[],
      MInteger outBegIdx,
      MInteger outNBElement,
      int outInteger[] )
   {
      double EqualPeriodTotal, BodyLongPeriodTotal;
      int i, outIdx, EqualTrailingIdx, BodyLongTrailingIdx, lookbackTotal;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      lookbackTotal = cdlOnNeckLookback ();
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      EqualPeriodTotal = 0;
      EqualTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.Equal.ordinal()].avgPeriod) ;
      BodyLongPeriodTotal = 0;
      BodyLongTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) ;
      i = EqualTrailingIdx;
      while( i < startIdx ) {
         EqualPeriodTotal += ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ;
         i++;
      }
      i = BodyLongTrailingIdx;
      while( i < startIdx ) {
         BodyLongPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ;
         i++;
      }
      i = startIdx;
      outIdx = 0;
      do
      {
         if( ( inClose[i-1] >= inOpen[i-1] ? 1 : -1 ) == -1 &&
            ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) > ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) != 0.0? BodyLongPeriodTotal / (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( inClose[i] >= inOpen[i] ? 1 : -1 ) == 1 &&
            inOpen[i] < inLow[i-1] &&
            inClose[i] <= inLow[i-1] + ( (this.candleSettings[CandleSettingType.Equal.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.Equal.ordinal()].avgPeriod) != 0.0? EqualPeriodTotal / (this.candleSettings[CandleSettingType.Equal.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            inClose[i] >= inLow[i-1] - ( (this.candleSettings[CandleSettingType.Equal.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.Equal.ordinal()].avgPeriod) != 0.0? EqualPeriodTotal / (this.candleSettings[CandleSettingType.Equal.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) )
            )
            outInteger[outIdx++] = -100;
         else
            outInteger[outIdx++] = 0;
         EqualPeriodTotal += ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) - ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[EqualTrailingIdx-1] - inOpen[EqualTrailingIdx-1] ) ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[EqualTrailingIdx-1] - inLow[EqualTrailingIdx-1] ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[EqualTrailingIdx-1] - ( inClose[EqualTrailingIdx-1] >= inOpen[EqualTrailingIdx-1] ? inClose[EqualTrailingIdx-1] : inOpen[EqualTrailingIdx-1] ) ) + ( ( inClose[EqualTrailingIdx-1] >= inOpen[EqualTrailingIdx-1] ? inOpen[EqualTrailingIdx-1] : inClose[EqualTrailingIdx-1] ) - inLow[EqualTrailingIdx-1] ) : 0 ) ) ) ;
         BodyLongPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) )
            - ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[BodyLongTrailingIdx-1] - inOpen[BodyLongTrailingIdx-1] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[BodyLongTrailingIdx-1] - inLow[BodyLongTrailingIdx-1] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[BodyLongTrailingIdx-1] - ( inClose[BodyLongTrailingIdx-1] >= inOpen[BodyLongTrailingIdx-1] ? inClose[BodyLongTrailingIdx-1] : inOpen[BodyLongTrailingIdx-1] ) ) + ( ( inClose[BodyLongTrailingIdx-1] >= inOpen[BodyLongTrailingIdx-1] ? inOpen[BodyLongTrailingIdx-1] : inClose[BodyLongTrailingIdx-1] ) - inLow[BodyLongTrailingIdx-1] ) : 0 ) ) ) ;
         i++;
         EqualTrailingIdx++;
         BodyLongTrailingIdx++;
      } while( i <= endIdx );
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   public int cdlOnNeckStateInit( struct TA_cdlOnNeck_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct cdlOnNeck ));
      _state.value .value .mem_index = 0;
      _state.value .value .mem_size = cdlOnNeckLookback ();
      if ( _state.value .value .mem_size > 0)
         _state.value .value .memory = TA_Calloc( _state.value .value .mem_size , sizeof(struct TA_CDLONNECK_Data));
      else
         _state.value .value .memory = NULL;
      return RetCode.Success ;
   }
   public int cdlOnNeckState( struct TA_cdlOnNeck_State* _state,
      double inOpen,
      double inHigh,
      double inLow,
      double inClose,
      int *outInteger )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      size_t _cur_idx = _state.value .mem_index++;
      if ( _state.value .mem_size > 0) _cur_idx %= _state.value .mem_size ;
      if ( _state.value .mem_size > _state.value .mem_index - 1 ) {
         ( _state.value .memory+_cur_idx).value .inOpen = inOpen ;
         ( _state.value .memory+_cur_idx).value .inHigh = inHigh ;
         ( _state.value .memory+_cur_idx).value .inLow = inLow ;
         ( _state.value .memory+_cur_idx).value .inClose = inClose ;
         return RetCode.NeedMoreData ; }
      return RetCode.Success ;
   }
   public int cdlOnNeckStateFree( struct TA_cdlOnNeck_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if ( _state.value != NULL) {
         if ( _state.value .value .memory != NULL) TA_Free( _state.value .value .memory );
         TA_Free( _state.value ); _state.value = NULL;}
      return RetCode.Success ;
   }
   public RetCode cdlOnNeck( int startIdx,
      int endIdx,
      float inOpen[],
      float inHigh[],
      float inLow[],
      float inClose[],
      MInteger outBegIdx,
      MInteger outNBElement,
      int outInteger[] )
   {
      double EqualPeriodTotal, BodyLongPeriodTotal;
      int i, outIdx, EqualTrailingIdx, BodyLongTrailingIdx, lookbackTotal;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      lookbackTotal = cdlOnNeckLookback ();
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      EqualPeriodTotal = 0;
      EqualTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.Equal.ordinal()].avgPeriod) ;
      BodyLongPeriodTotal = 0;
      BodyLongTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) ;
      i = EqualTrailingIdx;
      while( i < startIdx ) {
         EqualPeriodTotal += ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ;
         i++;
      }
      i = BodyLongTrailingIdx;
      while( i < startIdx ) {
         BodyLongPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ;
         i++;
      }
      i = startIdx;
      outIdx = 0;
      do
      {
         if( ( inClose[i-1] >= inOpen[i-1] ? 1 : -1 ) == -1 &&
            ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) > ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) != 0.0? BodyLongPeriodTotal / (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( inClose[i] >= inOpen[i] ? 1 : -1 ) == 1 &&
            inOpen[i] < inLow[i-1] &&
            inClose[i] <= inLow[i-1] + ( (this.candleSettings[CandleSettingType.Equal.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.Equal.ordinal()].avgPeriod) != 0.0? EqualPeriodTotal / (this.candleSettings[CandleSettingType.Equal.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            inClose[i] >= inLow[i-1] - ( (this.candleSettings[CandleSettingType.Equal.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.Equal.ordinal()].avgPeriod) != 0.0? EqualPeriodTotal / (this.candleSettings[CandleSettingType.Equal.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) )
            )
            outInteger[outIdx++] = -100;
         else
            outInteger[outIdx++] = 0;
         EqualPeriodTotal += ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) - ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[EqualTrailingIdx-1] - inOpen[EqualTrailingIdx-1] ) ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[EqualTrailingIdx-1] - inLow[EqualTrailingIdx-1] ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[EqualTrailingIdx-1] - ( inClose[EqualTrailingIdx-1] >= inOpen[EqualTrailingIdx-1] ? inClose[EqualTrailingIdx-1] : inOpen[EqualTrailingIdx-1] ) ) + ( ( inClose[EqualTrailingIdx-1] >= inOpen[EqualTrailingIdx-1] ? inOpen[EqualTrailingIdx-1] : inClose[EqualTrailingIdx-1] ) - inLow[EqualTrailingIdx-1] ) : 0 ) ) ) ;
         BodyLongPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) )
            - ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[BodyLongTrailingIdx-1] - inOpen[BodyLongTrailingIdx-1] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[BodyLongTrailingIdx-1] - inLow[BodyLongTrailingIdx-1] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[BodyLongTrailingIdx-1] - ( inClose[BodyLongTrailingIdx-1] >= inOpen[BodyLongTrailingIdx-1] ? inClose[BodyLongTrailingIdx-1] : inOpen[BodyLongTrailingIdx-1] ) ) + ( ( inClose[BodyLongTrailingIdx-1] >= inOpen[BodyLongTrailingIdx-1] ? inOpen[BodyLongTrailingIdx-1] : inClose[BodyLongTrailingIdx-1] ) - inLow[BodyLongTrailingIdx-1] ) : 0 ) ) ) ;
         i++;
         EqualTrailingIdx++;
         BodyLongTrailingIdx++;
      } while( i <= endIdx );
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   /* Generated */
   public int cdlPiercingLookback( )
   {
      return (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) + 1;
   }
   public RetCode cdlPiercing( int startIdx,
      int endIdx,
      double inOpen[],
      double inHigh[],
      double inLow[],
      double inClose[],
      MInteger outBegIdx,
      MInteger outNBElement,
      int outInteger[] )
   {
      double []BodyLongPeriodTotal = new double[2] ;
      int i, outIdx, totIdx, BodyLongTrailingIdx, lookbackTotal;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      lookbackTotal = cdlPiercingLookback ();
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      BodyLongPeriodTotal[1] = 0;
      BodyLongPeriodTotal[0] = 0;
      BodyLongTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) ;
      i = BodyLongTrailingIdx;
      while( i < startIdx ) {
         BodyLongPeriodTotal[1] += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ;
         BodyLongPeriodTotal[0] += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      i = startIdx;
      outIdx = 0;
      do
      {
         if( ( inClose[i-1] >= inOpen[i-1] ? 1 : -1 ) == -1 &&
            ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) > ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) != 0.0? BodyLongPeriodTotal[1] / (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( inClose[i] >= inOpen[i] ? 1 : -1 ) == 1 &&
            ( Math.abs ( inClose[i] - inOpen[i] ) ) > ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) != 0.0? BodyLongPeriodTotal[0] / (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            inOpen[i] < inLow[i-1] &&
            inClose[i] < inOpen[i-1] &&
            inClose[i] > inClose[i-1] + ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) * 0.5
            )
            outInteger[outIdx++] = 100;
         else
            outInteger[outIdx++] = 0;
         for (totIdx = 1; totIdx >= 0; --totIdx)
            BodyLongPeriodTotal[totIdx] += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-totIdx] - inOpen[i-totIdx] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-totIdx] - inLow[i-totIdx] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-totIdx] - ( inClose[i-totIdx] >= inOpen[i-totIdx] ? inClose[i-totIdx] : inOpen[i-totIdx] ) ) + ( ( inClose[i-totIdx] >= inOpen[i-totIdx] ? inOpen[i-totIdx] : inClose[i-totIdx] ) - inLow[i-totIdx] ) : 0 ) ) )
            - ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[BodyLongTrailingIdx-totIdx] - inOpen[BodyLongTrailingIdx-totIdx] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[BodyLongTrailingIdx-totIdx] - inLow[BodyLongTrailingIdx-totIdx] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[BodyLongTrailingIdx-totIdx] - ( inClose[BodyLongTrailingIdx-totIdx] >= inOpen[BodyLongTrailingIdx-totIdx] ? inClose[BodyLongTrailingIdx-totIdx] : inOpen[BodyLongTrailingIdx-totIdx] ) ) + ( ( inClose[BodyLongTrailingIdx-totIdx] >= inOpen[BodyLongTrailingIdx-totIdx] ? inOpen[BodyLongTrailingIdx-totIdx] : inClose[BodyLongTrailingIdx-totIdx] ) - inLow[BodyLongTrailingIdx-totIdx] ) : 0 ) ) ) ;
         i++;
         BodyLongTrailingIdx++;
      } while( i <= endIdx );
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   public int cdlPiercingStateInit( struct TA_cdlPiercing_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct cdlPiercing ));
      _state.value .value .mem_index = 0;
      _state.value .value .mem_size = cdlPiercingLookback ();
      if ( _state.value .value .mem_size > 0)
         _state.value .value .memory = TA_Calloc( _state.value .value .mem_size , sizeof(struct TA_CDLPIERCING_Data));
      else
         _state.value .value .memory = NULL;
      return RetCode.Success ;
   }
   public int cdlPiercingState( struct TA_cdlPiercing_State* _state,
      double inOpen,
      double inHigh,
      double inLow,
      double inClose,
      int *outInteger )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      size_t _cur_idx = _state.value .mem_index++;
      if ( _state.value .mem_size > 0) _cur_idx %= _state.value .mem_size ;
      if ( _state.value .mem_size > _state.value .mem_index - 1 ) {
         ( _state.value .memory+_cur_idx).value .inOpen = inOpen ;
         ( _state.value .memory+_cur_idx).value .inHigh = inHigh ;
         ( _state.value .memory+_cur_idx).value .inLow = inLow ;
         ( _state.value .memory+_cur_idx).value .inClose = inClose ;
         return RetCode.NeedMoreData ; }
      return RetCode.Success ;
   }
   public int cdlPiercingStateFree( struct TA_cdlPiercing_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if ( _state.value != NULL) {
         if ( _state.value .value .memory != NULL) TA_Free( _state.value .value .memory );
         TA_Free( _state.value ); _state.value = NULL;}
      return RetCode.Success ;
   }
   public RetCode cdlPiercing( int startIdx,
      int endIdx,
      float inOpen[],
      float inHigh[],
      float inLow[],
      float inClose[],
      MInteger outBegIdx,
      MInteger outNBElement,
      int outInteger[] )
   {
      double []BodyLongPeriodTotal = new double[2] ;
      int i, outIdx, totIdx, BodyLongTrailingIdx, lookbackTotal;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      lookbackTotal = cdlPiercingLookback ();
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      BodyLongPeriodTotal[1] = 0;
      BodyLongPeriodTotal[0] = 0;
      BodyLongTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) ;
      i = BodyLongTrailingIdx;
      while( i < startIdx ) {
         BodyLongPeriodTotal[1] += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ;
         BodyLongPeriodTotal[0] += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      i = startIdx;
      outIdx = 0;
      do
      {
         if( ( inClose[i-1] >= inOpen[i-1] ? 1 : -1 ) == -1 &&
            ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) > ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) != 0.0? BodyLongPeriodTotal[1] / (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( inClose[i] >= inOpen[i] ? 1 : -1 ) == 1 &&
            ( Math.abs ( inClose[i] - inOpen[i] ) ) > ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) != 0.0? BodyLongPeriodTotal[0] / (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            inOpen[i] < inLow[i-1] &&
            inClose[i] < inOpen[i-1] &&
            inClose[i] > inClose[i-1] + ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) * 0.5
            )
            outInteger[outIdx++] = 100;
         else
            outInteger[outIdx++] = 0;
         for (totIdx = 1; totIdx >= 0; --totIdx)
            BodyLongPeriodTotal[totIdx] += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-totIdx] - inOpen[i-totIdx] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-totIdx] - inLow[i-totIdx] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-totIdx] - ( inClose[i-totIdx] >= inOpen[i-totIdx] ? inClose[i-totIdx] : inOpen[i-totIdx] ) ) + ( ( inClose[i-totIdx] >= inOpen[i-totIdx] ? inOpen[i-totIdx] : inClose[i-totIdx] ) - inLow[i-totIdx] ) : 0 ) ) )
            - ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[BodyLongTrailingIdx-totIdx] - inOpen[BodyLongTrailingIdx-totIdx] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[BodyLongTrailingIdx-totIdx] - inLow[BodyLongTrailingIdx-totIdx] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[BodyLongTrailingIdx-totIdx] - ( inClose[BodyLongTrailingIdx-totIdx] >= inOpen[BodyLongTrailingIdx-totIdx] ? inClose[BodyLongTrailingIdx-totIdx] : inOpen[BodyLongTrailingIdx-totIdx] ) ) + ( ( inClose[BodyLongTrailingIdx-totIdx] >= inOpen[BodyLongTrailingIdx-totIdx] ? inOpen[BodyLongTrailingIdx-totIdx] : inClose[BodyLongTrailingIdx-totIdx] ) - inLow[BodyLongTrailingIdx-totIdx] ) : 0 ) ) ) ;
         i++;
         BodyLongTrailingIdx++;
      } while( i <= endIdx );
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   /* Generated */
   public int cdlRickshawManLookback( )
   {
      return ((( ((( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].avgPeriod) ) > ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].avgPeriod) )) ? ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].avgPeriod) ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].avgPeriod) )) ) > ( (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) )) ? ( ((( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].avgPeriod) ) > ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].avgPeriod) )) ? ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].avgPeriod) ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].avgPeriod) )) ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) )) ;
   }
   public RetCode cdlRickshawMan( int startIdx,
      int endIdx,
      double inOpen[],
      double inHigh[],
      double inLow[],
      double inClose[],
      MInteger outBegIdx,
      MInteger outNBElement,
      int outInteger[] )
   {
      double BodyDojiPeriodTotal, ShadowLongPeriodTotal, NearPeriodTotal;
      int i, outIdx, BodyDojiTrailingIdx, ShadowLongTrailingIdx, NearTrailingIdx, lookbackTotal;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      lookbackTotal = cdlRickshawManLookback ();
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      BodyDojiPeriodTotal = 0;
      BodyDojiTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].avgPeriod) ;
      ShadowLongPeriodTotal = 0;
      ShadowLongTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].avgPeriod) ;
      NearPeriodTotal = 0;
      NearTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) ;
      i = BodyDojiTrailingIdx;
      while( i < startIdx ) {
         BodyDojiPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      i = ShadowLongTrailingIdx;
      while( i < startIdx ) {
         ShadowLongPeriodTotal += ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      i = NearTrailingIdx;
      while( i < startIdx ) {
         NearPeriodTotal += ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      outIdx = 0;
      do
      {
         if( ( Math.abs ( inClose[i] - inOpen[i] ) ) <= ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].avgPeriod) != 0.0? BodyDojiPeriodTotal / (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) > ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].avgPeriod) != 0.0? ShadowLongPeriodTotal / (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) > ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].avgPeriod) != 0.0? ShadowLongPeriodTotal / (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            (
            (((inOpen[i]) < (inClose[i])) ? (inOpen[i]) : (inClose[i]))
            <= inLow[i] + ( inHigh[i] - inLow[i] ) / 2 + ( (this.candleSettings[CandleSettingType.Near.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) != 0.0? NearPeriodTotal / (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) )
            &&
            (((inOpen[i]) > (inClose[i])) ? (inOpen[i]) : (inClose[i]))
            >= inLow[i] + ( inHigh[i] - inLow[i] ) / 2 - ( (this.candleSettings[CandleSettingType.Near.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) != 0.0? NearPeriodTotal / (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) )
            )
            )
            outInteger[outIdx++] = 100;
         else
            outInteger[outIdx++] = 0;
         BodyDojiPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) - ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[BodyDojiTrailingIdx] - inOpen[BodyDojiTrailingIdx] ) ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[BodyDojiTrailingIdx] - inLow[BodyDojiTrailingIdx] ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[BodyDojiTrailingIdx] - ( inClose[BodyDojiTrailingIdx] >= inOpen[BodyDojiTrailingIdx] ? inClose[BodyDojiTrailingIdx] : inOpen[BodyDojiTrailingIdx] ) ) + ( ( inClose[BodyDojiTrailingIdx] >= inOpen[BodyDojiTrailingIdx] ? inOpen[BodyDojiTrailingIdx] : inClose[BodyDojiTrailingIdx] ) - inLow[BodyDojiTrailingIdx] ) : 0 ) ) ) ;
         ShadowLongPeriodTotal += ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) - ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[ShadowLongTrailingIdx] - inOpen[ShadowLongTrailingIdx] ) ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[ShadowLongTrailingIdx] - inLow[ShadowLongTrailingIdx] ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[ShadowLongTrailingIdx] - ( inClose[ShadowLongTrailingIdx] >= inOpen[ShadowLongTrailingIdx] ? inClose[ShadowLongTrailingIdx] : inOpen[ShadowLongTrailingIdx] ) ) + ( ( inClose[ShadowLongTrailingIdx] >= inOpen[ShadowLongTrailingIdx] ? inOpen[ShadowLongTrailingIdx] : inClose[ShadowLongTrailingIdx] ) - inLow[ShadowLongTrailingIdx] ) : 0 ) ) ) ;
         NearPeriodTotal += ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) - ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[NearTrailingIdx] - inOpen[NearTrailingIdx] ) ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[NearTrailingIdx] - inLow[NearTrailingIdx] ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[NearTrailingIdx] - ( inClose[NearTrailingIdx] >= inOpen[NearTrailingIdx] ? inClose[NearTrailingIdx] : inOpen[NearTrailingIdx] ) ) + ( ( inClose[NearTrailingIdx] >= inOpen[NearTrailingIdx] ? inOpen[NearTrailingIdx] : inClose[NearTrailingIdx] ) - inLow[NearTrailingIdx] ) : 0 ) ) ) ;
         i++;
         BodyDojiTrailingIdx++;
         ShadowLongTrailingIdx++;
         NearTrailingIdx++;
      } while( i <= endIdx );
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   public int cdlRickshawManStateInit( struct TA_cdlRickshawMan_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct cdlRickshawMan ));
      _state.value .value .mem_index = 0;
      _state.value .value .mem_size = cdlRickshawManLookback ();
      if ( _state.value .value .mem_size > 0)
         _state.value .value .memory = TA_Calloc( _state.value .value .mem_size , sizeof(struct TA_CDLRICKSHAWMAN_Data));
      else
         _state.value .value .memory = NULL;
      return RetCode.Success ;
   }
   public int cdlRickshawManState( struct TA_cdlRickshawMan_State* _state,
      double inOpen,
      double inHigh,
      double inLow,
      double inClose,
      int *outInteger )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      size_t _cur_idx = _state.value .mem_index++;
      if ( _state.value .mem_size > 0) _cur_idx %= _state.value .mem_size ;
      if ( _state.value .mem_size > _state.value .mem_index - 1 ) {
         ( _state.value .memory+_cur_idx).value .inOpen = inOpen ;
         ( _state.value .memory+_cur_idx).value .inHigh = inHigh ;
         ( _state.value .memory+_cur_idx).value .inLow = inLow ;
         ( _state.value .memory+_cur_idx).value .inClose = inClose ;
         return RetCode.NeedMoreData ; }
      return RetCode.Success ;
   }
   public int cdlRickshawManStateFree( struct TA_cdlRickshawMan_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if ( _state.value != NULL) {
         if ( _state.value .value .memory != NULL) TA_Free( _state.value .value .memory );
         TA_Free( _state.value ); _state.value = NULL;}
      return RetCode.Success ;
   }
   public RetCode cdlRickshawMan( int startIdx,
      int endIdx,
      float inOpen[],
      float inHigh[],
      float inLow[],
      float inClose[],
      MInteger outBegIdx,
      MInteger outNBElement,
      int outInteger[] )
   {
      double BodyDojiPeriodTotal, ShadowLongPeriodTotal, NearPeriodTotal;
      int i, outIdx, BodyDojiTrailingIdx, ShadowLongTrailingIdx, NearTrailingIdx, lookbackTotal;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      lookbackTotal = cdlRickshawManLookback ();
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      BodyDojiPeriodTotal = 0;
      BodyDojiTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].avgPeriod) ;
      ShadowLongPeriodTotal = 0;
      ShadowLongTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].avgPeriod) ;
      NearPeriodTotal = 0;
      NearTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) ;
      i = BodyDojiTrailingIdx;
      while( i < startIdx ) {
         BodyDojiPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      i = ShadowLongTrailingIdx;
      while( i < startIdx ) {
         ShadowLongPeriodTotal += ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      i = NearTrailingIdx;
      while( i < startIdx ) {
         NearPeriodTotal += ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      outIdx = 0;
      do
      {
         if( ( Math.abs ( inClose[i] - inOpen[i] ) ) <= ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].avgPeriod) != 0.0? BodyDojiPeriodTotal / (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) > ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].avgPeriod) != 0.0? ShadowLongPeriodTotal / (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) > ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].avgPeriod) != 0.0? ShadowLongPeriodTotal / (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            (
            (((inOpen[i]) < (inClose[i])) ? (inOpen[i]) : (inClose[i]))
            <= inLow[i] + ( inHigh[i] - inLow[i] ) / 2 + ( (this.candleSettings[CandleSettingType.Near.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) != 0.0? NearPeriodTotal / (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) )
            &&
            (((inOpen[i]) > (inClose[i])) ? (inOpen[i]) : (inClose[i]))
            >= inLow[i] + ( inHigh[i] - inLow[i] ) / 2 - ( (this.candleSettings[CandleSettingType.Near.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) != 0.0? NearPeriodTotal / (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) )
            )
            )
            outInteger[outIdx++] = 100;
         else
            outInteger[outIdx++] = 0;
         BodyDojiPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) - ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[BodyDojiTrailingIdx] - inOpen[BodyDojiTrailingIdx] ) ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[BodyDojiTrailingIdx] - inLow[BodyDojiTrailingIdx] ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[BodyDojiTrailingIdx] - ( inClose[BodyDojiTrailingIdx] >= inOpen[BodyDojiTrailingIdx] ? inClose[BodyDojiTrailingIdx] : inOpen[BodyDojiTrailingIdx] ) ) + ( ( inClose[BodyDojiTrailingIdx] >= inOpen[BodyDojiTrailingIdx] ? inOpen[BodyDojiTrailingIdx] : inClose[BodyDojiTrailingIdx] ) - inLow[BodyDojiTrailingIdx] ) : 0 ) ) ) ;
         ShadowLongPeriodTotal += ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) - ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[ShadowLongTrailingIdx] - inOpen[ShadowLongTrailingIdx] ) ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[ShadowLongTrailingIdx] - inLow[ShadowLongTrailingIdx] ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[ShadowLongTrailingIdx] - ( inClose[ShadowLongTrailingIdx] >= inOpen[ShadowLongTrailingIdx] ? inClose[ShadowLongTrailingIdx] : inOpen[ShadowLongTrailingIdx] ) ) + ( ( inClose[ShadowLongTrailingIdx] >= inOpen[ShadowLongTrailingIdx] ? inOpen[ShadowLongTrailingIdx] : inClose[ShadowLongTrailingIdx] ) - inLow[ShadowLongTrailingIdx] ) : 0 ) ) ) ;
         NearPeriodTotal += ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) - ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[NearTrailingIdx] - inOpen[NearTrailingIdx] ) ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[NearTrailingIdx] - inLow[NearTrailingIdx] ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[NearTrailingIdx] - ( inClose[NearTrailingIdx] >= inOpen[NearTrailingIdx] ? inClose[NearTrailingIdx] : inOpen[NearTrailingIdx] ) ) + ( ( inClose[NearTrailingIdx] >= inOpen[NearTrailingIdx] ? inOpen[NearTrailingIdx] : inClose[NearTrailingIdx] ) - inLow[NearTrailingIdx] ) : 0 ) ) ) ;
         i++;
         BodyDojiTrailingIdx++;
         ShadowLongTrailingIdx++;
         NearTrailingIdx++;
      } while( i <= endIdx );
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   /* Generated */
   public int cdlRiseFall3MethodsLookback( )
   {
      return ((( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) ) > ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) )) ? ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) )) + 4;
   }
   public RetCode cdlRiseFall3Methods( int startIdx,
      int endIdx,
      double inOpen[],
      double inHigh[],
      double inLow[],
      double inClose[],
      MInteger outBegIdx,
      MInteger outNBElement,
      int outInteger[] )
   {
      double []BodyPeriodTotal = new double[5] ;
      int i, outIdx, totIdx, BodyShortTrailingIdx, BodyLongTrailingIdx, lookbackTotal;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      lookbackTotal = cdlRiseFall3MethodsLookback ();
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      BodyPeriodTotal[4] = 0;
      BodyPeriodTotal[3] = 0;
      BodyPeriodTotal[2] = 0;
      BodyPeriodTotal[1] = 0;
      BodyPeriodTotal[0] = 0;
      BodyShortTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) ;
      BodyLongTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) ;
      i = BodyShortTrailingIdx;
      while( i < startIdx ) {
         BodyPeriodTotal[3] += ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-3] - inOpen[i-3] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-3] - inLow[i-3] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-3] - ( inClose[i-3] >= inOpen[i-3] ? inClose[i-3] : inOpen[i-3] ) ) + ( ( inClose[i-3] >= inOpen[i-3] ? inOpen[i-3] : inClose[i-3] ) - inLow[i-3] ) : 0 ) ) ) ;
         BodyPeriodTotal[2] += ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-2] - inLow[i-2] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-2] - ( inClose[i-2] >= inOpen[i-2] ? inClose[i-2] : inOpen[i-2] ) ) + ( ( inClose[i-2] >= inOpen[i-2] ? inOpen[i-2] : inClose[i-2] ) - inLow[i-2] ) : 0 ) ) ) ;
         BodyPeriodTotal[1] += ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ;
         i++;
      }
      i = BodyLongTrailingIdx;
      while( i < startIdx ) {
         BodyPeriodTotal[4] += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-4] - inOpen[i-4] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-4] - inLow[i-4] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-4] - ( inClose[i-4] >= inOpen[i-4] ? inClose[i-4] : inOpen[i-4] ) ) + ( ( inClose[i-4] >= inOpen[i-4] ? inOpen[i-4] : inClose[i-4] ) - inLow[i-4] ) : 0 ) ) ) ;
         BodyPeriodTotal[0] += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      i = startIdx;
      outIdx = 0;
      do
      {
         if(
            ( Math.abs ( inClose[i-4] - inOpen[i-4] ) ) > ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) != 0.0? BodyPeriodTotal[4] / (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-4] - inOpen[i-4] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-4] - inLow[i-4] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-4] - ( inClose[i-4] >= inOpen[i-4] ? inClose[i-4] : inOpen[i-4] ) ) + ( ( inClose[i-4] >= inOpen[i-4] ? inOpen[i-4] : inClose[i-4] ) - inLow[i-4] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( Math.abs ( inClose[i-3] - inOpen[i-3] ) ) < ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) != 0.0? BodyPeriodTotal[3] / (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-3] - inOpen[i-3] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-3] - inLow[i-3] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-3] - ( inClose[i-3] >= inOpen[i-3] ? inClose[i-3] : inOpen[i-3] ) ) + ( ( inClose[i-3] >= inOpen[i-3] ? inOpen[i-3] : inClose[i-3] ) - inLow[i-3] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) < ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) != 0.0? BodyPeriodTotal[2] / (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-2] - inLow[i-2] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-2] - ( inClose[i-2] >= inOpen[i-2] ? inClose[i-2] : inOpen[i-2] ) ) + ( ( inClose[i-2] >= inOpen[i-2] ? inOpen[i-2] : inClose[i-2] ) - inLow[i-2] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) < ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) != 0.0? BodyPeriodTotal[1] / (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( Math.abs ( inClose[i] - inOpen[i] ) ) > ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) != 0.0? BodyPeriodTotal[0] / (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( inClose[i-4] >= inOpen[i-4] ? 1 : -1 ) == - ( inClose[i-3] >= inOpen[i-3] ? 1 : -1 ) &&
            ( inClose[i-3] >= inOpen[i-3] ? 1 : -1 ) == ( inClose[i-2] >= inOpen[i-2] ? 1 : -1 ) &&
            ( inClose[i-2] >= inOpen[i-2] ? 1 : -1 ) == ( inClose[i-1] >= inOpen[i-1] ? 1 : -1 ) &&
            ( inClose[i-1] >= inOpen[i-1] ? 1 : -1 ) == - ( inClose[i] >= inOpen[i] ? 1 : -1 ) &&
            (((inOpen[i-3]) < (inClose[i-3])) ? (inOpen[i-3]) : (inClose[i-3])) < inHigh[i-4] && (((inOpen[i-3]) > (inClose[i-3])) ? (inOpen[i-3]) : (inClose[i-3])) > inLow[i-4] &&
            (((inOpen[i-2]) < (inClose[i-2])) ? (inOpen[i-2]) : (inClose[i-2])) < inHigh[i-4] && (((inOpen[i-2]) > (inClose[i-2])) ? (inOpen[i-2]) : (inClose[i-2])) > inLow[i-4] &&
            (((inOpen[i-1]) < (inClose[i-1])) ? (inOpen[i-1]) : (inClose[i-1])) < inHigh[i-4] && (((inOpen[i-1]) > (inClose[i-1])) ? (inOpen[i-1]) : (inClose[i-1])) > inLow[i-4] &&
            inClose[i-2] * ( inClose[i-4] >= inOpen[i-4] ? 1 : -1 ) < inClose[i-3] * ( inClose[i-4] >= inOpen[i-4] ? 1 : -1 ) &&
            inClose[i-1] * ( inClose[i-4] >= inOpen[i-4] ? 1 : -1 ) < inClose[i-2] * ( inClose[i-4] >= inOpen[i-4] ? 1 : -1 ) &&
            inOpen[i] * ( inClose[i-4] >= inOpen[i-4] ? 1 : -1 ) > inClose[i-1] * ( inClose[i-4] >= inOpen[i-4] ? 1 : -1 ) &&
            inClose[i] * ( inClose[i-4] >= inOpen[i-4] ? 1 : -1 ) > inClose[i-4] * ( inClose[i-4] >= inOpen[i-4] ? 1 : -1 )
            )
            outInteger[outIdx++] = 100 * ( inClose[i-4] >= inOpen[i-4] ? 1 : -1 ) ;
         else
            outInteger[outIdx++] = 0;
         BodyPeriodTotal[4] += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-4] - inOpen[i-4] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-4] - inLow[i-4] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-4] - ( inClose[i-4] >= inOpen[i-4] ? inClose[i-4] : inOpen[i-4] ) ) + ( ( inClose[i-4] >= inOpen[i-4] ? inOpen[i-4] : inClose[i-4] ) - inLow[i-4] ) : 0 ) ) ) - ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[BodyLongTrailingIdx-4] - inOpen[BodyLongTrailingIdx-4] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[BodyLongTrailingIdx-4] - inLow[BodyLongTrailingIdx-4] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[BodyLongTrailingIdx-4] - ( inClose[BodyLongTrailingIdx-4] >= inOpen[BodyLongTrailingIdx-4] ? inClose[BodyLongTrailingIdx-4] : inOpen[BodyLongTrailingIdx-4] ) ) + ( ( inClose[BodyLongTrailingIdx-4] >= inOpen[BodyLongTrailingIdx-4] ? inOpen[BodyLongTrailingIdx-4] : inClose[BodyLongTrailingIdx-4] ) - inLow[BodyLongTrailingIdx-4] ) : 0 ) ) ) ;
         for (totIdx = 3; totIdx >= 1; --totIdx)
            BodyPeriodTotal[totIdx] += ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-totIdx] - inOpen[i-totIdx] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-totIdx] - inLow[i-totIdx] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-totIdx] - ( inClose[i-totIdx] >= inOpen[i-totIdx] ? inClose[i-totIdx] : inOpen[i-totIdx] ) ) + ( ( inClose[i-totIdx] >= inOpen[i-totIdx] ? inOpen[i-totIdx] : inClose[i-totIdx] ) - inLow[i-totIdx] ) : 0 ) ) )
            - ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[BodyShortTrailingIdx-totIdx] - inOpen[BodyShortTrailingIdx-totIdx] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[BodyShortTrailingIdx-totIdx] - inLow[BodyShortTrailingIdx-totIdx] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[BodyShortTrailingIdx-totIdx] - ( inClose[BodyShortTrailingIdx-totIdx] >= inOpen[BodyShortTrailingIdx-totIdx] ? inClose[BodyShortTrailingIdx-totIdx] : inOpen[BodyShortTrailingIdx-totIdx] ) ) + ( ( inClose[BodyShortTrailingIdx-totIdx] >= inOpen[BodyShortTrailingIdx-totIdx] ? inOpen[BodyShortTrailingIdx-totIdx] : inClose[BodyShortTrailingIdx-totIdx] ) - inLow[BodyShortTrailingIdx-totIdx] ) : 0 ) ) ) ;
         BodyPeriodTotal[0] += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) - ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[BodyLongTrailingIdx] - inOpen[BodyLongTrailingIdx] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[BodyLongTrailingIdx] - inLow[BodyLongTrailingIdx] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[BodyLongTrailingIdx] - ( inClose[BodyLongTrailingIdx] >= inOpen[BodyLongTrailingIdx] ? inClose[BodyLongTrailingIdx] : inOpen[BodyLongTrailingIdx] ) ) + ( ( inClose[BodyLongTrailingIdx] >= inOpen[BodyLongTrailingIdx] ? inOpen[BodyLongTrailingIdx] : inClose[BodyLongTrailingIdx] ) - inLow[BodyLongTrailingIdx] ) : 0 ) ) ) ;
         i++;
         BodyShortTrailingIdx++;
         BodyLongTrailingIdx++;
      } while( i <= endIdx );
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   public int cdlRiseFall3MethodsStateInit( struct TA_cdlRiseFall3Methods_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct cdlRiseFall3Methods ));
      _state.value .value .mem_index = 0;
      _state.value .value .mem_size = cdlRiseFall3MethodsLookback ();
      if ( _state.value .value .mem_size > 0)
         _state.value .value .memory = TA_Calloc( _state.value .value .mem_size , sizeof(struct TA_CDLRISEFALL3METHODS_Data));
      else
         _state.value .value .memory = NULL;
      return RetCode.Success ;
   }
   public int cdlRiseFall3MethodsState( struct TA_cdlRiseFall3Methods_State* _state,
      double inOpen,
      double inHigh,
      double inLow,
      double inClose,
      int *outInteger )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      size_t _cur_idx = _state.value .mem_index++;
      if ( _state.value .mem_size > 0) _cur_idx %= _state.value .mem_size ;
      if ( _state.value .mem_size > _state.value .mem_index - 1 ) {
         ( _state.value .memory+_cur_idx).value .inOpen = inOpen ;
         ( _state.value .memory+_cur_idx).value .inHigh = inHigh ;
         ( _state.value .memory+_cur_idx).value .inLow = inLow ;
         ( _state.value .memory+_cur_idx).value .inClose = inClose ;
         return RetCode.NeedMoreData ; }
      return RetCode.Success ;
   }
   public int cdlRiseFall3MethodsStateFree( struct TA_cdlRiseFall3Methods_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if ( _state.value != NULL) {
         if ( _state.value .value .memory != NULL) TA_Free( _state.value .value .memory );
         TA_Free( _state.value ); _state.value = NULL;}
      return RetCode.Success ;
   }
   public RetCode cdlRiseFall3Methods( int startIdx,
      int endIdx,
      float inOpen[],
      float inHigh[],
      float inLow[],
      float inClose[],
      MInteger outBegIdx,
      MInteger outNBElement,
      int outInteger[] )
   {
      double []BodyPeriodTotal = new double[5] ;
      int i, outIdx, totIdx, BodyShortTrailingIdx, BodyLongTrailingIdx, lookbackTotal;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      lookbackTotal = cdlRiseFall3MethodsLookback ();
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      BodyPeriodTotal[4] = 0;
      BodyPeriodTotal[3] = 0;
      BodyPeriodTotal[2] = 0;
      BodyPeriodTotal[1] = 0;
      BodyPeriodTotal[0] = 0;
      BodyShortTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) ;
      BodyLongTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) ;
      i = BodyShortTrailingIdx;
      while( i < startIdx ) {
         BodyPeriodTotal[3] += ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-3] - inOpen[i-3] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-3] - inLow[i-3] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-3] - ( inClose[i-3] >= inOpen[i-3] ? inClose[i-3] : inOpen[i-3] ) ) + ( ( inClose[i-3] >= inOpen[i-3] ? inOpen[i-3] : inClose[i-3] ) - inLow[i-3] ) : 0 ) ) ) ;
         BodyPeriodTotal[2] += ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-2] - inLow[i-2] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-2] - ( inClose[i-2] >= inOpen[i-2] ? inClose[i-2] : inOpen[i-2] ) ) + ( ( inClose[i-2] >= inOpen[i-2] ? inOpen[i-2] : inClose[i-2] ) - inLow[i-2] ) : 0 ) ) ) ;
         BodyPeriodTotal[1] += ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ;
         i++;
      }
      i = BodyLongTrailingIdx;
      while( i < startIdx ) {
         BodyPeriodTotal[4] += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-4] - inOpen[i-4] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-4] - inLow[i-4] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-4] - ( inClose[i-4] >= inOpen[i-4] ? inClose[i-4] : inOpen[i-4] ) ) + ( ( inClose[i-4] >= inOpen[i-4] ? inOpen[i-4] : inClose[i-4] ) - inLow[i-4] ) : 0 ) ) ) ;
         BodyPeriodTotal[0] += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      i = startIdx;
      outIdx = 0;
      do
      {
         if(
            ( Math.abs ( inClose[i-4] - inOpen[i-4] ) ) > ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) != 0.0? BodyPeriodTotal[4] / (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-4] - inOpen[i-4] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-4] - inLow[i-4] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-4] - ( inClose[i-4] >= inOpen[i-4] ? inClose[i-4] : inOpen[i-4] ) ) + ( ( inClose[i-4] >= inOpen[i-4] ? inOpen[i-4] : inClose[i-4] ) - inLow[i-4] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( Math.abs ( inClose[i-3] - inOpen[i-3] ) ) < ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) != 0.0? BodyPeriodTotal[3] / (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-3] - inOpen[i-3] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-3] - inLow[i-3] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-3] - ( inClose[i-3] >= inOpen[i-3] ? inClose[i-3] : inOpen[i-3] ) ) + ( ( inClose[i-3] >= inOpen[i-3] ? inOpen[i-3] : inClose[i-3] ) - inLow[i-3] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) < ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) != 0.0? BodyPeriodTotal[2] / (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-2] - inLow[i-2] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-2] - ( inClose[i-2] >= inOpen[i-2] ? inClose[i-2] : inOpen[i-2] ) ) + ( ( inClose[i-2] >= inOpen[i-2] ? inOpen[i-2] : inClose[i-2] ) - inLow[i-2] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) < ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) != 0.0? BodyPeriodTotal[1] / (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( Math.abs ( inClose[i] - inOpen[i] ) ) > ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) != 0.0? BodyPeriodTotal[0] / (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( inClose[i-4] >= inOpen[i-4] ? 1 : -1 ) == - ( inClose[i-3] >= inOpen[i-3] ? 1 : -1 ) &&
            ( inClose[i-3] >= inOpen[i-3] ? 1 : -1 ) == ( inClose[i-2] >= inOpen[i-2] ? 1 : -1 ) &&
            ( inClose[i-2] >= inOpen[i-2] ? 1 : -1 ) == ( inClose[i-1] >= inOpen[i-1] ? 1 : -1 ) &&
            ( inClose[i-1] >= inOpen[i-1] ? 1 : -1 ) == - ( inClose[i] >= inOpen[i] ? 1 : -1 ) &&
            (((inOpen[i-3]) < (inClose[i-3])) ? (inOpen[i-3]) : (inClose[i-3])) < inHigh[i-4] && (((inOpen[i-3]) > (inClose[i-3])) ? (inOpen[i-3]) : (inClose[i-3])) > inLow[i-4] &&
            (((inOpen[i-2]) < (inClose[i-2])) ? (inOpen[i-2]) : (inClose[i-2])) < inHigh[i-4] && (((inOpen[i-2]) > (inClose[i-2])) ? (inOpen[i-2]) : (inClose[i-2])) > inLow[i-4] &&
            (((inOpen[i-1]) < (inClose[i-1])) ? (inOpen[i-1]) : (inClose[i-1])) < inHigh[i-4] && (((inOpen[i-1]) > (inClose[i-1])) ? (inOpen[i-1]) : (inClose[i-1])) > inLow[i-4] &&
            inClose[i-2] * ( inClose[i-4] >= inOpen[i-4] ? 1 : -1 ) < inClose[i-3] * ( inClose[i-4] >= inOpen[i-4] ? 1 : -1 ) &&
            inClose[i-1] * ( inClose[i-4] >= inOpen[i-4] ? 1 : -1 ) < inClose[i-2] * ( inClose[i-4] >= inOpen[i-4] ? 1 : -1 ) &&
            inOpen[i] * ( inClose[i-4] >= inOpen[i-4] ? 1 : -1 ) > inClose[i-1] * ( inClose[i-4] >= inOpen[i-4] ? 1 : -1 ) &&
            inClose[i] * ( inClose[i-4] >= inOpen[i-4] ? 1 : -1 ) > inClose[i-4] * ( inClose[i-4] >= inOpen[i-4] ? 1 : -1 )
            )
            outInteger[outIdx++] = 100 * ( inClose[i-4] >= inOpen[i-4] ? 1 : -1 ) ;
         else
            outInteger[outIdx++] = 0;
         BodyPeriodTotal[4] += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-4] - inOpen[i-4] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-4] - inLow[i-4] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-4] - ( inClose[i-4] >= inOpen[i-4] ? inClose[i-4] : inOpen[i-4] ) ) + ( ( inClose[i-4] >= inOpen[i-4] ? inOpen[i-4] : inClose[i-4] ) - inLow[i-4] ) : 0 ) ) ) - ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[BodyLongTrailingIdx-4] - inOpen[BodyLongTrailingIdx-4] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[BodyLongTrailingIdx-4] - inLow[BodyLongTrailingIdx-4] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[BodyLongTrailingIdx-4] - ( inClose[BodyLongTrailingIdx-4] >= inOpen[BodyLongTrailingIdx-4] ? inClose[BodyLongTrailingIdx-4] : inOpen[BodyLongTrailingIdx-4] ) ) + ( ( inClose[BodyLongTrailingIdx-4] >= inOpen[BodyLongTrailingIdx-4] ? inOpen[BodyLongTrailingIdx-4] : inClose[BodyLongTrailingIdx-4] ) - inLow[BodyLongTrailingIdx-4] ) : 0 ) ) ) ;
         for (totIdx = 3; totIdx >= 1; --totIdx)
            BodyPeriodTotal[totIdx] += ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-totIdx] - inOpen[i-totIdx] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-totIdx] - inLow[i-totIdx] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-totIdx] - ( inClose[i-totIdx] >= inOpen[i-totIdx] ? inClose[i-totIdx] : inOpen[i-totIdx] ) ) + ( ( inClose[i-totIdx] >= inOpen[i-totIdx] ? inOpen[i-totIdx] : inClose[i-totIdx] ) - inLow[i-totIdx] ) : 0 ) ) )
            - ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[BodyShortTrailingIdx-totIdx] - inOpen[BodyShortTrailingIdx-totIdx] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[BodyShortTrailingIdx-totIdx] - inLow[BodyShortTrailingIdx-totIdx] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[BodyShortTrailingIdx-totIdx] - ( inClose[BodyShortTrailingIdx-totIdx] >= inOpen[BodyShortTrailingIdx-totIdx] ? inClose[BodyShortTrailingIdx-totIdx] : inOpen[BodyShortTrailingIdx-totIdx] ) ) + ( ( inClose[BodyShortTrailingIdx-totIdx] >= inOpen[BodyShortTrailingIdx-totIdx] ? inOpen[BodyShortTrailingIdx-totIdx] : inClose[BodyShortTrailingIdx-totIdx] ) - inLow[BodyShortTrailingIdx-totIdx] ) : 0 ) ) ) ;
         BodyPeriodTotal[0] += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) - ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[BodyLongTrailingIdx] - inOpen[BodyLongTrailingIdx] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[BodyLongTrailingIdx] - inLow[BodyLongTrailingIdx] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[BodyLongTrailingIdx] - ( inClose[BodyLongTrailingIdx] >= inOpen[BodyLongTrailingIdx] ? inClose[BodyLongTrailingIdx] : inOpen[BodyLongTrailingIdx] ) ) + ( ( inClose[BodyLongTrailingIdx] >= inOpen[BodyLongTrailingIdx] ? inOpen[BodyLongTrailingIdx] : inClose[BodyLongTrailingIdx] ) - inLow[BodyLongTrailingIdx] ) : 0 ) ) ) ;
         i++;
         BodyShortTrailingIdx++;
         BodyLongTrailingIdx++;
      } while( i <= endIdx );
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   /* Generated */
   public int cdlSeperatingLinesLookback( )
   {
      return ((( ((( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) ) > ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) )) ? ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) )) ) > ( (this.candleSettings[CandleSettingType.Equal.ordinal()].avgPeriod) )) ? ( ((( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) ) > ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) )) ? ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) )) ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].avgPeriod) )) +
         1;
   }
   public RetCode cdlSeperatingLines( int startIdx,
      int endIdx,
      double inOpen[],
      double inHigh[],
      double inLow[],
      double inClose[],
      MInteger outBegIdx,
      MInteger outNBElement,
      int outInteger[] )
   {
      double ShadowVeryShortPeriodTotal, BodyLongPeriodTotal, EqualPeriodTotal;
      int i, outIdx, ShadowVeryShortTrailingIdx, BodyLongTrailingIdx, EqualTrailingIdx, lookbackTotal;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      lookbackTotal = cdlSeperatingLinesLookback ();
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      ShadowVeryShortPeriodTotal = 0;
      ShadowVeryShortTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) ;
      BodyLongPeriodTotal = 0;
      BodyLongTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) ;
      EqualPeriodTotal = 0;
      EqualTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.Equal.ordinal()].avgPeriod) ;
      i = ShadowVeryShortTrailingIdx;
      while( i < startIdx ) {
         ShadowVeryShortPeriodTotal += ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      i = BodyLongTrailingIdx;
      while( i < startIdx ) {
         BodyLongPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      i = EqualTrailingIdx;
      while( i < startIdx ) {
         EqualPeriodTotal += ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ;
         i++;
      }
      i = startIdx;
      outIdx = 0;
      do
      {
         if( ( inClose[i-1] >= inOpen[i-1] ? 1 : -1 ) == - ( inClose[i] >= inOpen[i] ? 1 : -1 ) &&
            inOpen[i] <= inOpen[i-1] + ( (this.candleSettings[CandleSettingType.Equal.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.Equal.ordinal()].avgPeriod) != 0.0? EqualPeriodTotal / (this.candleSettings[CandleSettingType.Equal.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            inOpen[i] >= inOpen[i-1] - ( (this.candleSettings[CandleSettingType.Equal.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.Equal.ordinal()].avgPeriod) != 0.0? EqualPeriodTotal / (this.candleSettings[CandleSettingType.Equal.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( Math.abs ( inClose[i] - inOpen[i] ) ) > ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) != 0.0? BodyLongPeriodTotal / (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            (
            ( ( inClose[i] >= inOpen[i] ? 1 : -1 ) == 1 &&
            ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) < ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) != 0.0? ShadowVeryShortPeriodTotal / (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) )
            )
            ||
            ( ( inClose[i] >= inOpen[i] ? 1 : -1 ) == -1 &&
            ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) < ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) != 0.0? ShadowVeryShortPeriodTotal / (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) )
            )
            )
            )
            outInteger[outIdx++] = ( inClose[i] >= inOpen[i] ? 1 : -1 ) * 100;
         else
            outInteger[outIdx++] = 0;
         ShadowVeryShortPeriodTotal += ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) )
            - ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[ShadowVeryShortTrailingIdx] - inOpen[ShadowVeryShortTrailingIdx] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[ShadowVeryShortTrailingIdx] - inLow[ShadowVeryShortTrailingIdx] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[ShadowVeryShortTrailingIdx] - ( inClose[ShadowVeryShortTrailingIdx] >= inOpen[ShadowVeryShortTrailingIdx] ? inClose[ShadowVeryShortTrailingIdx] : inOpen[ShadowVeryShortTrailingIdx] ) ) + ( ( inClose[ShadowVeryShortTrailingIdx] >= inOpen[ShadowVeryShortTrailingIdx] ? inOpen[ShadowVeryShortTrailingIdx] : inClose[ShadowVeryShortTrailingIdx] ) - inLow[ShadowVeryShortTrailingIdx] ) : 0 ) ) ) ;
         BodyLongPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) - ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[BodyLongTrailingIdx] - inOpen[BodyLongTrailingIdx] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[BodyLongTrailingIdx] - inLow[BodyLongTrailingIdx] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[BodyLongTrailingIdx] - ( inClose[BodyLongTrailingIdx] >= inOpen[BodyLongTrailingIdx] ? inClose[BodyLongTrailingIdx] : inOpen[BodyLongTrailingIdx] ) ) + ( ( inClose[BodyLongTrailingIdx] >= inOpen[BodyLongTrailingIdx] ? inOpen[BodyLongTrailingIdx] : inClose[BodyLongTrailingIdx] ) - inLow[BodyLongTrailingIdx] ) : 0 ) ) ) ;
         EqualPeriodTotal += ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) - ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[EqualTrailingIdx-1] - inOpen[EqualTrailingIdx-1] ) ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[EqualTrailingIdx-1] - inLow[EqualTrailingIdx-1] ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[EqualTrailingIdx-1] - ( inClose[EqualTrailingIdx-1] >= inOpen[EqualTrailingIdx-1] ? inClose[EqualTrailingIdx-1] : inOpen[EqualTrailingIdx-1] ) ) + ( ( inClose[EqualTrailingIdx-1] >= inOpen[EqualTrailingIdx-1] ? inOpen[EqualTrailingIdx-1] : inClose[EqualTrailingIdx-1] ) - inLow[EqualTrailingIdx-1] ) : 0 ) ) ) ;
         i++;
         ShadowVeryShortTrailingIdx++;
         BodyLongTrailingIdx++;
         EqualTrailingIdx++;
      } while( i <= endIdx );
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   public int cdlSeperatingLinesStateInit( struct TA_cdlSeperatingLines_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct cdlSeperatingLines ));
      _state.value .value .mem_index = 0;
      _state.value .value .mem_size = cdlSeperatingLinesLookback ();
      if ( _state.value .value .mem_size > 0)
         _state.value .value .memory = TA_Calloc( _state.value .value .mem_size , sizeof(struct TA_CDLSEPARATINGLINES_Data));
      else
         _state.value .value .memory = NULL;
      return RetCode.Success ;
   }
   public int cdlSeperatingLinesState( struct TA_cdlSeperatingLines_State* _state,
      double inOpen,
      double inHigh,
      double inLow,
      double inClose,
      int *outInteger )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      size_t _cur_idx = _state.value .mem_index++;
      if ( _state.value .mem_size > 0) _cur_idx %= _state.value .mem_size ;
      if ( _state.value .mem_size > _state.value .mem_index - 1 ) {
         ( _state.value .memory+_cur_idx).value .inOpen = inOpen ;
         ( _state.value .memory+_cur_idx).value .inHigh = inHigh ;
         ( _state.value .memory+_cur_idx).value .inLow = inLow ;
         ( _state.value .memory+_cur_idx).value .inClose = inClose ;
         return RetCode.NeedMoreData ; }
      return RetCode.Success ;
   }
   public int cdlSeperatingLinesStateFree( struct TA_cdlSeperatingLines_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if ( _state.value != NULL) {
         if ( _state.value .value .memory != NULL) TA_Free( _state.value .value .memory );
         TA_Free( _state.value ); _state.value = NULL;}
      return RetCode.Success ;
   }
   public RetCode cdlSeperatingLines( int startIdx,
      int endIdx,
      float inOpen[],
      float inHigh[],
      float inLow[],
      float inClose[],
      MInteger outBegIdx,
      MInteger outNBElement,
      int outInteger[] )
   {
      double ShadowVeryShortPeriodTotal, BodyLongPeriodTotal, EqualPeriodTotal;
      int i, outIdx, ShadowVeryShortTrailingIdx, BodyLongTrailingIdx, EqualTrailingIdx, lookbackTotal;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      lookbackTotal = cdlSeperatingLinesLookback ();
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      ShadowVeryShortPeriodTotal = 0;
      ShadowVeryShortTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) ;
      BodyLongPeriodTotal = 0;
      BodyLongTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) ;
      EqualPeriodTotal = 0;
      EqualTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.Equal.ordinal()].avgPeriod) ;
      i = ShadowVeryShortTrailingIdx;
      while( i < startIdx ) {
         ShadowVeryShortPeriodTotal += ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      i = BodyLongTrailingIdx;
      while( i < startIdx ) {
         BodyLongPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      i = EqualTrailingIdx;
      while( i < startIdx ) {
         EqualPeriodTotal += ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ;
         i++;
      }
      i = startIdx;
      outIdx = 0;
      do
      {
         if( ( inClose[i-1] >= inOpen[i-1] ? 1 : -1 ) == - ( inClose[i] >= inOpen[i] ? 1 : -1 ) &&
            inOpen[i] <= inOpen[i-1] + ( (this.candleSettings[CandleSettingType.Equal.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.Equal.ordinal()].avgPeriod) != 0.0? EqualPeriodTotal / (this.candleSettings[CandleSettingType.Equal.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            inOpen[i] >= inOpen[i-1] - ( (this.candleSettings[CandleSettingType.Equal.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.Equal.ordinal()].avgPeriod) != 0.0? EqualPeriodTotal / (this.candleSettings[CandleSettingType.Equal.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( Math.abs ( inClose[i] - inOpen[i] ) ) > ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) != 0.0? BodyLongPeriodTotal / (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            (
            ( ( inClose[i] >= inOpen[i] ? 1 : -1 ) == 1 &&
            ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) < ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) != 0.0? ShadowVeryShortPeriodTotal / (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) )
            )
            ||
            ( ( inClose[i] >= inOpen[i] ? 1 : -1 ) == -1 &&
            ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) < ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) != 0.0? ShadowVeryShortPeriodTotal / (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) )
            )
            )
            )
            outInteger[outIdx++] = ( inClose[i] >= inOpen[i] ? 1 : -1 ) * 100;
         else
            outInteger[outIdx++] = 0;
         ShadowVeryShortPeriodTotal += ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) )
            - ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[ShadowVeryShortTrailingIdx] - inOpen[ShadowVeryShortTrailingIdx] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[ShadowVeryShortTrailingIdx] - inLow[ShadowVeryShortTrailingIdx] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[ShadowVeryShortTrailingIdx] - ( inClose[ShadowVeryShortTrailingIdx] >= inOpen[ShadowVeryShortTrailingIdx] ? inClose[ShadowVeryShortTrailingIdx] : inOpen[ShadowVeryShortTrailingIdx] ) ) + ( ( inClose[ShadowVeryShortTrailingIdx] >= inOpen[ShadowVeryShortTrailingIdx] ? inOpen[ShadowVeryShortTrailingIdx] : inClose[ShadowVeryShortTrailingIdx] ) - inLow[ShadowVeryShortTrailingIdx] ) : 0 ) ) ) ;
         BodyLongPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) - ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[BodyLongTrailingIdx] - inOpen[BodyLongTrailingIdx] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[BodyLongTrailingIdx] - inLow[BodyLongTrailingIdx] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[BodyLongTrailingIdx] - ( inClose[BodyLongTrailingIdx] >= inOpen[BodyLongTrailingIdx] ? inClose[BodyLongTrailingIdx] : inOpen[BodyLongTrailingIdx] ) ) + ( ( inClose[BodyLongTrailingIdx] >= inOpen[BodyLongTrailingIdx] ? inOpen[BodyLongTrailingIdx] : inClose[BodyLongTrailingIdx] ) - inLow[BodyLongTrailingIdx] ) : 0 ) ) ) ;
         EqualPeriodTotal += ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) - ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[EqualTrailingIdx-1] - inOpen[EqualTrailingIdx-1] ) ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[EqualTrailingIdx-1] - inLow[EqualTrailingIdx-1] ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[EqualTrailingIdx-1] - ( inClose[EqualTrailingIdx-1] >= inOpen[EqualTrailingIdx-1] ? inClose[EqualTrailingIdx-1] : inOpen[EqualTrailingIdx-1] ) ) + ( ( inClose[EqualTrailingIdx-1] >= inOpen[EqualTrailingIdx-1] ? inOpen[EqualTrailingIdx-1] : inClose[EqualTrailingIdx-1] ) - inLow[EqualTrailingIdx-1] ) : 0 ) ) ) ;
         i++;
         ShadowVeryShortTrailingIdx++;
         BodyLongTrailingIdx++;
         EqualTrailingIdx++;
      } while( i <= endIdx );
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   /* Generated */
   public int cdlShootingStarLookback( )
   {
      return ((( ((( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) ) > ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].avgPeriod) )) ? ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].avgPeriod) )) ) > ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) )) ? ( ((( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) ) > ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].avgPeriod) )) ? ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].avgPeriod) )) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) )) +
         1;
   }
   public RetCode cdlShootingStar( int startIdx,
      int endIdx,
      double inOpen[],
      double inHigh[],
      double inLow[],
      double inClose[],
      MInteger outBegIdx,
      MInteger outNBElement,
      int outInteger[] )
   {
      double BodyPeriodTotal, ShadowLongPeriodTotal, ShadowVeryShortPeriodTotal;
      int i, outIdx, BodyTrailingIdx, ShadowLongTrailingIdx, ShadowVeryShortTrailingIdx, lookbackTotal;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      lookbackTotal = cdlShootingStarLookback ();
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      BodyPeriodTotal = 0;
      BodyTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) ;
      ShadowLongPeriodTotal = 0;
      ShadowLongTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].avgPeriod) ;
      ShadowVeryShortPeriodTotal = 0;
      ShadowVeryShortTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) ;
      i = BodyTrailingIdx;
      while( i < startIdx ) {
         BodyPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      i = ShadowLongTrailingIdx;
      while( i < startIdx ) {
         ShadowLongPeriodTotal += ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      i = ShadowVeryShortTrailingIdx;
      while( i < startIdx ) {
         ShadowVeryShortPeriodTotal += ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      outIdx = 0;
      do
      {
         if( ( Math.abs ( inClose[i] - inOpen[i] ) ) < ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) != 0.0? BodyPeriodTotal / (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) > ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].avgPeriod) != 0.0? ShadowLongPeriodTotal / (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) < ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) != 0.0? ShadowVeryShortPeriodTotal / (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( (((inOpen[i]) < (inClose[i])) ? (inOpen[i]) : (inClose[i])) > (((inOpen[i-1]) > (inClose[i-1])) ? (inOpen[i-1]) : (inClose[i-1])) ) )
            outInteger[outIdx++] = -100;
         else
            outInteger[outIdx++] = 0;
         BodyPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) )
            - ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[BodyTrailingIdx] - inOpen[BodyTrailingIdx] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[BodyTrailingIdx] - inLow[BodyTrailingIdx] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[BodyTrailingIdx] - ( inClose[BodyTrailingIdx] >= inOpen[BodyTrailingIdx] ? inClose[BodyTrailingIdx] : inOpen[BodyTrailingIdx] ) ) + ( ( inClose[BodyTrailingIdx] >= inOpen[BodyTrailingIdx] ? inOpen[BodyTrailingIdx] : inClose[BodyTrailingIdx] ) - inLow[BodyTrailingIdx] ) : 0 ) ) ) ;
         ShadowLongPeriodTotal += ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) )
            - ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[ShadowLongTrailingIdx] - inOpen[ShadowLongTrailingIdx] ) ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[ShadowLongTrailingIdx] - inLow[ShadowLongTrailingIdx] ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[ShadowLongTrailingIdx] - ( inClose[ShadowLongTrailingIdx] >= inOpen[ShadowLongTrailingIdx] ? inClose[ShadowLongTrailingIdx] : inOpen[ShadowLongTrailingIdx] ) ) + ( ( inClose[ShadowLongTrailingIdx] >= inOpen[ShadowLongTrailingIdx] ? inOpen[ShadowLongTrailingIdx] : inClose[ShadowLongTrailingIdx] ) - inLow[ShadowLongTrailingIdx] ) : 0 ) ) ) ;
         ShadowVeryShortPeriodTotal += ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) )
            - ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[ShadowVeryShortTrailingIdx] - inOpen[ShadowVeryShortTrailingIdx] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[ShadowVeryShortTrailingIdx] - inLow[ShadowVeryShortTrailingIdx] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[ShadowVeryShortTrailingIdx] - ( inClose[ShadowVeryShortTrailingIdx] >= inOpen[ShadowVeryShortTrailingIdx] ? inClose[ShadowVeryShortTrailingIdx] : inOpen[ShadowVeryShortTrailingIdx] ) ) + ( ( inClose[ShadowVeryShortTrailingIdx] >= inOpen[ShadowVeryShortTrailingIdx] ? inOpen[ShadowVeryShortTrailingIdx] : inClose[ShadowVeryShortTrailingIdx] ) - inLow[ShadowVeryShortTrailingIdx] ) : 0 ) ) ) ;
         i++;
         BodyTrailingIdx++;
         ShadowLongTrailingIdx++;
         ShadowVeryShortTrailingIdx++;
      } while( i <= endIdx );
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   public int cdlShootingStarStateInit( struct TA_cdlShootingStar_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct cdlShootingStar ));
      _state.value .value .mem_index = 0;
      _state.value .value .mem_size = cdlShootingStarLookback ();
      if ( _state.value .value .mem_size > 0)
         _state.value .value .memory = TA_Calloc( _state.value .value .mem_size , sizeof(struct TA_CDLSHOOTINGSTAR_Data));
      else
         _state.value .value .memory = NULL;
      return RetCode.Success ;
   }
   public int cdlShootingStarState( struct TA_cdlShootingStar_State* _state,
      double inOpen,
      double inHigh,
      double inLow,
      double inClose,
      int *outInteger )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      size_t _cur_idx = _state.value .mem_index++;
      if ( _state.value .mem_size > 0) _cur_idx %= _state.value .mem_size ;
      if ( _state.value .mem_size > _state.value .mem_index - 1 ) {
         ( _state.value .memory+_cur_idx).value .inOpen = inOpen ;
         ( _state.value .memory+_cur_idx).value .inHigh = inHigh ;
         ( _state.value .memory+_cur_idx).value .inLow = inLow ;
         ( _state.value .memory+_cur_idx).value .inClose = inClose ;
         return RetCode.NeedMoreData ; }
      return RetCode.Success ;
   }
   public int cdlShootingStarStateFree( struct TA_cdlShootingStar_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if ( _state.value != NULL) {
         if ( _state.value .value .memory != NULL) TA_Free( _state.value .value .memory );
         TA_Free( _state.value ); _state.value = NULL;}
      return RetCode.Success ;
   }
   public RetCode cdlShootingStar( int startIdx,
      int endIdx,
      float inOpen[],
      float inHigh[],
      float inLow[],
      float inClose[],
      MInteger outBegIdx,
      MInteger outNBElement,
      int outInteger[] )
   {
      double BodyPeriodTotal, ShadowLongPeriodTotal, ShadowVeryShortPeriodTotal;
      int i, outIdx, BodyTrailingIdx, ShadowLongTrailingIdx, ShadowVeryShortTrailingIdx, lookbackTotal;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      lookbackTotal = cdlShootingStarLookback ();
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      BodyPeriodTotal = 0;
      BodyTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) ;
      ShadowLongPeriodTotal = 0;
      ShadowLongTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].avgPeriod) ;
      ShadowVeryShortPeriodTotal = 0;
      ShadowVeryShortTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) ;
      i = BodyTrailingIdx;
      while( i < startIdx ) {
         BodyPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      i = ShadowLongTrailingIdx;
      while( i < startIdx ) {
         ShadowLongPeriodTotal += ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      i = ShadowVeryShortTrailingIdx;
      while( i < startIdx ) {
         ShadowVeryShortPeriodTotal += ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      outIdx = 0;
      do
      {
         if( ( Math.abs ( inClose[i] - inOpen[i] ) ) < ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) != 0.0? BodyPeriodTotal / (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) > ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].avgPeriod) != 0.0? ShadowLongPeriodTotal / (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) < ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) != 0.0? ShadowVeryShortPeriodTotal / (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( (((inOpen[i]) < (inClose[i])) ? (inOpen[i]) : (inClose[i])) > (((inOpen[i-1]) > (inClose[i-1])) ? (inOpen[i-1]) : (inClose[i-1])) ) )
            outInteger[outIdx++] = -100;
         else
            outInteger[outIdx++] = 0;
         BodyPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) )
            - ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[BodyTrailingIdx] - inOpen[BodyTrailingIdx] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[BodyTrailingIdx] - inLow[BodyTrailingIdx] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[BodyTrailingIdx] - ( inClose[BodyTrailingIdx] >= inOpen[BodyTrailingIdx] ? inClose[BodyTrailingIdx] : inOpen[BodyTrailingIdx] ) ) + ( ( inClose[BodyTrailingIdx] >= inOpen[BodyTrailingIdx] ? inOpen[BodyTrailingIdx] : inClose[BodyTrailingIdx] ) - inLow[BodyTrailingIdx] ) : 0 ) ) ) ;
         ShadowLongPeriodTotal += ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) )
            - ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[ShadowLongTrailingIdx] - inOpen[ShadowLongTrailingIdx] ) ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[ShadowLongTrailingIdx] - inLow[ShadowLongTrailingIdx] ) : ( (this.candleSettings[CandleSettingType.ShadowLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[ShadowLongTrailingIdx] - ( inClose[ShadowLongTrailingIdx] >= inOpen[ShadowLongTrailingIdx] ? inClose[ShadowLongTrailingIdx] : inOpen[ShadowLongTrailingIdx] ) ) + ( ( inClose[ShadowLongTrailingIdx] >= inOpen[ShadowLongTrailingIdx] ? inOpen[ShadowLongTrailingIdx] : inClose[ShadowLongTrailingIdx] ) - inLow[ShadowLongTrailingIdx] ) : 0 ) ) ) ;
         ShadowVeryShortPeriodTotal += ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) )
            - ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[ShadowVeryShortTrailingIdx] - inOpen[ShadowVeryShortTrailingIdx] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[ShadowVeryShortTrailingIdx] - inLow[ShadowVeryShortTrailingIdx] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[ShadowVeryShortTrailingIdx] - ( inClose[ShadowVeryShortTrailingIdx] >= inOpen[ShadowVeryShortTrailingIdx] ? inClose[ShadowVeryShortTrailingIdx] : inOpen[ShadowVeryShortTrailingIdx] ) ) + ( ( inClose[ShadowVeryShortTrailingIdx] >= inOpen[ShadowVeryShortTrailingIdx] ? inOpen[ShadowVeryShortTrailingIdx] : inClose[ShadowVeryShortTrailingIdx] ) - inLow[ShadowVeryShortTrailingIdx] ) : 0 ) ) ) ;
         i++;
         BodyTrailingIdx++;
         ShadowLongTrailingIdx++;
         ShadowVeryShortTrailingIdx++;
      } while( i <= endIdx );
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   /* Generated */
   public int cdlShortLineLookback( )
   {
      return ((( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) ) > ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].avgPeriod) )) ? ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) ) : ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].avgPeriod) )) ;
   }
   public RetCode cdlShortLine( int startIdx,
      int endIdx,
      double inOpen[],
      double inHigh[],
      double inLow[],
      double inClose[],
      MInteger outBegIdx,
      MInteger outNBElement,
      int outInteger[] )
   {
      double BodyPeriodTotal, ShadowPeriodTotal;
      int i, outIdx, BodyTrailingIdx, ShadowTrailingIdx, lookbackTotal;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      lookbackTotal = cdlShortLineLookback ();
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      BodyPeriodTotal = 0;
      BodyTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) ;
      ShadowPeriodTotal = 0;
      ShadowTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].avgPeriod) ;
      i = BodyTrailingIdx;
      while( i < startIdx ) {
         BodyPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      i = ShadowTrailingIdx;
      while( i < startIdx ) {
         ShadowPeriodTotal += ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      outIdx = 0;
      do
      {
         if( ( Math.abs ( inClose[i] - inOpen[i] ) ) < ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) != 0.0? BodyPeriodTotal / (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) < ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].avgPeriod) != 0.0? ShadowPeriodTotal / (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) < ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].avgPeriod) != 0.0? ShadowPeriodTotal / (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) )
            outInteger[outIdx++] = ( inClose[i] >= inOpen[i] ? 1 : -1 ) * 100;
         else
            outInteger[outIdx++] = 0;
         BodyPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) - ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[BodyTrailingIdx] - inOpen[BodyTrailingIdx] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[BodyTrailingIdx] - inLow[BodyTrailingIdx] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[BodyTrailingIdx] - ( inClose[BodyTrailingIdx] >= inOpen[BodyTrailingIdx] ? inClose[BodyTrailingIdx] : inOpen[BodyTrailingIdx] ) ) + ( ( inClose[BodyTrailingIdx] >= inOpen[BodyTrailingIdx] ? inOpen[BodyTrailingIdx] : inClose[BodyTrailingIdx] ) - inLow[BodyTrailingIdx] ) : 0 ) ) ) ;
         ShadowPeriodTotal += ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) - ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[ShadowTrailingIdx] - inOpen[ShadowTrailingIdx] ) ) : ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[ShadowTrailingIdx] - inLow[ShadowTrailingIdx] ) : ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[ShadowTrailingIdx] - ( inClose[ShadowTrailingIdx] >= inOpen[ShadowTrailingIdx] ? inClose[ShadowTrailingIdx] : inOpen[ShadowTrailingIdx] ) ) + ( ( inClose[ShadowTrailingIdx] >= inOpen[ShadowTrailingIdx] ? inOpen[ShadowTrailingIdx] : inClose[ShadowTrailingIdx] ) - inLow[ShadowTrailingIdx] ) : 0 ) ) ) ;
         i++;
         BodyTrailingIdx++;
         ShadowTrailingIdx++;
      } while( i <= endIdx );
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   public int cdlShortLineStateInit( struct TA_cdlShortLine_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct cdlShortLine ));
      _state.value .value .mem_index = 0;
      _state.value .value .mem_size = cdlShortLineLookback ();
      if ( _state.value .value .mem_size > 0)
         _state.value .value .memory = TA_Calloc( _state.value .value .mem_size , sizeof(struct TA_CDLSHORTLINE_Data));
      else
         _state.value .value .memory = NULL;
      return RetCode.Success ;
   }
   public int cdlShortLineState( struct TA_cdlShortLine_State* _state,
      double inOpen,
      double inHigh,
      double inLow,
      double inClose,
      int *outInteger )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      size_t _cur_idx = _state.value .mem_index++;
      if ( _state.value .mem_size > 0) _cur_idx %= _state.value .mem_size ;
      if ( _state.value .mem_size > _state.value .mem_index - 1 ) {
         ( _state.value .memory+_cur_idx).value .inOpen = inOpen ;
         ( _state.value .memory+_cur_idx).value .inHigh = inHigh ;
         ( _state.value .memory+_cur_idx).value .inLow = inLow ;
         ( _state.value .memory+_cur_idx).value .inClose = inClose ;
         return RetCode.NeedMoreData ; }
      return RetCode.Success ;
   }
   public int cdlShortLineStateFree( struct TA_cdlShortLine_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if ( _state.value != NULL) {
         if ( _state.value .value .memory != NULL) TA_Free( _state.value .value .memory );
         TA_Free( _state.value ); _state.value = NULL;}
      return RetCode.Success ;
   }
   public RetCode cdlShortLine( int startIdx,
      int endIdx,
      float inOpen[],
      float inHigh[],
      float inLow[],
      float inClose[],
      MInteger outBegIdx,
      MInteger outNBElement,
      int outInteger[] )
   {
      double BodyPeriodTotal, ShadowPeriodTotal;
      int i, outIdx, BodyTrailingIdx, ShadowTrailingIdx, lookbackTotal;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      lookbackTotal = cdlShortLineLookback ();
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      BodyPeriodTotal = 0;
      BodyTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) ;
      ShadowPeriodTotal = 0;
      ShadowTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].avgPeriod) ;
      i = BodyTrailingIdx;
      while( i < startIdx ) {
         BodyPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      i = ShadowTrailingIdx;
      while( i < startIdx ) {
         ShadowPeriodTotal += ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      outIdx = 0;
      do
      {
         if( ( Math.abs ( inClose[i] - inOpen[i] ) ) < ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) != 0.0? BodyPeriodTotal / (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) < ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].avgPeriod) != 0.0? ShadowPeriodTotal / (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) < ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].avgPeriod) != 0.0? ShadowPeriodTotal / (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) )
            outInteger[outIdx++] = ( inClose[i] >= inOpen[i] ? 1 : -1 ) * 100;
         else
            outInteger[outIdx++] = 0;
         BodyPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) - ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[BodyTrailingIdx] - inOpen[BodyTrailingIdx] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[BodyTrailingIdx] - inLow[BodyTrailingIdx] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[BodyTrailingIdx] - ( inClose[BodyTrailingIdx] >= inOpen[BodyTrailingIdx] ? inClose[BodyTrailingIdx] : inOpen[BodyTrailingIdx] ) ) + ( ( inClose[BodyTrailingIdx] >= inOpen[BodyTrailingIdx] ? inOpen[BodyTrailingIdx] : inClose[BodyTrailingIdx] ) - inLow[BodyTrailingIdx] ) : 0 ) ) ) ;
         ShadowPeriodTotal += ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) - ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[ShadowTrailingIdx] - inOpen[ShadowTrailingIdx] ) ) : ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[ShadowTrailingIdx] - inLow[ShadowTrailingIdx] ) : ( (this.candleSettings[CandleSettingType.ShadowShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[ShadowTrailingIdx] - ( inClose[ShadowTrailingIdx] >= inOpen[ShadowTrailingIdx] ? inClose[ShadowTrailingIdx] : inOpen[ShadowTrailingIdx] ) ) + ( ( inClose[ShadowTrailingIdx] >= inOpen[ShadowTrailingIdx] ? inOpen[ShadowTrailingIdx] : inClose[ShadowTrailingIdx] ) - inLow[ShadowTrailingIdx] ) : 0 ) ) ) ;
         i++;
         BodyTrailingIdx++;
         ShadowTrailingIdx++;
      } while( i <= endIdx );
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   /* Generated */
   public int cdlSpinningTopLookback( )
   {
      return (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) ;
   }
   public RetCode cdlSpinningTop( int startIdx,
      int endIdx,
      double inOpen[],
      double inHigh[],
      double inLow[],
      double inClose[],
      MInteger outBegIdx,
      MInteger outNBElement,
      int outInteger[] )
   {
      double BodyPeriodTotal;
      int i, outIdx, BodyTrailingIdx, lookbackTotal;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      lookbackTotal = cdlSpinningTopLookback ();
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      BodyPeriodTotal = 0;
      BodyTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) ;
      i = BodyTrailingIdx;
      while( i < startIdx ) {
         BodyPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      outIdx = 0;
      do
      {
         if( ( Math.abs ( inClose[i] - inOpen[i] ) ) < ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) != 0.0? BodyPeriodTotal / (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) > ( Math.abs ( inClose[i] - inOpen[i] ) ) &&
            ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) > ( Math.abs ( inClose[i] - inOpen[i] ) )
            )
            outInteger[outIdx++] = ( inClose[i] >= inOpen[i] ? 1 : -1 ) * 100;
         else
            outInteger[outIdx++] = 0;
         BodyPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) - ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[BodyTrailingIdx] - inOpen[BodyTrailingIdx] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[BodyTrailingIdx] - inLow[BodyTrailingIdx] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[BodyTrailingIdx] - ( inClose[BodyTrailingIdx] >= inOpen[BodyTrailingIdx] ? inClose[BodyTrailingIdx] : inOpen[BodyTrailingIdx] ) ) + ( ( inClose[BodyTrailingIdx] >= inOpen[BodyTrailingIdx] ? inOpen[BodyTrailingIdx] : inClose[BodyTrailingIdx] ) - inLow[BodyTrailingIdx] ) : 0 ) ) ) ;
         i++;
         BodyTrailingIdx++;
      } while( i <= endIdx );
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   public int cdlSpinningTopStateInit( struct TA_cdlSpinningTop_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct cdlSpinningTop ));
      _state.value .value .mem_index = 0;
      _state.value .value .mem_size = cdlSpinningTopLookback ();
      if ( _state.value .value .mem_size > 0)
         _state.value .value .memory = TA_Calloc( _state.value .value .mem_size , sizeof(struct TA_CDLSPINNINGTOP_Data));
      else
         _state.value .value .memory = NULL;
      return RetCode.Success ;
   }
   public int cdlSpinningTopState( struct TA_cdlSpinningTop_State* _state,
      double inOpen,
      double inHigh,
      double inLow,
      double inClose,
      int *outInteger )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      size_t _cur_idx = _state.value .mem_index++;
      if ( _state.value .mem_size > 0) _cur_idx %= _state.value .mem_size ;
      if ( _state.value .mem_size > _state.value .mem_index - 1 ) {
         ( _state.value .memory+_cur_idx).value .inOpen = inOpen ;
         ( _state.value .memory+_cur_idx).value .inHigh = inHigh ;
         ( _state.value .memory+_cur_idx).value .inLow = inLow ;
         ( _state.value .memory+_cur_idx).value .inClose = inClose ;
         return RetCode.NeedMoreData ; }
      return RetCode.Success ;
   }
   public int cdlSpinningTopStateFree( struct TA_cdlSpinningTop_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if ( _state.value != NULL) {
         if ( _state.value .value .memory != NULL) TA_Free( _state.value .value .memory );
         TA_Free( _state.value ); _state.value = NULL;}
      return RetCode.Success ;
   }
   public RetCode cdlSpinningTop( int startIdx,
      int endIdx,
      float inOpen[],
      float inHigh[],
      float inLow[],
      float inClose[],
      MInteger outBegIdx,
      MInteger outNBElement,
      int outInteger[] )
   {
      double BodyPeriodTotal;
      int i, outIdx, BodyTrailingIdx, lookbackTotal;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      lookbackTotal = cdlSpinningTopLookback ();
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      BodyPeriodTotal = 0;
      BodyTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) ;
      i = BodyTrailingIdx;
      while( i < startIdx ) {
         BodyPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      outIdx = 0;
      do
      {
         if( ( Math.abs ( inClose[i] - inOpen[i] ) ) < ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) != 0.0? BodyPeriodTotal / (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) > ( Math.abs ( inClose[i] - inOpen[i] ) ) &&
            ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) > ( Math.abs ( inClose[i] - inOpen[i] ) )
            )
            outInteger[outIdx++] = ( inClose[i] >= inOpen[i] ? 1 : -1 ) * 100;
         else
            outInteger[outIdx++] = 0;
         BodyPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) - ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[BodyTrailingIdx] - inOpen[BodyTrailingIdx] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[BodyTrailingIdx] - inLow[BodyTrailingIdx] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[BodyTrailingIdx] - ( inClose[BodyTrailingIdx] >= inOpen[BodyTrailingIdx] ? inClose[BodyTrailingIdx] : inOpen[BodyTrailingIdx] ) ) + ( ( inClose[BodyTrailingIdx] >= inOpen[BodyTrailingIdx] ? inOpen[BodyTrailingIdx] : inClose[BodyTrailingIdx] ) - inLow[BodyTrailingIdx] ) : 0 ) ) ) ;
         i++;
         BodyTrailingIdx++;
      } while( i <= endIdx );
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   /* Generated */
   public int cdlStalledPatternLookback( )
   {
      return ((( ((( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) ) > ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) )) ? ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) )) ) > ( ((( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) ) > ( (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) )) ? ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) )) )) ? ( ((( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) ) > ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) )) ? ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) )) ) : ( ((( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) ) > ( (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) )) ? ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) )) )) +
         2;
   }
   public RetCode cdlStalledPattern( int startIdx,
      int endIdx,
      double inOpen[],
      double inHigh[],
      double inLow[],
      double inClose[],
      MInteger outBegIdx,
      MInteger outNBElement,
      int outInteger[] )
   {
      double []BodyLongPeriodTotal = new double[3] ;
      double []NearPeriodTotal = new double[3] ;
      double BodyShortPeriodTotal, ShadowVeryShortPeriodTotal;
      int i, outIdx, totIdx, BodyLongTrailingIdx, BodyShortTrailingIdx, ShadowVeryShortTrailingIdx, NearTrailingIdx,
         lookbackTotal;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      lookbackTotal = cdlStalledPatternLookback ();
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      BodyLongPeriodTotal[2] = 0;
      BodyLongPeriodTotal[1] = 0;
      BodyLongPeriodTotal[0] = 0;
      BodyLongTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) ;
      BodyShortPeriodTotal = 0;
      BodyShortTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) ;
      ShadowVeryShortPeriodTotal = 0;
      ShadowVeryShortTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) ;
      NearPeriodTotal[2] = 0;
      NearPeriodTotal[1] = 0;
      NearPeriodTotal[0] = 0;
      NearTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) ;
      i = BodyLongTrailingIdx;
      while( i < startIdx ) {
         BodyLongPeriodTotal[2] += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-2] - inLow[i-2] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-2] - ( inClose[i-2] >= inOpen[i-2] ? inClose[i-2] : inOpen[i-2] ) ) + ( ( inClose[i-2] >= inOpen[i-2] ? inOpen[i-2] : inClose[i-2] ) - inLow[i-2] ) : 0 ) ) ) ;
         BodyLongPeriodTotal[1] += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ;
         i++;
      }
      i = BodyShortTrailingIdx;
      while( i < startIdx ) {
         BodyShortPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      i = ShadowVeryShortTrailingIdx;
      while( i < startIdx ) {
         ShadowVeryShortPeriodTotal += ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ;
         i++;
      }
      i = NearTrailingIdx;
      while( i < startIdx ) {
         NearPeriodTotal[2] += ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-2] - inLow[i-2] ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-2] - ( inClose[i-2] >= inOpen[i-2] ? inClose[i-2] : inOpen[i-2] ) ) + ( ( inClose[i-2] >= inOpen[i-2] ? inOpen[i-2] : inClose[i-2] ) - inLow[i-2] ) : 0 ) ) ) ;
         NearPeriodTotal[1] += ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ;
         i++;
      }
      i = startIdx;
      outIdx = 0;
      do
      {
         if( ( inClose[i-2] >= inOpen[i-2] ? 1 : -1 ) == 1 &&
            ( inClose[i-1] >= inOpen[i-1] ? 1 : -1 ) == 1 &&
            ( inClose[i] >= inOpen[i] ? 1 : -1 ) == 1 &&
            inClose[i] > inClose[i-1] && inClose[i-1] > inClose[i-2] &&
            ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) > ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) != 0.0? BodyLongPeriodTotal[2] / (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-2] - inLow[i-2] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-2] - ( inClose[i-2] >= inOpen[i-2] ? inClose[i-2] : inOpen[i-2] ) ) + ( ( inClose[i-2] >= inOpen[i-2] ? inOpen[i-2] : inClose[i-2] ) - inLow[i-2] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) > ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) != 0.0? BodyLongPeriodTotal[1] / (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) < ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) != 0.0? ShadowVeryShortPeriodTotal / (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            inOpen[i-1] > inOpen[i-2] &&
            inOpen[i-1] <= inClose[i-2] + ( (this.candleSettings[CandleSettingType.Near.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) != 0.0? NearPeriodTotal[2] / (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-2] - inLow[i-2] ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-2] - ( inClose[i-2] >= inOpen[i-2] ? inClose[i-2] : inOpen[i-2] ) ) + ( ( inClose[i-2] >= inOpen[i-2] ? inOpen[i-2] : inClose[i-2] ) - inLow[i-2] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( Math.abs ( inClose[i] - inOpen[i] ) ) < ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) != 0.0? BodyShortPeriodTotal / (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            inOpen[i] >= inClose[i-1] - ( Math.abs ( inClose[i] - inOpen[i] ) ) - ( (this.candleSettings[CandleSettingType.Near.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) != 0.0? NearPeriodTotal[1] / (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) )
            )
            outInteger[outIdx++] = -100;
         else
            outInteger[outIdx++] = 0;
         for (totIdx = 2; totIdx >= 1; --totIdx) {
            BodyLongPeriodTotal[totIdx] += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-totIdx] - inOpen[i-totIdx] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-totIdx] - inLow[i-totIdx] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-totIdx] - ( inClose[i-totIdx] >= inOpen[i-totIdx] ? inClose[i-totIdx] : inOpen[i-totIdx] ) ) + ( ( inClose[i-totIdx] >= inOpen[i-totIdx] ? inOpen[i-totIdx] : inClose[i-totIdx] ) - inLow[i-totIdx] ) : 0 ) ) )
               - ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[BodyLongTrailingIdx-totIdx] - inOpen[BodyLongTrailingIdx-totIdx] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[BodyLongTrailingIdx-totIdx] - inLow[BodyLongTrailingIdx-totIdx] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[BodyLongTrailingIdx-totIdx] - ( inClose[BodyLongTrailingIdx-totIdx] >= inOpen[BodyLongTrailingIdx-totIdx] ? inClose[BodyLongTrailingIdx-totIdx] : inOpen[BodyLongTrailingIdx-totIdx] ) ) + ( ( inClose[BodyLongTrailingIdx-totIdx] >= inOpen[BodyLongTrailingIdx-totIdx] ? inOpen[BodyLongTrailingIdx-totIdx] : inClose[BodyLongTrailingIdx-totIdx] ) - inLow[BodyLongTrailingIdx-totIdx] ) : 0 ) ) ) ;
            NearPeriodTotal[totIdx] += ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-totIdx] - inOpen[i-totIdx] ) ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-totIdx] - inLow[i-totIdx] ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-totIdx] - ( inClose[i-totIdx] >= inOpen[i-totIdx] ? inClose[i-totIdx] : inOpen[i-totIdx] ) ) + ( ( inClose[i-totIdx] >= inOpen[i-totIdx] ? inOpen[i-totIdx] : inClose[i-totIdx] ) - inLow[i-totIdx] ) : 0 ) ) )
               - ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[NearTrailingIdx-totIdx] - inOpen[NearTrailingIdx-totIdx] ) ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[NearTrailingIdx-totIdx] - inLow[NearTrailingIdx-totIdx] ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[NearTrailingIdx-totIdx] - ( inClose[NearTrailingIdx-totIdx] >= inOpen[NearTrailingIdx-totIdx] ? inClose[NearTrailingIdx-totIdx] : inOpen[NearTrailingIdx-totIdx] ) ) + ( ( inClose[NearTrailingIdx-totIdx] >= inOpen[NearTrailingIdx-totIdx] ? inOpen[NearTrailingIdx-totIdx] : inClose[NearTrailingIdx-totIdx] ) - inLow[NearTrailingIdx-totIdx] ) : 0 ) ) ) ;
         }
         BodyShortPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) - ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[BodyShortTrailingIdx] - inOpen[BodyShortTrailingIdx] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[BodyShortTrailingIdx] - inLow[BodyShortTrailingIdx] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[BodyShortTrailingIdx] - ( inClose[BodyShortTrailingIdx] >= inOpen[BodyShortTrailingIdx] ? inClose[BodyShortTrailingIdx] : inOpen[BodyShortTrailingIdx] ) ) + ( ( inClose[BodyShortTrailingIdx] >= inOpen[BodyShortTrailingIdx] ? inOpen[BodyShortTrailingIdx] : inClose[BodyShortTrailingIdx] ) - inLow[BodyShortTrailingIdx] ) : 0 ) ) ) ;
         ShadowVeryShortPeriodTotal += ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) )
            - ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[ShadowVeryShortTrailingIdx-1] - inOpen[ShadowVeryShortTrailingIdx-1] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[ShadowVeryShortTrailingIdx-1] - inLow[ShadowVeryShortTrailingIdx-1] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[ShadowVeryShortTrailingIdx-1] - ( inClose[ShadowVeryShortTrailingIdx-1] >= inOpen[ShadowVeryShortTrailingIdx-1] ? inClose[ShadowVeryShortTrailingIdx-1] : inOpen[ShadowVeryShortTrailingIdx-1] ) ) + ( ( inClose[ShadowVeryShortTrailingIdx-1] >= inOpen[ShadowVeryShortTrailingIdx-1] ? inOpen[ShadowVeryShortTrailingIdx-1] : inClose[ShadowVeryShortTrailingIdx-1] ) - inLow[ShadowVeryShortTrailingIdx-1] ) : 0 ) ) ) ;
         i++;
         BodyLongTrailingIdx++;
         BodyShortTrailingIdx++;
         ShadowVeryShortTrailingIdx++;
         NearTrailingIdx++;
      } while( i <= endIdx );
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   public int cdlStalledPatternStateInit( struct TA_cdlStalledPattern_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct cdlStalledPattern ));
      _state.value .value .mem_index = 0;
      _state.value .value .mem_size = cdlStalledPatternLookback ();
      if ( _state.value .value .mem_size > 0)
         _state.value .value .memory = TA_Calloc( _state.value .value .mem_size , sizeof(struct TA_CDLSTALLEDPATTERN_Data));
      else
         _state.value .value .memory = NULL;
      return RetCode.Success ;
   }
   public int cdlStalledPatternState( struct TA_cdlStalledPattern_State* _state,
      double inOpen,
      double inHigh,
      double inLow,
      double inClose,
      int *outInteger )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      size_t _cur_idx = _state.value .mem_index++;
      if ( _state.value .mem_size > 0) _cur_idx %= _state.value .mem_size ;
      if ( _state.value .mem_size > _state.value .mem_index - 1 ) {
         ( _state.value .memory+_cur_idx).value .inOpen = inOpen ;
         ( _state.value .memory+_cur_idx).value .inHigh = inHigh ;
         ( _state.value .memory+_cur_idx).value .inLow = inLow ;
         ( _state.value .memory+_cur_idx).value .inClose = inClose ;
         return RetCode.NeedMoreData ; }
      return RetCode.Success ;
   }
   public int cdlStalledPatternStateFree( struct TA_cdlStalledPattern_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if ( _state.value != NULL) {
         if ( _state.value .value .memory != NULL) TA_Free( _state.value .value .memory );
         TA_Free( _state.value ); _state.value = NULL;}
      return RetCode.Success ;
   }
   public RetCode cdlStalledPattern( int startIdx,
      int endIdx,
      float inOpen[],
      float inHigh[],
      float inLow[],
      float inClose[],
      MInteger outBegIdx,
      MInteger outNBElement,
      int outInteger[] )
   {
      double []BodyLongPeriodTotal = new double[3] ;
      double []NearPeriodTotal = new double[3] ;
      double BodyShortPeriodTotal, ShadowVeryShortPeriodTotal;
      int i, outIdx, totIdx, BodyLongTrailingIdx, BodyShortTrailingIdx, ShadowVeryShortTrailingIdx, NearTrailingIdx,
         lookbackTotal;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      lookbackTotal = cdlStalledPatternLookback ();
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      BodyLongPeriodTotal[2] = 0;
      BodyLongPeriodTotal[1] = 0;
      BodyLongPeriodTotal[0] = 0;
      BodyLongTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) ;
      BodyShortPeriodTotal = 0;
      BodyShortTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) ;
      ShadowVeryShortPeriodTotal = 0;
      ShadowVeryShortTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) ;
      NearPeriodTotal[2] = 0;
      NearPeriodTotal[1] = 0;
      NearPeriodTotal[0] = 0;
      NearTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) ;
      i = BodyLongTrailingIdx;
      while( i < startIdx ) {
         BodyLongPeriodTotal[2] += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-2] - inLow[i-2] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-2] - ( inClose[i-2] >= inOpen[i-2] ? inClose[i-2] : inOpen[i-2] ) ) + ( ( inClose[i-2] >= inOpen[i-2] ? inOpen[i-2] : inClose[i-2] ) - inLow[i-2] ) : 0 ) ) ) ;
         BodyLongPeriodTotal[1] += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ;
         i++;
      }
      i = BodyShortTrailingIdx;
      while( i < startIdx ) {
         BodyShortPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      i = ShadowVeryShortTrailingIdx;
      while( i < startIdx ) {
         ShadowVeryShortPeriodTotal += ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ;
         i++;
      }
      i = NearTrailingIdx;
      while( i < startIdx ) {
         NearPeriodTotal[2] += ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-2] - inLow[i-2] ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-2] - ( inClose[i-2] >= inOpen[i-2] ? inClose[i-2] : inOpen[i-2] ) ) + ( ( inClose[i-2] >= inOpen[i-2] ? inOpen[i-2] : inClose[i-2] ) - inLow[i-2] ) : 0 ) ) ) ;
         NearPeriodTotal[1] += ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ;
         i++;
      }
      i = startIdx;
      outIdx = 0;
      do
      {
         if( ( inClose[i-2] >= inOpen[i-2] ? 1 : -1 ) == 1 &&
            ( inClose[i-1] >= inOpen[i-1] ? 1 : -1 ) == 1 &&
            ( inClose[i] >= inOpen[i] ? 1 : -1 ) == 1 &&
            inClose[i] > inClose[i-1] && inClose[i-1] > inClose[i-2] &&
            ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) > ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) != 0.0? BodyLongPeriodTotal[2] / (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-2] - inLow[i-2] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-2] - ( inClose[i-2] >= inOpen[i-2] ? inClose[i-2] : inOpen[i-2] ) ) + ( ( inClose[i-2] >= inOpen[i-2] ? inOpen[i-2] : inClose[i-2] ) - inLow[i-2] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) > ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) != 0.0? BodyLongPeriodTotal[1] / (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) < ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) != 0.0? ShadowVeryShortPeriodTotal / (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            inOpen[i-1] > inOpen[i-2] &&
            inOpen[i-1] <= inClose[i-2] + ( (this.candleSettings[CandleSettingType.Near.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) != 0.0? NearPeriodTotal[2] / (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-2] - inLow[i-2] ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-2] - ( inClose[i-2] >= inOpen[i-2] ? inClose[i-2] : inOpen[i-2] ) ) + ( ( inClose[i-2] >= inOpen[i-2] ? inOpen[i-2] : inClose[i-2] ) - inLow[i-2] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( Math.abs ( inClose[i] - inOpen[i] ) ) < ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) != 0.0? BodyShortPeriodTotal / (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            inOpen[i] >= inClose[i-1] - ( Math.abs ( inClose[i] - inOpen[i] ) ) - ( (this.candleSettings[CandleSettingType.Near.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) != 0.0? NearPeriodTotal[1] / (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) )
            )
            outInteger[outIdx++] = -100;
         else
            outInteger[outIdx++] = 0;
         for (totIdx = 2; totIdx >= 1; --totIdx) {
            BodyLongPeriodTotal[totIdx] += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-totIdx] - inOpen[i-totIdx] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-totIdx] - inLow[i-totIdx] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-totIdx] - ( inClose[i-totIdx] >= inOpen[i-totIdx] ? inClose[i-totIdx] : inOpen[i-totIdx] ) ) + ( ( inClose[i-totIdx] >= inOpen[i-totIdx] ? inOpen[i-totIdx] : inClose[i-totIdx] ) - inLow[i-totIdx] ) : 0 ) ) )
               - ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[BodyLongTrailingIdx-totIdx] - inOpen[BodyLongTrailingIdx-totIdx] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[BodyLongTrailingIdx-totIdx] - inLow[BodyLongTrailingIdx-totIdx] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[BodyLongTrailingIdx-totIdx] - ( inClose[BodyLongTrailingIdx-totIdx] >= inOpen[BodyLongTrailingIdx-totIdx] ? inClose[BodyLongTrailingIdx-totIdx] : inOpen[BodyLongTrailingIdx-totIdx] ) ) + ( ( inClose[BodyLongTrailingIdx-totIdx] >= inOpen[BodyLongTrailingIdx-totIdx] ? inOpen[BodyLongTrailingIdx-totIdx] : inClose[BodyLongTrailingIdx-totIdx] ) - inLow[BodyLongTrailingIdx-totIdx] ) : 0 ) ) ) ;
            NearPeriodTotal[totIdx] += ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-totIdx] - inOpen[i-totIdx] ) ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-totIdx] - inLow[i-totIdx] ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-totIdx] - ( inClose[i-totIdx] >= inOpen[i-totIdx] ? inClose[i-totIdx] : inOpen[i-totIdx] ) ) + ( ( inClose[i-totIdx] >= inOpen[i-totIdx] ? inOpen[i-totIdx] : inClose[i-totIdx] ) - inLow[i-totIdx] ) : 0 ) ) )
               - ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[NearTrailingIdx-totIdx] - inOpen[NearTrailingIdx-totIdx] ) ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[NearTrailingIdx-totIdx] - inLow[NearTrailingIdx-totIdx] ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[NearTrailingIdx-totIdx] - ( inClose[NearTrailingIdx-totIdx] >= inOpen[NearTrailingIdx-totIdx] ? inClose[NearTrailingIdx-totIdx] : inOpen[NearTrailingIdx-totIdx] ) ) + ( ( inClose[NearTrailingIdx-totIdx] >= inOpen[NearTrailingIdx-totIdx] ? inOpen[NearTrailingIdx-totIdx] : inClose[NearTrailingIdx-totIdx] ) - inLow[NearTrailingIdx-totIdx] ) : 0 ) ) ) ;
         }
         BodyShortPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) - ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[BodyShortTrailingIdx] - inOpen[BodyShortTrailingIdx] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[BodyShortTrailingIdx] - inLow[BodyShortTrailingIdx] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[BodyShortTrailingIdx] - ( inClose[BodyShortTrailingIdx] >= inOpen[BodyShortTrailingIdx] ? inClose[BodyShortTrailingIdx] : inOpen[BodyShortTrailingIdx] ) ) + ( ( inClose[BodyShortTrailingIdx] >= inOpen[BodyShortTrailingIdx] ? inOpen[BodyShortTrailingIdx] : inClose[BodyShortTrailingIdx] ) - inLow[BodyShortTrailingIdx] ) : 0 ) ) ) ;
         ShadowVeryShortPeriodTotal += ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) )
            - ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[ShadowVeryShortTrailingIdx-1] - inOpen[ShadowVeryShortTrailingIdx-1] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[ShadowVeryShortTrailingIdx-1] - inLow[ShadowVeryShortTrailingIdx-1] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[ShadowVeryShortTrailingIdx-1] - ( inClose[ShadowVeryShortTrailingIdx-1] >= inOpen[ShadowVeryShortTrailingIdx-1] ? inClose[ShadowVeryShortTrailingIdx-1] : inOpen[ShadowVeryShortTrailingIdx-1] ) ) + ( ( inClose[ShadowVeryShortTrailingIdx-1] >= inOpen[ShadowVeryShortTrailingIdx-1] ? inOpen[ShadowVeryShortTrailingIdx-1] : inClose[ShadowVeryShortTrailingIdx-1] ) - inLow[ShadowVeryShortTrailingIdx-1] ) : 0 ) ) ) ;
         i++;
         BodyLongTrailingIdx++;
         BodyShortTrailingIdx++;
         ShadowVeryShortTrailingIdx++;
         NearTrailingIdx++;
      } while( i <= endIdx );
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   /* Generated */
   public int cdlStickSandwhichLookback( )
   {
      return (this.candleSettings[CandleSettingType.Equal.ordinal()].avgPeriod) + 2;
   }
   public RetCode cdlStickSandwhich( int startIdx,
      int endIdx,
      double inOpen[],
      double inHigh[],
      double inLow[],
      double inClose[],
      MInteger outBegIdx,
      MInteger outNBElement,
      int outInteger[] )
   {
      double EqualPeriodTotal;
      int i, outIdx, EqualTrailingIdx, lookbackTotal;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      lookbackTotal = cdlStickSandwhichLookback ();
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      EqualPeriodTotal = 0;
      EqualTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.Equal.ordinal()].avgPeriod) ;
      i = EqualTrailingIdx;
      while( i < startIdx ) {
         EqualPeriodTotal += ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-2] - inLow[i-2] ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-2] - ( inClose[i-2] >= inOpen[i-2] ? inClose[i-2] : inOpen[i-2] ) ) + ( ( inClose[i-2] >= inOpen[i-2] ? inOpen[i-2] : inClose[i-2] ) - inLow[i-2] ) : 0 ) ) ) ;
         i++;
      }
      i = startIdx;
      outIdx = 0;
      do
      {
         if( ( inClose[i-2] >= inOpen[i-2] ? 1 : -1 ) == -1 &&
            ( inClose[i-1] >= inOpen[i-1] ? 1 : -1 ) == 1 &&
            ( inClose[i] >= inOpen[i] ? 1 : -1 ) == -1 &&
            inLow[i-1] > inClose[i-2] &&
            inClose[i] <= inClose[i-2] + ( (this.candleSettings[CandleSettingType.Equal.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.Equal.ordinal()].avgPeriod) != 0.0? EqualPeriodTotal / (this.candleSettings[CandleSettingType.Equal.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-2] - inLow[i-2] ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-2] - ( inClose[i-2] >= inOpen[i-2] ? inClose[i-2] : inOpen[i-2] ) ) + ( ( inClose[i-2] >= inOpen[i-2] ? inOpen[i-2] : inClose[i-2] ) - inLow[i-2] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            inClose[i] >= inClose[i-2] - ( (this.candleSettings[CandleSettingType.Equal.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.Equal.ordinal()].avgPeriod) != 0.0? EqualPeriodTotal / (this.candleSettings[CandleSettingType.Equal.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-2] - inLow[i-2] ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-2] - ( inClose[i-2] >= inOpen[i-2] ? inClose[i-2] : inOpen[i-2] ) ) + ( ( inClose[i-2] >= inOpen[i-2] ? inOpen[i-2] : inClose[i-2] ) - inLow[i-2] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) )
            )
            outInteger[outIdx++] = 100;
         else
            outInteger[outIdx++] = 0;
         EqualPeriodTotal += ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-2] - inLow[i-2] ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-2] - ( inClose[i-2] >= inOpen[i-2] ? inClose[i-2] : inOpen[i-2] ) ) + ( ( inClose[i-2] >= inOpen[i-2] ? inOpen[i-2] : inClose[i-2] ) - inLow[i-2] ) : 0 ) ) ) - ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[EqualTrailingIdx-2] - inOpen[EqualTrailingIdx-2] ) ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[EqualTrailingIdx-2] - inLow[EqualTrailingIdx-2] ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[EqualTrailingIdx-2] - ( inClose[EqualTrailingIdx-2] >= inOpen[EqualTrailingIdx-2] ? inClose[EqualTrailingIdx-2] : inOpen[EqualTrailingIdx-2] ) ) + ( ( inClose[EqualTrailingIdx-2] >= inOpen[EqualTrailingIdx-2] ? inOpen[EqualTrailingIdx-2] : inClose[EqualTrailingIdx-2] ) - inLow[EqualTrailingIdx-2] ) : 0 ) ) ) ;
         i++;
         EqualTrailingIdx++;
      } while( i <= endIdx );
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   public int cdlStickSandwhichStateInit( struct TA_cdlStickSandwhich_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct cdlStickSandwhich ));
      _state.value .value .mem_index = 0;
      _state.value .value .mem_size = cdlStickSandwhichLookback ();
      if ( _state.value .value .mem_size > 0)
         _state.value .value .memory = TA_Calloc( _state.value .value .mem_size , sizeof(struct TA_CDLSTICKSANDWICH_Data));
      else
         _state.value .value .memory = NULL;
      return RetCode.Success ;
   }
   public int cdlStickSandwhichState( struct TA_cdlStickSandwhich_State* _state,
      double inOpen,
      double inHigh,
      double inLow,
      double inClose,
      int *outInteger )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      size_t _cur_idx = _state.value .mem_index++;
      if ( _state.value .mem_size > 0) _cur_idx %= _state.value .mem_size ;
      if ( _state.value .mem_size > _state.value .mem_index - 1 ) {
         ( _state.value .memory+_cur_idx).value .inOpen = inOpen ;
         ( _state.value .memory+_cur_idx).value .inHigh = inHigh ;
         ( _state.value .memory+_cur_idx).value .inLow = inLow ;
         ( _state.value .memory+_cur_idx).value .inClose = inClose ;
         return RetCode.NeedMoreData ; }
      return RetCode.Success ;
   }
   public int cdlStickSandwhichStateFree( struct TA_cdlStickSandwhich_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if ( _state.value != NULL) {
         if ( _state.value .value .memory != NULL) TA_Free( _state.value .value .memory );
         TA_Free( _state.value ); _state.value = NULL;}
      return RetCode.Success ;
   }
   public RetCode cdlStickSandwhich( int startIdx,
      int endIdx,
      float inOpen[],
      float inHigh[],
      float inLow[],
      float inClose[],
      MInteger outBegIdx,
      MInteger outNBElement,
      int outInteger[] )
   {
      double EqualPeriodTotal;
      int i, outIdx, EqualTrailingIdx, lookbackTotal;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      lookbackTotal = cdlStickSandwhichLookback ();
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      EqualPeriodTotal = 0;
      EqualTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.Equal.ordinal()].avgPeriod) ;
      i = EqualTrailingIdx;
      while( i < startIdx ) {
         EqualPeriodTotal += ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-2] - inLow[i-2] ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-2] - ( inClose[i-2] >= inOpen[i-2] ? inClose[i-2] : inOpen[i-2] ) ) + ( ( inClose[i-2] >= inOpen[i-2] ? inOpen[i-2] : inClose[i-2] ) - inLow[i-2] ) : 0 ) ) ) ;
         i++;
      }
      i = startIdx;
      outIdx = 0;
      do
      {
         if( ( inClose[i-2] >= inOpen[i-2] ? 1 : -1 ) == -1 &&
            ( inClose[i-1] >= inOpen[i-1] ? 1 : -1 ) == 1 &&
            ( inClose[i] >= inOpen[i] ? 1 : -1 ) == -1 &&
            inLow[i-1] > inClose[i-2] &&
            inClose[i] <= inClose[i-2] + ( (this.candleSettings[CandleSettingType.Equal.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.Equal.ordinal()].avgPeriod) != 0.0? EqualPeriodTotal / (this.candleSettings[CandleSettingType.Equal.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-2] - inLow[i-2] ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-2] - ( inClose[i-2] >= inOpen[i-2] ? inClose[i-2] : inOpen[i-2] ) ) + ( ( inClose[i-2] >= inOpen[i-2] ? inOpen[i-2] : inClose[i-2] ) - inLow[i-2] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            inClose[i] >= inClose[i-2] - ( (this.candleSettings[CandleSettingType.Equal.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.Equal.ordinal()].avgPeriod) != 0.0? EqualPeriodTotal / (this.candleSettings[CandleSettingType.Equal.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-2] - inLow[i-2] ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-2] - ( inClose[i-2] >= inOpen[i-2] ? inClose[i-2] : inOpen[i-2] ) ) + ( ( inClose[i-2] >= inOpen[i-2] ? inOpen[i-2] : inClose[i-2] ) - inLow[i-2] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) )
            )
            outInteger[outIdx++] = 100;
         else
            outInteger[outIdx++] = 0;
         EqualPeriodTotal += ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-2] - inLow[i-2] ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-2] - ( inClose[i-2] >= inOpen[i-2] ? inClose[i-2] : inOpen[i-2] ) ) + ( ( inClose[i-2] >= inOpen[i-2] ? inOpen[i-2] : inClose[i-2] ) - inLow[i-2] ) : 0 ) ) ) - ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[EqualTrailingIdx-2] - inOpen[EqualTrailingIdx-2] ) ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[EqualTrailingIdx-2] - inLow[EqualTrailingIdx-2] ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[EqualTrailingIdx-2] - ( inClose[EqualTrailingIdx-2] >= inOpen[EqualTrailingIdx-2] ? inClose[EqualTrailingIdx-2] : inOpen[EqualTrailingIdx-2] ) ) + ( ( inClose[EqualTrailingIdx-2] >= inOpen[EqualTrailingIdx-2] ? inOpen[EqualTrailingIdx-2] : inClose[EqualTrailingIdx-2] ) - inLow[EqualTrailingIdx-2] ) : 0 ) ) ) ;
         i++;
         EqualTrailingIdx++;
      } while( i <= endIdx );
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   /* Generated */
   public int cdlTakuriLookback( )
   {
      return ((( ((( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].avgPeriod) ) > ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) )) ? ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].avgPeriod) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) )) ) > ( (this.candleSettings[CandleSettingType.ShadowVeryLong.ordinal()].avgPeriod) )) ? ( ((( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].avgPeriod) ) > ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) )) ? ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].avgPeriod) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) )) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryLong.ordinal()].avgPeriod) )) ;
   }
   public RetCode cdlTakuri( int startIdx,
      int endIdx,
      double inOpen[],
      double inHigh[],
      double inLow[],
      double inClose[],
      MInteger outBegIdx,
      MInteger outNBElement,
      int outInteger[] )
   {
      double BodyDojiPeriodTotal, ShadowVeryShortPeriodTotal, ShadowVeryLongPeriodTotal;
      int i, outIdx, BodyDojiTrailingIdx, ShadowVeryShortTrailingIdx, ShadowVeryLongTrailingIdx, lookbackTotal;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      lookbackTotal = cdlTakuriLookback ();
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      BodyDojiPeriodTotal = 0;
      BodyDojiTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].avgPeriod) ;
      ShadowVeryShortPeriodTotal = 0;
      ShadowVeryShortTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) ;
      ShadowVeryLongPeriodTotal = 0;
      ShadowVeryLongTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.ShadowVeryLong.ordinal()].avgPeriod) ;
      i = BodyDojiTrailingIdx;
      while( i < startIdx ) {
         BodyDojiPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      i = ShadowVeryShortTrailingIdx;
      while( i < startIdx ) {
         ShadowVeryShortPeriodTotal += ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      i = ShadowVeryLongTrailingIdx;
      while( i < startIdx ) {
         ShadowVeryLongPeriodTotal += ( (this.candleSettings[CandleSettingType.ShadowVeryLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      outIdx = 0;
      do
      {
         if( ( Math.abs ( inClose[i] - inOpen[i] ) ) <= ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].avgPeriod) != 0.0? BodyDojiPeriodTotal / (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) < ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) != 0.0? ShadowVeryShortPeriodTotal / (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) > ( (this.candleSettings[CandleSettingType.ShadowVeryLong.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.ShadowVeryLong.ordinal()].avgPeriod) != 0.0? ShadowVeryLongPeriodTotal / (this.candleSettings[CandleSettingType.ShadowVeryLong.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.ShadowVeryLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.ShadowVeryLong.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) )
            )
            outInteger[outIdx++] = 100;
         else
            outInteger[outIdx++] = 0;
         BodyDojiPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) - ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[BodyDojiTrailingIdx] - inOpen[BodyDojiTrailingIdx] ) ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[BodyDojiTrailingIdx] - inLow[BodyDojiTrailingIdx] ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[BodyDojiTrailingIdx] - ( inClose[BodyDojiTrailingIdx] >= inOpen[BodyDojiTrailingIdx] ? inClose[BodyDojiTrailingIdx] : inOpen[BodyDojiTrailingIdx] ) ) + ( ( inClose[BodyDojiTrailingIdx] >= inOpen[BodyDojiTrailingIdx] ? inOpen[BodyDojiTrailingIdx] : inClose[BodyDojiTrailingIdx] ) - inLow[BodyDojiTrailingIdx] ) : 0 ) ) ) ;
         ShadowVeryShortPeriodTotal += ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) )
            - ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[ShadowVeryShortTrailingIdx] - inOpen[ShadowVeryShortTrailingIdx] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[ShadowVeryShortTrailingIdx] - inLow[ShadowVeryShortTrailingIdx] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[ShadowVeryShortTrailingIdx] - ( inClose[ShadowVeryShortTrailingIdx] >= inOpen[ShadowVeryShortTrailingIdx] ? inClose[ShadowVeryShortTrailingIdx] : inOpen[ShadowVeryShortTrailingIdx] ) ) + ( ( inClose[ShadowVeryShortTrailingIdx] >= inOpen[ShadowVeryShortTrailingIdx] ? inOpen[ShadowVeryShortTrailingIdx] : inClose[ShadowVeryShortTrailingIdx] ) - inLow[ShadowVeryShortTrailingIdx] ) : 0 ) ) ) ;
         ShadowVeryLongPeriodTotal += ( (this.candleSettings[CandleSettingType.ShadowVeryLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) )
            - ( (this.candleSettings[CandleSettingType.ShadowVeryLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[ShadowVeryLongTrailingIdx] - inOpen[ShadowVeryLongTrailingIdx] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[ShadowVeryLongTrailingIdx] - inLow[ShadowVeryLongTrailingIdx] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[ShadowVeryLongTrailingIdx] - ( inClose[ShadowVeryLongTrailingIdx] >= inOpen[ShadowVeryLongTrailingIdx] ? inClose[ShadowVeryLongTrailingIdx] : inOpen[ShadowVeryLongTrailingIdx] ) ) + ( ( inClose[ShadowVeryLongTrailingIdx] >= inOpen[ShadowVeryLongTrailingIdx] ? inOpen[ShadowVeryLongTrailingIdx] : inClose[ShadowVeryLongTrailingIdx] ) - inLow[ShadowVeryLongTrailingIdx] ) : 0 ) ) ) ;
         i++;
         BodyDojiTrailingIdx++;
         ShadowVeryShortTrailingIdx++;
         ShadowVeryLongTrailingIdx++;
      } while( i <= endIdx );
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   public int cdlTakuriStateInit( struct TA_cdlTakuri_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct cdlTakuri ));
      _state.value .value .mem_index = 0;
      _state.value .value .mem_size = cdlTakuriLookback ();
      if ( _state.value .value .mem_size > 0)
         _state.value .value .memory = TA_Calloc( _state.value .value .mem_size , sizeof(struct TA_CDLTAKURI_Data));
      else
         _state.value .value .memory = NULL;
      return RetCode.Success ;
   }
   public int cdlTakuriState( struct TA_cdlTakuri_State* _state,
      double inOpen,
      double inHigh,
      double inLow,
      double inClose,
      int *outInteger )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      size_t _cur_idx = _state.value .mem_index++;
      if ( _state.value .mem_size > 0) _cur_idx %= _state.value .mem_size ;
      if ( _state.value .mem_size > _state.value .mem_index - 1 ) {
         ( _state.value .memory+_cur_idx).value .inOpen = inOpen ;
         ( _state.value .memory+_cur_idx).value .inHigh = inHigh ;
         ( _state.value .memory+_cur_idx).value .inLow = inLow ;
         ( _state.value .memory+_cur_idx).value .inClose = inClose ;
         return RetCode.NeedMoreData ; }
      return RetCode.Success ;
   }
   public int cdlTakuriStateFree( struct TA_cdlTakuri_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if ( _state.value != NULL) {
         if ( _state.value .value .memory != NULL) TA_Free( _state.value .value .memory );
         TA_Free( _state.value ); _state.value = NULL;}
      return RetCode.Success ;
   }
   public RetCode cdlTakuri( int startIdx,
      int endIdx,
      float inOpen[],
      float inHigh[],
      float inLow[],
      float inClose[],
      MInteger outBegIdx,
      MInteger outNBElement,
      int outInteger[] )
   {
      double BodyDojiPeriodTotal, ShadowVeryShortPeriodTotal, ShadowVeryLongPeriodTotal;
      int i, outIdx, BodyDojiTrailingIdx, ShadowVeryShortTrailingIdx, ShadowVeryLongTrailingIdx, lookbackTotal;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      lookbackTotal = cdlTakuriLookback ();
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      BodyDojiPeriodTotal = 0;
      BodyDojiTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].avgPeriod) ;
      ShadowVeryShortPeriodTotal = 0;
      ShadowVeryShortTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) ;
      ShadowVeryLongPeriodTotal = 0;
      ShadowVeryLongTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.ShadowVeryLong.ordinal()].avgPeriod) ;
      i = BodyDojiTrailingIdx;
      while( i < startIdx ) {
         BodyDojiPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      i = ShadowVeryShortTrailingIdx;
      while( i < startIdx ) {
         ShadowVeryShortPeriodTotal += ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      i = ShadowVeryLongTrailingIdx;
      while( i < startIdx ) {
         ShadowVeryLongPeriodTotal += ( (this.candleSettings[CandleSettingType.ShadowVeryLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      outIdx = 0;
      do
      {
         if( ( Math.abs ( inClose[i] - inOpen[i] ) ) <= ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].avgPeriod) != 0.0? BodyDojiPeriodTotal / (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) < ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) != 0.0? ShadowVeryShortPeriodTotal / (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) > ( (this.candleSettings[CandleSettingType.ShadowVeryLong.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.ShadowVeryLong.ordinal()].avgPeriod) != 0.0? ShadowVeryLongPeriodTotal / (this.candleSettings[CandleSettingType.ShadowVeryLong.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.ShadowVeryLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.ShadowVeryLong.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) )
            )
            outInteger[outIdx++] = 100;
         else
            outInteger[outIdx++] = 0;
         BodyDojiPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) - ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[BodyDojiTrailingIdx] - inOpen[BodyDojiTrailingIdx] ) ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[BodyDojiTrailingIdx] - inLow[BodyDojiTrailingIdx] ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[BodyDojiTrailingIdx] - ( inClose[BodyDojiTrailingIdx] >= inOpen[BodyDojiTrailingIdx] ? inClose[BodyDojiTrailingIdx] : inOpen[BodyDojiTrailingIdx] ) ) + ( ( inClose[BodyDojiTrailingIdx] >= inOpen[BodyDojiTrailingIdx] ? inOpen[BodyDojiTrailingIdx] : inClose[BodyDojiTrailingIdx] ) - inLow[BodyDojiTrailingIdx] ) : 0 ) ) ) ;
         ShadowVeryShortPeriodTotal += ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) )
            - ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[ShadowVeryShortTrailingIdx] - inOpen[ShadowVeryShortTrailingIdx] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[ShadowVeryShortTrailingIdx] - inLow[ShadowVeryShortTrailingIdx] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[ShadowVeryShortTrailingIdx] - ( inClose[ShadowVeryShortTrailingIdx] >= inOpen[ShadowVeryShortTrailingIdx] ? inClose[ShadowVeryShortTrailingIdx] : inOpen[ShadowVeryShortTrailingIdx] ) ) + ( ( inClose[ShadowVeryShortTrailingIdx] >= inOpen[ShadowVeryShortTrailingIdx] ? inOpen[ShadowVeryShortTrailingIdx] : inClose[ShadowVeryShortTrailingIdx] ) - inLow[ShadowVeryShortTrailingIdx] ) : 0 ) ) ) ;
         ShadowVeryLongPeriodTotal += ( (this.candleSettings[CandleSettingType.ShadowVeryLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) )
            - ( (this.candleSettings[CandleSettingType.ShadowVeryLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[ShadowVeryLongTrailingIdx] - inOpen[ShadowVeryLongTrailingIdx] ) ) : ( (this.candleSettings[CandleSettingType.ShadowVeryLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[ShadowVeryLongTrailingIdx] - inLow[ShadowVeryLongTrailingIdx] ) : ( (this.candleSettings[CandleSettingType.ShadowVeryLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[ShadowVeryLongTrailingIdx] - ( inClose[ShadowVeryLongTrailingIdx] >= inOpen[ShadowVeryLongTrailingIdx] ? inClose[ShadowVeryLongTrailingIdx] : inOpen[ShadowVeryLongTrailingIdx] ) ) + ( ( inClose[ShadowVeryLongTrailingIdx] >= inOpen[ShadowVeryLongTrailingIdx] ? inOpen[ShadowVeryLongTrailingIdx] : inClose[ShadowVeryLongTrailingIdx] ) - inLow[ShadowVeryLongTrailingIdx] ) : 0 ) ) ) ;
         i++;
         BodyDojiTrailingIdx++;
         ShadowVeryShortTrailingIdx++;
         ShadowVeryLongTrailingIdx++;
      } while( i <= endIdx );
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   /* Generated */
   public int cdlTasukiGapLookback( )
   {
      return (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) + 2;
   }
   public RetCode cdlTasukiGap( int startIdx,
      int endIdx,
      double inOpen[],
      double inHigh[],
      double inLow[],
      double inClose[],
      MInteger outBegIdx,
      MInteger outNBElement,
      int outInteger[] )
   {
      double NearPeriodTotal;
      int i, outIdx, NearTrailingIdx, lookbackTotal;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      lookbackTotal = cdlTasukiGapLookback ();
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      NearPeriodTotal = 0;
      NearTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) ;
      i = NearTrailingIdx;
      while( i < startIdx ) {
         NearPeriodTotal += ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ;
         i++;
      }
      i = startIdx;
      outIdx = 0;
      do
      {
         if(
            (
            ( (((inOpen[i-1]) < (inClose[i-1])) ? (inOpen[i-1]) : (inClose[i-1])) > (((inOpen[i-2]) > (inClose[i-2])) ? (inOpen[i-2]) : (inClose[i-2])) ) &&
            ( inClose[i-1] >= inOpen[i-1] ? 1 : -1 ) == 1 &&
            ( inClose[i] >= inOpen[i] ? 1 : -1 ) == -1 &&
            inOpen[i] < inClose[i-1] && inOpen[i] > inOpen[i-1] &&
            inClose[i] < inOpen[i-1] &&
            inClose[i] > (((inClose[i-2]) > (inOpen[i-2])) ? (inClose[i-2]) : (inOpen[i-2])) &&
            Math.abs ( ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) - ( Math.abs ( inClose[i] - inOpen[i] ) ) ) < ( (this.candleSettings[CandleSettingType.Near.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) != 0.0? NearPeriodTotal / (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) )
            ) ||
            (
            ( (((inOpen[i-1]) > (inClose[i-1])) ? (inOpen[i-1]) : (inClose[i-1])) < (((inOpen[i-2]) < (inClose[i-2])) ? (inOpen[i-2]) : (inClose[i-2])) ) &&
            ( inClose[i-1] >= inOpen[i-1] ? 1 : -1 ) == -1 &&
            ( inClose[i] >= inOpen[i] ? 1 : -1 ) == 1 &&
            inOpen[i] < inOpen[i-1] && inOpen[i] > inClose[i-1] &&
            inClose[i] > inOpen[i-1] &&
            inClose[i] < (((inClose[i-2]) < (inOpen[i-2])) ? (inClose[i-2]) : (inOpen[i-2])) &&
            Math.abs ( ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) - ( Math.abs ( inClose[i] - inOpen[i] ) ) ) < ( (this.candleSettings[CandleSettingType.Near.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) != 0.0? NearPeriodTotal / (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) )
            )
            )
            outInteger[outIdx++] = ( inClose[i-1] >= inOpen[i-1] ? 1 : -1 ) * 100;
         else
            outInteger[outIdx++] = 0;
         NearPeriodTotal += ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) - ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[NearTrailingIdx-1] - inOpen[NearTrailingIdx-1] ) ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[NearTrailingIdx-1] - inLow[NearTrailingIdx-1] ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[NearTrailingIdx-1] - ( inClose[NearTrailingIdx-1] >= inOpen[NearTrailingIdx-1] ? inClose[NearTrailingIdx-1] : inOpen[NearTrailingIdx-1] ) ) + ( ( inClose[NearTrailingIdx-1] >= inOpen[NearTrailingIdx-1] ? inOpen[NearTrailingIdx-1] : inClose[NearTrailingIdx-1] ) - inLow[NearTrailingIdx-1] ) : 0 ) ) ) ;
         i++;
         NearTrailingIdx++;
      } while( i <= endIdx );
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   public int cdlTasukiGapStateInit( struct TA_cdlTasukiGap_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct cdlTasukiGap ));
      _state.value .value .mem_index = 0;
      _state.value .value .mem_size = cdlTasukiGapLookback ();
      if ( _state.value .value .mem_size > 0)
         _state.value .value .memory = TA_Calloc( _state.value .value .mem_size , sizeof(struct TA_CDLTASUKIGAP_Data));
      else
         _state.value .value .memory = NULL;
      return RetCode.Success ;
   }
   public int cdlTasukiGapState( struct TA_cdlTasukiGap_State* _state,
      double inOpen,
      double inHigh,
      double inLow,
      double inClose,
      int *outInteger )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      size_t _cur_idx = _state.value .mem_index++;
      if ( _state.value .mem_size > 0) _cur_idx %= _state.value .mem_size ;
      if ( _state.value .mem_size > _state.value .mem_index - 1 ) {
         ( _state.value .memory+_cur_idx).value .inOpen = inOpen ;
         ( _state.value .memory+_cur_idx).value .inHigh = inHigh ;
         ( _state.value .memory+_cur_idx).value .inLow = inLow ;
         ( _state.value .memory+_cur_idx).value .inClose = inClose ;
         return RetCode.NeedMoreData ; }
      return RetCode.Success ;
   }
   public int cdlTasukiGapStateFree( struct TA_cdlTasukiGap_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if ( _state.value != NULL) {
         if ( _state.value .value .memory != NULL) TA_Free( _state.value .value .memory );
         TA_Free( _state.value ); _state.value = NULL;}
      return RetCode.Success ;
   }
   public RetCode cdlTasukiGap( int startIdx,
      int endIdx,
      float inOpen[],
      float inHigh[],
      float inLow[],
      float inClose[],
      MInteger outBegIdx,
      MInteger outNBElement,
      int outInteger[] )
   {
      double NearPeriodTotal;
      int i, outIdx, NearTrailingIdx, lookbackTotal;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      lookbackTotal = cdlTasukiGapLookback ();
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      NearPeriodTotal = 0;
      NearTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) ;
      i = NearTrailingIdx;
      while( i < startIdx ) {
         NearPeriodTotal += ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ;
         i++;
      }
      i = startIdx;
      outIdx = 0;
      do
      {
         if(
            (
            ( (((inOpen[i-1]) < (inClose[i-1])) ? (inOpen[i-1]) : (inClose[i-1])) > (((inOpen[i-2]) > (inClose[i-2])) ? (inOpen[i-2]) : (inClose[i-2])) ) &&
            ( inClose[i-1] >= inOpen[i-1] ? 1 : -1 ) == 1 &&
            ( inClose[i] >= inOpen[i] ? 1 : -1 ) == -1 &&
            inOpen[i] < inClose[i-1] && inOpen[i] > inOpen[i-1] &&
            inClose[i] < inOpen[i-1] &&
            inClose[i] > (((inClose[i-2]) > (inOpen[i-2])) ? (inClose[i-2]) : (inOpen[i-2])) &&
            Math.abs ( ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) - ( Math.abs ( inClose[i] - inOpen[i] ) ) ) < ( (this.candleSettings[CandleSettingType.Near.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) != 0.0? NearPeriodTotal / (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) )
            ) ||
            (
            ( (((inOpen[i-1]) > (inClose[i-1])) ? (inOpen[i-1]) : (inClose[i-1])) < (((inOpen[i-2]) < (inClose[i-2])) ? (inOpen[i-2]) : (inClose[i-2])) ) &&
            ( inClose[i-1] >= inOpen[i-1] ? 1 : -1 ) == -1 &&
            ( inClose[i] >= inOpen[i] ? 1 : -1 ) == 1 &&
            inOpen[i] < inOpen[i-1] && inOpen[i] > inClose[i-1] &&
            inClose[i] > inOpen[i-1] &&
            inClose[i] < (((inClose[i-2]) < (inOpen[i-2])) ? (inClose[i-2]) : (inOpen[i-2])) &&
            Math.abs ( ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) - ( Math.abs ( inClose[i] - inOpen[i] ) ) ) < ( (this.candleSettings[CandleSettingType.Near.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) != 0.0? NearPeriodTotal / (this.candleSettings[CandleSettingType.Near.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) )
            )
            )
            outInteger[outIdx++] = ( inClose[i-1] >= inOpen[i-1] ? 1 : -1 ) * 100;
         else
            outInteger[outIdx++] = 0;
         NearPeriodTotal += ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) - ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[NearTrailingIdx-1] - inOpen[NearTrailingIdx-1] ) ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[NearTrailingIdx-1] - inLow[NearTrailingIdx-1] ) : ( (this.candleSettings[CandleSettingType.Near.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[NearTrailingIdx-1] - ( inClose[NearTrailingIdx-1] >= inOpen[NearTrailingIdx-1] ? inClose[NearTrailingIdx-1] : inOpen[NearTrailingIdx-1] ) ) + ( ( inClose[NearTrailingIdx-1] >= inOpen[NearTrailingIdx-1] ? inOpen[NearTrailingIdx-1] : inClose[NearTrailingIdx-1] ) - inLow[NearTrailingIdx-1] ) : 0 ) ) ) ;
         i++;
         NearTrailingIdx++;
      } while( i <= endIdx );
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   /* Generated */
   public int cdlThrustingLookback( )
   {
      return ((( (this.candleSettings[CandleSettingType.Equal.ordinal()].avgPeriod) ) > ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) )) ? ( (this.candleSettings[CandleSettingType.Equal.ordinal()].avgPeriod) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) )) +
         1;
   }
   public RetCode cdlThrusting( int startIdx,
      int endIdx,
      double inOpen[],
      double inHigh[],
      double inLow[],
      double inClose[],
      MInteger outBegIdx,
      MInteger outNBElement,
      int outInteger[] )
   {
      double EqualPeriodTotal, BodyLongPeriodTotal;
      int i, outIdx, EqualTrailingIdx, BodyLongTrailingIdx, lookbackTotal;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      lookbackTotal = cdlThrustingLookback ();
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      EqualPeriodTotal = 0;
      EqualTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.Equal.ordinal()].avgPeriod) ;
      BodyLongPeriodTotal = 0;
      BodyLongTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) ;
      i = EqualTrailingIdx;
      while( i < startIdx ) {
         EqualPeriodTotal += ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ;
         i++;
      }
      i = BodyLongTrailingIdx;
      while( i < startIdx ) {
         BodyLongPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ;
         i++;
      }
      i = startIdx;
      outIdx = 0;
      do
      {
         if( ( inClose[i-1] >= inOpen[i-1] ? 1 : -1 ) == -1 &&
            ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) > ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) != 0.0? BodyLongPeriodTotal / (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( inClose[i] >= inOpen[i] ? 1 : -1 ) == 1 &&
            inOpen[i] < inLow[i-1] &&
            inClose[i] > inClose[i-1] + ( (this.candleSettings[CandleSettingType.Equal.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.Equal.ordinal()].avgPeriod) != 0.0? EqualPeriodTotal / (this.candleSettings[CandleSettingType.Equal.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            inClose[i] <= inClose[i-1] + ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) * 0.5
            )
            outInteger[outIdx++] = -100;
         else
            outInteger[outIdx++] = 0;
         EqualPeriodTotal += ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) - ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[EqualTrailingIdx-1] - inOpen[EqualTrailingIdx-1] ) ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[EqualTrailingIdx-1] - inLow[EqualTrailingIdx-1] ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[EqualTrailingIdx-1] - ( inClose[EqualTrailingIdx-1] >= inOpen[EqualTrailingIdx-1] ? inClose[EqualTrailingIdx-1] : inOpen[EqualTrailingIdx-1] ) ) + ( ( inClose[EqualTrailingIdx-1] >= inOpen[EqualTrailingIdx-1] ? inOpen[EqualTrailingIdx-1] : inClose[EqualTrailingIdx-1] ) - inLow[EqualTrailingIdx-1] ) : 0 ) ) ) ;
         BodyLongPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) )
            - ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[BodyLongTrailingIdx-1] - inOpen[BodyLongTrailingIdx-1] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[BodyLongTrailingIdx-1] - inLow[BodyLongTrailingIdx-1] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[BodyLongTrailingIdx-1] - ( inClose[BodyLongTrailingIdx-1] >= inOpen[BodyLongTrailingIdx-1] ? inClose[BodyLongTrailingIdx-1] : inOpen[BodyLongTrailingIdx-1] ) ) + ( ( inClose[BodyLongTrailingIdx-1] >= inOpen[BodyLongTrailingIdx-1] ? inOpen[BodyLongTrailingIdx-1] : inClose[BodyLongTrailingIdx-1] ) - inLow[BodyLongTrailingIdx-1] ) : 0 ) ) ) ;
         i++;
         EqualTrailingIdx++;
         BodyLongTrailingIdx++;
      } while( i <= endIdx );
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   public int cdlThrustingStateInit( struct TA_cdlThrusting_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct cdlThrusting ));
      _state.value .value .mem_index = 0;
      _state.value .value .mem_size = cdlThrustingLookback ();
      if ( _state.value .value .mem_size > 0)
         _state.value .value .memory = TA_Calloc( _state.value .value .mem_size , sizeof(struct TA_CDLTHRUSTING_Data));
      else
         _state.value .value .memory = NULL;
      return RetCode.Success ;
   }
   public int cdlThrustingState( struct TA_cdlThrusting_State* _state,
      double inOpen,
      double inHigh,
      double inLow,
      double inClose,
      int *outInteger )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      size_t _cur_idx = _state.value .mem_index++;
      if ( _state.value .mem_size > 0) _cur_idx %= _state.value .mem_size ;
      if ( _state.value .mem_size > _state.value .mem_index - 1 ) {
         ( _state.value .memory+_cur_idx).value .inOpen = inOpen ;
         ( _state.value .memory+_cur_idx).value .inHigh = inHigh ;
         ( _state.value .memory+_cur_idx).value .inLow = inLow ;
         ( _state.value .memory+_cur_idx).value .inClose = inClose ;
         return RetCode.NeedMoreData ; }
      return RetCode.Success ;
   }
   public int cdlThrustingStateFree( struct TA_cdlThrusting_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if ( _state.value != NULL) {
         if ( _state.value .value .memory != NULL) TA_Free( _state.value .value .memory );
         TA_Free( _state.value ); _state.value = NULL;}
      return RetCode.Success ;
   }
   public RetCode cdlThrusting( int startIdx,
      int endIdx,
      float inOpen[],
      float inHigh[],
      float inLow[],
      float inClose[],
      MInteger outBegIdx,
      MInteger outNBElement,
      int outInteger[] )
   {
      double EqualPeriodTotal, BodyLongPeriodTotal;
      int i, outIdx, EqualTrailingIdx, BodyLongTrailingIdx, lookbackTotal;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      lookbackTotal = cdlThrustingLookback ();
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      EqualPeriodTotal = 0;
      EqualTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.Equal.ordinal()].avgPeriod) ;
      BodyLongPeriodTotal = 0;
      BodyLongTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) ;
      i = EqualTrailingIdx;
      while( i < startIdx ) {
         EqualPeriodTotal += ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ;
         i++;
      }
      i = BodyLongTrailingIdx;
      while( i < startIdx ) {
         BodyLongPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ;
         i++;
      }
      i = startIdx;
      outIdx = 0;
      do
      {
         if( ( inClose[i-1] >= inOpen[i-1] ? 1 : -1 ) == -1 &&
            ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) > ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) != 0.0? BodyLongPeriodTotal / (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( inClose[i] >= inOpen[i] ? 1 : -1 ) == 1 &&
            inOpen[i] < inLow[i-1] &&
            inClose[i] > inClose[i-1] + ( (this.candleSettings[CandleSettingType.Equal.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.Equal.ordinal()].avgPeriod) != 0.0? EqualPeriodTotal / (this.candleSettings[CandleSettingType.Equal.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            inClose[i] <= inClose[i-1] + ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) * 0.5
            )
            outInteger[outIdx++] = -100;
         else
            outInteger[outIdx++] = 0;
         EqualPeriodTotal += ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) - ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[EqualTrailingIdx-1] - inOpen[EqualTrailingIdx-1] ) ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[EqualTrailingIdx-1] - inLow[EqualTrailingIdx-1] ) : ( (this.candleSettings[CandleSettingType.Equal.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[EqualTrailingIdx-1] - ( inClose[EqualTrailingIdx-1] >= inOpen[EqualTrailingIdx-1] ? inClose[EqualTrailingIdx-1] : inOpen[EqualTrailingIdx-1] ) ) + ( ( inClose[EqualTrailingIdx-1] >= inOpen[EqualTrailingIdx-1] ? inOpen[EqualTrailingIdx-1] : inClose[EqualTrailingIdx-1] ) - inLow[EqualTrailingIdx-1] ) : 0 ) ) ) ;
         BodyLongPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) )
            - ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[BodyLongTrailingIdx-1] - inOpen[BodyLongTrailingIdx-1] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[BodyLongTrailingIdx-1] - inLow[BodyLongTrailingIdx-1] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[BodyLongTrailingIdx-1] - ( inClose[BodyLongTrailingIdx-1] >= inOpen[BodyLongTrailingIdx-1] ? inClose[BodyLongTrailingIdx-1] : inOpen[BodyLongTrailingIdx-1] ) ) + ( ( inClose[BodyLongTrailingIdx-1] >= inOpen[BodyLongTrailingIdx-1] ? inOpen[BodyLongTrailingIdx-1] : inClose[BodyLongTrailingIdx-1] ) - inLow[BodyLongTrailingIdx-1] ) : 0 ) ) ) ;
         i++;
         EqualTrailingIdx++;
         BodyLongTrailingIdx++;
      } while( i <= endIdx );
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   /* Generated */
   public int cdlTristarLookback( )
   {
      return (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].avgPeriod) + 2;
   }
   public RetCode cdlTristar( int startIdx,
      int endIdx,
      double inOpen[],
      double inHigh[],
      double inLow[],
      double inClose[],
      MInteger outBegIdx,
      MInteger outNBElement,
      int outInteger[] )
   {
      double BodyPeriodTotal;
      int i, outIdx, BodyTrailingIdx, lookbackTotal;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      lookbackTotal = cdlTristarLookback ();
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      BodyPeriodTotal = 0;
      BodyTrailingIdx = startIdx -2 - (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].avgPeriod) ;
      i = BodyTrailingIdx;
      while( i < startIdx-2 ) {
         BodyPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      i = startIdx;
      outIdx = 0;
      do
      {
         if( ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) <= ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].avgPeriod) != 0.0? BodyPeriodTotal / (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-2] - inLow[i-2] ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-2] - ( inClose[i-2] >= inOpen[i-2] ? inClose[i-2] : inOpen[i-2] ) ) + ( ( inClose[i-2] >= inOpen[i-2] ? inOpen[i-2] : inClose[i-2] ) - inLow[i-2] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) <= ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].avgPeriod) != 0.0? BodyPeriodTotal / (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-2] - inLow[i-2] ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-2] - ( inClose[i-2] >= inOpen[i-2] ? inClose[i-2] : inOpen[i-2] ) ) + ( ( inClose[i-2] >= inOpen[i-2] ? inOpen[i-2] : inClose[i-2] ) - inLow[i-2] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( Math.abs ( inClose[i] - inOpen[i] ) ) <= ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].avgPeriod) != 0.0? BodyPeriodTotal / (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-2] - inLow[i-2] ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-2] - ( inClose[i-2] >= inOpen[i-2] ? inClose[i-2] : inOpen[i-2] ) ) + ( ( inClose[i-2] >= inOpen[i-2] ? inOpen[i-2] : inClose[i-2] ) - inLow[i-2] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) ) {
            outInteger[outIdx] = 0;
            if ( ( (((inOpen[i-1]) < (inClose[i-1])) ? (inOpen[i-1]) : (inClose[i-1])) > (((inOpen[i-2]) > (inClose[i-2])) ? (inOpen[i-2]) : (inClose[i-2])) )
               &&
               (((inOpen[i]) > (inClose[i])) ? (inOpen[i]) : (inClose[i])) < (((inOpen[i-1]) > (inClose[i-1])) ? (inOpen[i-1]) : (inClose[i-1]))
               )
               outInteger[outIdx] = -100;
            if ( ( (((inOpen[i-1]) > (inClose[i-1])) ? (inOpen[i-1]) : (inClose[i-1])) < (((inOpen[i-2]) < (inClose[i-2])) ? (inOpen[i-2]) : (inClose[i-2])) )
               &&
               (((inOpen[i]) < (inClose[i])) ? (inOpen[i]) : (inClose[i])) > (((inOpen[i-1]) < (inClose[i-1])) ? (inOpen[i-1]) : (inClose[i-1]))
               )
               outInteger[outIdx] = +100;
            outIdx++;
         }
         else
            outInteger[outIdx++] = 0;
         BodyPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-2] - inLow[i-2] ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-2] - ( inClose[i-2] >= inOpen[i-2] ? inClose[i-2] : inOpen[i-2] ) ) + ( ( inClose[i-2] >= inOpen[i-2] ? inOpen[i-2] : inClose[i-2] ) - inLow[i-2] ) : 0 ) ) ) - ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[BodyTrailingIdx] - inOpen[BodyTrailingIdx] ) ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[BodyTrailingIdx] - inLow[BodyTrailingIdx] ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[BodyTrailingIdx] - ( inClose[BodyTrailingIdx] >= inOpen[BodyTrailingIdx] ? inClose[BodyTrailingIdx] : inOpen[BodyTrailingIdx] ) ) + ( ( inClose[BodyTrailingIdx] >= inOpen[BodyTrailingIdx] ? inOpen[BodyTrailingIdx] : inClose[BodyTrailingIdx] ) - inLow[BodyTrailingIdx] ) : 0 ) ) ) ;
         i++;
         BodyTrailingIdx++;
      } while( i <= endIdx );
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   public int cdlTristarStateInit( struct TA_cdlTristar_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct cdlTristar ));
      _state.value .value .mem_index = 0;
      _state.value .value .mem_size = cdlTristarLookback ();
      if ( _state.value .value .mem_size > 0)
         _state.value .value .memory = TA_Calloc( _state.value .value .mem_size , sizeof(struct TA_CDLTRISTAR_Data));
      else
         _state.value .value .memory = NULL;
      return RetCode.Success ;
   }
   public int cdlTristarState( struct TA_cdlTristar_State* _state,
      double inOpen,
      double inHigh,
      double inLow,
      double inClose,
      int *outInteger )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      size_t _cur_idx = _state.value .mem_index++;
      if ( _state.value .mem_size > 0) _cur_idx %= _state.value .mem_size ;
      if ( _state.value .mem_size > _state.value .mem_index - 1 ) {
         ( _state.value .memory+_cur_idx).value .inOpen = inOpen ;
         ( _state.value .memory+_cur_idx).value .inHigh = inHigh ;
         ( _state.value .memory+_cur_idx).value .inLow = inLow ;
         ( _state.value .memory+_cur_idx).value .inClose = inClose ;
         return RetCode.NeedMoreData ; }
      return RetCode.Success ;
   }
   public int cdlTristarStateFree( struct TA_cdlTristar_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if ( _state.value != NULL) {
         if ( _state.value .value .memory != NULL) TA_Free( _state.value .value .memory );
         TA_Free( _state.value ); _state.value = NULL;}
      return RetCode.Success ;
   }
   public RetCode cdlTristar( int startIdx,
      int endIdx,
      float inOpen[],
      float inHigh[],
      float inLow[],
      float inClose[],
      MInteger outBegIdx,
      MInteger outNBElement,
      int outInteger[] )
   {
      double BodyPeriodTotal;
      int i, outIdx, BodyTrailingIdx, lookbackTotal;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      lookbackTotal = cdlTristarLookback ();
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      BodyPeriodTotal = 0;
      BodyTrailingIdx = startIdx -2 - (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].avgPeriod) ;
      i = BodyTrailingIdx;
      while( i < startIdx-2 ) {
         BodyPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      i = startIdx;
      outIdx = 0;
      do
      {
         if( ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) <= ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].avgPeriod) != 0.0? BodyPeriodTotal / (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-2] - inLow[i-2] ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-2] - ( inClose[i-2] >= inOpen[i-2] ? inClose[i-2] : inOpen[i-2] ) ) + ( ( inClose[i-2] >= inOpen[i-2] ? inOpen[i-2] : inClose[i-2] ) - inLow[i-2] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) <= ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].avgPeriod) != 0.0? BodyPeriodTotal / (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-2] - inLow[i-2] ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-2] - ( inClose[i-2] >= inOpen[i-2] ? inClose[i-2] : inOpen[i-2] ) ) + ( ( inClose[i-2] >= inOpen[i-2] ? inOpen[i-2] : inClose[i-2] ) - inLow[i-2] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( Math.abs ( inClose[i] - inOpen[i] ) ) <= ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].avgPeriod) != 0.0? BodyPeriodTotal / (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-2] - inLow[i-2] ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-2] - ( inClose[i-2] >= inOpen[i-2] ? inClose[i-2] : inOpen[i-2] ) ) + ( ( inClose[i-2] >= inOpen[i-2] ? inOpen[i-2] : inClose[i-2] ) - inLow[i-2] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) ) {
            outInteger[outIdx] = 0;
            if ( ( (((inOpen[i-1]) < (inClose[i-1])) ? (inOpen[i-1]) : (inClose[i-1])) > (((inOpen[i-2]) > (inClose[i-2])) ? (inOpen[i-2]) : (inClose[i-2])) )
               &&
               (((inOpen[i]) > (inClose[i])) ? (inOpen[i]) : (inClose[i])) < (((inOpen[i-1]) > (inClose[i-1])) ? (inOpen[i-1]) : (inClose[i-1]))
               )
               outInteger[outIdx] = -100;
            if ( ( (((inOpen[i-1]) > (inClose[i-1])) ? (inOpen[i-1]) : (inClose[i-1])) < (((inOpen[i-2]) < (inClose[i-2])) ? (inOpen[i-2]) : (inClose[i-2])) )
               &&
               (((inOpen[i]) < (inClose[i])) ? (inOpen[i]) : (inClose[i])) > (((inOpen[i-1]) < (inClose[i-1])) ? (inOpen[i-1]) : (inClose[i-1]))
               )
               outInteger[outIdx] = +100;
            outIdx++;
         }
         else
            outInteger[outIdx++] = 0;
         BodyPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-2] - inLow[i-2] ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-2] - ( inClose[i-2] >= inOpen[i-2] ? inClose[i-2] : inOpen[i-2] ) ) + ( ( inClose[i-2] >= inOpen[i-2] ? inOpen[i-2] : inClose[i-2] ) - inLow[i-2] ) : 0 ) ) ) - ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[BodyTrailingIdx] - inOpen[BodyTrailingIdx] ) ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[BodyTrailingIdx] - inLow[BodyTrailingIdx] ) : ( (this.candleSettings[CandleSettingType.BodyDoji.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[BodyTrailingIdx] - ( inClose[BodyTrailingIdx] >= inOpen[BodyTrailingIdx] ? inClose[BodyTrailingIdx] : inOpen[BodyTrailingIdx] ) ) + ( ( inClose[BodyTrailingIdx] >= inOpen[BodyTrailingIdx] ? inOpen[BodyTrailingIdx] : inClose[BodyTrailingIdx] ) - inLow[BodyTrailingIdx] ) : 0 ) ) ) ;
         i++;
         BodyTrailingIdx++;
      } while( i <= endIdx );
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   /* Generated */
   public int cdlUnique3RiverLookback( )
   {
      return ((( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) ) > ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) )) ? ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) )) + 2;
   }
   public RetCode cdlUnique3River( int startIdx,
      int endIdx,
      double inOpen[],
      double inHigh[],
      double inLow[],
      double inClose[],
      MInteger outBegIdx,
      MInteger outNBElement,
      int outInteger[] )
   {
      double BodyShortPeriodTotal, BodyLongPeriodTotal;
      int i, outIdx, BodyShortTrailingIdx, BodyLongTrailingIdx, lookbackTotal;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      lookbackTotal = cdlUnique3RiverLookback ();
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      BodyLongPeriodTotal = 0;
      BodyShortPeriodTotal = 0;
      BodyLongTrailingIdx = startIdx -2 - (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) ;
      BodyShortTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) ;
      i = BodyLongTrailingIdx;
      while( i < startIdx-2 ) {
         BodyLongPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      i = BodyShortTrailingIdx;
      while( i < startIdx ) {
         BodyShortPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      i = startIdx;
      outIdx = 0;
      do
      {
         if( ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) > ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) != 0.0? BodyLongPeriodTotal / (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-2] - inLow[i-2] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-2] - ( inClose[i-2] >= inOpen[i-2] ? inClose[i-2] : inOpen[i-2] ) ) + ( ( inClose[i-2] >= inOpen[i-2] ? inOpen[i-2] : inClose[i-2] ) - inLow[i-2] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( inClose[i-2] >= inOpen[i-2] ? 1 : -1 ) == -1 &&
            ( inClose[i-1] >= inOpen[i-1] ? 1 : -1 ) == -1 &&
            inClose[i-1] > inClose[i-2] && inOpen[i-1] <= inOpen[i-2] &&
            inLow[i-1] < inLow[i-2] &&
            ( Math.abs ( inClose[i] - inOpen[i] ) ) < ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) != 0.0? BodyShortPeriodTotal / (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( inClose[i] >= inOpen[i] ? 1 : -1 ) == 1 &&
            inOpen[i] > inLow[i-1]
            )
            outInteger[outIdx++] = 100;
         else
            outInteger[outIdx++] = 0;
         BodyLongPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-2] - inLow[i-2] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-2] - ( inClose[i-2] >= inOpen[i-2] ? inClose[i-2] : inOpen[i-2] ) ) + ( ( inClose[i-2] >= inOpen[i-2] ? inOpen[i-2] : inClose[i-2] ) - inLow[i-2] ) : 0 ) ) ) - ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[BodyLongTrailingIdx] - inOpen[BodyLongTrailingIdx] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[BodyLongTrailingIdx] - inLow[BodyLongTrailingIdx] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[BodyLongTrailingIdx] - ( inClose[BodyLongTrailingIdx] >= inOpen[BodyLongTrailingIdx] ? inClose[BodyLongTrailingIdx] : inOpen[BodyLongTrailingIdx] ) ) + ( ( inClose[BodyLongTrailingIdx] >= inOpen[BodyLongTrailingIdx] ? inOpen[BodyLongTrailingIdx] : inClose[BodyLongTrailingIdx] ) - inLow[BodyLongTrailingIdx] ) : 0 ) ) ) ;
         BodyShortPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) - ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[BodyShortTrailingIdx] - inOpen[BodyShortTrailingIdx] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[BodyShortTrailingIdx] - inLow[BodyShortTrailingIdx] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[BodyShortTrailingIdx] - ( inClose[BodyShortTrailingIdx] >= inOpen[BodyShortTrailingIdx] ? inClose[BodyShortTrailingIdx] : inOpen[BodyShortTrailingIdx] ) ) + ( ( inClose[BodyShortTrailingIdx] >= inOpen[BodyShortTrailingIdx] ? inOpen[BodyShortTrailingIdx] : inClose[BodyShortTrailingIdx] ) - inLow[BodyShortTrailingIdx] ) : 0 ) ) ) ;
         i++;
         BodyLongTrailingIdx++;
         BodyShortTrailingIdx++;
      } while( i <= endIdx );
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   public int cdlUnique3RiverStateInit( struct TA_cdlUnique3River_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct cdlUnique3River ));
      _state.value .value .mem_index = 0;
      _state.value .value .mem_size = cdlUnique3RiverLookback ();
      if ( _state.value .value .mem_size > 0)
         _state.value .value .memory = TA_Calloc( _state.value .value .mem_size , sizeof(struct TA_CDLUNIQUE3RIVER_Data));
      else
         _state.value .value .memory = NULL;
      return RetCode.Success ;
   }
   public int cdlUnique3RiverState( struct TA_cdlUnique3River_State* _state,
      double inOpen,
      double inHigh,
      double inLow,
      double inClose,
      int *outInteger )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      size_t _cur_idx = _state.value .mem_index++;
      if ( _state.value .mem_size > 0) _cur_idx %= _state.value .mem_size ;
      if ( _state.value .mem_size > _state.value .mem_index - 1 ) {
         ( _state.value .memory+_cur_idx).value .inOpen = inOpen ;
         ( _state.value .memory+_cur_idx).value .inHigh = inHigh ;
         ( _state.value .memory+_cur_idx).value .inLow = inLow ;
         ( _state.value .memory+_cur_idx).value .inClose = inClose ;
         return RetCode.NeedMoreData ; }
      return RetCode.Success ;
   }
   public int cdlUnique3RiverStateFree( struct TA_cdlUnique3River_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if ( _state.value != NULL) {
         if ( _state.value .value .memory != NULL) TA_Free( _state.value .value .memory );
         TA_Free( _state.value ); _state.value = NULL;}
      return RetCode.Success ;
   }
   public RetCode cdlUnique3River( int startIdx,
      int endIdx,
      float inOpen[],
      float inHigh[],
      float inLow[],
      float inClose[],
      MInteger outBegIdx,
      MInteger outNBElement,
      int outInteger[] )
   {
      double BodyShortPeriodTotal, BodyLongPeriodTotal;
      int i, outIdx, BodyShortTrailingIdx, BodyLongTrailingIdx, lookbackTotal;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      lookbackTotal = cdlUnique3RiverLookback ();
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      BodyLongPeriodTotal = 0;
      BodyShortPeriodTotal = 0;
      BodyLongTrailingIdx = startIdx -2 - (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) ;
      BodyShortTrailingIdx = startIdx - (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) ;
      i = BodyLongTrailingIdx;
      while( i < startIdx-2 ) {
         BodyLongPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      i = BodyShortTrailingIdx;
      while( i < startIdx ) {
         BodyShortPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      i = startIdx;
      outIdx = 0;
      do
      {
         if( ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) > ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) != 0.0? BodyLongPeriodTotal / (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-2] - inLow[i-2] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-2] - ( inClose[i-2] >= inOpen[i-2] ? inClose[i-2] : inOpen[i-2] ) ) + ( ( inClose[i-2] >= inOpen[i-2] ? inOpen[i-2] : inClose[i-2] ) - inLow[i-2] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( inClose[i-2] >= inOpen[i-2] ? 1 : -1 ) == -1 &&
            ( inClose[i-1] >= inOpen[i-1] ? 1 : -1 ) == -1 &&
            inClose[i-1] > inClose[i-2] && inOpen[i-1] <= inOpen[i-2] &&
            inLow[i-1] < inLow[i-2] &&
            ( Math.abs ( inClose[i] - inOpen[i] ) ) < ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) != 0.0? BodyShortPeriodTotal / (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( inClose[i] >= inOpen[i] ? 1 : -1 ) == 1 &&
            inOpen[i] > inLow[i-1]
            )
            outInteger[outIdx++] = 100;
         else
            outInteger[outIdx++] = 0;
         BodyLongPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-2] - inLow[i-2] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-2] - ( inClose[i-2] >= inOpen[i-2] ? inClose[i-2] : inOpen[i-2] ) ) + ( ( inClose[i-2] >= inOpen[i-2] ? inOpen[i-2] : inClose[i-2] ) - inLow[i-2] ) : 0 ) ) ) - ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[BodyLongTrailingIdx] - inOpen[BodyLongTrailingIdx] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[BodyLongTrailingIdx] - inLow[BodyLongTrailingIdx] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[BodyLongTrailingIdx] - ( inClose[BodyLongTrailingIdx] >= inOpen[BodyLongTrailingIdx] ? inClose[BodyLongTrailingIdx] : inOpen[BodyLongTrailingIdx] ) ) + ( ( inClose[BodyLongTrailingIdx] >= inOpen[BodyLongTrailingIdx] ? inOpen[BodyLongTrailingIdx] : inClose[BodyLongTrailingIdx] ) - inLow[BodyLongTrailingIdx] ) : 0 ) ) ) ;
         BodyShortPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) - ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[BodyShortTrailingIdx] - inOpen[BodyShortTrailingIdx] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[BodyShortTrailingIdx] - inLow[BodyShortTrailingIdx] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[BodyShortTrailingIdx] - ( inClose[BodyShortTrailingIdx] >= inOpen[BodyShortTrailingIdx] ? inClose[BodyShortTrailingIdx] : inOpen[BodyShortTrailingIdx] ) ) + ( ( inClose[BodyShortTrailingIdx] >= inOpen[BodyShortTrailingIdx] ? inOpen[BodyShortTrailingIdx] : inClose[BodyShortTrailingIdx] ) - inLow[BodyShortTrailingIdx] ) : 0 ) ) ) ;
         i++;
         BodyLongTrailingIdx++;
         BodyShortTrailingIdx++;
      } while( i <= endIdx );
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   /* Generated */
   public int cdlUpsideGap2CrowsLookback( )
   {
      return ((( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) ) > ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) )) ? ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) )) + 2;
   }
   public RetCode cdlUpsideGap2Crows( int startIdx,
      int endIdx,
      double inOpen[],
      double inHigh[],
      double inLow[],
      double inClose[],
      MInteger outBegIdx,
      MInteger outNBElement,
      int outInteger[] )
   {
      double BodyShortPeriodTotal, BodyLongPeriodTotal;
      int i, outIdx, BodyShortTrailingIdx, BodyLongTrailingIdx, lookbackTotal;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      lookbackTotal = cdlUpsideGap2CrowsLookback ();
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      BodyLongPeriodTotal = 0;
      BodyShortPeriodTotal = 0;
      BodyLongTrailingIdx = startIdx -2 - (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) ;
      BodyShortTrailingIdx = startIdx -1 - (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) ;
      i = BodyLongTrailingIdx;
      while( i < startIdx-2 ) {
         BodyLongPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      i = BodyShortTrailingIdx;
      while( i < startIdx-1 ) {
         BodyShortPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      i = startIdx;
      outIdx = 0;
      do
      {
         if( ( inClose[i-2] >= inOpen[i-2] ? 1 : -1 ) == 1 &&
            ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) > ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) != 0.0? BodyLongPeriodTotal / (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-2] - inLow[i-2] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-2] - ( inClose[i-2] >= inOpen[i-2] ? inClose[i-2] : inOpen[i-2] ) ) + ( ( inClose[i-2] >= inOpen[i-2] ? inOpen[i-2] : inClose[i-2] ) - inLow[i-2] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( inClose[i-1] >= inOpen[i-1] ? 1 : -1 ) == -1 &&
            ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) <= ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) != 0.0? BodyShortPeriodTotal / (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( (((inOpen[i-1]) < (inClose[i-1])) ? (inOpen[i-1]) : (inClose[i-1])) > (((inOpen[i-2]) > (inClose[i-2])) ? (inOpen[i-2]) : (inClose[i-2])) ) &&
            ( inClose[i] >= inOpen[i] ? 1 : -1 ) == -1 &&
            inOpen[i] > inOpen[i-1] && inClose[i] < inClose[i-1] &&
            inClose[i] > inClose[i-2]
            )
            outInteger[outIdx++] = -100;
         else
            outInteger[outIdx++] = 0;
         BodyLongPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-2] - inLow[i-2] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-2] - ( inClose[i-2] >= inOpen[i-2] ? inClose[i-2] : inOpen[i-2] ) ) + ( ( inClose[i-2] >= inOpen[i-2] ? inOpen[i-2] : inClose[i-2] ) - inLow[i-2] ) : 0 ) ) ) - ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[BodyLongTrailingIdx] - inOpen[BodyLongTrailingIdx] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[BodyLongTrailingIdx] - inLow[BodyLongTrailingIdx] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[BodyLongTrailingIdx] - ( inClose[BodyLongTrailingIdx] >= inOpen[BodyLongTrailingIdx] ? inClose[BodyLongTrailingIdx] : inOpen[BodyLongTrailingIdx] ) ) + ( ( inClose[BodyLongTrailingIdx] >= inOpen[BodyLongTrailingIdx] ? inOpen[BodyLongTrailingIdx] : inClose[BodyLongTrailingIdx] ) - inLow[BodyLongTrailingIdx] ) : 0 ) ) ) ;
         BodyShortPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) - ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[BodyShortTrailingIdx] - inOpen[BodyShortTrailingIdx] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[BodyShortTrailingIdx] - inLow[BodyShortTrailingIdx] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[BodyShortTrailingIdx] - ( inClose[BodyShortTrailingIdx] >= inOpen[BodyShortTrailingIdx] ? inClose[BodyShortTrailingIdx] : inOpen[BodyShortTrailingIdx] ) ) + ( ( inClose[BodyShortTrailingIdx] >= inOpen[BodyShortTrailingIdx] ? inOpen[BodyShortTrailingIdx] : inClose[BodyShortTrailingIdx] ) - inLow[BodyShortTrailingIdx] ) : 0 ) ) ) ;
         i++;
         BodyLongTrailingIdx++;
         BodyShortTrailingIdx++;
      } while( i <= endIdx );
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   public int cdlUpsideGap2CrowsStateInit( struct TA_cdlUpsideGap2Crows_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct cdlUpsideGap2Crows ));
      _state.value .value .mem_index = 0;
      _state.value .value .mem_size = cdlUpsideGap2CrowsLookback ();
      if ( _state.value .value .mem_size > 0)
         _state.value .value .memory = TA_Calloc( _state.value .value .mem_size , sizeof(struct TA_CDLUPSIDEGAP2CROWS_Data));
      else
         _state.value .value .memory = NULL;
      return RetCode.Success ;
   }
   public int cdlUpsideGap2CrowsState( struct TA_cdlUpsideGap2Crows_State* _state,
      double inOpen,
      double inHigh,
      double inLow,
      double inClose,
      int *outInteger )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      size_t _cur_idx = _state.value .mem_index++;
      if ( _state.value .mem_size > 0) _cur_idx %= _state.value .mem_size ;
      if ( _state.value .mem_size > _state.value .mem_index - 1 ) {
         ( _state.value .memory+_cur_idx).value .inOpen = inOpen ;
         ( _state.value .memory+_cur_idx).value .inHigh = inHigh ;
         ( _state.value .memory+_cur_idx).value .inLow = inLow ;
         ( _state.value .memory+_cur_idx).value .inClose = inClose ;
         return RetCode.NeedMoreData ; }
      return RetCode.Success ;
   }
   public int cdlUpsideGap2CrowsStateFree( struct TA_cdlUpsideGap2Crows_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if ( _state.value != NULL) {
         if ( _state.value .value .memory != NULL) TA_Free( _state.value .value .memory );
         TA_Free( _state.value ); _state.value = NULL;}
      return RetCode.Success ;
   }
   public RetCode cdlUpsideGap2Crows( int startIdx,
      int endIdx,
      float inOpen[],
      float inHigh[],
      float inLow[],
      float inClose[],
      MInteger outBegIdx,
      MInteger outNBElement,
      int outInteger[] )
   {
      double BodyShortPeriodTotal, BodyLongPeriodTotal;
      int i, outIdx, BodyShortTrailingIdx, BodyLongTrailingIdx, lookbackTotal;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      lookbackTotal = cdlUpsideGap2CrowsLookback ();
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      BodyLongPeriodTotal = 0;
      BodyShortPeriodTotal = 0;
      BodyLongTrailingIdx = startIdx -2 - (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) ;
      BodyShortTrailingIdx = startIdx -1 - (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) ;
      i = BodyLongTrailingIdx;
      while( i < startIdx-2 ) {
         BodyLongPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      i = BodyShortTrailingIdx;
      while( i < startIdx-1 ) {
         BodyShortPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i] - inOpen[i] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i] - inLow[i] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i] - ( inClose[i] >= inOpen[i] ? inClose[i] : inOpen[i] ) ) + ( ( inClose[i] >= inOpen[i] ? inOpen[i] : inClose[i] ) - inLow[i] ) : 0 ) ) ) ;
         i++;
      }
      i = startIdx;
      outIdx = 0;
      do
      {
         if( ( inClose[i-2] >= inOpen[i-2] ? 1 : -1 ) == 1 &&
            ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) > ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) != 0.0? BodyLongPeriodTotal / (this.candleSettings[CandleSettingType.BodyLong.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-2] - inLow[i-2] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-2] - ( inClose[i-2] >= inOpen[i-2] ? inClose[i-2] : inOpen[i-2] ) ) + ( ( inClose[i-2] >= inOpen[i-2] ? inOpen[i-2] : inClose[i-2] ) - inLow[i-2] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( inClose[i-1] >= inOpen[i-1] ? 1 : -1 ) == -1 &&
            ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) <= ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].factor) * ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) != 0.0? BodyShortPeriodTotal / (this.candleSettings[CandleSettingType.BodyShort.ordinal()].avgPeriod) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) ) / ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? 2.0 : 1.0 ) ) &&
            ( (((inOpen[i-1]) < (inClose[i-1])) ? (inOpen[i-1]) : (inClose[i-1])) > (((inOpen[i-2]) > (inClose[i-2])) ? (inOpen[i-2]) : (inClose[i-2])) ) &&
            ( inClose[i] >= inOpen[i] ? 1 : -1 ) == -1 &&
            inOpen[i] > inOpen[i-1] && inClose[i] < inClose[i-1] &&
            inClose[i] > inClose[i-2]
            )
            outInteger[outIdx++] = -100;
         else
            outInteger[outIdx++] = 0;
         BodyLongPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-2] - inOpen[i-2] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-2] - inLow[i-2] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-2] - ( inClose[i-2] >= inOpen[i-2] ? inClose[i-2] : inOpen[i-2] ) ) + ( ( inClose[i-2] >= inOpen[i-2] ? inOpen[i-2] : inClose[i-2] ) - inLow[i-2] ) : 0 ) ) ) - ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[BodyLongTrailingIdx] - inOpen[BodyLongTrailingIdx] ) ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[BodyLongTrailingIdx] - inLow[BodyLongTrailingIdx] ) : ( (this.candleSettings[CandleSettingType.BodyLong.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[BodyLongTrailingIdx] - ( inClose[BodyLongTrailingIdx] >= inOpen[BodyLongTrailingIdx] ? inClose[BodyLongTrailingIdx] : inOpen[BodyLongTrailingIdx] ) ) + ( ( inClose[BodyLongTrailingIdx] >= inOpen[BodyLongTrailingIdx] ? inOpen[BodyLongTrailingIdx] : inClose[BodyLongTrailingIdx] ) - inLow[BodyLongTrailingIdx] ) : 0 ) ) ) ;
         BodyShortPeriodTotal += ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[i-1] - inOpen[i-1] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[i-1] - inLow[i-1] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[i-1] - ( inClose[i-1] >= inOpen[i-1] ? inClose[i-1] : inOpen[i-1] ) ) + ( ( inClose[i-1] >= inOpen[i-1] ? inOpen[i-1] : inClose[i-1] ) - inLow[i-1] ) : 0 ) ) ) - ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.RealBody ? ( Math.abs ( inClose[BodyShortTrailingIdx] - inOpen[BodyShortTrailingIdx] ) ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.HighLow ? ( inHigh[BodyShortTrailingIdx] - inLow[BodyShortTrailingIdx] ) : ( (this.candleSettings[CandleSettingType.BodyShort.ordinal()].rangeType) == RangeType.Shadows ? ( inHigh[BodyShortTrailingIdx] - ( inClose[BodyShortTrailingIdx] >= inOpen[BodyShortTrailingIdx] ? inClose[BodyShortTrailingIdx] : inOpen[BodyShortTrailingIdx] ) ) + ( ( inClose[BodyShortTrailingIdx] >= inOpen[BodyShortTrailingIdx] ? inOpen[BodyShortTrailingIdx] : inClose[BodyShortTrailingIdx] ) - inLow[BodyShortTrailingIdx] ) : 0 ) ) ) ;
         i++;
         BodyLongTrailingIdx++;
         BodyShortTrailingIdx++;
      } while( i <= endIdx );
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   /* Generated */
   public int cdlXSideGap3MethodsLookback( )
   {
      return 2;
   }
   public RetCode cdlXSideGap3Methods( int startIdx,
      int endIdx,
      double inOpen[],
      double inHigh[],
      double inLow[],
      double inClose[],
      MInteger outBegIdx,
      MInteger outNBElement,
      int outInteger[] )
   {
      int i, outIdx, lookbackTotal;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      lookbackTotal = cdlXSideGap3MethodsLookback ();
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      i = startIdx;
      outIdx = 0;
      do
      {
         if( ( inClose[i-2] >= inOpen[i-2] ? 1 : -1 ) == ( inClose[i-1] >= inOpen[i-1] ? 1 : -1 ) &&
            ( inClose[i-1] >= inOpen[i-1] ? 1 : -1 ) == - ( inClose[i] >= inOpen[i] ? 1 : -1 ) &&
            inOpen[i] < (((inClose[i-1]) > (inOpen[i-1])) ? (inClose[i-1]) : (inOpen[i-1])) &&
            inOpen[i] > (((inClose[i-1]) < (inOpen[i-1])) ? (inClose[i-1]) : (inOpen[i-1])) &&
            inClose[i] < (((inClose[i-2]) > (inOpen[i-2])) ? (inClose[i-2]) : (inOpen[i-2])) &&
            inClose[i] > (((inClose[i-2]) < (inOpen[i-2])) ? (inClose[i-2]) : (inOpen[i-2])) &&
            ( (
            ( inClose[i-2] >= inOpen[i-2] ? 1 : -1 ) == 1 &&
            ( (((inOpen[i-1]) < (inClose[i-1])) ? (inOpen[i-1]) : (inClose[i-1])) > (((inOpen[i-2]) > (inClose[i-2])) ? (inOpen[i-2]) : (inClose[i-2])) )
            ) ||
            (
            ( inClose[i-2] >= inOpen[i-2] ? 1 : -1 ) == -1 &&
            ( (((inOpen[i-1]) > (inClose[i-1])) ? (inOpen[i-1]) : (inClose[i-1])) < (((inOpen[i-2]) < (inClose[i-2])) ? (inOpen[i-2]) : (inClose[i-2])) )
            )
            )
            )
            outInteger[outIdx++] = ( inClose[i-2] >= inOpen[i-2] ? 1 : -1 ) * 100;
         else
            outInteger[outIdx++] = 0;
         i++;
      } while( i <= endIdx );
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   public int cdlXSideGap3MethodsStateInit( struct TA_cdlXSideGap3Methods_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct cdlXSideGap3Methods ));
      _state.value .value .mem_index = 0;
      _state.value .value .mem_size = cdlXSideGap3MethodsLookback ();
      if ( _state.value .value .mem_size > 0)
         _state.value .value .memory = TA_Calloc( _state.value .value .mem_size , sizeof(struct TA_CDLXSIDEGAP3METHODS_Data));
      else
         _state.value .value .memory = NULL;
      return RetCode.Success ;
   }
   public int cdlXSideGap3MethodsState( struct TA_cdlXSideGap3Methods_State* _state,
      double inOpen,
      double inHigh,
      double inLow,
      double inClose,
      int *outInteger )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      size_t _cur_idx = _state.value .mem_index++;
      if ( _state.value .mem_size > 0) _cur_idx %= _state.value .mem_size ;
      if ( _state.value .mem_size > _state.value .mem_index - 1 ) {
         ( _state.value .memory+_cur_idx).value .inOpen = inOpen ;
         ( _state.value .memory+_cur_idx).value .inHigh = inHigh ;
         ( _state.value .memory+_cur_idx).value .inLow = inLow ;
         ( _state.value .memory+_cur_idx).value .inClose = inClose ;
         return RetCode.NeedMoreData ; }
      return RetCode.Success ;
   }
   public int cdlXSideGap3MethodsStateFree( struct TA_cdlXSideGap3Methods_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if ( _state.value != NULL) {
         if ( _state.value .value .memory != NULL) TA_Free( _state.value .value .memory );
         TA_Free( _state.value ); _state.value = NULL;}
      return RetCode.Success ;
   }
   public RetCode cdlXSideGap3Methods( int startIdx,
      int endIdx,
      float inOpen[],
      float inHigh[],
      float inLow[],
      float inClose[],
      MInteger outBegIdx,
      MInteger outNBElement,
      int outInteger[] )
   {
      int i, outIdx, lookbackTotal;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      lookbackTotal = cdlXSideGap3MethodsLookback ();
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      i = startIdx;
      outIdx = 0;
      do
      {
         if( ( inClose[i-2] >= inOpen[i-2] ? 1 : -1 ) == ( inClose[i-1] >= inOpen[i-1] ? 1 : -1 ) &&
            ( inClose[i-1] >= inOpen[i-1] ? 1 : -1 ) == - ( inClose[i] >= inOpen[i] ? 1 : -1 ) &&
            inOpen[i] < (((inClose[i-1]) > (inOpen[i-1])) ? (inClose[i-1]) : (inOpen[i-1])) &&
            inOpen[i] > (((inClose[i-1]) < (inOpen[i-1])) ? (inClose[i-1]) : (inOpen[i-1])) &&
            inClose[i] < (((inClose[i-2]) > (inOpen[i-2])) ? (inClose[i-2]) : (inOpen[i-2])) &&
            inClose[i] > (((inClose[i-2]) < (inOpen[i-2])) ? (inClose[i-2]) : (inOpen[i-2])) &&
            ( (
            ( inClose[i-2] >= inOpen[i-2] ? 1 : -1 ) == 1 &&
            ( (((inOpen[i-1]) < (inClose[i-1])) ? (inOpen[i-1]) : (inClose[i-1])) > (((inOpen[i-2]) > (inClose[i-2])) ? (inOpen[i-2]) : (inClose[i-2])) )
            ) ||
            (
            ( inClose[i-2] >= inOpen[i-2] ? 1 : -1 ) == -1 &&
            ( (((inOpen[i-1]) > (inClose[i-1])) ? (inOpen[i-1]) : (inClose[i-1])) < (((inOpen[i-2]) < (inClose[i-2])) ? (inOpen[i-2]) : (inClose[i-2])) )
            )
            )
            )
            outInteger[outIdx++] = ( inClose[i-2] >= inOpen[i-2] ? 1 : -1 ) * 100;
         else
            outInteger[outIdx++] = 0;
         i++;
      } while( i <= endIdx );
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   /* Generated */
   public int ceilLookback( )
   {
      return RetCode.Success ;
   }
   public RetCode ceil( int startIdx,
      int endIdx,
      double inReal[],
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      int outIdx;
      int i;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      for( i=startIdx, outIdx=0; i <= endIdx; i++, outIdx++ )
      {
         outReal[outIdx] = Math.ceil (inReal[i]);
      }
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   public int ceilStateInit( struct TA_ceil_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct ceil ));
      _state.value .value .mem_index = 0;
      _state.value .value .mem_size = ceilLookback ();
      if ( _state.value .value .mem_size > 0)
         _state.value .value .memory = TA_Calloc( _state.value .value .mem_size , sizeof(struct TA_CEIL_Data));
      else
         _state.value .value .memory = NULL;
      return RetCode.Success ;
   }
   public int ceilState( struct TA_ceil_State* _state,
      double inReal,
      double *outReal )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      size_t _cur_idx = _state.value .mem_index++;
      if ( _state.value .mem_size > 0) _cur_idx %= _state.value .mem_size ;
      if ( _state.value .mem_size > _state.value .mem_index - 1 ) {
         ( _state.value .memory+_cur_idx).value .inReal = inReal ;
         return RetCode.NeedMoreData ; }
      outReal.value = Math.ceil (inReal);
      return RetCode.Success ;
   }
   public int ceilStateFree( struct TA_ceil_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if ( _state.value != NULL) {
         if ( _state.value .value .memory != NULL) TA_Free( _state.value .value .memory );
         TA_Free( _state.value ); _state.value = NULL;}
      return RetCode.Success ;
   }
   public RetCode ceil( int startIdx,
      int endIdx,
      float inReal[],
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      int outIdx;
      int i;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      for( i=startIdx, outIdx=0; i <= endIdx; i++, outIdx++ )
      {
         outReal[outIdx] = Math.ceil (inReal[i]);
      }
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   /* Generated */
   public int cmoLookback( int optInTimePeriod )
   {
      int retValue;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 14;
      else if( ((int)optInTimePeriod < 2) || ((int)optInTimePeriod > 100000) )
         return -1;
      retValue = optInTimePeriod + (this.unstablePeriod[FuncUnstId.Cmo.ordinal()]) ;
      if( (this.compatibility) == Compatibility.Metastock )
         retValue--;
      return retValue;
   }
   public RetCode cmo( int startIdx,
      int endIdx,
      double inReal[],
      int optInTimePeriod,
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      int outIdx;
      int today, lookbackTotal, unstablePeriod, i;
      double prevGain, prevLoss, prevValue, savePrevValue;
      double tempValue1, tempValue2, tempValue3, tempValue4;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 14;
      else if( ((int)optInTimePeriod < 2) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      outBegIdx.value = 0 ;
      outNBElement.value = 0 ;
      lookbackTotal = cmoLookback ( optInTimePeriod );
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
         return RetCode.Success ;
      outIdx = 0;
      if( optInTimePeriod == 1 )
      {
         outBegIdx.value = startIdx;
         i = (endIdx-startIdx)+1;
         outNBElement.value = i;
         System.arraycopy(inReal,startIdx,outReal,0,i) ;
         return RetCode.Success ;
      }
      today = startIdx-lookbackTotal;
      prevValue = inReal[today];
      unstablePeriod = (this.unstablePeriod[FuncUnstId.Cmo.ordinal()]) ;
      if( (unstablePeriod == 0) &&
         ( (this.compatibility) == Compatibility.Metastock ))
      {
         savePrevValue = prevValue;
         prevGain = 0.0;
         prevLoss = 0.0;
         for( i=optInTimePeriod; i > 0; i-- )
         {
            tempValue1 = inReal[today++];
            tempValue2 = tempValue1 - prevValue;
            prevValue = tempValue1;
            if( tempValue2 < 0 )
               prevLoss -= tempValue2;
            else
               prevGain += tempValue2;
         }
         tempValue1 = prevLoss/optInTimePeriod;
         tempValue2 = prevGain/optInTimePeriod;
         tempValue3 = tempValue2-tempValue1;
         tempValue4 = tempValue1+tempValue2;
         if( ! (((- (0.00000000000001) )<tempValue4)&&(tempValue4< (0.00000000000001) )) )
            outReal[outIdx++] = 100*(tempValue3/tempValue4);
         else
            outReal[outIdx++] = 0.0;
         if( today > endIdx )
         {
            outBegIdx.value = startIdx;
            outNBElement.value = outIdx;
            return RetCode.Success ;
         }
         today -= optInTimePeriod;
         prevValue = savePrevValue;
      }
      prevGain = 0.0;
      prevLoss = 0.0;
      today++;
      for( i=optInTimePeriod; i > 0; i-- )
      {
         tempValue1 = inReal[today++];
         tempValue2 = tempValue1 - prevValue;
         prevValue = tempValue1;
         if( tempValue2 < 0 )
            prevLoss -= tempValue2;
         else
            prevGain += tempValue2;
      }
      prevLoss /= optInTimePeriod;
      prevGain /= optInTimePeriod;
      if( today > startIdx )
      {
         tempValue1 = prevGain+prevLoss;
         if( ! (((- (0.00000000000001) )<tempValue1)&&(tempValue1< (0.00000000000001) )) )
            outReal[outIdx++] = 100.0*((prevGain-prevLoss)/tempValue1);
         else
            outReal[outIdx++] = 0.0;
      }
      else
      {
         while( today < startIdx )
         {
            tempValue1 = inReal[today];
            tempValue2 = tempValue1 - prevValue;
            prevValue = tempValue1;
            prevLoss *= (optInTimePeriod-1);
            prevGain *= (optInTimePeriod-1);
            if( tempValue2 < 0 )
               prevLoss -= tempValue2;
            else
               prevGain += tempValue2;
            prevLoss /= optInTimePeriod;
            prevGain /= optInTimePeriod;
            today++;
         }
      }
      while( today <= endIdx )
      {
         tempValue1 = inReal[today++];
         tempValue2 = tempValue1 - prevValue;
         prevValue = tempValue1;
         prevLoss *= (optInTimePeriod-1);
         prevGain *= (optInTimePeriod-1);
         if( tempValue2 < 0 )
            prevLoss -= tempValue2;
         else
            prevGain += tempValue2;
         prevLoss /= optInTimePeriod;
         prevGain /= optInTimePeriod;
         tempValue1 = prevGain+prevLoss;
         if( ! (((- (0.00000000000001) )<tempValue1)&&(tempValue1< (0.00000000000001) )) )
            outReal[outIdx++] = 100.0*((prevGain-prevLoss)/tempValue1);
         else
            outReal[outIdx++] = 0.0;
      }
      outBegIdx.value = startIdx;
      outNBElement.value = outIdx;
      return RetCode.Success ;
   }
   public int cmoStateInit( struct TA_cmo_State** _state,
      int optInTimePeriod )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 14;
      else if( ((int)optInTimePeriod < 2) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct cmo ));
      _state.value .value .mem_index = 0;
      _state.value .value .optInTimePeriod = optInTimePeriod;
      _state.value .value .mem_size = cmoLookback (optInTimePeriod );
      if ( _state.value .value .mem_size > 0)
         _state.value .value .memory = TA_Calloc( _state.value .value .mem_size , sizeof(struct TA_CMO_Data));
      else
         _state.value .value .memory = NULL;
      return RetCode.Success ;
   }
   public int cmoState( struct TA_cmo_State* _state,
      double inReal,
      double *outReal )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      size_t _cur_idx = _state.value .mem_index++;
      if ( _state.value .mem_size > 0) _cur_idx %= _state.value .mem_size ;
      if ( _state.value .mem_size > _state.value .mem_index - 1 ) {
         ( _state.value .memory+_cur_idx).value .inReal = inReal ;
         return RetCode.NeedMoreData ; }
      return RetCode.Success ;
   }
   public int cmoStateFree( struct TA_cmo_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if ( _state.value != NULL) {
         if ( _state.value .value .memory != NULL) TA_Free( _state.value .value .memory );
         TA_Free( _state.value ); _state.value = NULL;}
      return RetCode.Success ;
   }
   public RetCode cmo( int startIdx,
      int endIdx,
      float inReal[],
      int optInTimePeriod,
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      int outIdx;
      int today, lookbackTotal, unstablePeriod, i;
      double prevGain, prevLoss, prevValue, savePrevValue;
      double tempValue1, tempValue2, tempValue3, tempValue4;
      int mmmixi, mmmixdestIdx, mmmixsrcIdx ;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 14;
      else if( ((int)optInTimePeriod < 2) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      outBegIdx.value = 0 ;
      outNBElement.value = 0 ;
      lookbackTotal = cmoLookback ( optInTimePeriod );
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
         return RetCode.Success ;
      outIdx = 0;
      if( optInTimePeriod == 1 )
      {
         outBegIdx.value = startIdx;
         i = (endIdx-startIdx)+1;
         outNBElement.value = i;
         { for( mmmixi=0, mmmixdestIdx=0, mmmixsrcIdx=startIdx; mmmixi < i; mmmixi++, mmmixdestIdx++, mmmixsrcIdx++ ) { outReal[mmmixdestIdx] = inReal[mmmixsrcIdx]; } } ;
         return RetCode.Success ;
      }
      today = startIdx-lookbackTotal;
      prevValue = inReal[today];
      unstablePeriod = (this.unstablePeriod[FuncUnstId.Cmo.ordinal()]) ;
      if( (unstablePeriod == 0) &&
         ( (this.compatibility) == Compatibility.Metastock ))
      {
         savePrevValue = prevValue;
         prevGain = 0.0;
         prevLoss = 0.0;
         for( i=optInTimePeriod; i > 0; i-- )
         {
            tempValue1 = inReal[today++];
            tempValue2 = tempValue1 - prevValue;
            prevValue = tempValue1;
            if( tempValue2 < 0 )
               prevLoss -= tempValue2;
            else
               prevGain += tempValue2;
         }
         tempValue1 = prevLoss/optInTimePeriod;
         tempValue2 = prevGain/optInTimePeriod;
         tempValue3 = tempValue2-tempValue1;
         tempValue4 = tempValue1+tempValue2;
         if( ! (((- (0.00000000000001) )<tempValue4)&&(tempValue4< (0.00000000000001) )) )
            outReal[outIdx++] = 100*(tempValue3/tempValue4);
         else
            outReal[outIdx++] = 0.0;
         if( today > endIdx )
         {
            outBegIdx.value = startIdx;
            outNBElement.value = outIdx;
            return RetCode.Success ;
         }
         today -= optInTimePeriod;
         prevValue = savePrevValue;
      }
      prevGain = 0.0;
      prevLoss = 0.0;
      today++;
      for( i=optInTimePeriod; i > 0; i-- )
      {
         tempValue1 = inReal[today++];
         tempValue2 = tempValue1 - prevValue;
         prevValue = tempValue1;
         if( tempValue2 < 0 )
            prevLoss -= tempValue2;
         else
            prevGain += tempValue2;
      }
      prevLoss /= optInTimePeriod;
      prevGain /= optInTimePeriod;
      if( today > startIdx )
      {
         tempValue1 = prevGain+prevLoss;
         if( ! (((- (0.00000000000001) )<tempValue1)&&(tempValue1< (0.00000000000001) )) )
            outReal[outIdx++] = 100.0*((prevGain-prevLoss)/tempValue1);
         else
            outReal[outIdx++] = 0.0;
      }
      else
      {
         while( today < startIdx )
         {
            tempValue1 = inReal[today];
            tempValue2 = tempValue1 - prevValue;
            prevValue = tempValue1;
            prevLoss *= (optInTimePeriod-1);
            prevGain *= (optInTimePeriod-1);
            if( tempValue2 < 0 )
               prevLoss -= tempValue2;
            else
               prevGain += tempValue2;
            prevLoss /= optInTimePeriod;
            prevGain /= optInTimePeriod;
            today++;
         }
      }
      while( today <= endIdx )
      {
         tempValue1 = inReal[today++];
         tempValue2 = tempValue1 - prevValue;
         prevValue = tempValue1;
         prevLoss *= (optInTimePeriod-1);
         prevGain *= (optInTimePeriod-1);
         if( tempValue2 < 0 )
            prevLoss -= tempValue2;
         else
            prevGain += tempValue2;
         prevLoss /= optInTimePeriod;
         prevGain /= optInTimePeriod;
         tempValue1 = prevGain+prevLoss;
         if( ! (((- (0.00000000000001) )<tempValue1)&&(tempValue1< (0.00000000000001) )) )
            outReal[outIdx++] = 100.0*((prevGain-prevLoss)/tempValue1);
         else
            outReal[outIdx++] = 0.0;
      }
      outBegIdx.value = startIdx;
      outNBElement.value = outIdx;
      return RetCode.Success ;
   }
   /* Generated */
   public int correlLookback( int optInTimePeriod )
   {
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 30;
      else if( ((int)optInTimePeriod < 1) || ((int)optInTimePeriod > 100000) )
         return -1;
      return optInTimePeriod-1;
   }
   public RetCode correl( int startIdx,
      int endIdx,
      double inReal0[],
      double inReal1[],
      int optInTimePeriod,
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      double sumXY, sumX, sumY, sumX2, sumY2, x, y, trailingX, trailingY;
      double tempReal;
      int lookbackTotal, today, trailingIdx, outIdx;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 30;
      else if( ((int)optInTimePeriod < 1) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      lookbackTotal = optInTimePeriod-1;
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      outBegIdx.value = startIdx;
      trailingIdx = startIdx - lookbackTotal;
      sumXY = sumX = sumY = sumX2 = sumY2 = 0.0;
      for( today=trailingIdx; today <= startIdx; today++ )
      {
         x = inReal0[today];
         sumX += x;
         sumX2 += x*x;
         y = inReal1[today];
         sumXY += x*y;
         sumY += y;
         sumY2 += y*y;
      }
      trailingX = inReal0[trailingIdx];
      trailingY = inReal1[trailingIdx++];
      tempReal = (sumX2-((sumX*sumX)/optInTimePeriod)) * (sumY2-((sumY*sumY)/optInTimePeriod));
      if( ! (tempReal< (0.00000000000001) ) )
         outReal[0] = (sumXY-((sumX*sumY)/optInTimePeriod)) / Math.sqrt (tempReal);
      else
         outReal[0] = 0.0;
      outIdx = 1;
      while( today <= endIdx )
      {
         sumX -= trailingX;
         sumX2 -= trailingX*trailingX;
         sumXY -= trailingX*trailingY;
         sumY -= trailingY;
         sumY2 -= trailingY*trailingY;
         x = inReal0[today];
         sumX += x;
         sumX2 += x*x;
         y = inReal1[today++];
         sumXY += x*y;
         sumY += y;
         sumY2 += y*y;
         trailingX = inReal0[trailingIdx];
         trailingY = inReal1[trailingIdx++];
         tempReal = (sumX2-((sumX*sumX)/optInTimePeriod)) * (sumY2-((sumY*sumY)/optInTimePeriod));
         if( ! (tempReal< (0.00000000000001) ) )
            outReal[outIdx++] = (sumXY-((sumX*sumY)/optInTimePeriod)) / Math.sqrt (tempReal);
         else
            outReal[outIdx++] = 0.0;
      }
      outNBElement.value = outIdx;
      return RetCode.Success ;
   }
   public int correlStateInit( struct TA_correl_State** _state,
      int optInTimePeriod )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 30;
      else if( ((int)optInTimePeriod < 1) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct correl ));
      _state.value .value .mem_index = 0;
      _state.value .value .optInTimePeriod = optInTimePeriod;
      _state.value .value .mem_size = correlLookback (optInTimePeriod );
      if ( _state.value .value .mem_size > 0)
         _state.value .value .memory = TA_Calloc( _state.value .value .mem_size , sizeof(struct TA_CORREL_Data));
      else
         _state.value .value .memory = NULL;
      return RetCode.Success ;
   }
   public int correlState( struct TA_correl_State* _state,
      double inReal0,
      double inReal1,
      double *outReal )
   {
      double x,y, tempReal;
      if (_state == NULL)
         return RetCode.BadParam ;
      size_t _cur_idx = _state.value .mem_index++;
      if ( _state.value .mem_size > 0) _cur_idx %= _state.value .mem_size ;
      if ( ( _state.value .mem_index == 1) )
      {
         _state.value .sumXY = 0.0;
         _state.value .sumX = 0.0;
         _state.value .sumY = 0.0;
         _state.value .sumX2 = 0.0;
         _state.value .sumY2 = 0.0;
      }
      if ( _state.value .mem_size > _state.value .mem_index - 1 )
      {
         { _state.value .sumX += 1*inReal0; _state.value .sumX2 += 1*inReal0*inReal0; _state.value .sumXY += 1*inReal0*inReal1; _state.value .sumY += 1*inReal1; _state.value .sumY2 += 1*inReal1*inReal1; }
         ( _state.value .memory+_cur_idx).value .inReal0 = inReal0 ;
         ( _state.value .memory+_cur_idx).value .inReal1 = inReal1 ;
         return RetCode.NeedMoreData ;
      }
      tempReal = ( _state.value .sumX2-(( _state.value .sumX* _state.value .sumX)/ _state.value .optInTimePeriod)) * ( _state.value .sumY2-(( _state.value .sumY* _state.value .sumY)/ _state.value .optInTimePeriod));
      if( ! (tempReal< (0.00000000000001) ) )
         outReal.value = ( _state.value .sumXY-(( _state.value .sumX* _state.value .sumY)/ _state.value .optInTimePeriod)) / Math.sqrt (tempReal);
      else
         outReal.value = 0.0;
      x= ( _state.value .memory+_cur_idx).value .inReal0 ;
      y= ( _state.value .memory+_cur_idx).value .inReal1 ;
      { _state.value .sumX += -1*x; _state.value .sumX2 += -1*x*x; _state.value .sumXY += -1*x*y; _state.value .sumY += -1*y; _state.value .sumY2 += -1*y*y; }
      ( _state.value .memory+_cur_idx).value .inReal0 = inReal0 ;
      ( _state.value .memory+_cur_idx).value .inReal1 = inReal1 ;
      return RetCode.Success ;
   }
   public int correlStateFree( struct TA_correl_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if ( _state.value != NULL) {
         if ( _state.value .value .memory != NULL) TA_Free( _state.value .value .memory );
         TA_Free( _state.value ); _state.value = NULL;}
      return RetCode.Success ;
   }
   public RetCode correl( int startIdx,
      int endIdx,
      float inReal0[],
      float inReal1[],
      int optInTimePeriod,
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      double sumXY, sumX, sumY, sumX2, sumY2, x, y, trailingX, trailingY;
      double tempReal;
      int lookbackTotal, today, trailingIdx, outIdx;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 30;
      else if( ((int)optInTimePeriod < 1) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      lookbackTotal = optInTimePeriod-1;
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      outBegIdx.value = startIdx;
      trailingIdx = startIdx - lookbackTotal;
      sumXY = sumX = sumY = sumX2 = sumY2 = 0.0;
      for( today=trailingIdx; today <= startIdx; today++ )
      {
         x = inReal0[today];
         sumX += x;
         sumX2 += x*x;
         y = inReal1[today];
         sumXY += x*y;
         sumY += y;
         sumY2 += y*y;
      }
      trailingX = inReal0[trailingIdx];
      trailingY = inReal1[trailingIdx++];
      tempReal = (sumX2-((sumX*sumX)/optInTimePeriod)) * (sumY2-((sumY*sumY)/optInTimePeriod));
      if( ! (tempReal< (0.00000000000001) ) )
         outReal[0] = (sumXY-((sumX*sumY)/optInTimePeriod)) / Math.sqrt (tempReal);
      else
         outReal[0] = 0.0;
      outIdx = 1;
      while( today <= endIdx )
      {
         sumX -= trailingX;
         sumX2 -= trailingX*trailingX;
         sumXY -= trailingX*trailingY;
         sumY -= trailingY;
         sumY2 -= trailingY*trailingY;
         x = inReal0[today];
         sumX += x;
         sumX2 += x*x;
         y = inReal1[today++];
         sumXY += x*y;
         sumY += y;
         sumY2 += y*y;
         trailingX = inReal0[trailingIdx];
         trailingY = inReal1[trailingIdx++];
         tempReal = (sumX2-((sumX*sumX)/optInTimePeriod)) * (sumY2-((sumY*sumY)/optInTimePeriod));
         if( ! (tempReal< (0.00000000000001) ) )
            outReal[outIdx++] = (sumXY-((sumX*sumY)/optInTimePeriod)) / Math.sqrt (tempReal);
         else
            outReal[outIdx++] = 0.0;
      }
      outNBElement.value = outIdx;
      return RetCode.Success ;
   }
   /* Generated */
   public int cosLookback( )
   {
      return RetCode.Success ;
   }
   public RetCode cos( int startIdx,
      int endIdx,
      double inReal[],
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      int outIdx;
      int i;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      for( i=startIdx, outIdx=0; i <= endIdx; i++, outIdx++ )
      {
         outReal[outIdx] = Math.cos (inReal[i]);
      }
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   public int cosStateInit( struct TA_cos_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct cos ));
      _state.value .value .mem_index = 0;
      _state.value .value .mem_size = cosLookback ();
      if ( _state.value .value .mem_size > 0)
         _state.value .value .memory = TA_Calloc( _state.value .value .mem_size , sizeof(struct TA_COS_Data));
      else
         _state.value .value .memory = NULL;
      return RetCode.Success ;
   }
   public int cosState( struct TA_cos_State* _state,
      double inReal,
      double *outReal )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      size_t _cur_idx = _state.value .mem_index++;
      if ( _state.value .mem_size > 0) _cur_idx %= _state.value .mem_size ;
      if ( _state.value .mem_size > _state.value .mem_index - 1 ) {
         ( _state.value .memory+_cur_idx).value .inReal = inReal ;
         return RetCode.NeedMoreData ; }
      outReal.value = Math.cos (inReal);
      return RetCode.Success ;
   }
   public int cosStateFree( struct TA_cos_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if ( _state.value != NULL) {
         if ( _state.value .value .memory != NULL) TA_Free( _state.value .value .memory );
         TA_Free( _state.value ); _state.value = NULL;}
      return RetCode.Success ;
   }
   public RetCode cos( int startIdx,
      int endIdx,
      float inReal[],
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      int outIdx;
      int i;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      for( i=startIdx, outIdx=0; i <= endIdx; i++, outIdx++ )
      {
         outReal[outIdx] = Math.cos (inReal[i]);
      }
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   /* Generated */
   public int coshLookback( )
   {
      return RetCode.Success ;
   }
   public RetCode cosh( int startIdx,
      int endIdx,
      double inReal[],
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      int outIdx;
      int i;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      for( i=startIdx, outIdx=0; i <= endIdx; i++, outIdx++ )
      {
         outReal[outIdx] = Math.cosh (inReal[i]);
      }
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   public int coshStateInit( struct TA_cosh_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct cosh ));
      _state.value .value .mem_index = 0;
      _state.value .value .mem_size = coshLookback ();
      if ( _state.value .value .mem_size > 0)
         _state.value .value .memory = TA_Calloc( _state.value .value .mem_size , sizeof(struct TA_COSH_Data));
      else
         _state.value .value .memory = NULL;
      return RetCode.Success ;
   }
   public int coshState( struct TA_cosh_State* _state,
      double inReal,
      double *outReal )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      size_t _cur_idx = _state.value .mem_index++;
      if ( _state.value .mem_size > 0) _cur_idx %= _state.value .mem_size ;
      if ( _state.value .mem_size > _state.value .mem_index - 1 ) {
         ( _state.value .memory+_cur_idx).value .inReal = inReal ;
         return RetCode.NeedMoreData ; }
      outReal.value = Math.cosh (inReal);
      return RetCode.Success ;
   }
   public int coshStateFree( struct TA_cosh_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if ( _state.value != NULL) {
         if ( _state.value .value .memory != NULL) TA_Free( _state.value .value .memory );
         TA_Free( _state.value ); _state.value = NULL;}
      return RetCode.Success ;
   }
   public RetCode cosh( int startIdx,
      int endIdx,
      float inReal[],
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      int outIdx;
      int i;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      for( i=startIdx, outIdx=0; i <= endIdx; i++, outIdx++ )
      {
         outReal[outIdx] = Math.cosh (inReal[i]);
      }
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   /* Generated */
   public int demaLookback( int optInTimePeriod )
   {
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 30;
      else if( ((int)optInTimePeriod < 2) || ((int)optInTimePeriod > 100000) )
         return -1;
      return emaLookback ( optInTimePeriod ) * 2;
   }
   public RetCode dema( int startIdx,
      int endIdx,
      double inReal[],
      int optInTimePeriod,
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      double []firstEMA ;
      double []secondEMA ;
      double k;
      MInteger firstEMABegIdx = new MInteger() ;
      MInteger firstEMANbElement = new MInteger() ;
      MInteger secondEMABegIdx = new MInteger() ;
      MInteger secondEMANbElement = new MInteger() ;
      int tempInt, outIdx, firstEMAIdx, lookbackTotal, lookbackEMA;
      RetCode retCode;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 30;
      else if( ((int)optInTimePeriod < 2) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      outNBElement.value = 0 ;
      outBegIdx.value = 0 ;
      lookbackEMA = emaLookback ( optInTimePeriod );
      lookbackTotal = lookbackEMA * 2;
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
         return RetCode.Success ;
      if( inReal == outReal )
         firstEMA = outReal;
      else
      {
         tempInt = lookbackTotal+(endIdx-startIdx)+1;
         firstEMA = new double[tempInt] ;
      }
      k = ((double)2.0 / ((double)(optInTimePeriod + 1))) ;
      retCode = TA_INT_EMA ( startIdx-lookbackEMA, endIdx, inReal,
         optInTimePeriod, k,
         firstEMABegIdx , firstEMANbElement ,
         firstEMA );
      if( (retCode != RetCode.Success ) || ( firstEMANbElement.value == 0) )
      {
         return retCode;
      }
      secondEMA = new double[firstEMANbElement.value ] ;
      retCode = TA_INT_EMA ( 0, firstEMANbElement.value -1, firstEMA,
         optInTimePeriod, k,
         secondEMABegIdx , secondEMANbElement ,
         secondEMA );
      if( (retCode != RetCode.Success ) || ( secondEMANbElement.value == 0) )
      {
         return retCode;
      }
      firstEMAIdx = secondEMABegIdx.value ;
      outIdx = 0;
      while( outIdx < secondEMANbElement.value )
      {
         outReal[outIdx] = (2.0*firstEMA[firstEMAIdx++]) - secondEMA[outIdx];
         outIdx++;
      }
      outBegIdx.value = firstEMABegIdx.value + secondEMABegIdx.value ;
      outNBElement.value = outIdx;
      return RetCode.Success ;
   }
   public int demaStateInit( struct TA_dema_State** _state,
      int optInTimePeriod )
   {
      int res;
      if (_state == NULL)
         return RetCode.BadParam ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 30;
      else if( ((int)optInTimePeriod < 2) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct dema ));
      _state.value .value .mem_index = 0;
      _state.value .value .optInTimePeriod = optInTimePeriod;
      _state.value .value .mem_size = demaLookback (optInTimePeriod );
      _state.value .value .memory = NULL;
      res = ema ((struct ema **)& _state.value .value .state_EMA, optInTimePeriod);
      if (res == RetCode.Success )
      {
         res = ema ((struct ema **)& _state.value .value .state_EMA2, optInTimePeriod);
      }
      return res;
   }
   public int demaState( struct TA_dema_State* _state,
      double inReal,
      double *outReal )
   {
      double ema, ema2;
      int retCode;
      if (_state == NULL)
         return RetCode.BadParam ;
      size_t _cur_idx = _state.value .mem_index++;
      if ( _state.value .mem_size > 0) _cur_idx %= _state.value .mem_size ;
      retCode = ema ( _state.value .state_EMA, inReal, &ema );
      if( retCode != RetCode.Success )
         return retCode;
      retCode = ema ( _state.value .state_EMA2, ema, &ema2 );
      if( retCode != RetCode.Success )
         return retCode;
      outReal.value = (2.0*ema) - ema2;
      return RetCode.Success ;
   }
   public int demaStateFree( struct TA_dema_State** _state )
   {
      int res = ema ((struct ema **)& _state.value .value .state_EMA);
      if (res == RetCode.Success )
      {
         res = ema ((struct ema **)& _state.value .value .state_EMA2);
      }
      if (_state == NULL)
         return RetCode.BadParam ;
      if ( _state.value != NULL) {
         if ( _state.value .value .memory != NULL) TA_Free( _state.value .value .memory );
         TA_Free( _state.value ); _state.value = NULL;}
      return res;
   }
   public RetCode dema( int startIdx,
      int endIdx,
      float inReal[],
      int optInTimePeriod,
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      double []firstEMA ;
      double []secondEMA ;
      double k;
      MInteger firstEMABegIdx = new MInteger() ;
      MInteger firstEMANbElement = new MInteger() ;
      MInteger secondEMABegIdx = new MInteger() ;
      MInteger secondEMANbElement = new MInteger() ;
      int tempInt, outIdx, firstEMAIdx, lookbackTotal, lookbackEMA;
      RetCode retCode;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 30;
      else if( ((int)optInTimePeriod < 2) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      outNBElement.value = 0 ;
      outBegIdx.value = 0 ;
      lookbackEMA = emaLookback ( optInTimePeriod );
      lookbackTotal = lookbackEMA * 2;
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
         return RetCode.Success ;
      tempInt = lookbackTotal+(endIdx-startIdx)+1;
      firstEMA = new double[tempInt] ;
      k = ((double)2.0 / ((double)(optInTimePeriod + 1))) ;
      retCode = TA_INT_EMA ( startIdx-lookbackEMA, endIdx, inReal,
         optInTimePeriod, k,
         firstEMABegIdx , firstEMANbElement ,
         firstEMA );
      if( (retCode != RetCode.Success ) || ( firstEMANbElement.value == 0) )
      {
         return retCode;
      }
      secondEMA = new double[firstEMANbElement.value ] ;
      retCode = TA_INT_EMA ( 0, firstEMANbElement.value -1, firstEMA,
         optInTimePeriod, k,
         secondEMABegIdx , secondEMANbElement ,
         secondEMA );
      if( (retCode != RetCode.Success ) || ( secondEMANbElement.value == 0) )
      {
         return retCode;
      }
      firstEMAIdx = secondEMABegIdx.value ;
      outIdx = 0;
      while( outIdx < secondEMANbElement.value )
      {
         outReal[outIdx] = (2.0*firstEMA[firstEMAIdx++]) - secondEMA[outIdx];
         outIdx++;
      }
      outBegIdx.value = firstEMABegIdx.value + secondEMABegIdx.value ;
      outNBElement.value = outIdx;
      return RetCode.Success ;
   }
   /* Generated */
   public int divLookback( )
   {
      return RetCode.Success ;
   }
   public RetCode div( int startIdx,
      int endIdx,
      double inReal0[],
      double inReal1[],
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      int outIdx;
      int i;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      for( i=startIdx, outIdx=0; i <= endIdx; i++, outIdx++ )
      {
         outReal[outIdx] = inReal0[i]/inReal1[i];
      }
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   public int divStateInit( struct TA_div_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct div ));
      _state.value .value .mem_index = 0;
      _state.value .value .mem_size = divLookback ();
      if ( _state.value .value .mem_size > 0)
         _state.value .value .memory = TA_Calloc( _state.value .value .mem_size , sizeof(struct TA_DIV_Data));
      else
         _state.value .value .memory = NULL;
      return RetCode.Success ;
   }
   public int divState( struct TA_div_State* _state,
      double inReal0,
      double inReal1,
      double *outReal )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      size_t _cur_idx = _state.value .mem_index++;
      if ( _state.value .mem_size > 0) _cur_idx %= _state.value .mem_size ;
      if ( _state.value .mem_size > _state.value .mem_index - 1 ) {
         ( _state.value .memory+_cur_idx).value .inReal0 = inReal0 ;
         ( _state.value .memory+_cur_idx).value .inReal1 = inReal1 ;
         return RetCode.NeedMoreData ; }
      outReal.value = inReal0 / inReal1;
      return RetCode.Success ;
   }
   public int divStateFree( struct TA_div_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if ( _state.value != NULL) {
         if ( _state.value .value .memory != NULL) TA_Free( _state.value .value .memory );
         TA_Free( _state.value ); _state.value = NULL;}
      return RetCode.Success ;
   }
   public RetCode div( int startIdx,
      int endIdx,
      float inReal0[],
      float inReal1[],
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      int outIdx;
      int i;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      for( i=startIdx, outIdx=0; i <= endIdx; i++, outIdx++ )
      {
         outReal[outIdx] = inReal0[i]/inReal1[i];
      }
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   /* Generated */
   public int dxLookback( int optInTimePeriod )
   {
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 14;
      else if( ((int)optInTimePeriod < 2) || ((int)optInTimePeriod > 100000) )
         return -1;
      if( optInTimePeriod > 1 )
         return optInTimePeriod + (this.unstablePeriod[FuncUnstId.Dx.ordinal()]) ;
      else
         return 2;
   }
   public RetCode dx( int startIdx,
      int endIdx,
      double inHigh[],
      double inLow[],
      double inClose[],
      int optInTimePeriod,
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      int today, lookbackTotal, outIdx;
      double prevHigh, prevLow, prevClose;
      double prevMinusDM, prevPlusDM, prevTR;
      double tempReal, tempReal2, diffP, diffM;
      double minusDI, plusDI;
      int i;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 14;
      else if( ((int)optInTimePeriod < 2) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      if( optInTimePeriod > 1 )
         lookbackTotal = optInTimePeriod + (this.unstablePeriod[FuncUnstId.Dx.ordinal()]) ;
      else
         lookbackTotal = 2;
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      outIdx = 0;
      outBegIdx.value = today = startIdx;
      prevMinusDM = 0.0;
      prevPlusDM = 0.0;
      prevTR = 0.0;
      today = startIdx - lookbackTotal;
      prevHigh = inHigh[today];
      prevLow = inLow[today];
      prevClose = inClose[today];
      i = optInTimePeriod-1;
      while( i-- > 0 )
      {
         today++;
         tempReal = inHigh[today];
         diffP = tempReal-prevHigh;
         prevHigh = tempReal;
         tempReal = inLow[today];
         diffM = prevLow-tempReal;
         prevLow = tempReal;
         if( (diffM > 0) && (diffP < diffM) )
         {
            prevMinusDM += diffM;
         }
         else if( (diffP > 0) && (diffP > diffM) )
         {
            prevPlusDM += diffP;
         }
         { tempReal = prevHigh-prevLow; tempReal2 = Math.abs (prevHigh-prevClose); if( tempReal2 > tempReal ) tempReal = tempReal2; tempReal2 = Math.abs (prevLow-prevClose); if( tempReal2 > tempReal ) tempReal = tempReal2; } ;
         prevTR += tempReal;
         prevClose = inClose[today];
      }
      i = (this.unstablePeriod[FuncUnstId.Dx.ordinal()]) + 1;
      while( i-- != 0 )
      {
         today++;
         tempReal = inHigh[today];
         diffP = tempReal-prevHigh;
         prevHigh = tempReal;
         tempReal = inLow[today];
         diffM = prevLow-tempReal;
         prevLow = tempReal;
         prevMinusDM -= prevMinusDM/optInTimePeriod;
         prevPlusDM -= prevPlusDM/optInTimePeriod;
         if( (diffM > 0) && (diffP < diffM) )
         {
            prevMinusDM += diffM;
         }
         else if( (diffP > 0) && (diffP > diffM) )
         {
            prevPlusDM += diffP;
         }
         { tempReal = prevHigh-prevLow; tempReal2 = Math.abs (prevHigh-prevClose); if( tempReal2 > tempReal ) tempReal = tempReal2; tempReal2 = Math.abs (prevLow-prevClose); if( tempReal2 > tempReal ) tempReal = tempReal2; } ;
         prevTR = prevTR - (prevTR/optInTimePeriod) + tempReal;
         prevClose = inClose[today];
      }
      if( ! (((- (0.00000000000001) )<prevTR)&&(prevTR< (0.00000000000001) )) )
      {
         minusDI = (100.0*(prevMinusDM/prevTR)) ;
         plusDI = (100.0*(prevPlusDM/prevTR)) ;
         tempReal = minusDI+plusDI;
         if( ! (((- (0.00000000000001) )<tempReal)&&(tempReal< (0.00000000000001) )) )
            outReal[0] = (100.0 * ( Math.abs (minusDI-plusDI)/tempReal)) ;
         else
            outReal[0] = 0.0;
      }
      else
         outReal[0] = 0.0;
      outIdx = 1;
      while( today < endIdx )
      {
         today++;
         tempReal = inHigh[today];
         diffP = tempReal-prevHigh;
         prevHigh = tempReal;
         tempReal = inLow[today];
         diffM = prevLow-tempReal;
         prevLow = tempReal;
         prevMinusDM -= prevMinusDM/optInTimePeriod;
         prevPlusDM -= prevPlusDM/optInTimePeriod;
         if( (diffM > 0) && (diffP < diffM) )
         {
            prevMinusDM += diffM;
         }
         else if( (diffP > 0) && (diffP > diffM) )
         {
            prevPlusDM += diffP;
         }
         { tempReal = prevHigh-prevLow; tempReal2 = Math.abs (prevHigh-prevClose); if( tempReal2 > tempReal ) tempReal = tempReal2; tempReal2 = Math.abs (prevLow-prevClose); if( tempReal2 > tempReal ) tempReal = tempReal2; } ;
         prevTR = prevTR - (prevTR/optInTimePeriod) + tempReal;
         prevClose = inClose[today];
         if( ! (((- (0.00000000000001) )<prevTR)&&(prevTR< (0.00000000000001) )) )
         {
            minusDI = (100.0*(prevMinusDM/prevTR)) ;
            plusDI = (100.0*(prevPlusDM/prevTR)) ;
            tempReal = minusDI+plusDI;
            if( ! (((- (0.00000000000001) )<tempReal)&&(tempReal< (0.00000000000001) )) )
               outReal[outIdx] = (100.0 * ( Math.abs (minusDI-plusDI)/tempReal)) ;
            else
               outReal[outIdx] = outReal[outIdx-1];
         }
         else
            outReal[outIdx] = outReal[outIdx-1];
         outIdx++;
      }
      outNBElement.value = outIdx;
      return RetCode.Success ;
   }
   public int dxStateInit( struct TA_dx_State** _state,
      int optInTimePeriod )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 14;
      else if( ((int)optInTimePeriod < 2) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct dx ));
      _state.value .value .mem_index = 0;
      _state.value .value .optInTimePeriod = optInTimePeriod;
      _state.value .value .mem_size = dxLookback (optInTimePeriod );
      if ( _state.value .value .mem_size > 0)
         _state.value .value .memory = TA_Calloc( _state.value .value .mem_size , sizeof(struct TA_DX_Data));
      else
         _state.value .value .memory = NULL;
      return RetCode.Success ;
   }
   public int dxState( struct TA_dx_State* _state,
      double inHigh,
      double inLow,
      double inClose,
      double *outReal )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      size_t _cur_idx = _state.value .mem_index++;
      if ( _state.value .mem_size > 0) _cur_idx %= _state.value .mem_size ;
      if ( _state.value .mem_size > _state.value .mem_index - 1 ) {
         ( _state.value .memory+_cur_idx).value .inHigh = inHigh ;
         ( _state.value .memory+_cur_idx).value .inLow = inLow ;
         ( _state.value .memory+_cur_idx).value .inClose = inClose ;
         return RetCode.NeedMoreData ; }
      return RetCode.Success ;
   }
   public int dxStateFree( struct TA_dx_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if ( _state.value != NULL) {
         if ( _state.value .value .memory != NULL) TA_Free( _state.value .value .memory );
         TA_Free( _state.value ); _state.value = NULL;}
      return RetCode.Success ;
   }
   public RetCode dx( int startIdx,
      int endIdx,
      float inHigh[],
      float inLow[],
      float inClose[],
      int optInTimePeriod,
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      int today, lookbackTotal, outIdx;
      double prevHigh, prevLow, prevClose;
      double prevMinusDM, prevPlusDM, prevTR;
      double tempReal, tempReal2, diffP, diffM;
      double minusDI, plusDI;
      int i;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 14;
      else if( ((int)optInTimePeriod < 2) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      if( optInTimePeriod > 1 )
         lookbackTotal = optInTimePeriod + (this.unstablePeriod[FuncUnstId.Dx.ordinal()]) ;
      else
         lookbackTotal = 2;
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      outIdx = 0;
      outBegIdx.value = today = startIdx;
      prevMinusDM = 0.0;
      prevPlusDM = 0.0;
      prevTR = 0.0;
      today = startIdx - lookbackTotal;
      prevHigh = inHigh[today];
      prevLow = inLow[today];
      prevClose = inClose[today];
      i = optInTimePeriod-1;
      while( i-- > 0 )
      {
         today++;
         tempReal = inHigh[today];
         diffP = tempReal-prevHigh;
         prevHigh = tempReal;
         tempReal = inLow[today];
         diffM = prevLow-tempReal;
         prevLow = tempReal;
         if( (diffM > 0) && (diffP < diffM) )
         {
            prevMinusDM += diffM;
         }
         else if( (diffP > 0) && (diffP > diffM) )
         {
            prevPlusDM += diffP;
         }
         { tempReal = prevHigh-prevLow; tempReal2 = Math.abs (prevHigh-prevClose); if( tempReal2 > tempReal ) tempReal = tempReal2; tempReal2 = Math.abs (prevLow-prevClose); if( tempReal2 > tempReal ) tempReal = tempReal2; } ;
         prevTR += tempReal;
         prevClose = inClose[today];
      }
      i = (this.unstablePeriod[FuncUnstId.Dx.ordinal()]) + 1;
      while( i-- != 0 )
      {
         today++;
         tempReal = inHigh[today];
         diffP = tempReal-prevHigh;
         prevHigh = tempReal;
         tempReal = inLow[today];
         diffM = prevLow-tempReal;
         prevLow = tempReal;
         prevMinusDM -= prevMinusDM/optInTimePeriod;
         prevPlusDM -= prevPlusDM/optInTimePeriod;
         if( (diffM > 0) && (diffP < diffM) )
         {
            prevMinusDM += diffM;
         }
         else if( (diffP > 0) && (diffP > diffM) )
         {
            prevPlusDM += diffP;
         }
         { tempReal = prevHigh-prevLow; tempReal2 = Math.abs (prevHigh-prevClose); if( tempReal2 > tempReal ) tempReal = tempReal2; tempReal2 = Math.abs (prevLow-prevClose); if( tempReal2 > tempReal ) tempReal = tempReal2; } ;
         prevTR = prevTR - (prevTR/optInTimePeriod) + tempReal;
         prevClose = inClose[today];
      }
      if( ! (((- (0.00000000000001) )<prevTR)&&(prevTR< (0.00000000000001) )) )
      {
         minusDI = (100.0*(prevMinusDM/prevTR)) ;
         plusDI = (100.0*(prevPlusDM/prevTR)) ;
         tempReal = minusDI+plusDI;
         if( ! (((- (0.00000000000001) )<tempReal)&&(tempReal< (0.00000000000001) )) )
            outReal[0] = (100.0 * ( Math.abs (minusDI-plusDI)/tempReal)) ;
         else
            outReal[0] = 0.0;
      }
      else
         outReal[0] = 0.0;
      outIdx = 1;
      while( today < endIdx )
      {
         today++;
         tempReal = inHigh[today];
         diffP = tempReal-prevHigh;
         prevHigh = tempReal;
         tempReal = inLow[today];
         diffM = prevLow-tempReal;
         prevLow = tempReal;
         prevMinusDM -= prevMinusDM/optInTimePeriod;
         prevPlusDM -= prevPlusDM/optInTimePeriod;
         if( (diffM > 0) && (diffP < diffM) )
         {
            prevMinusDM += diffM;
         }
         else if( (diffP > 0) && (diffP > diffM) )
         {
            prevPlusDM += diffP;
         }
         { tempReal = prevHigh-prevLow; tempReal2 = Math.abs (prevHigh-prevClose); if( tempReal2 > tempReal ) tempReal = tempReal2; tempReal2 = Math.abs (prevLow-prevClose); if( tempReal2 > tempReal ) tempReal = tempReal2; } ;
         prevTR = prevTR - (prevTR/optInTimePeriod) + tempReal;
         prevClose = inClose[today];
         if( ! (((- (0.00000000000001) )<prevTR)&&(prevTR< (0.00000000000001) )) )
         {
            minusDI = (100.0*(prevMinusDM/prevTR)) ;
            plusDI = (100.0*(prevPlusDM/prevTR)) ;
            tempReal = minusDI+plusDI;
            if( ! (((- (0.00000000000001) )<tempReal)&&(tempReal< (0.00000000000001) )) )
               outReal[outIdx] = (100.0 * ( Math.abs (minusDI-plusDI)/tempReal)) ;
            else
               outReal[outIdx] = outReal[outIdx-1];
         }
         else
            outReal[outIdx] = outReal[outIdx-1];
         outIdx++;
      }
      outNBElement.value = outIdx;
      return RetCode.Success ;
   }
   /* Generated */
   public int emaLookback( int optInTimePeriod )
   {
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 30;
      else if( ((int)optInTimePeriod < 2) || ((int)optInTimePeriod > 100000) )
         return -1;
      return optInTimePeriod - 1 + (this.unstablePeriod[FuncUnstId.Ema.ordinal()]) ;
   }
   public RetCode ema( int startIdx,
      int endIdx,
      double inReal[],
      int optInTimePeriod,
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 30;
      else if( ((int)optInTimePeriod < 2) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      return TA_INT_EMA ( startIdx, endIdx, inReal,
         optInTimePeriod,
         ((double)2.0 / ((double)(optInTimePeriod + 1))) ,
         outBegIdx, outNBElement, outReal );
   }
   public RetCode TA_INT_EMA( int startIdx,
      int endIdx,
      double []inReal,
      int optInTimePeriod,
      double optInK_1,
      MInteger outBegIdx,
      MInteger outNBElement,
      double []outReal )
   {
      double tempReal, prevMA;
      int i, today, outIdx, lookbackTotal;
      lookbackTotal = emaLookback ( optInTimePeriod );
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      outBegIdx.value = startIdx;
      if( (this.compatibility) == Compatibility.Default )
      {
         today = startIdx-lookbackTotal;
         i = optInTimePeriod;
         tempReal = 0.0;
         while( i-- > 0 )
            tempReal += inReal[today++];
         prevMA = tempReal / optInTimePeriod;
      }
      else
      {
         prevMA = inReal[0];
         today = 1;
      }
      while( today <= startIdx )
         prevMA = ((inReal[today++]-prevMA)*optInK_1) + prevMA;
      outReal[0] = prevMA;
      outIdx = 1;
      while( today <= endIdx )
      {
         prevMA = ((inReal[today++]-prevMA)*optInK_1) + prevMA;
         outReal[outIdx++] = prevMA;
      }
      outNBElement.value = outIdx;
      return RetCode.Success ;
   }
   public int emaStateInit( struct TA_ema_State** _state,
      int optInTimePeriod )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 30;
      else if( ((int)optInTimePeriod < 2) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct ema ));
      _state.value .value .mem_index = 0;
      _state.value .value .optInTimePeriod = optInTimePeriod;
      _state.value .value .mem_size = emaLookback (optInTimePeriod );
      _state.value .value .memory = NULL;
      return RetCode.Success ;
   }
   public int emaState( struct TA_ema_State* _state,
      double inReal,
      double *outReal )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      size_t _cur_idx = _state.value .mem_index++;
      if ( _state.value .mem_size > 0) _cur_idx %= _state.value .mem_size ;
      if ( ( _state.value .mem_index == 1) )
      {
         _state.value .prevMA = 0.;
         _state.value .tempSum = 0.;
      }
      if( (this.compatibility) == Compatibility.Default )
      {
         if ((int) _state.value .mem_index-1 < _state.value .optInTimePeriod)
         {
            _state.value .tempSum += inReal;
            if ((int) _state.value .mem_index == _state.value .optInTimePeriod)
            {
               _state.value .prevMA = _state.value .tempSum / _state.value .optInTimePeriod;
               if (!( _state.value .mem_size > _state.value .mem_index - 1 ))
               {
                  outReal.value = _state.value .prevMA;
                  return RetCode.Success ;
               }
            } else
               return RetCode.NeedMoreData ;
         }
      }
      else {
         if ( ( _state.value .mem_index == 1) )
         {
            _state.value .prevMA = inReal;
            return RetCode.NeedMoreData ;
         }
      }
      _state.value .prevMA = ((inReal- _state.value .prevMA) * ((double)2.0 / ((double)( _state.value .optInTimePeriod + 1))) ) + _state.value .prevMA;
      if ( _state.value .mem_size > _state.value .mem_index - 1 )
         return RetCode.NeedMoreData ;
      outReal.value = _state.value .prevMA;
      return RetCode.Success ;
   }
   public int emaStateFree( struct TA_ema_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if ( _state.value != NULL) {
         if ( _state.value .value .memory != NULL) TA_Free( _state.value .value .memory );
         TA_Free( _state.value ); _state.value = NULL;}
      return RetCode.Success ;
   }
   public RetCode ema( int startIdx,
      int endIdx,
      float inReal[],
      int optInTimePeriod,
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 30;
      else if( ((int)optInTimePeriod < 2) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      return TA_INT_EMA ( startIdx, endIdx, inReal,
         optInTimePeriod,
         ((double)2.0 / ((double)(optInTimePeriod + 1))) ,
         outBegIdx, outNBElement, outReal );
   }
   public RetCode TA_INT_EMA( int startIdx,
      int endIdx,
      float []inReal,
      int optInTimePeriod,
      double optInK_1,
      MInteger outBegIdx,
      MInteger outNBElement,
      double []outReal )
   {
      double tempReal, prevMA;
      int i, today, outIdx, lookbackTotal;
      lookbackTotal = emaLookback ( optInTimePeriod );
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      outBegIdx.value = startIdx;
      if( (this.compatibility) == Compatibility.Default )
      {
         today = startIdx-lookbackTotal;
         i = optInTimePeriod;
         tempReal = 0.0;
         while( i-- > 0 )
            tempReal += inReal[today++];
         prevMA = tempReal / optInTimePeriod;
      }
      else
      {
         prevMA = inReal[0];
         today = 1;
      }
      while( today <= startIdx )
         prevMA = ((inReal[today++]-prevMA)*optInK_1) + prevMA;
      outReal[0] = prevMA;
      outIdx = 1;
      while( today <= endIdx )
      {
         prevMA = ((inReal[today++]-prevMA)*optInK_1) + prevMA;
         outReal[outIdx++] = prevMA;
      }
      outNBElement.value = outIdx;
      return RetCode.Success ;
   }
   /* Generated */
   public int expLookback( )
   {
      return RetCode.Success ;
   }
   public RetCode exp( int startIdx,
      int endIdx,
      double inReal[],
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      int outIdx;
      int i;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      for( i=startIdx, outIdx=0; i <= endIdx; i++, outIdx++ )
      {
         outReal[outIdx] = Math.exp (inReal[i]);
      }
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   public int expStateInit( struct TA_exp_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct exp ));
      _state.value .value .mem_index = 0;
      _state.value .value .mem_size = expLookback ();
      if ( _state.value .value .mem_size > 0)
         _state.value .value .memory = TA_Calloc( _state.value .value .mem_size , sizeof(struct TA_EXP_Data));
      else
         _state.value .value .memory = NULL;
      return RetCode.Success ;
   }
   public int expState( struct TA_exp_State* _state,
      double inReal,
      double *outReal )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      size_t _cur_idx = _state.value .mem_index++;
      if ( _state.value .mem_size > 0) _cur_idx %= _state.value .mem_size ;
      if ( _state.value .mem_size > _state.value .mem_index - 1 ) {
         ( _state.value .memory+_cur_idx).value .inReal = inReal ;
         return RetCode.NeedMoreData ; }
      outReal.value = Math.exp (inReal);
      return RetCode.Success ;
   }
   public int expStateFree( struct TA_exp_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if ( _state.value != NULL) {
         if ( _state.value .value .memory != NULL) TA_Free( _state.value .value .memory );
         TA_Free( _state.value ); _state.value = NULL;}
      return RetCode.Success ;
   }
   public RetCode exp( int startIdx,
      int endIdx,
      float inReal[],
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      int outIdx;
      int i;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      for( i=startIdx, outIdx=0; i <= endIdx; i++, outIdx++ )
      {
         outReal[outIdx] = Math.exp (inReal[i]);
      }
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   /* Generated */
   public int floorLookback( )
   {
      return RetCode.Success ;
   }
   public RetCode floor( int startIdx,
      int endIdx,
      double inReal[],
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      int outIdx;
      int i;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      for( i=startIdx, outIdx=0; i <= endIdx; i++, outIdx++ )
      {
         outReal[outIdx] = Math.floor (inReal[i]);
      }
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   public int floorStateInit( struct TA_floor_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct floor ));
      _state.value .value .mem_index = 0;
      _state.value .value .mem_size = floorLookback ();
      if ( _state.value .value .mem_size > 0)
         _state.value .value .memory = TA_Calloc( _state.value .value .mem_size , sizeof(struct TA_FLOOR_Data));
      else
         _state.value .value .memory = NULL;
      return RetCode.Success ;
   }
   public int floorState( struct TA_floor_State* _state,
      double inReal,
      double *outReal )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      size_t _cur_idx = _state.value .mem_index++;
      if ( _state.value .mem_size > 0) _cur_idx %= _state.value .mem_size ;
      if ( _state.value .mem_size > _state.value .mem_index - 1 ) {
         ( _state.value .memory+_cur_idx).value .inReal = inReal ;
         return RetCode.NeedMoreData ; }
      outReal.value = Math.floor (inReal);
      return RetCode.Success ;
   }
   public int floorStateFree( struct TA_floor_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if ( _state.value != NULL) {
         if ( _state.value .value .memory != NULL) TA_Free( _state.value .value .memory );
         TA_Free( _state.value ); _state.value = NULL;}
      return RetCode.Success ;
   }
   public RetCode floor( int startIdx,
      int endIdx,
      float inReal[],
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      int outIdx;
      int i;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      for( i=startIdx, outIdx=0; i <= endIdx; i++, outIdx++ )
      {
         outReal[outIdx] = Math.floor (inReal[i]);
      }
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   /* Generated */
   public int htDcPeriodLookback( )
   {
      return 32 + (this.unstablePeriod[FuncUnstId.HtDcPeriod.ordinal()]) ;
   }
   public RetCode htDcPeriod( int startIdx,
      int endIdx,
      double inReal[],
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      int outIdx, i;
      int lookbackTotal, today;
      double tempReal, tempReal2;
      double adjustedPrevPeriod, period;
      int trailingWMAIdx;
      double periodWMASum, periodWMASub, trailingWMAValue;
      double smoothedValue;
      final double a = 0.0962;
      final double b = 0.5769;
      double hilbertTempReal;
      int hilbertIdx;
      double []detrender_Odd = new double[3] ; double []detrender_Even = new double[3] ; double detrender; double prev_detrender_Odd ; double prev_detrender_Even ; double prev_detrender_input_Odd ; double prev_detrender_input_Even ;
      double []Q1_Odd = new double[3] ; double []Q1_Even = new double[3] ; double Q1; double prev_Q1_Odd ; double prev_Q1_Even ; double prev_Q1_input_Odd ; double prev_Q1_input_Even ;
      double []jI_Odd = new double[3] ; double []jI_Even = new double[3] ; double jI; double prev_jI_Odd ; double prev_jI_Even ; double prev_jI_input_Odd ; double prev_jI_input_Even ;
      double []jQ_Odd = new double[3] ; double []jQ_Even = new double[3] ; double jQ; double prev_jQ_Odd ; double prev_jQ_Even ; double prev_jQ_input_Odd ; double prev_jQ_input_Even ;
      double Q2, I2, prevQ2, prevI2, Re, Im;
      double I1ForOddPrev2, I1ForOddPrev3;
      double I1ForEvenPrev2, I1ForEvenPrev3;
      double rad2Deg;
      double todayValue, smoothPeriod;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      rad2Deg = 180.0 / (4.0 * Math.atan (1));
      lookbackTotal = 32 + (this.unstablePeriod[FuncUnstId.HtDcPeriod.ordinal()]) ;
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      outBegIdx.value = startIdx;
      trailingWMAIdx = startIdx - lookbackTotal;
      today = trailingWMAIdx;
      tempReal = inReal[today++];
      periodWMASub = tempReal;
      periodWMASum = tempReal;
      tempReal = inReal[today++];
      periodWMASub += tempReal;
      periodWMASum += tempReal*2.0;
      tempReal = inReal[today++];
      periodWMASub += tempReal;
      periodWMASum += tempReal*3.0;
      trailingWMAValue = 0.0;
      i = 9;
      do
      {
         tempReal = inReal[today++];
         { periodWMASub += tempReal; periodWMASub -= trailingWMAValue; periodWMASum += tempReal*4.0; trailingWMAValue = inReal[trailingWMAIdx++]; smoothedValue = periodWMASum*0.1; periodWMASum -= periodWMASub; } ;
      } while( --i != 0);
      hilbertIdx = 0;
      { detrender_Odd [0] = 0.0; detrender_Odd [1] = 0.0; detrender_Odd [2] = 0.0; detrender_Even [0] = 0.0; detrender_Even [1] = 0.0; detrender_Even [2] = 0.0; detrender = 0.0; prev_detrender_Odd = 0.0; prev_detrender_Even = 0.0; prev_detrender_input_Odd = 0.0; prev_detrender_input_Even = 0.0; } ;
      { Q1_Odd [0] = 0.0; Q1_Odd [1] = 0.0; Q1_Odd [2] = 0.0; Q1_Even [0] = 0.0; Q1_Even [1] = 0.0; Q1_Even [2] = 0.0; Q1 = 0.0; prev_Q1_Odd = 0.0; prev_Q1_Even = 0.0; prev_Q1_input_Odd = 0.0; prev_Q1_input_Even = 0.0; } ;
      { jI_Odd [0] = 0.0; jI_Odd [1] = 0.0; jI_Odd [2] = 0.0; jI_Even [0] = 0.0; jI_Even [1] = 0.0; jI_Even [2] = 0.0; jI = 0.0; prev_jI_Odd = 0.0; prev_jI_Even = 0.0; prev_jI_input_Odd = 0.0; prev_jI_input_Even = 0.0; } ;
      { jQ_Odd [0] = 0.0; jQ_Odd [1] = 0.0; jQ_Odd [2] = 0.0; jQ_Even [0] = 0.0; jQ_Even [1] = 0.0; jQ_Even [2] = 0.0; jQ = 0.0; prev_jQ_Odd = 0.0; prev_jQ_Even = 0.0; prev_jQ_input_Odd = 0.0; prev_jQ_input_Even = 0.0; } ;
      period = 0.0;
      outIdx = 0;
      prevI2 = prevQ2 = 0.0;
      Re = Im = 0.0;
      I1ForOddPrev3 = I1ForEvenPrev3 = 0.0;
      I1ForOddPrev2 = I1ForEvenPrev2 = 0.0;
      smoothPeriod = 0.0;
      while( today <= endIdx )
      {
         adjustedPrevPeriod = (0.075*period)+0.54;
         todayValue = inReal[today];
         { periodWMASub += todayValue; periodWMASub -= trailingWMAValue; periodWMASum += todayValue*4.0; trailingWMAValue = inReal[trailingWMAIdx++]; smoothedValue = periodWMASum*0.1; periodWMASum -= periodWMASub; } ;
         if( (today%2) == 0 )
         {
            { hilbertTempReal = a * smoothedValue; detrender = -detrender_Even [hilbertIdx]; detrender_Even [hilbertIdx] = hilbertTempReal; detrender += hilbertTempReal; detrender -= prev_detrender_Even ; prev_detrender_Even = b * prev_detrender_input_Even ; detrender += prev_detrender_Even ; prev_detrender_input_Even = smoothedValue; detrender *= adjustedPrevPeriod; } ;
            { hilbertTempReal = a * detrender; Q1 = -Q1_Even [hilbertIdx]; Q1_Even [hilbertIdx] = hilbertTempReal; Q1 += hilbertTempReal; Q1 -= prev_Q1_Even ; prev_Q1_Even = b * prev_Q1_input_Even ; Q1 += prev_Q1_Even ; prev_Q1_input_Even = detrender; Q1 *= adjustedPrevPeriod; } ;
            { hilbertTempReal = a * I1ForEvenPrev3; jI = -jI_Even [hilbertIdx]; jI_Even [hilbertIdx] = hilbertTempReal; jI += hilbertTempReal; jI -= prev_jI_Even ; prev_jI_Even = b * prev_jI_input_Even ; jI += prev_jI_Even ; prev_jI_input_Even = I1ForEvenPrev3; jI *= adjustedPrevPeriod; } ;
            { hilbertTempReal = a * Q1; jQ = -jQ_Even [hilbertIdx]; jQ_Even [hilbertIdx] = hilbertTempReal; jQ += hilbertTempReal; jQ -= prev_jQ_Even ; prev_jQ_Even = b * prev_jQ_input_Even ; jQ += prev_jQ_Even ; prev_jQ_input_Even = Q1; jQ *= adjustedPrevPeriod; } ;
            if( ++hilbertIdx == 3 )
               hilbertIdx = 0;
            Q2 = (0.2*(Q1 + jI)) + (0.8*prevQ2);
            I2 = (0.2*(I1ForEvenPrev3 - jQ)) + (0.8*prevI2);
            I1ForOddPrev3 = I1ForOddPrev2;
            I1ForOddPrev2 = detrender;
         }
         else
         {
            { hilbertTempReal = a * smoothedValue; detrender = -detrender_Odd [hilbertIdx]; detrender_Odd [hilbertIdx] = hilbertTempReal; detrender += hilbertTempReal; detrender -= prev_detrender_Odd ; prev_detrender_Odd = b * prev_detrender_input_Odd ; detrender += prev_detrender_Odd ; prev_detrender_input_Odd = smoothedValue; detrender *= adjustedPrevPeriod; } ;
            { hilbertTempReal = a * detrender; Q1 = -Q1_Odd [hilbertIdx]; Q1_Odd [hilbertIdx] = hilbertTempReal; Q1 += hilbertTempReal; Q1 -= prev_Q1_Odd ; prev_Q1_Odd = b * prev_Q1_input_Odd ; Q1 += prev_Q1_Odd ; prev_Q1_input_Odd = detrender; Q1 *= adjustedPrevPeriod; } ;
            { hilbertTempReal = a * I1ForOddPrev3; jI = -jI_Odd [hilbertIdx]; jI_Odd [hilbertIdx] = hilbertTempReal; jI += hilbertTempReal; jI -= prev_jI_Odd ; prev_jI_Odd = b * prev_jI_input_Odd ; jI += prev_jI_Odd ; prev_jI_input_Odd = I1ForOddPrev3; jI *= adjustedPrevPeriod; } ;
            { hilbertTempReal = a * Q1; jQ = -jQ_Odd [hilbertIdx]; jQ_Odd [hilbertIdx] = hilbertTempReal; jQ += hilbertTempReal; jQ -= prev_jQ_Odd ; prev_jQ_Odd = b * prev_jQ_input_Odd ; jQ += prev_jQ_Odd ; prev_jQ_input_Odd = Q1; jQ *= adjustedPrevPeriod; } ;
            Q2 = (0.2*(Q1 + jI)) + (0.8*prevQ2);
            I2 = (0.2*(I1ForOddPrev3 - jQ)) + (0.8*prevI2);
            I1ForEvenPrev3 = I1ForEvenPrev2;
            I1ForEvenPrev2 = detrender;
         }
         Re = (0.2*((I2*prevI2)+(Q2*prevQ2)))+(0.8*Re);
         Im = (0.2*((I2*prevQ2)-(Q2*prevI2)))+(0.8*Im);
         prevQ2 = Q2;
         prevI2 = I2;
         tempReal = period;
         if( (Im != 0.0) && (Re != 0.0) )
            period = 360.0 / ( Math.atan (Im/Re)*rad2Deg);
         tempReal2 = 1.5*tempReal;
         if( period > tempReal2)
            period = tempReal2;
         tempReal2 = 0.67*tempReal;
         if( period < tempReal2 )
            period = tempReal2;
         if( period < 6 )
            period = 6;
         else if( period > 50 )
            period = 50;
         period = (0.2*period) + (0.8 * tempReal);
         smoothPeriod = (0.33*period)+(0.67*smoothPeriod);
         if( today >= startIdx )
         {
            outReal[outIdx++] = smoothPeriod;
         }
         today++;
      }
      outNBElement.value = outIdx;
      return RetCode.Success ;
   }
   struct TA_HT_DCPERIOD_HILBERT_STRUCT { double []_Odd = new double[3] ; double []_Even = new double[3] ; double var; double prev_Odd; double prev_Even; double prev_input_Odd; double prev_input_Even; };
   public int htDcPeriodStateInit( struct TA_htDcPeriod_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct htDcPeriod ));
      _state.value .value .mem_index = 0;
      _state.value .value .mem_size = htDcPeriodLookback ();
      if ( _state.value .value .mem_size > 0)
         _state.value .value .memory = TA_Calloc( _state.value .value .mem_size , sizeof(struct TA_HT_DCPERIOD_Data));
      else
         _state.value .value .memory = NULL;
      { _state.value .value .detrender = calloc(1, sizeof(struct TA_HT_DCPERIOD_HILBERT_STRUCT )); if ( _state.value .value .detrender == NULL) return RetCode.AllocErr ; } ;
      { _state.value .value .Q1 = calloc(1, sizeof(struct TA_HT_DCPERIOD_HILBERT_STRUCT )); if ( _state.value .value .Q1 == NULL) return RetCode.AllocErr ; } ;
      { _state.value .value .jI = calloc(1, sizeof(struct TA_HT_DCPERIOD_HILBERT_STRUCT )); if ( _state.value .value .jI == NULL) return RetCode.AllocErr ; } ;
      { _state.value .value .jQ = calloc(1, sizeof(struct TA_HT_DCPERIOD_HILBERT_STRUCT )); if ( _state.value .value .jQ == NULL) return RetCode.AllocErr ; } ;
      return RetCode.Success ;
   }
   public int htDcPeriodState( struct TA_htDcPeriod_State* _state,
      double inReal,
      double *outReal )
   {
      double hilbertTempReal, smoothedValue;
      double adjustedPrevPeriod;
      double Q2, I2;
      double tempReal, tempReal2;
      if (_state == NULL)
         return RetCode.BadParam ;
      size_t _cur_idx = _state.value .mem_index++;
      if ( _state.value .mem_size > 0) _cur_idx %= _state.value .mem_size ;
      if ( ( _state.value .mem_index == 1) )
      {
         _state.value .periodWMASub = 0.;
         _state.value .periodWMASum = 0.;
         _state.value .hilbertIdx = 0;
         _state.value .period = 0;
         _state.value .prevI2 = 0.;
         _state.value .prevQ2 = 0.;
         _state.value .I1ForOddPrev2 = 0;
         _state.value .I1ForEvenPrev2 = 0;
         _state.value .I1ForOddPrev3 = 0;
         _state.value .I1ForEvenPrev3 = 0;
         _state.value .smoothPeriod = 0.0;
         _state.value .Im = 0.;
         _state.value .Re = 0.;
         _state.value .trailingWMAValue = 0.;
         _state.value .rad2Deg = 180.0 / (4.0 * Math.atan (1));
         _state.value .a = 0.0962;
         _state.value .b = 0.5769;
         { struct TA_HT_DCPERIOD_HILBERT_STRUCT * ref; ref = (struct TA_HT_DCPERIOD_HILBERT_STRUCT *) _state.value .detrender; ref.value ._Odd [0] = 0.0; ref.value ._Odd [1] = 0.0; ref.value ._Odd [2] = 0.0; ref.value ._Even[0] = 0.0; ref.value ._Even[1] = 0.0; ref.value ._Even[2] = 0.0; ref.value .var = 0.0; ref.value .prev_Odd = 0.0; ref.value .prev_Even = 0.0; ref.value .prev_input_Odd = 0.0; ref.value .prev_input_Even = 0.0; } ;
         { struct TA_HT_DCPERIOD_HILBERT_STRUCT * ref; ref = (struct TA_HT_DCPERIOD_HILBERT_STRUCT *) _state.value .Q1; ref.value ._Odd [0] = 0.0; ref.value ._Odd [1] = 0.0; ref.value ._Odd [2] = 0.0; ref.value ._Even[0] = 0.0; ref.value ._Even[1] = 0.0; ref.value ._Even[2] = 0.0; ref.value .var = 0.0; ref.value .prev_Odd = 0.0; ref.value .prev_Even = 0.0; ref.value .prev_input_Odd = 0.0; ref.value .prev_input_Even = 0.0; } ;
         { struct TA_HT_DCPERIOD_HILBERT_STRUCT * ref; ref = (struct TA_HT_DCPERIOD_HILBERT_STRUCT *) _state.value .jI; ref.value ._Odd [0] = 0.0; ref.value ._Odd [1] = 0.0; ref.value ._Odd [2] = 0.0; ref.value ._Even[0] = 0.0; ref.value ._Even[1] = 0.0; ref.value ._Even[2] = 0.0; ref.value .var = 0.0; ref.value .prev_Odd = 0.0; ref.value .prev_Even = 0.0; ref.value .prev_input_Odd = 0.0; ref.value .prev_input_Even = 0.0; } ;
         { struct TA_HT_DCPERIOD_HILBERT_STRUCT * ref; ref = (struct TA_HT_DCPERIOD_HILBERT_STRUCT *) _state.value .jQ; ref.value ._Odd [0] = 0.0; ref.value ._Odd [1] = 0.0; ref.value ._Odd [2] = 0.0; ref.value ._Even[0] = 0.0; ref.value ._Even[1] = 0.0; ref.value ._Even[2] = 0.0; ref.value .var = 0.0; ref.value .prev_Odd = 0.0; ref.value .prev_Even = 0.0; ref.value .prev_input_Odd = 0.0; ref.value .prev_input_Even = 0.0; } ;
      }
      if ( _state.value .mem_index < 4)
      {
         _state.value .periodWMASub += inReal;
         _state.value .periodWMASum += _state.value .mem_index*inReal;
         ( _state.value .memory+_cur_idx).value .inReal = inReal ;
         return RetCode.NeedMoreData ;
      } else
         if ( _state.value .mem_index <= 12)
      {
         { _state.value .periodWMASub += inReal; _state.value .periodWMASub -= _state.value .trailingWMAValue; _state.value .periodWMASum += inReal*4.0; _state.value .trailingWMAValue = ( _state.value .memory+( _state.value .mem_index-4) % _state.value .mem_size ).value .inReal ; smoothedValue = _state.value .periodWMASum*0.1; _state.value .periodWMASum -= _state.value .periodWMASub; } ;
         ( _state.value .memory+_cur_idx).value .inReal = inReal ;
         return RetCode.NeedMoreData ;
      }
      adjustedPrevPeriod = (0.075* _state.value .period)+0.54;
      { _state.value .periodWMASub += inReal; _state.value .periodWMASub -= _state.value .trailingWMAValue; _state.value .periodWMASum += inReal*4.0; _state.value .trailingWMAValue = ( _state.value .memory+( _state.value .mem_index-4) % _state.value .mem_size ).value .inReal ; smoothedValue = _state.value .periodWMASum*0.1; _state.value .periodWMASum -= _state.value .periodWMASub; } ;
      if( (( _state.value .mem_index+1)%2) == 0 )
      {
         { struct TA_HT_DCPERIOD_HILBERT_STRUCT * ref; ref = (struct TA_HT_DCPERIOD_HILBERT_STRUCT *) _state.value .detrender; hilbertTempReal = _state.value .a * smoothedValue; ref.value .var = - ref.value ._Even [ _state.value .hilbertIdx]; ref.value ._Even [ _state.value .hilbertIdx] = hilbertTempReal; ref.value .var += hilbertTempReal; ref.value .var -= ref.value .prev_Even ; ref.value .prev_Even = _state.value .b * ref.value .prev_input_Even ; ref.value .var += ref.value .prev_Even ; ref.value .prev_input_Even = smoothedValue; ref.value .var *= adjustedPrevPeriod; } ;
         { struct TA_HT_DCPERIOD_HILBERT_STRUCT * ref; ref = (struct TA_HT_DCPERIOD_HILBERT_STRUCT *) _state.value .Q1; hilbertTempReal = _state.value .a * (struct TA_HT_DCPERIOD_HILBERT_STRUCT *) _state.value .detrender.value .var ; ref.value .var = - ref.value ._Even [ _state.value .hilbertIdx]; ref.value ._Even [ _state.value .hilbertIdx] = hilbertTempReal; ref.value .var += hilbertTempReal; ref.value .var -= ref.value .prev_Even ; ref.value .prev_Even = _state.value .b * ref.value .prev_input_Even ; ref.value .var += ref.value .prev_Even ; ref.value .prev_input_Even = (struct TA_HT_DCPERIOD_HILBERT_STRUCT *) _state.value .detrender.value .var ; ref.value .var *= adjustedPrevPeriod; } ;
         { struct TA_HT_DCPERIOD_HILBERT_STRUCT * ref; ref = (struct TA_HT_DCPERIOD_HILBERT_STRUCT *) _state.value .jI; hilbertTempReal = _state.value .a * _state.value .I1ForEvenPrev3; ref.value .var = - ref.value ._Even [ _state.value .hilbertIdx]; ref.value ._Even [ _state.value .hilbertIdx] = hilbertTempReal; ref.value .var += hilbertTempReal; ref.value .var -= ref.value .prev_Even ; ref.value .prev_Even = _state.value .b * ref.value .prev_input_Even ; ref.value .var += ref.value .prev_Even ; ref.value .prev_input_Even = _state.value .I1ForEvenPrev3; ref.value .var *= adjustedPrevPeriod; } ;
         { struct TA_HT_DCPERIOD_HILBERT_STRUCT * ref; ref = (struct TA_HT_DCPERIOD_HILBERT_STRUCT *) _state.value .jQ; hilbertTempReal = _state.value .a * (struct TA_HT_DCPERIOD_HILBERT_STRUCT *) _state.value .Q1.value .var ; ref.value .var = - ref.value ._Even [ _state.value .hilbertIdx]; ref.value ._Even [ _state.value .hilbertIdx] = hilbertTempReal; ref.value .var += hilbertTempReal; ref.value .var -= ref.value .prev_Even ; ref.value .prev_Even = _state.value .b * ref.value .prev_input_Even ; ref.value .var += ref.value .prev_Even ; ref.value .prev_input_Even = (struct TA_HT_DCPERIOD_HILBERT_STRUCT *) _state.value .Q1.value .var ; ref.value .var *= adjustedPrevPeriod; } ;
         if( ++ _state.value .hilbertIdx == 3 )
            _state.value .hilbertIdx = 0;
         Q2 = (0.2*( (struct TA_HT_DCPERIOD_HILBERT_STRUCT *) _state.value .Q1.value .var + (struct TA_HT_DCPERIOD_HILBERT_STRUCT *) _state.value .jI.value .var )) + (0.8* _state.value .prevQ2);
         I2 = (0.2*( _state.value .I1ForEvenPrev3 - (struct TA_HT_DCPERIOD_HILBERT_STRUCT *) _state.value .jQ.value .var )) + (0.8* _state.value .prevI2);
         _state.value .I1ForOddPrev3 = _state.value .I1ForOddPrev2;
         _state.value .I1ForOddPrev2 = (struct TA_HT_DCPERIOD_HILBERT_STRUCT *) _state.value .detrender.value .var ;
      } else {
         { struct TA_HT_DCPERIOD_HILBERT_STRUCT * ref; ref = (struct TA_HT_DCPERIOD_HILBERT_STRUCT *) _state.value .detrender; hilbertTempReal = _state.value .a * smoothedValue; ref.value .var = - ref.value ._Odd [ _state.value .hilbertIdx]; ref.value ._Odd [ _state.value .hilbertIdx] = hilbertTempReal; ref.value .var += hilbertTempReal; ref.value .var -= ref.value .prev_Odd ; ref.value .prev_Odd = _state.value .b * ref.value .prev_input_Odd ; ref.value .var += ref.value .prev_Odd ; ref.value .prev_input_Odd = smoothedValue; ref.value .var *= adjustedPrevPeriod; } ;
         { struct TA_HT_DCPERIOD_HILBERT_STRUCT * ref; ref = (struct TA_HT_DCPERIOD_HILBERT_STRUCT *) _state.value .Q1; hilbertTempReal = _state.value .a * (struct TA_HT_DCPERIOD_HILBERT_STRUCT *) _state.value .detrender.value .var ; ref.value .var = - ref.value ._Odd [ _state.value .hilbertIdx]; ref.value ._Odd [ _state.value .hilbertIdx] = hilbertTempReal; ref.value .var += hilbertTempReal; ref.value .var -= ref.value .prev_Odd ; ref.value .prev_Odd = _state.value .b * ref.value .prev_input_Odd ; ref.value .var += ref.value .prev_Odd ; ref.value .prev_input_Odd = (struct TA_HT_DCPERIOD_HILBERT_STRUCT *) _state.value .detrender.value .var ; ref.value .var *= adjustedPrevPeriod; } ;
         { struct TA_HT_DCPERIOD_HILBERT_STRUCT * ref; ref = (struct TA_HT_DCPERIOD_HILBERT_STRUCT *) _state.value .jI; hilbertTempReal = _state.value .a * _state.value .I1ForOddPrev3; ref.value .var = - ref.value ._Odd [ _state.value .hilbertIdx]; ref.value ._Odd [ _state.value .hilbertIdx] = hilbertTempReal; ref.value .var += hilbertTempReal; ref.value .var -= ref.value .prev_Odd ; ref.value .prev_Odd = _state.value .b * ref.value .prev_input_Odd ; ref.value .var += ref.value .prev_Odd ; ref.value .prev_input_Odd = _state.value .I1ForOddPrev3; ref.value .var *= adjustedPrevPeriod; } ;
         { struct TA_HT_DCPERIOD_HILBERT_STRUCT * ref; ref = (struct TA_HT_DCPERIOD_HILBERT_STRUCT *) _state.value .jQ; hilbertTempReal = _state.value .a * (struct TA_HT_DCPERIOD_HILBERT_STRUCT *) _state.value .Q1.value .var ; ref.value .var = - ref.value ._Odd [ _state.value .hilbertIdx]; ref.value ._Odd [ _state.value .hilbertIdx] = hilbertTempReal; ref.value .var += hilbertTempReal; ref.value .var -= ref.value .prev_Odd ; ref.value .prev_Odd = _state.value .b * ref.value .prev_input_Odd ; ref.value .var += ref.value .prev_Odd ; ref.value .prev_input_Odd = (struct TA_HT_DCPERIOD_HILBERT_STRUCT *) _state.value .Q1.value .var ; ref.value .var *= adjustedPrevPeriod; } ;
         Q2 = (0.2*( (struct TA_HT_DCPERIOD_HILBERT_STRUCT *) _state.value .Q1.value .var + (struct TA_HT_DCPERIOD_HILBERT_STRUCT *) _state.value .jI.value .var )) + (0.8* _state.value .prevQ2);
         I2 = (0.2*( _state.value .I1ForOddPrev3 - (struct TA_HT_DCPERIOD_HILBERT_STRUCT *) _state.value .jQ.value .var )) + (0.8* _state.value .prevI2);
         _state.value .I1ForEvenPrev3 = _state.value .I1ForEvenPrev2;
         _state.value .I1ForEvenPrev2 = (struct TA_HT_DCPERIOD_HILBERT_STRUCT *) _state.value .detrender.value .var ;
      }
      _state.value .Re = (0.2*((I2* _state.value .prevI2)+(Q2* _state.value .prevQ2)))+(0.8* _state.value .Re);
      _state.value .Im = (0.2*((I2* _state.value .prevQ2)-(Q2* _state.value .prevI2)))+(0.8* _state.value .Im);
      _state.value .prevQ2 = Q2;
      _state.value .prevI2 = I2;
      tempReal = _state.value .period;
      if( ( _state.value .Im != 0.0) && ( _state.value .Re != 0.0) )
         _state.value .period = 360.0 / ( Math.atan ( _state.value .Im/ _state.value .Re)* _state.value .rad2Deg);
      tempReal2 = 1.5*tempReal;
      if( _state.value .period > tempReal2)
         _state.value .period = tempReal2;
      tempReal2 = 0.67*tempReal;
      if( _state.value .period < tempReal2 )
         _state.value .period = tempReal2;
      if( _state.value .period < 6 )
         _state.value .period = 6;
      else if( _state.value .period > 50 )
         _state.value .period = 50;
      _state.value .period = (0.2* _state.value .period) + (0.8 * tempReal);
      _state.value .smoothPeriod = (0.33* _state.value .period)+(0.67* _state.value .smoothPeriod);
      ( _state.value .memory+_cur_idx).value .inReal = inReal ;
      if ( _state.value .mem_size > _state.value .mem_index - 1 )
         return RetCode.NeedMoreData ;
      else {
         outReal.value = _state.value .smoothPeriod;
         return RetCode.Success ;
      }
   }
   public int htDcPeriodStateFree( struct TA_htDcPeriod_State** _state )
   {
      { if ( _state.value .value .detrender != NULL) { free ( _state.value .value .detrender); _state.value .value .detrender = NULL; } } ;
      { if ( _state.value .value .Q1 != NULL) { free ( _state.value .value .Q1); _state.value .value .Q1 = NULL; } } ;
      { if ( _state.value .value .jI != NULL) { free ( _state.value .value .jI); _state.value .value .jI = NULL; } } ;
      { if ( _state.value .value .jQ != NULL) { free ( _state.value .value .jQ); _state.value .value .jQ = NULL; } } ;
      if (_state == NULL)
         return RetCode.BadParam ;
      if ( _state.value != NULL) {
         if ( _state.value .value .memory != NULL) TA_Free( _state.value .value .memory );
         TA_Free( _state.value ); _state.value = NULL;}
      return RetCode.Success ;
   }
   public RetCode htDcPeriod( int startIdx,
      int endIdx,
      float inReal[],
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      int outIdx, i;
      int lookbackTotal, today;
      double tempReal, tempReal2;
      double adjustedPrevPeriod, period;
      int trailingWMAIdx;
      double periodWMASum, periodWMASub, trailingWMAValue;
      double smoothedValue;
      final double a = 0.0962;
      final double b = 0.5769;
      double hilbertTempReal;
      int hilbertIdx;
      double []detrender_Odd = new double[3] ; double []detrender_Even = new double[3] ; double detrender; double prev_detrender_Odd ; double prev_detrender_Even ; double prev_detrender_input_Odd ; double prev_detrender_input_Even ;
      double []Q1_Odd = new double[3] ; double []Q1_Even = new double[3] ; double Q1; double prev_Q1_Odd ; double prev_Q1_Even ; double prev_Q1_input_Odd ; double prev_Q1_input_Even ;
      double []jI_Odd = new double[3] ; double []jI_Even = new double[3] ; double jI; double prev_jI_Odd ; double prev_jI_Even ; double prev_jI_input_Odd ; double prev_jI_input_Even ;
      double []jQ_Odd = new double[3] ; double []jQ_Even = new double[3] ; double jQ; double prev_jQ_Odd ; double prev_jQ_Even ; double prev_jQ_input_Odd ; double prev_jQ_input_Even ;
      double Q2, I2, prevQ2, prevI2, Re, Im;
      double I1ForOddPrev2, I1ForOddPrev3;
      double I1ForEvenPrev2, I1ForEvenPrev3;
      double rad2Deg;
      double todayValue, smoothPeriod;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      rad2Deg = 180.0 / (4.0 * Math.atan (1));
      lookbackTotal = 32 + (this.unstablePeriod[FuncUnstId.HtDcPeriod.ordinal()]) ;
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      outBegIdx.value = startIdx;
      trailingWMAIdx = startIdx - lookbackTotal;
      today = trailingWMAIdx;
      tempReal = inReal[today++];
      periodWMASub = tempReal;
      periodWMASum = tempReal;
      tempReal = inReal[today++];
      periodWMASub += tempReal;
      periodWMASum += tempReal*2.0;
      tempReal = inReal[today++];
      periodWMASub += tempReal;
      periodWMASum += tempReal*3.0;
      trailingWMAValue = 0.0;
      i = 9;
      do
      {
         tempReal = inReal[today++];
         { periodWMASub += tempReal; periodWMASub -= trailingWMAValue; periodWMASum += tempReal*4.0; trailingWMAValue = inReal[trailingWMAIdx++]; smoothedValue = periodWMASum*0.1; periodWMASum -= periodWMASub; } ;
      } while( --i != 0);
      hilbertIdx = 0;
      { detrender_Odd [0] = 0.0; detrender_Odd [1] = 0.0; detrender_Odd [2] = 0.0; detrender_Even [0] = 0.0; detrender_Even [1] = 0.0; detrender_Even [2] = 0.0; detrender = 0.0; prev_detrender_Odd = 0.0; prev_detrender_Even = 0.0; prev_detrender_input_Odd = 0.0; prev_detrender_input_Even = 0.0; } ;
      { Q1_Odd [0] = 0.0; Q1_Odd [1] = 0.0; Q1_Odd [2] = 0.0; Q1_Even [0] = 0.0; Q1_Even [1] = 0.0; Q1_Even [2] = 0.0; Q1 = 0.0; prev_Q1_Odd = 0.0; prev_Q1_Even = 0.0; prev_Q1_input_Odd = 0.0; prev_Q1_input_Even = 0.0; } ;
      { jI_Odd [0] = 0.0; jI_Odd [1] = 0.0; jI_Odd [2] = 0.0; jI_Even [0] = 0.0; jI_Even [1] = 0.0; jI_Even [2] = 0.0; jI = 0.0; prev_jI_Odd = 0.0; prev_jI_Even = 0.0; prev_jI_input_Odd = 0.0; prev_jI_input_Even = 0.0; } ;
      { jQ_Odd [0] = 0.0; jQ_Odd [1] = 0.0; jQ_Odd [2] = 0.0; jQ_Even [0] = 0.0; jQ_Even [1] = 0.0; jQ_Even [2] = 0.0; jQ = 0.0; prev_jQ_Odd = 0.0; prev_jQ_Even = 0.0; prev_jQ_input_Odd = 0.0; prev_jQ_input_Even = 0.0; } ;
      period = 0.0;
      outIdx = 0;
      prevI2 = prevQ2 = 0.0;
      Re = Im = 0.0;
      I1ForOddPrev3 = I1ForEvenPrev3 = 0.0;
      I1ForOddPrev2 = I1ForEvenPrev2 = 0.0;
      smoothPeriod = 0.0;
      while( today <= endIdx )
      {
         adjustedPrevPeriod = (0.075*period)+0.54;
         todayValue = inReal[today];
         { periodWMASub += todayValue; periodWMASub -= trailingWMAValue; periodWMASum += todayValue*4.0; trailingWMAValue = inReal[trailingWMAIdx++]; smoothedValue = periodWMASum*0.1; periodWMASum -= periodWMASub; } ;
         if( (today%2) == 0 )
         {
            { hilbertTempReal = a * smoothedValue; detrender = -detrender_Even [hilbertIdx]; detrender_Even [hilbertIdx] = hilbertTempReal; detrender += hilbertTempReal; detrender -= prev_detrender_Even ; prev_detrender_Even = b * prev_detrender_input_Even ; detrender += prev_detrender_Even ; prev_detrender_input_Even = smoothedValue; detrender *= adjustedPrevPeriod; } ;
            { hilbertTempReal = a * detrender; Q1 = -Q1_Even [hilbertIdx]; Q1_Even [hilbertIdx] = hilbertTempReal; Q1 += hilbertTempReal; Q1 -= prev_Q1_Even ; prev_Q1_Even = b * prev_Q1_input_Even ; Q1 += prev_Q1_Even ; prev_Q1_input_Even = detrender; Q1 *= adjustedPrevPeriod; } ;
            { hilbertTempReal = a * I1ForEvenPrev3; jI = -jI_Even [hilbertIdx]; jI_Even [hilbertIdx] = hilbertTempReal; jI += hilbertTempReal; jI -= prev_jI_Even ; prev_jI_Even = b * prev_jI_input_Even ; jI += prev_jI_Even ; prev_jI_input_Even = I1ForEvenPrev3; jI *= adjustedPrevPeriod; } ;
            { hilbertTempReal = a * Q1; jQ = -jQ_Even [hilbertIdx]; jQ_Even [hilbertIdx] = hilbertTempReal; jQ += hilbertTempReal; jQ -= prev_jQ_Even ; prev_jQ_Even = b * prev_jQ_input_Even ; jQ += prev_jQ_Even ; prev_jQ_input_Even = Q1; jQ *= adjustedPrevPeriod; } ;
            if( ++hilbertIdx == 3 )
               hilbertIdx = 0;
            Q2 = (0.2*(Q1 + jI)) + (0.8*prevQ2);
            I2 = (0.2*(I1ForEvenPrev3 - jQ)) + (0.8*prevI2);
            I1ForOddPrev3 = I1ForOddPrev2;
            I1ForOddPrev2 = detrender;
         }
         else
         {
            { hilbertTempReal = a * smoothedValue; detrender = -detrender_Odd [hilbertIdx]; detrender_Odd [hilbertIdx] = hilbertTempReal; detrender += hilbertTempReal; detrender -= prev_detrender_Odd ; prev_detrender_Odd = b * prev_detrender_input_Odd ; detrender += prev_detrender_Odd ; prev_detrender_input_Odd = smoothedValue; detrender *= adjustedPrevPeriod; } ;
            { hilbertTempReal = a * detrender; Q1 = -Q1_Odd [hilbertIdx]; Q1_Odd [hilbertIdx] = hilbertTempReal; Q1 += hilbertTempReal; Q1 -= prev_Q1_Odd ; prev_Q1_Odd = b * prev_Q1_input_Odd ; Q1 += prev_Q1_Odd ; prev_Q1_input_Odd = detrender; Q1 *= adjustedPrevPeriod; } ;
            { hilbertTempReal = a * I1ForOddPrev3; jI = -jI_Odd [hilbertIdx]; jI_Odd [hilbertIdx] = hilbertTempReal; jI += hilbertTempReal; jI -= prev_jI_Odd ; prev_jI_Odd = b * prev_jI_input_Odd ; jI += prev_jI_Odd ; prev_jI_input_Odd = I1ForOddPrev3; jI *= adjustedPrevPeriod; } ;
            { hilbertTempReal = a * Q1; jQ = -jQ_Odd [hilbertIdx]; jQ_Odd [hilbertIdx] = hilbertTempReal; jQ += hilbertTempReal; jQ -= prev_jQ_Odd ; prev_jQ_Odd = b * prev_jQ_input_Odd ; jQ += prev_jQ_Odd ; prev_jQ_input_Odd = Q1; jQ *= adjustedPrevPeriod; } ;
            Q2 = (0.2*(Q1 + jI)) + (0.8*prevQ2);
            I2 = (0.2*(I1ForOddPrev3 - jQ)) + (0.8*prevI2);
            I1ForEvenPrev3 = I1ForEvenPrev2;
            I1ForEvenPrev2 = detrender;
         }
         Re = (0.2*((I2*prevI2)+(Q2*prevQ2)))+(0.8*Re);
         Im = (0.2*((I2*prevQ2)-(Q2*prevI2)))+(0.8*Im);
         prevQ2 = Q2;
         prevI2 = I2;
         tempReal = period;
         if( (Im != 0.0) && (Re != 0.0) )
            period = 360.0 / ( Math.atan (Im/Re)*rad2Deg);
         tempReal2 = 1.5*tempReal;
         if( period > tempReal2)
            period = tempReal2;
         tempReal2 = 0.67*tempReal;
         if( period < tempReal2 )
            period = tempReal2;
         if( period < 6 )
            period = 6;
         else if( period > 50 )
            period = 50;
         period = (0.2*period) + (0.8 * tempReal);
         smoothPeriod = (0.33*period)+(0.67*smoothPeriod);
         if( today >= startIdx )
         {
            outReal[outIdx++] = smoothPeriod;
         }
         today++;
      }
      outNBElement.value = outIdx;
      return RetCode.Success ;
   }
   /* Generated */
   public int htDcPhaseLookback( )
   {
      return 63 + (this.unstablePeriod[FuncUnstId.HtDcPhase.ordinal()]) ;
   }
   public RetCode htDcPhase( int startIdx,
      int endIdx,
      double inReal[],
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      int outIdx, i;
      int lookbackTotal, today;
      double tempReal, tempReal2;
      double adjustedPrevPeriod, period;
      int trailingWMAIdx;
      double periodWMASum, periodWMASub, trailingWMAValue;
      double smoothedValue;
      final double a = 0.0962;
      final double b = 0.5769;
      double hilbertTempReal;
      int hilbertIdx;
      double []detrender_Odd = new double[3] ; double []detrender_Even = new double[3] ; double detrender; double prev_detrender_Odd ; double prev_detrender_Even ; double prev_detrender_input_Odd ; double prev_detrender_input_Even ;
      double []Q1_Odd = new double[3] ; double []Q1_Even = new double[3] ; double Q1; double prev_Q1_Odd ; double prev_Q1_Even ; double prev_Q1_input_Odd ; double prev_Q1_input_Even ;
      double []jI_Odd = new double[3] ; double []jI_Even = new double[3] ; double jI; double prev_jI_Odd ; double prev_jI_Even ; double prev_jI_input_Odd ; double prev_jI_input_Even ;
      double []jQ_Odd = new double[3] ; double []jQ_Even = new double[3] ; double jQ; double prev_jQ_Odd ; double prev_jQ_Even ; double prev_jQ_input_Odd ; double prev_jQ_input_Even ;
      double Q2, I2, prevQ2, prevI2, Re, Im;
      double I1ForOddPrev2, I1ForOddPrev3;
      double I1ForEvenPrev2, I1ForEvenPrev3;
      double rad2Deg, constDeg2RadBy360;
      double todayValue, smoothPeriod;
      int smoothPrice_Idx = 0; double []smoothPrice; int maxIdx_smoothPrice = ( 50 -1) ;
      int idx;
      int DCPeriodInt;
      double DCPhase, DCPeriod, imagPart, realPart;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      { smoothPrice = new double[maxIdx_smoothPrice +1]; } ;
      tempReal = Math.atan (1);
      rad2Deg = 45.0/tempReal;
      constDeg2RadBy360 = tempReal*8.0;
      lookbackTotal = 63 + (this.unstablePeriod[FuncUnstId.HtDcPhase.ordinal()]) ;
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      outBegIdx.value = startIdx;
      trailingWMAIdx = startIdx - lookbackTotal;
      today = trailingWMAIdx;
      tempReal = inReal[today++];
      periodWMASub = tempReal;
      periodWMASum = tempReal;
      tempReal = inReal[today++];
      periodWMASub += tempReal;
      periodWMASum += tempReal*2.0;
      tempReal = inReal[today++];
      periodWMASub += tempReal;
      periodWMASum += tempReal*3.0;
      trailingWMAValue = 0.0;
      i = 34;
      do
      {
         tempReal = inReal[today++];
         { periodWMASub += tempReal; periodWMASub -= trailingWMAValue; periodWMASum += tempReal*4.0; trailingWMAValue = inReal[trailingWMAIdx++]; smoothedValue = periodWMASum*0.1; periodWMASum -= periodWMASub; } ;
      } while( --i != 0);
      hilbertIdx = 0;
      { detrender_Odd [0] = 0.0; detrender_Odd [1] = 0.0; detrender_Odd [2] = 0.0; detrender_Even [0] = 0.0; detrender_Even [1] = 0.0; detrender_Even [2] = 0.0; detrender = 0.0; prev_detrender_Odd = 0.0; prev_detrender_Even = 0.0; prev_detrender_input_Odd = 0.0; prev_detrender_input_Even = 0.0; } ;
      { Q1_Odd [0] = 0.0; Q1_Odd [1] = 0.0; Q1_Odd [2] = 0.0; Q1_Even [0] = 0.0; Q1_Even [1] = 0.0; Q1_Even [2] = 0.0; Q1 = 0.0; prev_Q1_Odd = 0.0; prev_Q1_Even = 0.0; prev_Q1_input_Odd = 0.0; prev_Q1_input_Even = 0.0; } ;
      { jI_Odd [0] = 0.0; jI_Odd [1] = 0.0; jI_Odd [2] = 0.0; jI_Even [0] = 0.0; jI_Even [1] = 0.0; jI_Even [2] = 0.0; jI = 0.0; prev_jI_Odd = 0.0; prev_jI_Even = 0.0; prev_jI_input_Odd = 0.0; prev_jI_input_Even = 0.0; } ;
      { jQ_Odd [0] = 0.0; jQ_Odd [1] = 0.0; jQ_Odd [2] = 0.0; jQ_Even [0] = 0.0; jQ_Even [1] = 0.0; jQ_Even [2] = 0.0; jQ = 0.0; prev_jQ_Odd = 0.0; prev_jQ_Even = 0.0; prev_jQ_input_Odd = 0.0; prev_jQ_input_Even = 0.0; } ;
      period = 0.0;
      outIdx = 0;
      prevI2 = prevQ2 = 0.0;
      Re = Im = 0.0;
      I1ForOddPrev3 = I1ForEvenPrev3 = 0.0;
      I1ForOddPrev2 = I1ForEvenPrev2 = 0.0;
      smoothPeriod = 0.0;
      for( i=0; i < 50 ; i++ )
         smoothPrice[i] = 0.0;
      DCPhase = 0.0;
      while( today <= endIdx )
      {
         adjustedPrevPeriod = (0.075*period)+0.54;
         todayValue = inReal[today];
         { periodWMASub += todayValue; periodWMASub -= trailingWMAValue; periodWMASum += todayValue*4.0; trailingWMAValue = inReal[trailingWMAIdx++]; smoothedValue = periodWMASum*0.1; periodWMASum -= periodWMASub; } ;
         smoothPrice[smoothPrice_Idx] = smoothedValue;
         if( (today%2) == 0 )
         {
            { hilbertTempReal = a * smoothedValue; detrender = -detrender_Even [hilbertIdx]; detrender_Even [hilbertIdx] = hilbertTempReal; detrender += hilbertTempReal; detrender -= prev_detrender_Even ; prev_detrender_Even = b * prev_detrender_input_Even ; detrender += prev_detrender_Even ; prev_detrender_input_Even = smoothedValue; detrender *= adjustedPrevPeriod; } ;
            { hilbertTempReal = a * detrender; Q1 = -Q1_Even [hilbertIdx]; Q1_Even [hilbertIdx] = hilbertTempReal; Q1 += hilbertTempReal; Q1 -= prev_Q1_Even ; prev_Q1_Even = b * prev_Q1_input_Even ; Q1 += prev_Q1_Even ; prev_Q1_input_Even = detrender; Q1 *= adjustedPrevPeriod; } ;
            { hilbertTempReal = a * I1ForEvenPrev3; jI = -jI_Even [hilbertIdx]; jI_Even [hilbertIdx] = hilbertTempReal; jI += hilbertTempReal; jI -= prev_jI_Even ; prev_jI_Even = b * prev_jI_input_Even ; jI += prev_jI_Even ; prev_jI_input_Even = I1ForEvenPrev3; jI *= adjustedPrevPeriod; } ;
            { hilbertTempReal = a * Q1; jQ = -jQ_Even [hilbertIdx]; jQ_Even [hilbertIdx] = hilbertTempReal; jQ += hilbertTempReal; jQ -= prev_jQ_Even ; prev_jQ_Even = b * prev_jQ_input_Even ; jQ += prev_jQ_Even ; prev_jQ_input_Even = Q1; jQ *= adjustedPrevPeriod; } ;
            if( ++hilbertIdx == 3 )
               hilbertIdx = 0;
            Q2 = (0.2*(Q1 + jI)) + (0.8*prevQ2);
            I2 = (0.2*(I1ForEvenPrev3 - jQ)) + (0.8*prevI2);
            I1ForOddPrev3 = I1ForOddPrev2;
            I1ForOddPrev2 = detrender;
         }
         else
         {
            { hilbertTempReal = a * smoothedValue; detrender = -detrender_Odd [hilbertIdx]; detrender_Odd [hilbertIdx] = hilbertTempReal; detrender += hilbertTempReal; detrender -= prev_detrender_Odd ; prev_detrender_Odd = b * prev_detrender_input_Odd ; detrender += prev_detrender_Odd ; prev_detrender_input_Odd = smoothedValue; detrender *= adjustedPrevPeriod; } ;
            { hilbertTempReal = a * detrender; Q1 = -Q1_Odd [hilbertIdx]; Q1_Odd [hilbertIdx] = hilbertTempReal; Q1 += hilbertTempReal; Q1 -= prev_Q1_Odd ; prev_Q1_Odd = b * prev_Q1_input_Odd ; Q1 += prev_Q1_Odd ; prev_Q1_input_Odd = detrender; Q1 *= adjustedPrevPeriod; } ;
            { hilbertTempReal = a * I1ForOddPrev3; jI = -jI_Odd [hilbertIdx]; jI_Odd [hilbertIdx] = hilbertTempReal; jI += hilbertTempReal; jI -= prev_jI_Odd ; prev_jI_Odd = b * prev_jI_input_Odd ; jI += prev_jI_Odd ; prev_jI_input_Odd = I1ForOddPrev3; jI *= adjustedPrevPeriod; } ;
            { hilbertTempReal = a * Q1; jQ = -jQ_Odd [hilbertIdx]; jQ_Odd [hilbertIdx] = hilbertTempReal; jQ += hilbertTempReal; jQ -= prev_jQ_Odd ; prev_jQ_Odd = b * prev_jQ_input_Odd ; jQ += prev_jQ_Odd ; prev_jQ_input_Odd = Q1; jQ *= adjustedPrevPeriod; } ;
            Q2 = (0.2*(Q1 + jI)) + (0.8*prevQ2);
            I2 = (0.2*(I1ForOddPrev3 - jQ)) + (0.8*prevI2);
            I1ForEvenPrev3 = I1ForEvenPrev2;
            I1ForEvenPrev2 = detrender;
         }
         Re = (0.2*((I2*prevI2)+(Q2*prevQ2)))+(0.8*Re);
         Im = (0.2*((I2*prevQ2)-(Q2*prevI2)))+(0.8*Im);
         prevQ2 = Q2;
         prevI2 = I2;
         tempReal = period;
         if( (Im != 0.0) && (Re != 0.0) )
            period = 360.0 / ( Math.atan (Im/Re)*rad2Deg);
         tempReal2 = 1.5*tempReal;
         if( period > tempReal2)
            period = tempReal2;
         tempReal2 = 0.67*tempReal;
         if( period < tempReal2 )
            period = tempReal2;
         if( period < 6 )
            period = 6;
         else if( period > 50 )
            period = 50;
         period = (0.2*period) + (0.8 * tempReal);
         smoothPeriod = (0.33*period)+(0.67*smoothPeriod);
         DCPeriod = smoothPeriod+0.5;
         DCPeriodInt = (int)DCPeriod;
         realPart = 0.0;
         imagPart = 0.0;
         idx = smoothPrice_Idx;
         for( i=0; i < DCPeriodInt; i++ )
         {
            tempReal = ((double)i*constDeg2RadBy360)/(double)DCPeriodInt;
            tempReal2 = smoothPrice[idx];
            realPart += Math.sin (tempReal)*tempReal2;
            imagPart += Math.cos (tempReal)*tempReal2;
            if( idx == 0 )
               idx = 50 -1;
            else
               idx--;
         }
         tempReal = Math.abs (imagPart);
         if( tempReal > 0.0 )
            DCPhase = Math.atan (realPart/imagPart)*rad2Deg;
         else if( tempReal <= 0.01 )
         {
            if( realPart < 0.0 )
               DCPhase -= 90.0;
            else if( realPart > 0.0 )
               DCPhase += 90.0;
         }
         DCPhase += 90.0;
         DCPhase += 360.0 / smoothPeriod;
         if( imagPart < 0.0 )
            DCPhase += 180.0;
         if( DCPhase > 315.0 )
            DCPhase -= 360.0;
         if( today >= startIdx )
         {
            outReal[outIdx++] = DCPhase;
         }
         { smoothPrice_Idx ++; if( smoothPrice_Idx > maxIdx_smoothPrice ) smoothPrice_Idx = 0; } ;
         today++;
      }
      outNBElement.value = outIdx;
      return RetCode.Success ;
   }
   public int htDcPhaseStateInit( struct TA_htDcPhase_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct htDcPhase ));
      _state.value .value .mem_index = 0;
      _state.value .value .mem_size = htDcPhaseLookback ();
      if ( _state.value .value .mem_size > 0)
         _state.value .value .memory = TA_Calloc( _state.value .value .mem_size , sizeof(struct TA_HT_DCPHASE_Data));
      else
         _state.value .value .memory = NULL;
      return RetCode.Success ;
   }
   public int htDcPhaseState( struct TA_htDcPhase_State* _state,
      double inReal,
      double *outReal )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      size_t _cur_idx = _state.value .mem_index++;
      if ( _state.value .mem_size > 0) _cur_idx %= _state.value .mem_size ;
      if ( _state.value .mem_size > _state.value .mem_index - 1 ) {
         ( _state.value .memory+_cur_idx).value .inReal = inReal ;
         return RetCode.NeedMoreData ; }
      return RetCode.Success ;
   }
   public int htDcPhaseStateFree( struct TA_htDcPhase_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if ( _state.value != NULL) {
         if ( _state.value .value .memory != NULL) TA_Free( _state.value .value .memory );
         TA_Free( _state.value ); _state.value = NULL;}
      return RetCode.Success ;
   }
   public RetCode htDcPhase( int startIdx,
      int endIdx,
      float inReal[],
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      int outIdx, i;
      int lookbackTotal, today;
      double tempReal, tempReal2;
      double adjustedPrevPeriod, period;
      int trailingWMAIdx;
      double periodWMASum, periodWMASub, trailingWMAValue;
      double smoothedValue;
      final double a = 0.0962;
      final double b = 0.5769;
      double hilbertTempReal;
      int hilbertIdx;
      double []detrender_Odd = new double[3] ; double []detrender_Even = new double[3] ; double detrender; double prev_detrender_Odd ; double prev_detrender_Even ; double prev_detrender_input_Odd ; double prev_detrender_input_Even ;
      double []Q1_Odd = new double[3] ; double []Q1_Even = new double[3] ; double Q1; double prev_Q1_Odd ; double prev_Q1_Even ; double prev_Q1_input_Odd ; double prev_Q1_input_Even ;
      double []jI_Odd = new double[3] ; double []jI_Even = new double[3] ; double jI; double prev_jI_Odd ; double prev_jI_Even ; double prev_jI_input_Odd ; double prev_jI_input_Even ;
      double []jQ_Odd = new double[3] ; double []jQ_Even = new double[3] ; double jQ; double prev_jQ_Odd ; double prev_jQ_Even ; double prev_jQ_input_Odd ; double prev_jQ_input_Even ;
      double Q2, I2, prevQ2, prevI2, Re, Im;
      double I1ForOddPrev2, I1ForOddPrev3;
      double I1ForEvenPrev2, I1ForEvenPrev3;
      double rad2Deg, constDeg2RadBy360;
      double todayValue, smoothPeriod;
      int smoothPrice_Idx = 0; double []smoothPrice; int maxIdx_smoothPrice = ( 50 -1) ;
      int idx;
      int DCPeriodInt;
      double DCPhase, DCPeriod, imagPart, realPart;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      { smoothPrice = new double[maxIdx_smoothPrice +1]; } ;
      tempReal = Math.atan (1);
      rad2Deg = 45.0/tempReal;
      constDeg2RadBy360 = tempReal*8.0;
      lookbackTotal = 63 + (this.unstablePeriod[FuncUnstId.HtDcPhase.ordinal()]) ;
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      outBegIdx.value = startIdx;
      trailingWMAIdx = startIdx - lookbackTotal;
      today = trailingWMAIdx;
      tempReal = inReal[today++];
      periodWMASub = tempReal;
      periodWMASum = tempReal;
      tempReal = inReal[today++];
      periodWMASub += tempReal;
      periodWMASum += tempReal*2.0;
      tempReal = inReal[today++];
      periodWMASub += tempReal;
      periodWMASum += tempReal*3.0;
      trailingWMAValue = 0.0;
      i = 34;
      do
      {
         tempReal = inReal[today++];
         { periodWMASub += tempReal; periodWMASub -= trailingWMAValue; periodWMASum += tempReal*4.0; trailingWMAValue = inReal[trailingWMAIdx++]; smoothedValue = periodWMASum*0.1; periodWMASum -= periodWMASub; } ;
      } while( --i != 0);
      hilbertIdx = 0;
      { detrender_Odd [0] = 0.0; detrender_Odd [1] = 0.0; detrender_Odd [2] = 0.0; detrender_Even [0] = 0.0; detrender_Even [1] = 0.0; detrender_Even [2] = 0.0; detrender = 0.0; prev_detrender_Odd = 0.0; prev_detrender_Even = 0.0; prev_detrender_input_Odd = 0.0; prev_detrender_input_Even = 0.0; } ;
      { Q1_Odd [0] = 0.0; Q1_Odd [1] = 0.0; Q1_Odd [2] = 0.0; Q1_Even [0] = 0.0; Q1_Even [1] = 0.0; Q1_Even [2] = 0.0; Q1 = 0.0; prev_Q1_Odd = 0.0; prev_Q1_Even = 0.0; prev_Q1_input_Odd = 0.0; prev_Q1_input_Even = 0.0; } ;
      { jI_Odd [0] = 0.0; jI_Odd [1] = 0.0; jI_Odd [2] = 0.0; jI_Even [0] = 0.0; jI_Even [1] = 0.0; jI_Even [2] = 0.0; jI = 0.0; prev_jI_Odd = 0.0; prev_jI_Even = 0.0; prev_jI_input_Odd = 0.0; prev_jI_input_Even = 0.0; } ;
      { jQ_Odd [0] = 0.0; jQ_Odd [1] = 0.0; jQ_Odd [2] = 0.0; jQ_Even [0] = 0.0; jQ_Even [1] = 0.0; jQ_Even [2] = 0.0; jQ = 0.0; prev_jQ_Odd = 0.0; prev_jQ_Even = 0.0; prev_jQ_input_Odd = 0.0; prev_jQ_input_Even = 0.0; } ;
      period = 0.0;
      outIdx = 0;
      prevI2 = prevQ2 = 0.0;
      Re = Im = 0.0;
      I1ForOddPrev3 = I1ForEvenPrev3 = 0.0;
      I1ForOddPrev2 = I1ForEvenPrev2 = 0.0;
      smoothPeriod = 0.0;
      for( i=0; i < 50 ; i++ )
         smoothPrice[i] = 0.0;
      DCPhase = 0.0;
      while( today <= endIdx )
      {
         adjustedPrevPeriod = (0.075*period)+0.54;
         todayValue = inReal[today];
         { periodWMASub += todayValue; periodWMASub -= trailingWMAValue; periodWMASum += todayValue*4.0; trailingWMAValue = inReal[trailingWMAIdx++]; smoothedValue = periodWMASum*0.1; periodWMASum -= periodWMASub; } ;
         smoothPrice[smoothPrice_Idx] = smoothedValue;
         if( (today%2) == 0 )
         {
            { hilbertTempReal = a * smoothedValue; detrender = -detrender_Even [hilbertIdx]; detrender_Even [hilbertIdx] = hilbertTempReal; detrender += hilbertTempReal; detrender -= prev_detrender_Even ; prev_detrender_Even = b * prev_detrender_input_Even ; detrender += prev_detrender_Even ; prev_detrender_input_Even = smoothedValue; detrender *= adjustedPrevPeriod; } ;
            { hilbertTempReal = a * detrender; Q1 = -Q1_Even [hilbertIdx]; Q1_Even [hilbertIdx] = hilbertTempReal; Q1 += hilbertTempReal; Q1 -= prev_Q1_Even ; prev_Q1_Even = b * prev_Q1_input_Even ; Q1 += prev_Q1_Even ; prev_Q1_input_Even = detrender; Q1 *= adjustedPrevPeriod; } ;
            { hilbertTempReal = a * I1ForEvenPrev3; jI = -jI_Even [hilbertIdx]; jI_Even [hilbertIdx] = hilbertTempReal; jI += hilbertTempReal; jI -= prev_jI_Even ; prev_jI_Even = b * prev_jI_input_Even ; jI += prev_jI_Even ; prev_jI_input_Even = I1ForEvenPrev3; jI *= adjustedPrevPeriod; } ;
            { hilbertTempReal = a * Q1; jQ = -jQ_Even [hilbertIdx]; jQ_Even [hilbertIdx] = hilbertTempReal; jQ += hilbertTempReal; jQ -= prev_jQ_Even ; prev_jQ_Even = b * prev_jQ_input_Even ; jQ += prev_jQ_Even ; prev_jQ_input_Even = Q1; jQ *= adjustedPrevPeriod; } ;
            if( ++hilbertIdx == 3 )
               hilbertIdx = 0;
            Q2 = (0.2*(Q1 + jI)) + (0.8*prevQ2);
            I2 = (0.2*(I1ForEvenPrev3 - jQ)) + (0.8*prevI2);
            I1ForOddPrev3 = I1ForOddPrev2;
            I1ForOddPrev2 = detrender;
         }
         else
         {
            { hilbertTempReal = a * smoothedValue; detrender = -detrender_Odd [hilbertIdx]; detrender_Odd [hilbertIdx] = hilbertTempReal; detrender += hilbertTempReal; detrender -= prev_detrender_Odd ; prev_detrender_Odd = b * prev_detrender_input_Odd ; detrender += prev_detrender_Odd ; prev_detrender_input_Odd = smoothedValue; detrender *= adjustedPrevPeriod; } ;
            { hilbertTempReal = a * detrender; Q1 = -Q1_Odd [hilbertIdx]; Q1_Odd [hilbertIdx] = hilbertTempReal; Q1 += hilbertTempReal; Q1 -= prev_Q1_Odd ; prev_Q1_Odd = b * prev_Q1_input_Odd ; Q1 += prev_Q1_Odd ; prev_Q1_input_Odd = detrender; Q1 *= adjustedPrevPeriod; } ;
            { hilbertTempReal = a * I1ForOddPrev3; jI = -jI_Odd [hilbertIdx]; jI_Odd [hilbertIdx] = hilbertTempReal; jI += hilbertTempReal; jI -= prev_jI_Odd ; prev_jI_Odd = b * prev_jI_input_Odd ; jI += prev_jI_Odd ; prev_jI_input_Odd = I1ForOddPrev3; jI *= adjustedPrevPeriod; } ;
            { hilbertTempReal = a * Q1; jQ = -jQ_Odd [hilbertIdx]; jQ_Odd [hilbertIdx] = hilbertTempReal; jQ += hilbertTempReal; jQ -= prev_jQ_Odd ; prev_jQ_Odd = b * prev_jQ_input_Odd ; jQ += prev_jQ_Odd ; prev_jQ_input_Odd = Q1; jQ *= adjustedPrevPeriod; } ;
            Q2 = (0.2*(Q1 + jI)) + (0.8*prevQ2);
            I2 = (0.2*(I1ForOddPrev3 - jQ)) + (0.8*prevI2);
            I1ForEvenPrev3 = I1ForEvenPrev2;
            I1ForEvenPrev2 = detrender;
         }
         Re = (0.2*((I2*prevI2)+(Q2*prevQ2)))+(0.8*Re);
         Im = (0.2*((I2*prevQ2)-(Q2*prevI2)))+(0.8*Im);
         prevQ2 = Q2;
         prevI2 = I2;
         tempReal = period;
         if( (Im != 0.0) && (Re != 0.0) )
            period = 360.0 / ( Math.atan (Im/Re)*rad2Deg);
         tempReal2 = 1.5*tempReal;
         if( period > tempReal2)
            period = tempReal2;
         tempReal2 = 0.67*tempReal;
         if( period < tempReal2 )
            period = tempReal2;
         if( period < 6 )
            period = 6;
         else if( period > 50 )
            period = 50;
         period = (0.2*period) + (0.8 * tempReal);
         smoothPeriod = (0.33*period)+(0.67*smoothPeriod);
         DCPeriod = smoothPeriod+0.5;
         DCPeriodInt = (int)DCPeriod;
         realPart = 0.0;
         imagPart = 0.0;
         idx = smoothPrice_Idx;
         for( i=0; i < DCPeriodInt; i++ )
         {
            tempReal = ((double)i*constDeg2RadBy360)/(double)DCPeriodInt;
            tempReal2 = smoothPrice[idx];
            realPart += Math.sin (tempReal)*tempReal2;
            imagPart += Math.cos (tempReal)*tempReal2;
            if( idx == 0 )
               idx = 50 -1;
            else
               idx--;
         }
         tempReal = Math.abs (imagPart);
         if( tempReal > 0.0 )
            DCPhase = Math.atan (realPart/imagPart)*rad2Deg;
         else if( tempReal <= 0.01 )
         {
            if( realPart < 0.0 )
               DCPhase -= 90.0;
            else if( realPart > 0.0 )
               DCPhase += 90.0;
         }
         DCPhase += 90.0;
         DCPhase += 360.0 / smoothPeriod;
         if( imagPart < 0.0 )
            DCPhase += 180.0;
         if( DCPhase > 315.0 )
            DCPhase -= 360.0;
         if( today >= startIdx )
         {
            outReal[outIdx++] = DCPhase;
         }
         { smoothPrice_Idx ++; if( smoothPrice_Idx > maxIdx_smoothPrice ) smoothPrice_Idx = 0; } ;
         today++;
      }
      outNBElement.value = outIdx;
      return RetCode.Success ;
   }
   /* Generated */
   public int htPhasorLookback( )
   {
      return 32 + (this.unstablePeriod[FuncUnstId.HtPhasor.ordinal()]) ;
   }
   public RetCode htPhasor( int startIdx,
      int endIdx,
      double inReal[],
      MInteger outBegIdx,
      MInteger outNBElement,
      double outInPhase[],
      double outQuadrature[] )
   {
      int outIdx, i;
      int lookbackTotal, today;
      double tempReal, tempReal2;
      double adjustedPrevPeriod, period;
      int trailingWMAIdx;
      double periodWMASum, periodWMASub, trailingWMAValue;
      double smoothedValue;
      final double a = 0.0962;
      final double b = 0.5769;
      double hilbertTempReal;
      int hilbertIdx;
      double []detrender_Odd = new double[3] ; double []detrender_Even = new double[3] ; double detrender; double prev_detrender_Odd ; double prev_detrender_Even ; double prev_detrender_input_Odd ; double prev_detrender_input_Even ;
      double []Q1_Odd = new double[3] ; double []Q1_Even = new double[3] ; double Q1; double prev_Q1_Odd ; double prev_Q1_Even ; double prev_Q1_input_Odd ; double prev_Q1_input_Even ;
      double []jI_Odd = new double[3] ; double []jI_Even = new double[3] ; double jI; double prev_jI_Odd ; double prev_jI_Even ; double prev_jI_input_Odd ; double prev_jI_input_Even ;
      double []jQ_Odd = new double[3] ; double []jQ_Even = new double[3] ; double jQ; double prev_jQ_Odd ; double prev_jQ_Even ; double prev_jQ_input_Odd ; double prev_jQ_input_Even ;
      double Q2, I2, prevQ2, prevI2, Re, Im;
      double I1ForOddPrev2, I1ForOddPrev3;
      double I1ForEvenPrev2, I1ForEvenPrev3;
      double rad2Deg;
      double todayValue;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      rad2Deg = 180.0 / (4.0 * Math.atan (1));
      lookbackTotal = 32 + (this.unstablePeriod[FuncUnstId.HtPhasor.ordinal()]) ;
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      outBegIdx.value = startIdx;
      trailingWMAIdx = startIdx - lookbackTotal;
      today = trailingWMAIdx;
      tempReal = inReal[today++];
      periodWMASub = tempReal;
      periodWMASum = tempReal;
      tempReal = inReal[today++];
      periodWMASub += tempReal;
      periodWMASum += tempReal*2.0;
      tempReal = inReal[today++];
      periodWMASub += tempReal;
      periodWMASum += tempReal*3.0;
      trailingWMAValue = 0.0;
      i = 9;
      do
      {
         tempReal = inReal[today++];
         { periodWMASub += tempReal; periodWMASub -= trailingWMAValue; periodWMASum += tempReal*4.0; trailingWMAValue = inReal[trailingWMAIdx++]; smoothedValue = periodWMASum*0.1; periodWMASum -= periodWMASub; } ;
      } while( --i != 0);
      hilbertIdx = 0;
      { detrender_Odd [0] = 0.0; detrender_Odd [1] = 0.0; detrender_Odd [2] = 0.0; detrender_Even [0] = 0.0; detrender_Even [1] = 0.0; detrender_Even [2] = 0.0; detrender = 0.0; prev_detrender_Odd = 0.0; prev_detrender_Even = 0.0; prev_detrender_input_Odd = 0.0; prev_detrender_input_Even = 0.0; } ;
      { Q1_Odd [0] = 0.0; Q1_Odd [1] = 0.0; Q1_Odd [2] = 0.0; Q1_Even [0] = 0.0; Q1_Even [1] = 0.0; Q1_Even [2] = 0.0; Q1 = 0.0; prev_Q1_Odd = 0.0; prev_Q1_Even = 0.0; prev_Q1_input_Odd = 0.0; prev_Q1_input_Even = 0.0; } ;
      { jI_Odd [0] = 0.0; jI_Odd [1] = 0.0; jI_Odd [2] = 0.0; jI_Even [0] = 0.0; jI_Even [1] = 0.0; jI_Even [2] = 0.0; jI = 0.0; prev_jI_Odd = 0.0; prev_jI_Even = 0.0; prev_jI_input_Odd = 0.0; prev_jI_input_Even = 0.0; } ;
      { jQ_Odd [0] = 0.0; jQ_Odd [1] = 0.0; jQ_Odd [2] = 0.0; jQ_Even [0] = 0.0; jQ_Even [1] = 0.0; jQ_Even [2] = 0.0; jQ = 0.0; prev_jQ_Odd = 0.0; prev_jQ_Even = 0.0; prev_jQ_input_Odd = 0.0; prev_jQ_input_Even = 0.0; } ;
      period = 0.0;
      outIdx = 0;
      prevI2 = prevQ2 = 0.0;
      Re = Im = 0.0;
      I1ForOddPrev3 = I1ForEvenPrev3 = 0.0;
      I1ForOddPrev2 = I1ForEvenPrev2 = 0.0;
      while( today <= endIdx )
      {
         adjustedPrevPeriod = (0.075*period)+0.54;
         todayValue = inReal[today];
         { periodWMASub += todayValue; periodWMASub -= trailingWMAValue; periodWMASum += todayValue*4.0; trailingWMAValue = inReal[trailingWMAIdx++]; smoothedValue = periodWMASum*0.1; periodWMASum -= periodWMASub; } ;
         if( (today%2) == 0 )
         {
            { hilbertTempReal = a * smoothedValue; detrender = -detrender_Even [hilbertIdx]; detrender_Even [hilbertIdx] = hilbertTempReal; detrender += hilbertTempReal; detrender -= prev_detrender_Even ; prev_detrender_Even = b * prev_detrender_input_Even ; detrender += prev_detrender_Even ; prev_detrender_input_Even = smoothedValue; detrender *= adjustedPrevPeriod; } ;
            { hilbertTempReal = a * detrender; Q1 = -Q1_Even [hilbertIdx]; Q1_Even [hilbertIdx] = hilbertTempReal; Q1 += hilbertTempReal; Q1 -= prev_Q1_Even ; prev_Q1_Even = b * prev_Q1_input_Even ; Q1 += prev_Q1_Even ; prev_Q1_input_Even = detrender; Q1 *= adjustedPrevPeriod; } ;
            if( today >= startIdx )
            {
               outQuadrature[outIdx] = Q1;
               outInPhase[outIdx++] = I1ForEvenPrev3;
            }
            { hilbertTempReal = a * I1ForEvenPrev3; jI = -jI_Even [hilbertIdx]; jI_Even [hilbertIdx] = hilbertTempReal; jI += hilbertTempReal; jI -= prev_jI_Even ; prev_jI_Even = b * prev_jI_input_Even ; jI += prev_jI_Even ; prev_jI_input_Even = I1ForEvenPrev3; jI *= adjustedPrevPeriod; } ;
            { hilbertTempReal = a * Q1; jQ = -jQ_Even [hilbertIdx]; jQ_Even [hilbertIdx] = hilbertTempReal; jQ += hilbertTempReal; jQ -= prev_jQ_Even ; prev_jQ_Even = b * prev_jQ_input_Even ; jQ += prev_jQ_Even ; prev_jQ_input_Even = Q1; jQ *= adjustedPrevPeriod; } ;
            if( ++hilbertIdx == 3 )
               hilbertIdx = 0;
            Q2 = (0.2*(Q1 + jI)) + (0.8*prevQ2);
            I2 = (0.2*(I1ForEvenPrev3 - jQ)) + (0.8*prevI2);
            I1ForOddPrev3 = I1ForOddPrev2;
            I1ForOddPrev2 = detrender;
         }
         else
         {
            { hilbertTempReal = a * smoothedValue; detrender = -detrender_Odd [hilbertIdx]; detrender_Odd [hilbertIdx] = hilbertTempReal; detrender += hilbertTempReal; detrender -= prev_detrender_Odd ; prev_detrender_Odd = b * prev_detrender_input_Odd ; detrender += prev_detrender_Odd ; prev_detrender_input_Odd = smoothedValue; detrender *= adjustedPrevPeriod; } ;
            { hilbertTempReal = a * detrender; Q1 = -Q1_Odd [hilbertIdx]; Q1_Odd [hilbertIdx] = hilbertTempReal; Q1 += hilbertTempReal; Q1 -= prev_Q1_Odd ; prev_Q1_Odd = b * prev_Q1_input_Odd ; Q1 += prev_Q1_Odd ; prev_Q1_input_Odd = detrender; Q1 *= adjustedPrevPeriod; } ;
            if( today >= startIdx )
            {
               outQuadrature[outIdx] = Q1;
               outInPhase[outIdx++] = I1ForOddPrev3;
            }
            { hilbertTempReal = a * I1ForOddPrev3; jI = -jI_Odd [hilbertIdx]; jI_Odd [hilbertIdx] = hilbertTempReal; jI += hilbertTempReal; jI -= prev_jI_Odd ; prev_jI_Odd = b * prev_jI_input_Odd ; jI += prev_jI_Odd ; prev_jI_input_Odd = I1ForOddPrev3; jI *= adjustedPrevPeriod; } ;
            { hilbertTempReal = a * Q1; jQ = -jQ_Odd [hilbertIdx]; jQ_Odd [hilbertIdx] = hilbertTempReal; jQ += hilbertTempReal; jQ -= prev_jQ_Odd ; prev_jQ_Odd = b * prev_jQ_input_Odd ; jQ += prev_jQ_Odd ; prev_jQ_input_Odd = Q1; jQ *= adjustedPrevPeriod; } ;
            Q2 = (0.2*(Q1 + jI)) + (0.8*prevQ2);
            I2 = (0.2*(I1ForOddPrev3 - jQ)) + (0.8*prevI2);
            I1ForEvenPrev3 = I1ForEvenPrev2;
            I1ForEvenPrev2 = detrender;
         }
         Re = (0.2*((I2*prevI2)+(Q2*prevQ2)))+(0.8*Re);
         Im = (0.2*((I2*prevQ2)-(Q2*prevI2)))+(0.8*Im);
         prevQ2 = Q2;
         prevI2 = I2;
         tempReal = period;
         if( (Im != 0.0) && (Re != 0.0) )
            period = 360.0 / ( Math.atan (Im/Re)*rad2Deg);
         tempReal2 = 1.5*tempReal;
         if( period > tempReal2)
            period = tempReal2;
         tempReal2 = 0.67*tempReal;
         if( period < tempReal2 )
            period = tempReal2;
         if( period < 6 )
            period = 6;
         else if( period > 50 )
            period = 50;
         period = (0.2*period) + (0.8 * tempReal);
         today++;
      }
      outNBElement.value = outIdx;
      return RetCode.Success ;
   }
   struct TA_HT_PHASOR_HILBERT_STRUCT { double []_Odd = new double[3] ; double []_Even = new double[3] ; double var; double prev_Odd; double prev_Even; double prev_input_Odd; double prev_input_Even; };
   public int htPhasorStateInit( struct TA_htPhasor_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct htPhasor ));
      _state.value .value .mem_index = 0;
      _state.value .value .mem_size = htPhasorLookback ();
      if ( _state.value .value .mem_size > 0)
         _state.value .value .memory = TA_Calloc( _state.value .value .mem_size , sizeof(struct TA_HT_PHASOR_Data));
      else
         _state.value .value .memory = NULL;
      { _state.value .value .detrender = calloc(1, sizeof(struct TA_HT_PHASOR_HILBERT_STRUCT )); if ( _state.value .value .detrender == NULL) return RetCode.AllocErr ; } ;
      { _state.value .value .Q1 = calloc(1, sizeof(struct TA_HT_PHASOR_HILBERT_STRUCT )); if ( _state.value .value .Q1 == NULL) return RetCode.AllocErr ; } ;
      { _state.value .value .jI = calloc(1, sizeof(struct TA_HT_PHASOR_HILBERT_STRUCT )); if ( _state.value .value .jI == NULL) return RetCode.AllocErr ; } ;
      { _state.value .value .jQ = calloc(1, sizeof(struct TA_HT_PHASOR_HILBERT_STRUCT )); if ( _state.value .value .jQ == NULL) return RetCode.AllocErr ; } ;
      return RetCode.Success ;
   }
   public int htPhasorState( struct TA_htPhasor_State* _state,
      double inReal,
      double *outInPhase,
      double *outQuadrature )
   {
      double hilbertTempReal, smoothedValue;
      double adjustedPrevPeriod;
      double Q2, I2;
      double tempReal, tempReal2;
      if (_state == NULL)
         return RetCode.BadParam ;
      size_t _cur_idx = _state.value .mem_index++;
      if ( _state.value .mem_size > 0) _cur_idx %= _state.value .mem_size ;
      if ( ( _state.value .mem_index == 1) )
      {
         _state.value .periodWMASub = 0.;
         _state.value .periodWMASum = 0.;
         _state.value .hilbertIdx = 0;
         _state.value .period = 0;
         _state.value .prevI2 = 0.;
         _state.value .prevQ2 = 0.;
         _state.value .I1ForOddPrev2 = 0;
         _state.value .I1ForEvenPrev2 = 0;
         _state.value .I1ForOddPrev3 = 0;
         _state.value .I1ForEvenPrev3 = 0;
         _state.value .Im = 0.;
         _state.value .Re = 0.;
         _state.value .trailingWMAValue = 0.;
         _state.value .rad2Deg = 180.0 / (4.0 * Math.atan (1));
         _state.value .a = 0.0962;
         _state.value .b = 0.5769;
         { struct TA_HT_PHASOR_HILBERT_STRUCT * ref; ref = (struct TA_HT_PHASOR_HILBERT_STRUCT *) _state.value .detrender; ref.value ._Odd [0] = 0.0; ref.value ._Odd [1] = 0.0; ref.value ._Odd [2] = 0.0; ref.value ._Even[0] = 0.0; ref.value ._Even[1] = 0.0; ref.value ._Even[2] = 0.0; ref.value .var = 0.0; ref.value .prev_Odd = 0.0; ref.value .prev_Even = 0.0; ref.value .prev_input_Odd = 0.0; ref.value .prev_input_Even = 0.0; } ;
         { struct TA_HT_PHASOR_HILBERT_STRUCT * ref; ref = (struct TA_HT_PHASOR_HILBERT_STRUCT *) _state.value .Q1; ref.value ._Odd [0] = 0.0; ref.value ._Odd [1] = 0.0; ref.value ._Odd [2] = 0.0; ref.value ._Even[0] = 0.0; ref.value ._Even[1] = 0.0; ref.value ._Even[2] = 0.0; ref.value .var = 0.0; ref.value .prev_Odd = 0.0; ref.value .prev_Even = 0.0; ref.value .prev_input_Odd = 0.0; ref.value .prev_input_Even = 0.0; } ;
         { struct TA_HT_PHASOR_HILBERT_STRUCT * ref; ref = (struct TA_HT_PHASOR_HILBERT_STRUCT *) _state.value .jI; ref.value ._Odd [0] = 0.0; ref.value ._Odd [1] = 0.0; ref.value ._Odd [2] = 0.0; ref.value ._Even[0] = 0.0; ref.value ._Even[1] = 0.0; ref.value ._Even[2] = 0.0; ref.value .var = 0.0; ref.value .prev_Odd = 0.0; ref.value .prev_Even = 0.0; ref.value .prev_input_Odd = 0.0; ref.value .prev_input_Even = 0.0; } ;
         { struct TA_HT_PHASOR_HILBERT_STRUCT * ref; ref = (struct TA_HT_PHASOR_HILBERT_STRUCT *) _state.value .jQ; ref.value ._Odd [0] = 0.0; ref.value ._Odd [1] = 0.0; ref.value ._Odd [2] = 0.0; ref.value ._Even[0] = 0.0; ref.value ._Even[1] = 0.0; ref.value ._Even[2] = 0.0; ref.value .var = 0.0; ref.value .prev_Odd = 0.0; ref.value .prev_Even = 0.0; ref.value .prev_input_Odd = 0.0; ref.value .prev_input_Even = 0.0; } ;
      }
      if ( _state.value .mem_index < 4)
      {
         _state.value .periodWMASub += inReal;
         _state.value .periodWMASum += _state.value .mem_index*inReal;
         ( _state.value .memory+_cur_idx).value .inReal = inReal ;
         return RetCode.NeedMoreData ;
      } else
         if ( _state.value .mem_index <= 12)
      {
         { _state.value .periodWMASub += inReal; _state.value .periodWMASub -= _state.value .trailingWMAValue; _state.value .periodWMASum += inReal*4.0; _state.value .trailingWMAValue = ( _state.value .memory+( _state.value .mem_index-4) % _state.value .mem_size ).value .inReal ; smoothedValue = _state.value .periodWMASum*0.1; _state.value .periodWMASum -= _state.value .periodWMASub; } ;
         ( _state.value .memory+_cur_idx).value .inReal = inReal ;
         return RetCode.NeedMoreData ;
      }
      adjustedPrevPeriod = (0.075* _state.value .period)+0.54;
      { _state.value .periodWMASub += inReal; _state.value .periodWMASub -= _state.value .trailingWMAValue; _state.value .periodWMASum += inReal*4.0; _state.value .trailingWMAValue = ( _state.value .memory+( _state.value .mem_index-4) % _state.value .mem_size ).value .inReal ; smoothedValue = _state.value .periodWMASum*0.1; _state.value .periodWMASum -= _state.value .periodWMASub; } ;
      if( (( _state.value .mem_index+1)%2) == 0 )
      {
         { struct TA_HT_PHASOR_HILBERT_STRUCT * ref; ref = (struct TA_HT_PHASOR_HILBERT_STRUCT *) _state.value .detrender; hilbertTempReal = _state.value .a * smoothedValue; ref.value .var = - ref.value ._Even [ _state.value .hilbertIdx]; ref.value ._Even [ _state.value .hilbertIdx] = hilbertTempReal; ref.value .var += hilbertTempReal; ref.value .var -= ref.value .prev_Even ; ref.value .prev_Even = _state.value .b * ref.value .prev_input_Even ; ref.value .var += ref.value .prev_Even ; ref.value .prev_input_Even = smoothedValue; ref.value .var *= adjustedPrevPeriod; } ;
         { struct TA_HT_PHASOR_HILBERT_STRUCT * ref; ref = (struct TA_HT_PHASOR_HILBERT_STRUCT *) _state.value .Q1; hilbertTempReal = _state.value .a * (struct TA_HT_PHASOR_HILBERT_STRUCT *) _state.value .detrender.value .var ; ref.value .var = - ref.value ._Even [ _state.value .hilbertIdx]; ref.value ._Even [ _state.value .hilbertIdx] = hilbertTempReal; ref.value .var += hilbertTempReal; ref.value .var -= ref.value .prev_Even ; ref.value .prev_Even = _state.value .b * ref.value .prev_input_Even ; ref.value .var += ref.value .prev_Even ; ref.value .prev_input_Even = (struct TA_HT_PHASOR_HILBERT_STRUCT *) _state.value .detrender.value .var ; ref.value .var *= adjustedPrevPeriod; } ;
         if (!( _state.value .mem_size > _state.value .mem_index - 1 ))
         {
            outQuadrature.value = (struct TA_HT_PHASOR_HILBERT_STRUCT *) _state.value .Q1.value .var ;
            outInPhase.value = _state.value .I1ForEvenPrev3;
         }
         { struct TA_HT_PHASOR_HILBERT_STRUCT * ref; ref = (struct TA_HT_PHASOR_HILBERT_STRUCT *) _state.value .jI; hilbertTempReal = _state.value .a * _state.value .I1ForEvenPrev3; ref.value .var = - ref.value ._Even [ _state.value .hilbertIdx]; ref.value ._Even [ _state.value .hilbertIdx] = hilbertTempReal; ref.value .var += hilbertTempReal; ref.value .var -= ref.value .prev_Even ; ref.value .prev_Even = _state.value .b * ref.value .prev_input_Even ; ref.value .var += ref.value .prev_Even ; ref.value .prev_input_Even = _state.value .I1ForEvenPrev3; ref.value .var *= adjustedPrevPeriod; } ;
         { struct TA_HT_PHASOR_HILBERT_STRUCT * ref; ref = (struct TA_HT_PHASOR_HILBERT_STRUCT *) _state.value .jQ; hilbertTempReal = _state.value .a * (struct TA_HT_PHASOR_HILBERT_STRUCT *) _state.value .Q1.value .var ; ref.value .var = - ref.value ._Even [ _state.value .hilbertIdx]; ref.value ._Even [ _state.value .hilbertIdx] = hilbertTempReal; ref.value .var += hilbertTempReal; ref.value .var -= ref.value .prev_Even ; ref.value .prev_Even = _state.value .b * ref.value .prev_input_Even ; ref.value .var += ref.value .prev_Even ; ref.value .prev_input_Even = (struct TA_HT_PHASOR_HILBERT_STRUCT *) _state.value .Q1.value .var ; ref.value .var *= adjustedPrevPeriod; } ;
         if( ++ _state.value .hilbertIdx == 3 )
            _state.value .hilbertIdx = 0;
         Q2 = (0.2*( (struct TA_HT_PHASOR_HILBERT_STRUCT *) _state.value .Q1.value .var + (struct TA_HT_PHASOR_HILBERT_STRUCT *) _state.value .jI.value .var )) + (0.8* _state.value .prevQ2);
         I2 = (0.2*( _state.value .I1ForEvenPrev3 - (struct TA_HT_PHASOR_HILBERT_STRUCT *) _state.value .jQ.value .var )) + (0.8* _state.value .prevI2);
         _state.value .I1ForOddPrev3 = _state.value .I1ForOddPrev2;
         _state.value .I1ForOddPrev2 = (struct TA_HT_PHASOR_HILBERT_STRUCT *) _state.value .detrender.value .var ;
      } else {
         { struct TA_HT_PHASOR_HILBERT_STRUCT * ref; ref = (struct TA_HT_PHASOR_HILBERT_STRUCT *) _state.value .detrender; hilbertTempReal = _state.value .a * smoothedValue; ref.value .var = - ref.value ._Odd [ _state.value .hilbertIdx]; ref.value ._Odd [ _state.value .hilbertIdx] = hilbertTempReal; ref.value .var += hilbertTempReal; ref.value .var -= ref.value .prev_Odd ; ref.value .prev_Odd = _state.value .b * ref.value .prev_input_Odd ; ref.value .var += ref.value .prev_Odd ; ref.value .prev_input_Odd = smoothedValue; ref.value .var *= adjustedPrevPeriod; } ;
         { struct TA_HT_PHASOR_HILBERT_STRUCT * ref; ref = (struct TA_HT_PHASOR_HILBERT_STRUCT *) _state.value .Q1; hilbertTempReal = _state.value .a * (struct TA_HT_PHASOR_HILBERT_STRUCT *) _state.value .detrender.value .var ; ref.value .var = - ref.value ._Odd [ _state.value .hilbertIdx]; ref.value ._Odd [ _state.value .hilbertIdx] = hilbertTempReal; ref.value .var += hilbertTempReal; ref.value .var -= ref.value .prev_Odd ; ref.value .prev_Odd = _state.value .b * ref.value .prev_input_Odd ; ref.value .var += ref.value .prev_Odd ; ref.value .prev_input_Odd = (struct TA_HT_PHASOR_HILBERT_STRUCT *) _state.value .detrender.value .var ; ref.value .var *= adjustedPrevPeriod; } ;
         if (!( _state.value .mem_size > _state.value .mem_index - 1 ))
         {
            outQuadrature.value = (struct TA_HT_PHASOR_HILBERT_STRUCT *) _state.value .Q1.value .var ;
            outInPhase.value = _state.value .I1ForOddPrev3;
         }
         { struct TA_HT_PHASOR_HILBERT_STRUCT * ref; ref = (struct TA_HT_PHASOR_HILBERT_STRUCT *) _state.value .jI; hilbertTempReal = _state.value .a * _state.value .I1ForOddPrev3; ref.value .var = - ref.value ._Odd [ _state.value .hilbertIdx]; ref.value ._Odd [ _state.value .hilbertIdx] = hilbertTempReal; ref.value .var += hilbertTempReal; ref.value .var -= ref.value .prev_Odd ; ref.value .prev_Odd = _state.value .b * ref.value .prev_input_Odd ; ref.value .var += ref.value .prev_Odd ; ref.value .prev_input_Odd = _state.value .I1ForOddPrev3; ref.value .var *= adjustedPrevPeriod; } ;
         { struct TA_HT_PHASOR_HILBERT_STRUCT * ref; ref = (struct TA_HT_PHASOR_HILBERT_STRUCT *) _state.value .jQ; hilbertTempReal = _state.value .a * (struct TA_HT_PHASOR_HILBERT_STRUCT *) _state.value .Q1.value .var ; ref.value .var = - ref.value ._Odd [ _state.value .hilbertIdx]; ref.value ._Odd [ _state.value .hilbertIdx] = hilbertTempReal; ref.value .var += hilbertTempReal; ref.value .var -= ref.value .prev_Odd ; ref.value .prev_Odd = _state.value .b * ref.value .prev_input_Odd ; ref.value .var += ref.value .prev_Odd ; ref.value .prev_input_Odd = (struct TA_HT_PHASOR_HILBERT_STRUCT *) _state.value .Q1.value .var ; ref.value .var *= adjustedPrevPeriod; } ;
         Q2 = (0.2*( (struct TA_HT_PHASOR_HILBERT_STRUCT *) _state.value .Q1.value .var + (struct TA_HT_PHASOR_HILBERT_STRUCT *) _state.value .jI.value .var )) + (0.8* _state.value .prevQ2);
         I2 = (0.2*( _state.value .I1ForOddPrev3 - (struct TA_HT_PHASOR_HILBERT_STRUCT *) _state.value .jQ.value .var )) + (0.8* _state.value .prevI2);
         _state.value .I1ForEvenPrev3 = _state.value .I1ForEvenPrev2;
         _state.value .I1ForEvenPrev2 = (struct TA_HT_PHASOR_HILBERT_STRUCT *) _state.value .detrender.value .var ;
      }
      _state.value .Re = (0.2*((I2* _state.value .prevI2)+(Q2* _state.value .prevQ2)))+(0.8* _state.value .Re);
      _state.value .Im = (0.2*((I2* _state.value .prevQ2)-(Q2* _state.value .prevI2)))+(0.8* _state.value .Im);
      _state.value .prevQ2 = Q2;
      _state.value .prevI2 = I2;
      tempReal = _state.value .period;
      if( ( _state.value .Im != 0.0) && ( _state.value .Re != 0.0) )
         _state.value .period = 360.0 / ( Math.atan ( _state.value .Im/ _state.value .Re)* _state.value .rad2Deg);
      tempReal2 = 1.5*tempReal;
      if( _state.value .period > tempReal2)
         _state.value .period = tempReal2;
      tempReal2 = 0.67*tempReal;
      if( _state.value .period < tempReal2 )
         _state.value .period = tempReal2;
      if( _state.value .period < 6 )
         _state.value .period = 6;
      else if( _state.value .period > 50 )
         _state.value .period = 50;
      _state.value .period = (0.2* _state.value .period) + (0.8 * tempReal);
      ( _state.value .memory+_cur_idx).value .inReal = inReal ;
      if ( _state.value .mem_size > _state.value .mem_index - 1 )
         return RetCode.NeedMoreData ;
      else {
         return RetCode.Success ;
      }
   }
   public int htPhasorStateFree( struct TA_htPhasor_State** _state )
   {
      { if ( _state.value .value .detrender != NULL) { free ( _state.value .value .detrender); _state.value .value .detrender = NULL; } } ;
      { if ( _state.value .value .Q1 != NULL) { free ( _state.value .value .Q1); _state.value .value .Q1 = NULL; } } ;
      { if ( _state.value .value .jI != NULL) { free ( _state.value .value .jI); _state.value .value .jI = NULL; } } ;
      { if ( _state.value .value .jQ != NULL) { free ( _state.value .value .jQ); _state.value .value .jQ = NULL; } } ;
      if (_state == NULL)
         return RetCode.BadParam ;
      if ( _state.value != NULL) {
         if ( _state.value .value .memory != NULL) TA_Free( _state.value .value .memory );
         TA_Free( _state.value ); _state.value = NULL;}
      return RetCode.Success ;
   }
   public RetCode htPhasor( int startIdx,
      int endIdx,
      float inReal[],
      MInteger outBegIdx,
      MInteger outNBElement,
      double outInPhase[],
      double outQuadrature[] )
   {
      int outIdx, i;
      int lookbackTotal, today;
      double tempReal, tempReal2;
      double adjustedPrevPeriod, period;
      int trailingWMAIdx;
      double periodWMASum, periodWMASub, trailingWMAValue;
      double smoothedValue;
      final double a = 0.0962;
      final double b = 0.5769;
      double hilbertTempReal;
      int hilbertIdx;
      double []detrender_Odd = new double[3] ; double []detrender_Even = new double[3] ; double detrender; double prev_detrender_Odd ; double prev_detrender_Even ; double prev_detrender_input_Odd ; double prev_detrender_input_Even ;
      double []Q1_Odd = new double[3] ; double []Q1_Even = new double[3] ; double Q1; double prev_Q1_Odd ; double prev_Q1_Even ; double prev_Q1_input_Odd ; double prev_Q1_input_Even ;
      double []jI_Odd = new double[3] ; double []jI_Even = new double[3] ; double jI; double prev_jI_Odd ; double prev_jI_Even ; double prev_jI_input_Odd ; double prev_jI_input_Even ;
      double []jQ_Odd = new double[3] ; double []jQ_Even = new double[3] ; double jQ; double prev_jQ_Odd ; double prev_jQ_Even ; double prev_jQ_input_Odd ; double prev_jQ_input_Even ;
      double Q2, I2, prevQ2, prevI2, Re, Im;
      double I1ForOddPrev2, I1ForOddPrev3;
      double I1ForEvenPrev2, I1ForEvenPrev3;
      double rad2Deg;
      double todayValue;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      rad2Deg = 180.0 / (4.0 * Math.atan (1));
      lookbackTotal = 32 + (this.unstablePeriod[FuncUnstId.HtPhasor.ordinal()]) ;
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      outBegIdx.value = startIdx;
      trailingWMAIdx = startIdx - lookbackTotal;
      today = trailingWMAIdx;
      tempReal = inReal[today++];
      periodWMASub = tempReal;
      periodWMASum = tempReal;
      tempReal = inReal[today++];
      periodWMASub += tempReal;
      periodWMASum += tempReal*2.0;
      tempReal = inReal[today++];
      periodWMASub += tempReal;
      periodWMASum += tempReal*3.0;
      trailingWMAValue = 0.0;
      i = 9;
      do
      {
         tempReal = inReal[today++];
         { periodWMASub += tempReal; periodWMASub -= trailingWMAValue; periodWMASum += tempReal*4.0; trailingWMAValue = inReal[trailingWMAIdx++]; smoothedValue = periodWMASum*0.1; periodWMASum -= periodWMASub; } ;
      } while( --i != 0);
      hilbertIdx = 0;
      { detrender_Odd [0] = 0.0; detrender_Odd [1] = 0.0; detrender_Odd [2] = 0.0; detrender_Even [0] = 0.0; detrender_Even [1] = 0.0; detrender_Even [2] = 0.0; detrender = 0.0; prev_detrender_Odd = 0.0; prev_detrender_Even = 0.0; prev_detrender_input_Odd = 0.0; prev_detrender_input_Even = 0.0; } ;
      { Q1_Odd [0] = 0.0; Q1_Odd [1] = 0.0; Q1_Odd [2] = 0.0; Q1_Even [0] = 0.0; Q1_Even [1] = 0.0; Q1_Even [2] = 0.0; Q1 = 0.0; prev_Q1_Odd = 0.0; prev_Q1_Even = 0.0; prev_Q1_input_Odd = 0.0; prev_Q1_input_Even = 0.0; } ;
      { jI_Odd [0] = 0.0; jI_Odd [1] = 0.0; jI_Odd [2] = 0.0; jI_Even [0] = 0.0; jI_Even [1] = 0.0; jI_Even [2] = 0.0; jI = 0.0; prev_jI_Odd = 0.0; prev_jI_Even = 0.0; prev_jI_input_Odd = 0.0; prev_jI_input_Even = 0.0; } ;
      { jQ_Odd [0] = 0.0; jQ_Odd [1] = 0.0; jQ_Odd [2] = 0.0; jQ_Even [0] = 0.0; jQ_Even [1] = 0.0; jQ_Even [2] = 0.0; jQ = 0.0; prev_jQ_Odd = 0.0; prev_jQ_Even = 0.0; prev_jQ_input_Odd = 0.0; prev_jQ_input_Even = 0.0; } ;
      period = 0.0;
      outIdx = 0;
      prevI2 = prevQ2 = 0.0;
      Re = Im = 0.0;
      I1ForOddPrev3 = I1ForEvenPrev3 = 0.0;
      I1ForOddPrev2 = I1ForEvenPrev2 = 0.0;
      while( today <= endIdx )
      {
         adjustedPrevPeriod = (0.075*period)+0.54;
         todayValue = inReal[today];
         { periodWMASub += todayValue; periodWMASub -= trailingWMAValue; periodWMASum += todayValue*4.0; trailingWMAValue = inReal[trailingWMAIdx++]; smoothedValue = periodWMASum*0.1; periodWMASum -= periodWMASub; } ;
         if( (today%2) == 0 )
         {
            { hilbertTempReal = a * smoothedValue; detrender = -detrender_Even [hilbertIdx]; detrender_Even [hilbertIdx] = hilbertTempReal; detrender += hilbertTempReal; detrender -= prev_detrender_Even ; prev_detrender_Even = b * prev_detrender_input_Even ; detrender += prev_detrender_Even ; prev_detrender_input_Even = smoothedValue; detrender *= adjustedPrevPeriod; } ;
            { hilbertTempReal = a * detrender; Q1 = -Q1_Even [hilbertIdx]; Q1_Even [hilbertIdx] = hilbertTempReal; Q1 += hilbertTempReal; Q1 -= prev_Q1_Even ; prev_Q1_Even = b * prev_Q1_input_Even ; Q1 += prev_Q1_Even ; prev_Q1_input_Even = detrender; Q1 *= adjustedPrevPeriod; } ;
            if( today >= startIdx )
            {
               outQuadrature[outIdx] = Q1;
               outInPhase[outIdx++] = I1ForEvenPrev3;
            }
            { hilbertTempReal = a * I1ForEvenPrev3; jI = -jI_Even [hilbertIdx]; jI_Even [hilbertIdx] = hilbertTempReal; jI += hilbertTempReal; jI -= prev_jI_Even ; prev_jI_Even = b * prev_jI_input_Even ; jI += prev_jI_Even ; prev_jI_input_Even = I1ForEvenPrev3; jI *= adjustedPrevPeriod; } ;
            { hilbertTempReal = a * Q1; jQ = -jQ_Even [hilbertIdx]; jQ_Even [hilbertIdx] = hilbertTempReal; jQ += hilbertTempReal; jQ -= prev_jQ_Even ; prev_jQ_Even = b * prev_jQ_input_Even ; jQ += prev_jQ_Even ; prev_jQ_input_Even = Q1; jQ *= adjustedPrevPeriod; } ;
            if( ++hilbertIdx == 3 )
               hilbertIdx = 0;
            Q2 = (0.2*(Q1 + jI)) + (0.8*prevQ2);
            I2 = (0.2*(I1ForEvenPrev3 - jQ)) + (0.8*prevI2);
            I1ForOddPrev3 = I1ForOddPrev2;
            I1ForOddPrev2 = detrender;
         }
         else
         {
            { hilbertTempReal = a * smoothedValue; detrender = -detrender_Odd [hilbertIdx]; detrender_Odd [hilbertIdx] = hilbertTempReal; detrender += hilbertTempReal; detrender -= prev_detrender_Odd ; prev_detrender_Odd = b * prev_detrender_input_Odd ; detrender += prev_detrender_Odd ; prev_detrender_input_Odd = smoothedValue; detrender *= adjustedPrevPeriod; } ;
            { hilbertTempReal = a * detrender; Q1 = -Q1_Odd [hilbertIdx]; Q1_Odd [hilbertIdx] = hilbertTempReal; Q1 += hilbertTempReal; Q1 -= prev_Q1_Odd ; prev_Q1_Odd = b * prev_Q1_input_Odd ; Q1 += prev_Q1_Odd ; prev_Q1_input_Odd = detrender; Q1 *= adjustedPrevPeriod; } ;
            if( today >= startIdx )
            {
               outQuadrature[outIdx] = Q1;
               outInPhase[outIdx++] = I1ForOddPrev3;
            }
            { hilbertTempReal = a * I1ForOddPrev3; jI = -jI_Odd [hilbertIdx]; jI_Odd [hilbertIdx] = hilbertTempReal; jI += hilbertTempReal; jI -= prev_jI_Odd ; prev_jI_Odd = b * prev_jI_input_Odd ; jI += prev_jI_Odd ; prev_jI_input_Odd = I1ForOddPrev3; jI *= adjustedPrevPeriod; } ;
            { hilbertTempReal = a * Q1; jQ = -jQ_Odd [hilbertIdx]; jQ_Odd [hilbertIdx] = hilbertTempReal; jQ += hilbertTempReal; jQ -= prev_jQ_Odd ; prev_jQ_Odd = b * prev_jQ_input_Odd ; jQ += prev_jQ_Odd ; prev_jQ_input_Odd = Q1; jQ *= adjustedPrevPeriod; } ;
            Q2 = (0.2*(Q1 + jI)) + (0.8*prevQ2);
            I2 = (0.2*(I1ForOddPrev3 - jQ)) + (0.8*prevI2);
            I1ForEvenPrev3 = I1ForEvenPrev2;
            I1ForEvenPrev2 = detrender;
         }
         Re = (0.2*((I2*prevI2)+(Q2*prevQ2)))+(0.8*Re);
         Im = (0.2*((I2*prevQ2)-(Q2*prevI2)))+(0.8*Im);
         prevQ2 = Q2;
         prevI2 = I2;
         tempReal = period;
         if( (Im != 0.0) && (Re != 0.0) )
            period = 360.0 / ( Math.atan (Im/Re)*rad2Deg);
         tempReal2 = 1.5*tempReal;
         if( period > tempReal2)
            period = tempReal2;
         tempReal2 = 0.67*tempReal;
         if( period < tempReal2 )
            period = tempReal2;
         if( period < 6 )
            period = 6;
         else if( period > 50 )
            period = 50;
         period = (0.2*period) + (0.8 * tempReal);
         today++;
      }
      outNBElement.value = outIdx;
      return RetCode.Success ;
   }
   /* Generated */
   public int htSineLookback( )
   {
      return 63 + (this.unstablePeriod[FuncUnstId.HtSine.ordinal()]) ;
   }
   public RetCode htSine( int startIdx,
      int endIdx,
      double inReal[],
      MInteger outBegIdx,
      MInteger outNBElement,
      double outSine[],
      double outLeadSine[] )
   {
      int outIdx, i;
      int lookbackTotal, today;
      double tempReal, tempReal2;
      double adjustedPrevPeriod, period;
      int trailingWMAIdx;
      double periodWMASum, periodWMASub, trailingWMAValue;
      double smoothedValue;
      final double a = 0.0962;
      final double b = 0.5769;
      double hilbertTempReal;
      int hilbertIdx;
      double []detrender_Odd = new double[3] ; double []detrender_Even = new double[3] ; double detrender; double prev_detrender_Odd ; double prev_detrender_Even ; double prev_detrender_input_Odd ; double prev_detrender_input_Even ;
      double []Q1_Odd = new double[3] ; double []Q1_Even = new double[3] ; double Q1; double prev_Q1_Odd ; double prev_Q1_Even ; double prev_Q1_input_Odd ; double prev_Q1_input_Even ;
      double []jI_Odd = new double[3] ; double []jI_Even = new double[3] ; double jI; double prev_jI_Odd ; double prev_jI_Even ; double prev_jI_input_Odd ; double prev_jI_input_Even ;
      double []jQ_Odd = new double[3] ; double []jQ_Even = new double[3] ; double jQ; double prev_jQ_Odd ; double prev_jQ_Even ; double prev_jQ_input_Odd ; double prev_jQ_input_Even ;
      double Q2, I2, prevQ2, prevI2, Re, Im;
      double I1ForOddPrev2, I1ForOddPrev3;
      double I1ForEvenPrev2, I1ForEvenPrev3;
      double rad2Deg, deg2Rad, constDeg2RadBy360;
      double todayValue, smoothPeriod;
      int smoothPrice_Idx = 0; double []smoothPrice; int maxIdx_smoothPrice = ( 50 -1) ;
      int idx;
      int DCPeriodInt;
      double DCPhase, DCPeriod, imagPart, realPart;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      { smoothPrice = new double[maxIdx_smoothPrice +1]; } ;
      tempReal = Math.atan (1);
      rad2Deg = 45.0/tempReal;
      deg2Rad = 1.0/rad2Deg;
      constDeg2RadBy360 = tempReal*8.0;
      lookbackTotal = 63 + (this.unstablePeriod[FuncUnstId.HtSine.ordinal()]) ;
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      outBegIdx.value = startIdx;
      trailingWMAIdx = startIdx - lookbackTotal;
      today = trailingWMAIdx;
      tempReal = inReal[today++];
      periodWMASub = tempReal;
      periodWMASum = tempReal;
      tempReal = inReal[today++];
      periodWMASub += tempReal;
      periodWMASum += tempReal*2.0;
      tempReal = inReal[today++];
      periodWMASub += tempReal;
      periodWMASum += tempReal*3.0;
      trailingWMAValue = 0.0;
      i = 34;
      do
      {
         tempReal = inReal[today++];
         { periodWMASub += tempReal; periodWMASub -= trailingWMAValue; periodWMASum += tempReal*4.0; trailingWMAValue = inReal[trailingWMAIdx++]; smoothedValue = periodWMASum*0.1; periodWMASum -= periodWMASub; } ;
      } while( --i != 0);
      hilbertIdx = 0;
      { detrender_Odd [0] = 0.0; detrender_Odd [1] = 0.0; detrender_Odd [2] = 0.0; detrender_Even [0] = 0.0; detrender_Even [1] = 0.0; detrender_Even [2] = 0.0; detrender = 0.0; prev_detrender_Odd = 0.0; prev_detrender_Even = 0.0; prev_detrender_input_Odd = 0.0; prev_detrender_input_Even = 0.0; } ;
      { Q1_Odd [0] = 0.0; Q1_Odd [1] = 0.0; Q1_Odd [2] = 0.0; Q1_Even [0] = 0.0; Q1_Even [1] = 0.0; Q1_Even [2] = 0.0; Q1 = 0.0; prev_Q1_Odd = 0.0; prev_Q1_Even = 0.0; prev_Q1_input_Odd = 0.0; prev_Q1_input_Even = 0.0; } ;
      { jI_Odd [0] = 0.0; jI_Odd [1] = 0.0; jI_Odd [2] = 0.0; jI_Even [0] = 0.0; jI_Even [1] = 0.0; jI_Even [2] = 0.0; jI = 0.0; prev_jI_Odd = 0.0; prev_jI_Even = 0.0; prev_jI_input_Odd = 0.0; prev_jI_input_Even = 0.0; } ;
      { jQ_Odd [0] = 0.0; jQ_Odd [1] = 0.0; jQ_Odd [2] = 0.0; jQ_Even [0] = 0.0; jQ_Even [1] = 0.0; jQ_Even [2] = 0.0; jQ = 0.0; prev_jQ_Odd = 0.0; prev_jQ_Even = 0.0; prev_jQ_input_Odd = 0.0; prev_jQ_input_Even = 0.0; } ;
      period = 0.0;
      outIdx = 0;
      prevI2 = prevQ2 = 0.0;
      Re = Im = 0.0;
      I1ForOddPrev3 = I1ForEvenPrev3 = 0.0;
      I1ForOddPrev2 = I1ForEvenPrev2 = 0.0;
      smoothPeriod = 0.0;
      for( i=0; i < 50 ; i++ )
         smoothPrice[i] = 0.0;
      DCPhase = 0.0;
      while( today <= endIdx )
      {
         adjustedPrevPeriod = (0.075*period)+0.54;
         todayValue = inReal[today];
         { periodWMASub += todayValue; periodWMASub -= trailingWMAValue; periodWMASum += todayValue*4.0; trailingWMAValue = inReal[trailingWMAIdx++]; smoothedValue = periodWMASum*0.1; periodWMASum -= periodWMASub; } ;
         smoothPrice[smoothPrice_Idx] = smoothedValue;
         if( (today%2) == 0 )
         {
            { hilbertTempReal = a * smoothedValue; detrender = -detrender_Even [hilbertIdx]; detrender_Even [hilbertIdx] = hilbertTempReal; detrender += hilbertTempReal; detrender -= prev_detrender_Even ; prev_detrender_Even = b * prev_detrender_input_Even ; detrender += prev_detrender_Even ; prev_detrender_input_Even = smoothedValue; detrender *= adjustedPrevPeriod; } ;
            { hilbertTempReal = a * detrender; Q1 = -Q1_Even [hilbertIdx]; Q1_Even [hilbertIdx] = hilbertTempReal; Q1 += hilbertTempReal; Q1 -= prev_Q1_Even ; prev_Q1_Even = b * prev_Q1_input_Even ; Q1 += prev_Q1_Even ; prev_Q1_input_Even = detrender; Q1 *= adjustedPrevPeriod; } ;
            { hilbertTempReal = a * I1ForEvenPrev3; jI = -jI_Even [hilbertIdx]; jI_Even [hilbertIdx] = hilbertTempReal; jI += hilbertTempReal; jI -= prev_jI_Even ; prev_jI_Even = b * prev_jI_input_Even ; jI += prev_jI_Even ; prev_jI_input_Even = I1ForEvenPrev3; jI *= adjustedPrevPeriod; } ;
            { hilbertTempReal = a * Q1; jQ = -jQ_Even [hilbertIdx]; jQ_Even [hilbertIdx] = hilbertTempReal; jQ += hilbertTempReal; jQ -= prev_jQ_Even ; prev_jQ_Even = b * prev_jQ_input_Even ; jQ += prev_jQ_Even ; prev_jQ_input_Even = Q1; jQ *= adjustedPrevPeriod; } ;
            if( ++hilbertIdx == 3 )
               hilbertIdx = 0;
            Q2 = (0.2*(Q1 + jI)) + (0.8*prevQ2);
            I2 = (0.2*(I1ForEvenPrev3 - jQ)) + (0.8*prevI2);
            I1ForOddPrev3 = I1ForOddPrev2;
            I1ForOddPrev2 = detrender;
         }
         else
         {
            { hilbertTempReal = a * smoothedValue; detrender = -detrender_Odd [hilbertIdx]; detrender_Odd [hilbertIdx] = hilbertTempReal; detrender += hilbertTempReal; detrender -= prev_detrender_Odd ; prev_detrender_Odd = b * prev_detrender_input_Odd ; detrender += prev_detrender_Odd ; prev_detrender_input_Odd = smoothedValue; detrender *= adjustedPrevPeriod; } ;
            { hilbertTempReal = a * detrender; Q1 = -Q1_Odd [hilbertIdx]; Q1_Odd [hilbertIdx] = hilbertTempReal; Q1 += hilbertTempReal; Q1 -= prev_Q1_Odd ; prev_Q1_Odd = b * prev_Q1_input_Odd ; Q1 += prev_Q1_Odd ; prev_Q1_input_Odd = detrender; Q1 *= adjustedPrevPeriod; } ;
            { hilbertTempReal = a * I1ForOddPrev3; jI = -jI_Odd [hilbertIdx]; jI_Odd [hilbertIdx] = hilbertTempReal; jI += hilbertTempReal; jI -= prev_jI_Odd ; prev_jI_Odd = b * prev_jI_input_Odd ; jI += prev_jI_Odd ; prev_jI_input_Odd = I1ForOddPrev3; jI *= adjustedPrevPeriod; } ;
            { hilbertTempReal = a * Q1; jQ = -jQ_Odd [hilbertIdx]; jQ_Odd [hilbertIdx] = hilbertTempReal; jQ += hilbertTempReal; jQ -= prev_jQ_Odd ; prev_jQ_Odd = b * prev_jQ_input_Odd ; jQ += prev_jQ_Odd ; prev_jQ_input_Odd = Q1; jQ *= adjustedPrevPeriod; } ;
            Q2 = (0.2*(Q1 + jI)) + (0.8*prevQ2);
            I2 = (0.2*(I1ForOddPrev3 - jQ)) + (0.8*prevI2);
            I1ForEvenPrev3 = I1ForEvenPrev2;
            I1ForEvenPrev2 = detrender;
         }
         Re = (0.2*((I2*prevI2)+(Q2*prevQ2)))+(0.8*Re);
         Im = (0.2*((I2*prevQ2)-(Q2*prevI2)))+(0.8*Im);
         prevQ2 = Q2;
         prevI2 = I2;
         tempReal = period;
         if( (Im != 0.0) && (Re != 0.0) )
            period = 360.0 / ( Math.atan (Im/Re)*rad2Deg);
         tempReal2 = 1.5*tempReal;
         if( period > tempReal2)
            period = tempReal2;
         tempReal2 = 0.67*tempReal;
         if( period < tempReal2 )
            period = tempReal2;
         if( period < 6 )
            period = 6;
         else if( period > 50 )
            period = 50;
         period = (0.2*period) + (0.8 * tempReal);
         smoothPeriod = (0.33*period)+(0.67*smoothPeriod);
         DCPeriod = smoothPeriod+0.5;
         DCPeriodInt = (int)DCPeriod;
         realPart = 0.0;
         imagPart = 0.0;
         idx = smoothPrice_Idx;
         for( i=0; i < DCPeriodInt; i++ )
         {
            tempReal = ((double)i*constDeg2RadBy360)/(double)DCPeriodInt;
            tempReal2 = smoothPrice[idx];
            realPart += Math.sin (tempReal)*tempReal2;
            imagPart += Math.cos (tempReal)*tempReal2;
            if( idx == 0 )
               idx = 50 -1;
            else
               idx--;
         }
         tempReal = Math.abs (imagPart);
         if( tempReal > 0.0 )
            DCPhase = Math.atan (realPart/imagPart)*rad2Deg;
         else if( tempReal <= 0.01 )
         {
            if( realPart < 0.0 )
               DCPhase -= 90.0;
            else if( realPart > 0.0 )
               DCPhase += 90.0;
         }
         DCPhase += 90.0;
         DCPhase += 360.0 / smoothPeriod;
         if( imagPart < 0.0 )
            DCPhase += 180.0;
         if( DCPhase > 315.0 )
            DCPhase -= 360.0;
         if( today >= startIdx )
         {
            outSine[outIdx] = Math.sin (DCPhase*deg2Rad);
            outLeadSine[outIdx++] = Math.sin ((DCPhase+45)*deg2Rad);
         }
         { smoothPrice_Idx ++; if( smoothPrice_Idx > maxIdx_smoothPrice ) smoothPrice_Idx = 0; } ;
         today++;
      }
      outNBElement.value = outIdx;
      return RetCode.Success ;
   }
   public int htSineStateInit( struct TA_htSine_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct htSine ));
      _state.value .value .mem_index = 0;
      _state.value .value .mem_size = htSineLookback ();
      if ( _state.value .value .mem_size > 0)
         _state.value .value .memory = TA_Calloc( _state.value .value .mem_size , sizeof(struct TA_HT_SINE_Data));
      else
         _state.value .value .memory = NULL;
      return RetCode.Success ;
   }
   public int htSineState( struct TA_htSine_State* _state,
      double inReal,
      double *outSine,
      double *outLeadSine )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      size_t _cur_idx = _state.value .mem_index++;
      if ( _state.value .mem_size > 0) _cur_idx %= _state.value .mem_size ;
      if ( _state.value .mem_size > _state.value .mem_index - 1 ) {
         ( _state.value .memory+_cur_idx).value .inReal = inReal ;
         return RetCode.NeedMoreData ; }
      return RetCode.Success ;
   }
   public int htSineStateFree( struct TA_htSine_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if ( _state.value != NULL) {
         if ( _state.value .value .memory != NULL) TA_Free( _state.value .value .memory );
         TA_Free( _state.value ); _state.value = NULL;}
      return RetCode.Success ;
   }
   public RetCode htSine( int startIdx,
      int endIdx,
      float inReal[],
      MInteger outBegIdx,
      MInteger outNBElement,
      double outSine[],
      double outLeadSine[] )
   {
      int outIdx, i;
      int lookbackTotal, today;
      double tempReal, tempReal2;
      double adjustedPrevPeriod, period;
      int trailingWMAIdx;
      double periodWMASum, periodWMASub, trailingWMAValue;
      double smoothedValue;
      final double a = 0.0962;
      final double b = 0.5769;
      double hilbertTempReal;
      int hilbertIdx;
      double []detrender_Odd = new double[3] ; double []detrender_Even = new double[3] ; double detrender; double prev_detrender_Odd ; double prev_detrender_Even ; double prev_detrender_input_Odd ; double prev_detrender_input_Even ;
      double []Q1_Odd = new double[3] ; double []Q1_Even = new double[3] ; double Q1; double prev_Q1_Odd ; double prev_Q1_Even ; double prev_Q1_input_Odd ; double prev_Q1_input_Even ;
      double []jI_Odd = new double[3] ; double []jI_Even = new double[3] ; double jI; double prev_jI_Odd ; double prev_jI_Even ; double prev_jI_input_Odd ; double prev_jI_input_Even ;
      double []jQ_Odd = new double[3] ; double []jQ_Even = new double[3] ; double jQ; double prev_jQ_Odd ; double prev_jQ_Even ; double prev_jQ_input_Odd ; double prev_jQ_input_Even ;
      double Q2, I2, prevQ2, prevI2, Re, Im;
      double I1ForOddPrev2, I1ForOddPrev3;
      double I1ForEvenPrev2, I1ForEvenPrev3;
      double rad2Deg, deg2Rad, constDeg2RadBy360;
      double todayValue, smoothPeriod;
      int smoothPrice_Idx = 0; double []smoothPrice; int maxIdx_smoothPrice = ( 50 -1) ;
      int idx;
      int DCPeriodInt;
      double DCPhase, DCPeriod, imagPart, realPart;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      { smoothPrice = new double[maxIdx_smoothPrice +1]; } ;
      tempReal = Math.atan (1);
      rad2Deg = 45.0/tempReal;
      deg2Rad = 1.0/rad2Deg;
      constDeg2RadBy360 = tempReal*8.0;
      lookbackTotal = 63 + (this.unstablePeriod[FuncUnstId.HtSine.ordinal()]) ;
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      outBegIdx.value = startIdx;
      trailingWMAIdx = startIdx - lookbackTotal;
      today = trailingWMAIdx;
      tempReal = inReal[today++];
      periodWMASub = tempReal;
      periodWMASum = tempReal;
      tempReal = inReal[today++];
      periodWMASub += tempReal;
      periodWMASum += tempReal*2.0;
      tempReal = inReal[today++];
      periodWMASub += tempReal;
      periodWMASum += tempReal*3.0;
      trailingWMAValue = 0.0;
      i = 34;
      do
      {
         tempReal = inReal[today++];
         { periodWMASub += tempReal; periodWMASub -= trailingWMAValue; periodWMASum += tempReal*4.0; trailingWMAValue = inReal[trailingWMAIdx++]; smoothedValue = periodWMASum*0.1; periodWMASum -= periodWMASub; } ;
      } while( --i != 0);
      hilbertIdx = 0;
      { detrender_Odd [0] = 0.0; detrender_Odd [1] = 0.0; detrender_Odd [2] = 0.0; detrender_Even [0] = 0.0; detrender_Even [1] = 0.0; detrender_Even [2] = 0.0; detrender = 0.0; prev_detrender_Odd = 0.0; prev_detrender_Even = 0.0; prev_detrender_input_Odd = 0.0; prev_detrender_input_Even = 0.0; } ;
      { Q1_Odd [0] = 0.0; Q1_Odd [1] = 0.0; Q1_Odd [2] = 0.0; Q1_Even [0] = 0.0; Q1_Even [1] = 0.0; Q1_Even [2] = 0.0; Q1 = 0.0; prev_Q1_Odd = 0.0; prev_Q1_Even = 0.0; prev_Q1_input_Odd = 0.0; prev_Q1_input_Even = 0.0; } ;
      { jI_Odd [0] = 0.0; jI_Odd [1] = 0.0; jI_Odd [2] = 0.0; jI_Even [0] = 0.0; jI_Even [1] = 0.0; jI_Even [2] = 0.0; jI = 0.0; prev_jI_Odd = 0.0; prev_jI_Even = 0.0; prev_jI_input_Odd = 0.0; prev_jI_input_Even = 0.0; } ;
      { jQ_Odd [0] = 0.0; jQ_Odd [1] = 0.0; jQ_Odd [2] = 0.0; jQ_Even [0] = 0.0; jQ_Even [1] = 0.0; jQ_Even [2] = 0.0; jQ = 0.0; prev_jQ_Odd = 0.0; prev_jQ_Even = 0.0; prev_jQ_input_Odd = 0.0; prev_jQ_input_Even = 0.0; } ;
      period = 0.0;
      outIdx = 0;
      prevI2 = prevQ2 = 0.0;
      Re = Im = 0.0;
      I1ForOddPrev3 = I1ForEvenPrev3 = 0.0;
      I1ForOddPrev2 = I1ForEvenPrev2 = 0.0;
      smoothPeriod = 0.0;
      for( i=0; i < 50 ; i++ )
         smoothPrice[i] = 0.0;
      DCPhase = 0.0;
      while( today <= endIdx )
      {
         adjustedPrevPeriod = (0.075*period)+0.54;
         todayValue = inReal[today];
         { periodWMASub += todayValue; periodWMASub -= trailingWMAValue; periodWMASum += todayValue*4.0; trailingWMAValue = inReal[trailingWMAIdx++]; smoothedValue = periodWMASum*0.1; periodWMASum -= periodWMASub; } ;
         smoothPrice[smoothPrice_Idx] = smoothedValue;
         if( (today%2) == 0 )
         {
            { hilbertTempReal = a * smoothedValue; detrender = -detrender_Even [hilbertIdx]; detrender_Even [hilbertIdx] = hilbertTempReal; detrender += hilbertTempReal; detrender -= prev_detrender_Even ; prev_detrender_Even = b * prev_detrender_input_Even ; detrender += prev_detrender_Even ; prev_detrender_input_Even = smoothedValue; detrender *= adjustedPrevPeriod; } ;
            { hilbertTempReal = a * detrender; Q1 = -Q1_Even [hilbertIdx]; Q1_Even [hilbertIdx] = hilbertTempReal; Q1 += hilbertTempReal; Q1 -= prev_Q1_Even ; prev_Q1_Even = b * prev_Q1_input_Even ; Q1 += prev_Q1_Even ; prev_Q1_input_Even = detrender; Q1 *= adjustedPrevPeriod; } ;
            { hilbertTempReal = a * I1ForEvenPrev3; jI = -jI_Even [hilbertIdx]; jI_Even [hilbertIdx] = hilbertTempReal; jI += hilbertTempReal; jI -= prev_jI_Even ; prev_jI_Even = b * prev_jI_input_Even ; jI += prev_jI_Even ; prev_jI_input_Even = I1ForEvenPrev3; jI *= adjustedPrevPeriod; } ;
            { hilbertTempReal = a * Q1; jQ = -jQ_Even [hilbertIdx]; jQ_Even [hilbertIdx] = hilbertTempReal; jQ += hilbertTempReal; jQ -= prev_jQ_Even ; prev_jQ_Even = b * prev_jQ_input_Even ; jQ += prev_jQ_Even ; prev_jQ_input_Even = Q1; jQ *= adjustedPrevPeriod; } ;
            if( ++hilbertIdx == 3 )
               hilbertIdx = 0;
            Q2 = (0.2*(Q1 + jI)) + (0.8*prevQ2);
            I2 = (0.2*(I1ForEvenPrev3 - jQ)) + (0.8*prevI2);
            I1ForOddPrev3 = I1ForOddPrev2;
            I1ForOddPrev2 = detrender;
         }
         else
         {
            { hilbertTempReal = a * smoothedValue; detrender = -detrender_Odd [hilbertIdx]; detrender_Odd [hilbertIdx] = hilbertTempReal; detrender += hilbertTempReal; detrender -= prev_detrender_Odd ; prev_detrender_Odd = b * prev_detrender_input_Odd ; detrender += prev_detrender_Odd ; prev_detrender_input_Odd = smoothedValue; detrender *= adjustedPrevPeriod; } ;
            { hilbertTempReal = a * detrender; Q1 = -Q1_Odd [hilbertIdx]; Q1_Odd [hilbertIdx] = hilbertTempReal; Q1 += hilbertTempReal; Q1 -= prev_Q1_Odd ; prev_Q1_Odd = b * prev_Q1_input_Odd ; Q1 += prev_Q1_Odd ; prev_Q1_input_Odd = detrender; Q1 *= adjustedPrevPeriod; } ;
            { hilbertTempReal = a * I1ForOddPrev3; jI = -jI_Odd [hilbertIdx]; jI_Odd [hilbertIdx] = hilbertTempReal; jI += hilbertTempReal; jI -= prev_jI_Odd ; prev_jI_Odd = b * prev_jI_input_Odd ; jI += prev_jI_Odd ; prev_jI_input_Odd = I1ForOddPrev3; jI *= adjustedPrevPeriod; } ;
            { hilbertTempReal = a * Q1; jQ = -jQ_Odd [hilbertIdx]; jQ_Odd [hilbertIdx] = hilbertTempReal; jQ += hilbertTempReal; jQ -= prev_jQ_Odd ; prev_jQ_Odd = b * prev_jQ_input_Odd ; jQ += prev_jQ_Odd ; prev_jQ_input_Odd = Q1; jQ *= adjustedPrevPeriod; } ;
            Q2 = (0.2*(Q1 + jI)) + (0.8*prevQ2);
            I2 = (0.2*(I1ForOddPrev3 - jQ)) + (0.8*prevI2);
            I1ForEvenPrev3 = I1ForEvenPrev2;
            I1ForEvenPrev2 = detrender;
         }
         Re = (0.2*((I2*prevI2)+(Q2*prevQ2)))+(0.8*Re);
         Im = (0.2*((I2*prevQ2)-(Q2*prevI2)))+(0.8*Im);
         prevQ2 = Q2;
         prevI2 = I2;
         tempReal = period;
         if( (Im != 0.0) && (Re != 0.0) )
            period = 360.0 / ( Math.atan (Im/Re)*rad2Deg);
         tempReal2 = 1.5*tempReal;
         if( period > tempReal2)
            period = tempReal2;
         tempReal2 = 0.67*tempReal;
         if( period < tempReal2 )
            period = tempReal2;
         if( period < 6 )
            period = 6;
         else if( period > 50 )
            period = 50;
         period = (0.2*period) + (0.8 * tempReal);
         smoothPeriod = (0.33*period)+(0.67*smoothPeriod);
         DCPeriod = smoothPeriod+0.5;
         DCPeriodInt = (int)DCPeriod;
         realPart = 0.0;
         imagPart = 0.0;
         idx = smoothPrice_Idx;
         for( i=0; i < DCPeriodInt; i++ )
         {
            tempReal = ((double)i*constDeg2RadBy360)/(double)DCPeriodInt;
            tempReal2 = smoothPrice[idx];
            realPart += Math.sin (tempReal)*tempReal2;
            imagPart += Math.cos (tempReal)*tempReal2;
            if( idx == 0 )
               idx = 50 -1;
            else
               idx--;
         }
         tempReal = Math.abs (imagPart);
         if( tempReal > 0.0 )
            DCPhase = Math.atan (realPart/imagPart)*rad2Deg;
         else if( tempReal <= 0.01 )
         {
            if( realPart < 0.0 )
               DCPhase -= 90.0;
            else if( realPart > 0.0 )
               DCPhase += 90.0;
         }
         DCPhase += 90.0;
         DCPhase += 360.0 / smoothPeriod;
         if( imagPart < 0.0 )
            DCPhase += 180.0;
         if( DCPhase > 315.0 )
            DCPhase -= 360.0;
         if( today >= startIdx )
         {
            outSine[outIdx] = Math.sin (DCPhase*deg2Rad);
            outLeadSine[outIdx++] = Math.sin ((DCPhase+45)*deg2Rad);
         }
         { smoothPrice_Idx ++; if( smoothPrice_Idx > maxIdx_smoothPrice ) smoothPrice_Idx = 0; } ;
         today++;
      }
      outNBElement.value = outIdx;
      return RetCode.Success ;
   }
   /* Generated */
   public int htTrendlineLookback( )
   {
      return 63 + (this.unstablePeriod[FuncUnstId.HtTrendline.ordinal()]) ;
   }
   public RetCode htTrendline( int startIdx,
      int endIdx,
      double inReal[],
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      int outIdx, i;
      int lookbackTotal, today;
      double tempReal, tempReal2;
      double adjustedPrevPeriod, period;
      int trailingWMAIdx;
      double periodWMASum, periodWMASub, trailingWMAValue;
      double smoothedValue;
      double iTrend1, iTrend2, iTrend3;
      final double a = 0.0962;
      final double b = 0.5769;
      double hilbertTempReal;
      int hilbertIdx;
      double []detrender_Odd = new double[3] ; double []detrender_Even = new double[3] ; double detrender; double prev_detrender_Odd ; double prev_detrender_Even ; double prev_detrender_input_Odd ; double prev_detrender_input_Even ;
      double []Q1_Odd = new double[3] ; double []Q1_Even = new double[3] ; double Q1; double prev_Q1_Odd ; double prev_Q1_Even ; double prev_Q1_input_Odd ; double prev_Q1_input_Even ;
      double []jI_Odd = new double[3] ; double []jI_Even = new double[3] ; double jI; double prev_jI_Odd ; double prev_jI_Even ; double prev_jI_input_Odd ; double prev_jI_input_Even ;
      double []jQ_Odd = new double[3] ; double []jQ_Even = new double[3] ; double jQ; double prev_jQ_Odd ; double prev_jQ_Even ; double prev_jQ_input_Odd ; double prev_jQ_input_Even ;
      double Q2, I2, prevQ2, prevI2, Re, Im;
      double I1ForOddPrev2, I1ForOddPrev3;
      double I1ForEvenPrev2, I1ForEvenPrev3;
      double rad2Deg;
      double todayValue, smoothPeriod;
      int smoothPrice_Idx = 0; double []smoothPrice; int maxIdx_smoothPrice = ( 50 -1) ;
      int idx;
      int DCPeriodInt;
      double DCPeriod;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      { smoothPrice = new double[maxIdx_smoothPrice +1]; } ;
      iTrend1 = iTrend2 = iTrend3 = 0.0;
      tempReal = Math.atan (1);
      rad2Deg = 45.0/tempReal;
      lookbackTotal = 63 + (this.unstablePeriod[FuncUnstId.HtTrendline.ordinal()]) ;
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      outBegIdx.value = startIdx;
      trailingWMAIdx = startIdx - lookbackTotal;
      today = trailingWMAIdx;
      tempReal = inReal[today++];
      periodWMASub = tempReal;
      periodWMASum = tempReal;
      tempReal = inReal[today++];
      periodWMASub += tempReal;
      periodWMASum += tempReal*2.0;
      tempReal = inReal[today++];
      periodWMASub += tempReal;
      periodWMASum += tempReal*3.0;
      trailingWMAValue = 0.0;
      i = 34;
      do
      {
         tempReal = inReal[today++];
         { periodWMASub += tempReal; periodWMASub -= trailingWMAValue; periodWMASum += tempReal*4.0; trailingWMAValue = inReal[trailingWMAIdx++]; smoothedValue = periodWMASum*0.1; periodWMASum -= periodWMASub; } ;
      } while( --i != 0);
      hilbertIdx = 0;
      { detrender_Odd [0] = 0.0; detrender_Odd [1] = 0.0; detrender_Odd [2] = 0.0; detrender_Even [0] = 0.0; detrender_Even [1] = 0.0; detrender_Even [2] = 0.0; detrender = 0.0; prev_detrender_Odd = 0.0; prev_detrender_Even = 0.0; prev_detrender_input_Odd = 0.0; prev_detrender_input_Even = 0.0; } ;
      { Q1_Odd [0] = 0.0; Q1_Odd [1] = 0.0; Q1_Odd [2] = 0.0; Q1_Even [0] = 0.0; Q1_Even [1] = 0.0; Q1_Even [2] = 0.0; Q1 = 0.0; prev_Q1_Odd = 0.0; prev_Q1_Even = 0.0; prev_Q1_input_Odd = 0.0; prev_Q1_input_Even = 0.0; } ;
      { jI_Odd [0] = 0.0; jI_Odd [1] = 0.0; jI_Odd [2] = 0.0; jI_Even [0] = 0.0; jI_Even [1] = 0.0; jI_Even [2] = 0.0; jI = 0.0; prev_jI_Odd = 0.0; prev_jI_Even = 0.0; prev_jI_input_Odd = 0.0; prev_jI_input_Even = 0.0; } ;
      { jQ_Odd [0] = 0.0; jQ_Odd [1] = 0.0; jQ_Odd [2] = 0.0; jQ_Even [0] = 0.0; jQ_Even [1] = 0.0; jQ_Even [2] = 0.0; jQ = 0.0; prev_jQ_Odd = 0.0; prev_jQ_Even = 0.0; prev_jQ_input_Odd = 0.0; prev_jQ_input_Even = 0.0; } ;
      period = 0.0;
      outIdx = 0;
      prevI2 = prevQ2 = 0.0;
      Re = Im = 0.0;
      I1ForOddPrev3 = I1ForEvenPrev3 = 0.0;
      I1ForOddPrev2 = I1ForEvenPrev2 = 0.0;
      smoothPeriod = 0.0;
      for( i=0; i < 50 ; i++ )
         smoothPrice[i] = 0.0;
      while( today <= endIdx )
      {
         adjustedPrevPeriod = (0.075*period)+0.54;
         todayValue = inReal[today];
         { periodWMASub += todayValue; periodWMASub -= trailingWMAValue; periodWMASum += todayValue*4.0; trailingWMAValue = inReal[trailingWMAIdx++]; smoothedValue = periodWMASum*0.1; periodWMASum -= periodWMASub; } ;
         smoothPrice[smoothPrice_Idx] = smoothedValue;
         if( (today%2) == 0 )
         {
            { hilbertTempReal = a * smoothedValue; detrender = -detrender_Even [hilbertIdx]; detrender_Even [hilbertIdx] = hilbertTempReal; detrender += hilbertTempReal; detrender -= prev_detrender_Even ; prev_detrender_Even = b * prev_detrender_input_Even ; detrender += prev_detrender_Even ; prev_detrender_input_Even = smoothedValue; detrender *= adjustedPrevPeriod; } ;
            { hilbertTempReal = a * detrender; Q1 = -Q1_Even [hilbertIdx]; Q1_Even [hilbertIdx] = hilbertTempReal; Q1 += hilbertTempReal; Q1 -= prev_Q1_Even ; prev_Q1_Even = b * prev_Q1_input_Even ; Q1 += prev_Q1_Even ; prev_Q1_input_Even = detrender; Q1 *= adjustedPrevPeriod; } ;
            { hilbertTempReal = a * I1ForEvenPrev3; jI = -jI_Even [hilbertIdx]; jI_Even [hilbertIdx] = hilbertTempReal; jI += hilbertTempReal; jI -= prev_jI_Even ; prev_jI_Even = b * prev_jI_input_Even ; jI += prev_jI_Even ; prev_jI_input_Even = I1ForEvenPrev3; jI *= adjustedPrevPeriod; } ;
            { hilbertTempReal = a * Q1; jQ = -jQ_Even [hilbertIdx]; jQ_Even [hilbertIdx] = hilbertTempReal; jQ += hilbertTempReal; jQ -= prev_jQ_Even ; prev_jQ_Even = b * prev_jQ_input_Even ; jQ += prev_jQ_Even ; prev_jQ_input_Even = Q1; jQ *= adjustedPrevPeriod; } ;
            if( ++hilbertIdx == 3 )
               hilbertIdx = 0;
            Q2 = (0.2*(Q1 + jI)) + (0.8*prevQ2);
            I2 = (0.2*(I1ForEvenPrev3 - jQ)) + (0.8*prevI2);
            I1ForOddPrev3 = I1ForOddPrev2;
            I1ForOddPrev2 = detrender;
         }
         else
         {
            { hilbertTempReal = a * smoothedValue; detrender = -detrender_Odd [hilbertIdx]; detrender_Odd [hilbertIdx] = hilbertTempReal; detrender += hilbertTempReal; detrender -= prev_detrender_Odd ; prev_detrender_Odd = b * prev_detrender_input_Odd ; detrender += prev_detrender_Odd ; prev_detrender_input_Odd = smoothedValue; detrender *= adjustedPrevPeriod; } ;
            { hilbertTempReal = a * detrender; Q1 = -Q1_Odd [hilbertIdx]; Q1_Odd [hilbertIdx] = hilbertTempReal; Q1 += hilbertTempReal; Q1 -= prev_Q1_Odd ; prev_Q1_Odd = b * prev_Q1_input_Odd ; Q1 += prev_Q1_Odd ; prev_Q1_input_Odd = detrender; Q1 *= adjustedPrevPeriod; } ;
            { hilbertTempReal = a * I1ForOddPrev3; jI = -jI_Odd [hilbertIdx]; jI_Odd [hilbertIdx] = hilbertTempReal; jI += hilbertTempReal; jI -= prev_jI_Odd ; prev_jI_Odd = b * prev_jI_input_Odd ; jI += prev_jI_Odd ; prev_jI_input_Odd = I1ForOddPrev3; jI *= adjustedPrevPeriod; } ;
            { hilbertTempReal = a * Q1; jQ = -jQ_Odd [hilbertIdx]; jQ_Odd [hilbertIdx] = hilbertTempReal; jQ += hilbertTempReal; jQ -= prev_jQ_Odd ; prev_jQ_Odd = b * prev_jQ_input_Odd ; jQ += prev_jQ_Odd ; prev_jQ_input_Odd = Q1; jQ *= adjustedPrevPeriod; } ;
            Q2 = (0.2*(Q1 + jI)) + (0.8*prevQ2);
            I2 = (0.2*(I1ForOddPrev3 - jQ)) + (0.8*prevI2);
            I1ForEvenPrev3 = I1ForEvenPrev2;
            I1ForEvenPrev2 = detrender;
         }
         Re = (0.2*((I2*prevI2)+(Q2*prevQ2)))+(0.8*Re);
         Im = (0.2*((I2*prevQ2)-(Q2*prevI2)))+(0.8*Im);
         prevQ2 = Q2;
         prevI2 = I2;
         tempReal = period;
         if( (Im != 0.0) && (Re != 0.0) )
            period = 360.0 / ( Math.atan (Im/Re)*rad2Deg);
         tempReal2 = 1.5*tempReal;
         if( period > tempReal2)
            period = tempReal2;
         tempReal2 = 0.67*tempReal;
         if( period < tempReal2 )
            period = tempReal2;
         if( period < 6 )
            period = 6;
         else if( period > 50 )
            period = 50;
         period = (0.2*period) + (0.8 * tempReal);
         smoothPeriod = (0.33*period)+(0.67*smoothPeriod);
         DCPeriod = smoothPeriod+0.5;
         DCPeriodInt = (int)DCPeriod;
         idx = today;
         tempReal = 0.0;
         for( i=0; i < DCPeriodInt; i++ )
            tempReal += inReal[idx--];
         if( DCPeriodInt > 0 )
            tempReal = tempReal/(double)DCPeriodInt;
         tempReal2 = (4.0*tempReal + 3.0*iTrend1 + 2.0*iTrend2 + iTrend3) / 10.0;
         iTrend3 = iTrend2;
         iTrend2 = iTrend1;
         iTrend1 = tempReal;
         if( today >= startIdx )
         {
            outReal[outIdx++] = tempReal2;
         }
         { smoothPrice_Idx ++; if( smoothPrice_Idx > maxIdx_smoothPrice ) smoothPrice_Idx = 0; } ;
         today++;
      }
      outNBElement.value = outIdx;
      return RetCode.Success ;
   }
   public int htTrendlineStateInit( struct TA_htTrendline_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct htTrendline ));
      _state.value .value .mem_index = 0;
      _state.value .value .mem_size = htTrendlineLookback ();
      if ( _state.value .value .mem_size > 0)
         _state.value .value .memory = TA_Calloc( _state.value .value .mem_size , sizeof(struct TA_HT_TRENDLINE_Data));
      else
         _state.value .value .memory = NULL;
      return RetCode.Success ;
   }
   public int htTrendlineState( struct TA_htTrendline_State* _state,
      double inReal,
      double *outReal )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      size_t _cur_idx = _state.value .mem_index++;
      if ( _state.value .mem_size > 0) _cur_idx %= _state.value .mem_size ;
      if ( _state.value .mem_size > _state.value .mem_index - 1 ) {
         ( _state.value .memory+_cur_idx).value .inReal = inReal ;
         return RetCode.NeedMoreData ; }
      return RetCode.Success ;
   }
   public int htTrendlineStateFree( struct TA_htTrendline_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if ( _state.value != NULL) {
         if ( _state.value .value .memory != NULL) TA_Free( _state.value .value .memory );
         TA_Free( _state.value ); _state.value = NULL;}
      return RetCode.Success ;
   }
   public RetCode htTrendline( int startIdx,
      int endIdx,
      float inReal[],
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      int outIdx, i;
      int lookbackTotal, today;
      double tempReal, tempReal2;
      double adjustedPrevPeriod, period;
      int trailingWMAIdx;
      double periodWMASum, periodWMASub, trailingWMAValue;
      double smoothedValue;
      double iTrend1, iTrend2, iTrend3;
      final double a = 0.0962;
      final double b = 0.5769;
      double hilbertTempReal;
      int hilbertIdx;
      double []detrender_Odd = new double[3] ; double []detrender_Even = new double[3] ; double detrender; double prev_detrender_Odd ; double prev_detrender_Even ; double prev_detrender_input_Odd ; double prev_detrender_input_Even ;
      double []Q1_Odd = new double[3] ; double []Q1_Even = new double[3] ; double Q1; double prev_Q1_Odd ; double prev_Q1_Even ; double prev_Q1_input_Odd ; double prev_Q1_input_Even ;
      double []jI_Odd = new double[3] ; double []jI_Even = new double[3] ; double jI; double prev_jI_Odd ; double prev_jI_Even ; double prev_jI_input_Odd ; double prev_jI_input_Even ;
      double []jQ_Odd = new double[3] ; double []jQ_Even = new double[3] ; double jQ; double prev_jQ_Odd ; double prev_jQ_Even ; double prev_jQ_input_Odd ; double prev_jQ_input_Even ;
      double Q2, I2, prevQ2, prevI2, Re, Im;
      double I1ForOddPrev2, I1ForOddPrev3;
      double I1ForEvenPrev2, I1ForEvenPrev3;
      double rad2Deg;
      double todayValue, smoothPeriod;
      int smoothPrice_Idx = 0; double []smoothPrice; int maxIdx_smoothPrice = ( 50 -1) ;
      int idx;
      int DCPeriodInt;
      double DCPeriod;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      { smoothPrice = new double[maxIdx_smoothPrice +1]; } ;
      iTrend1 = iTrend2 = iTrend3 = 0.0;
      tempReal = Math.atan (1);
      rad2Deg = 45.0/tempReal;
      lookbackTotal = 63 + (this.unstablePeriod[FuncUnstId.HtTrendline.ordinal()]) ;
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      outBegIdx.value = startIdx;
      trailingWMAIdx = startIdx - lookbackTotal;
      today = trailingWMAIdx;
      tempReal = inReal[today++];
      periodWMASub = tempReal;
      periodWMASum = tempReal;
      tempReal = inReal[today++];
      periodWMASub += tempReal;
      periodWMASum += tempReal*2.0;
      tempReal = inReal[today++];
      periodWMASub += tempReal;
      periodWMASum += tempReal*3.0;
      trailingWMAValue = 0.0;
      i = 34;
      do
      {
         tempReal = inReal[today++];
         { periodWMASub += tempReal; periodWMASub -= trailingWMAValue; periodWMASum += tempReal*4.0; trailingWMAValue = inReal[trailingWMAIdx++]; smoothedValue = periodWMASum*0.1; periodWMASum -= periodWMASub; } ;
      } while( --i != 0);
      hilbertIdx = 0;
      { detrender_Odd [0] = 0.0; detrender_Odd [1] = 0.0; detrender_Odd [2] = 0.0; detrender_Even [0] = 0.0; detrender_Even [1] = 0.0; detrender_Even [2] = 0.0; detrender = 0.0; prev_detrender_Odd = 0.0; prev_detrender_Even = 0.0; prev_detrender_input_Odd = 0.0; prev_detrender_input_Even = 0.0; } ;
      { Q1_Odd [0] = 0.0; Q1_Odd [1] = 0.0; Q1_Odd [2] = 0.0; Q1_Even [0] = 0.0; Q1_Even [1] = 0.0; Q1_Even [2] = 0.0; Q1 = 0.0; prev_Q1_Odd = 0.0; prev_Q1_Even = 0.0; prev_Q1_input_Odd = 0.0; prev_Q1_input_Even = 0.0; } ;
      { jI_Odd [0] = 0.0; jI_Odd [1] = 0.0; jI_Odd [2] = 0.0; jI_Even [0] = 0.0; jI_Even [1] = 0.0; jI_Even [2] = 0.0; jI = 0.0; prev_jI_Odd = 0.0; prev_jI_Even = 0.0; prev_jI_input_Odd = 0.0; prev_jI_input_Even = 0.0; } ;
      { jQ_Odd [0] = 0.0; jQ_Odd [1] = 0.0; jQ_Odd [2] = 0.0; jQ_Even [0] = 0.0; jQ_Even [1] = 0.0; jQ_Even [2] = 0.0; jQ = 0.0; prev_jQ_Odd = 0.0; prev_jQ_Even = 0.0; prev_jQ_input_Odd = 0.0; prev_jQ_input_Even = 0.0; } ;
      period = 0.0;
      outIdx = 0;
      prevI2 = prevQ2 = 0.0;
      Re = Im = 0.0;
      I1ForOddPrev3 = I1ForEvenPrev3 = 0.0;
      I1ForOddPrev2 = I1ForEvenPrev2 = 0.0;
      smoothPeriod = 0.0;
      for( i=0; i < 50 ; i++ )
         smoothPrice[i] = 0.0;
      while( today <= endIdx )
      {
         adjustedPrevPeriod = (0.075*period)+0.54;
         todayValue = inReal[today];
         { periodWMASub += todayValue; periodWMASub -= trailingWMAValue; periodWMASum += todayValue*4.0; trailingWMAValue = inReal[trailingWMAIdx++]; smoothedValue = periodWMASum*0.1; periodWMASum -= periodWMASub; } ;
         smoothPrice[smoothPrice_Idx] = smoothedValue;
         if( (today%2) == 0 )
         {
            { hilbertTempReal = a * smoothedValue; detrender = -detrender_Even [hilbertIdx]; detrender_Even [hilbertIdx] = hilbertTempReal; detrender += hilbertTempReal; detrender -= prev_detrender_Even ; prev_detrender_Even = b * prev_detrender_input_Even ; detrender += prev_detrender_Even ; prev_detrender_input_Even = smoothedValue; detrender *= adjustedPrevPeriod; } ;
            { hilbertTempReal = a * detrender; Q1 = -Q1_Even [hilbertIdx]; Q1_Even [hilbertIdx] = hilbertTempReal; Q1 += hilbertTempReal; Q1 -= prev_Q1_Even ; prev_Q1_Even = b * prev_Q1_input_Even ; Q1 += prev_Q1_Even ; prev_Q1_input_Even = detrender; Q1 *= adjustedPrevPeriod; } ;
            { hilbertTempReal = a * I1ForEvenPrev3; jI = -jI_Even [hilbertIdx]; jI_Even [hilbertIdx] = hilbertTempReal; jI += hilbertTempReal; jI -= prev_jI_Even ; prev_jI_Even = b * prev_jI_input_Even ; jI += prev_jI_Even ; prev_jI_input_Even = I1ForEvenPrev3; jI *= adjustedPrevPeriod; } ;
            { hilbertTempReal = a * Q1; jQ = -jQ_Even [hilbertIdx]; jQ_Even [hilbertIdx] = hilbertTempReal; jQ += hilbertTempReal; jQ -= prev_jQ_Even ; prev_jQ_Even = b * prev_jQ_input_Even ; jQ += prev_jQ_Even ; prev_jQ_input_Even = Q1; jQ *= adjustedPrevPeriod; } ;
            if( ++hilbertIdx == 3 )
               hilbertIdx = 0;
            Q2 = (0.2*(Q1 + jI)) + (0.8*prevQ2);
            I2 = (0.2*(I1ForEvenPrev3 - jQ)) + (0.8*prevI2);
            I1ForOddPrev3 = I1ForOddPrev2;
            I1ForOddPrev2 = detrender;
         }
         else
         {
            { hilbertTempReal = a * smoothedValue; detrender = -detrender_Odd [hilbertIdx]; detrender_Odd [hilbertIdx] = hilbertTempReal; detrender += hilbertTempReal; detrender -= prev_detrender_Odd ; prev_detrender_Odd = b * prev_detrender_input_Odd ; detrender += prev_detrender_Odd ; prev_detrender_input_Odd = smoothedValue; detrender *= adjustedPrevPeriod; } ;
            { hilbertTempReal = a * detrender; Q1 = -Q1_Odd [hilbertIdx]; Q1_Odd [hilbertIdx] = hilbertTempReal; Q1 += hilbertTempReal; Q1 -= prev_Q1_Odd ; prev_Q1_Odd = b * prev_Q1_input_Odd ; Q1 += prev_Q1_Odd ; prev_Q1_input_Odd = detrender; Q1 *= adjustedPrevPeriod; } ;
            { hilbertTempReal = a * I1ForOddPrev3; jI = -jI_Odd [hilbertIdx]; jI_Odd [hilbertIdx] = hilbertTempReal; jI += hilbertTempReal; jI -= prev_jI_Odd ; prev_jI_Odd = b * prev_jI_input_Odd ; jI += prev_jI_Odd ; prev_jI_input_Odd = I1ForOddPrev3; jI *= adjustedPrevPeriod; } ;
            { hilbertTempReal = a * Q1; jQ = -jQ_Odd [hilbertIdx]; jQ_Odd [hilbertIdx] = hilbertTempReal; jQ += hilbertTempReal; jQ -= prev_jQ_Odd ; prev_jQ_Odd = b * prev_jQ_input_Odd ; jQ += prev_jQ_Odd ; prev_jQ_input_Odd = Q1; jQ *= adjustedPrevPeriod; } ;
            Q2 = (0.2*(Q1 + jI)) + (0.8*prevQ2);
            I2 = (0.2*(I1ForOddPrev3 - jQ)) + (0.8*prevI2);
            I1ForEvenPrev3 = I1ForEvenPrev2;
            I1ForEvenPrev2 = detrender;
         }
         Re = (0.2*((I2*prevI2)+(Q2*prevQ2)))+(0.8*Re);
         Im = (0.2*((I2*prevQ2)-(Q2*prevI2)))+(0.8*Im);
         prevQ2 = Q2;
         prevI2 = I2;
         tempReal = period;
         if( (Im != 0.0) && (Re != 0.0) )
            period = 360.0 / ( Math.atan (Im/Re)*rad2Deg);
         tempReal2 = 1.5*tempReal;
         if( period > tempReal2)
            period = tempReal2;
         tempReal2 = 0.67*tempReal;
         if( period < tempReal2 )
            period = tempReal2;
         if( period < 6 )
            period = 6;
         else if( period > 50 )
            period = 50;
         period = (0.2*period) + (0.8 * tempReal);
         smoothPeriod = (0.33*period)+(0.67*smoothPeriod);
         DCPeriod = smoothPeriod+0.5;
         DCPeriodInt = (int)DCPeriod;
         idx = today;
         tempReal = 0.0;
         for( i=0; i < DCPeriodInt; i++ )
            tempReal += inReal[idx--];
         if( DCPeriodInt > 0 )
            tempReal = tempReal/(double)DCPeriodInt;
         tempReal2 = (4.0*tempReal + 3.0*iTrend1 + 2.0*iTrend2 + iTrend3) / 10.0;
         iTrend3 = iTrend2;
         iTrend2 = iTrend1;
         iTrend1 = tempReal;
         if( today >= startIdx )
         {
            outReal[outIdx++] = tempReal2;
         }
         { smoothPrice_Idx ++; if( smoothPrice_Idx > maxIdx_smoothPrice ) smoothPrice_Idx = 0; } ;
         today++;
      }
      outNBElement.value = outIdx;
      return RetCode.Success ;
   }
   /* Generated */
   public int htTrendModeLookback( )
   {
      return 63 + (this.unstablePeriod[FuncUnstId.HtTrendMode.ordinal()]) ;
   }
   public RetCode htTrendMode( int startIdx,
      int endIdx,
      double inReal[],
      MInteger outBegIdx,
      MInteger outNBElement,
      int outInteger[] )
   {
      int outIdx, i;
      int lookbackTotal, today;
      double tempReal, tempReal2;
      double adjustedPrevPeriod, period;
      int trailingWMAIdx;
      double periodWMASum, periodWMASub, trailingWMAValue;
      double smoothedValue;
      double iTrend1, iTrend2, iTrend3;
      final double a = 0.0962;
      final double b = 0.5769;
      double hilbertTempReal;
      int hilbertIdx;
      double []detrender_Odd = new double[3] ; double []detrender_Even = new double[3] ; double detrender; double prev_detrender_Odd ; double prev_detrender_Even ; double prev_detrender_input_Odd ; double prev_detrender_input_Even ;
      double []Q1_Odd = new double[3] ; double []Q1_Even = new double[3] ; double Q1; double prev_Q1_Odd ; double prev_Q1_Even ; double prev_Q1_input_Odd ; double prev_Q1_input_Even ;
      double []jI_Odd = new double[3] ; double []jI_Even = new double[3] ; double jI; double prev_jI_Odd ; double prev_jI_Even ; double prev_jI_input_Odd ; double prev_jI_input_Even ;
      double []jQ_Odd = new double[3] ; double []jQ_Even = new double[3] ; double jQ; double prev_jQ_Odd ; double prev_jQ_Even ; double prev_jQ_input_Odd ; double prev_jQ_input_Even ;
      double Q2, I2, prevQ2, prevI2, Re, Im;
      double I1ForOddPrev2, I1ForOddPrev3;
      double I1ForEvenPrev2, I1ForEvenPrev3;
      double rad2Deg, deg2Rad, constDeg2RadBy360;
      double todayValue, smoothPeriod;
      int smoothPrice_Idx = 0; double []smoothPrice; int maxIdx_smoothPrice = ( 50 -1) ;
      int idx;
      int DCPeriodInt;
      double DCPhase, DCPeriod, imagPart, realPart;
      int daysInTrend, trend;
      double prevDCPhase, trendline;
      double prevSine, prevLeadSine, sine, leadSine;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      { smoothPrice = new double[maxIdx_smoothPrice +1]; } ;
      iTrend1 = iTrend2 = iTrend3 = 0.0;
      daysInTrend = 0;
      prevDCPhase = DCPhase = 0.0;
      prevSine = sine = 0.0;
      prevLeadSine = leadSine = 0.0;
      tempReal = Math.atan (1);
      rad2Deg = 45.0/tempReal;
      deg2Rad = 1.0/rad2Deg;
      constDeg2RadBy360 = tempReal*8.0;
      lookbackTotal = 63 + (this.unstablePeriod[FuncUnstId.HtTrendMode.ordinal()]) ;
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      outBegIdx.value = startIdx;
      trailingWMAIdx = startIdx - lookbackTotal;
      today = trailingWMAIdx;
      tempReal = inReal[today++];
      periodWMASub = tempReal;
      periodWMASum = tempReal;
      tempReal = inReal[today++];
      periodWMASub += tempReal;
      periodWMASum += tempReal*2.0;
      tempReal = inReal[today++];
      periodWMASub += tempReal;
      periodWMASum += tempReal*3.0;
      trailingWMAValue = 0.0;
      i = 34;
      do
      {
         tempReal = inReal[today++];
         { periodWMASub += tempReal; periodWMASub -= trailingWMAValue; periodWMASum += tempReal*4.0; trailingWMAValue = inReal[trailingWMAIdx++]; smoothedValue = periodWMASum*0.1; periodWMASum -= periodWMASub; } ;
      } while( --i != 0);
      hilbertIdx = 0;
      { detrender_Odd [0] = 0.0; detrender_Odd [1] = 0.0; detrender_Odd [2] = 0.0; detrender_Even [0] = 0.0; detrender_Even [1] = 0.0; detrender_Even [2] = 0.0; detrender = 0.0; prev_detrender_Odd = 0.0; prev_detrender_Even = 0.0; prev_detrender_input_Odd = 0.0; prev_detrender_input_Even = 0.0; } ;
      { Q1_Odd [0] = 0.0; Q1_Odd [1] = 0.0; Q1_Odd [2] = 0.0; Q1_Even [0] = 0.0; Q1_Even [1] = 0.0; Q1_Even [2] = 0.0; Q1 = 0.0; prev_Q1_Odd = 0.0; prev_Q1_Even = 0.0; prev_Q1_input_Odd = 0.0; prev_Q1_input_Even = 0.0; } ;
      { jI_Odd [0] = 0.0; jI_Odd [1] = 0.0; jI_Odd [2] = 0.0; jI_Even [0] = 0.0; jI_Even [1] = 0.0; jI_Even [2] = 0.0; jI = 0.0; prev_jI_Odd = 0.0; prev_jI_Even = 0.0; prev_jI_input_Odd = 0.0; prev_jI_input_Even = 0.0; } ;
      { jQ_Odd [0] = 0.0; jQ_Odd [1] = 0.0; jQ_Odd [2] = 0.0; jQ_Even [0] = 0.0; jQ_Even [1] = 0.0; jQ_Even [2] = 0.0; jQ = 0.0; prev_jQ_Odd = 0.0; prev_jQ_Even = 0.0; prev_jQ_input_Odd = 0.0; prev_jQ_input_Even = 0.0; } ;
      period = 0.0;
      outIdx = 0;
      prevI2 = prevQ2 = 0.0;
      Re = Im = 0.0;
      I1ForOddPrev3 = I1ForEvenPrev3 = 0.0;
      I1ForOddPrev2 = I1ForEvenPrev2 = 0.0;
      smoothPeriod = 0.0;
      for( i=0; i < 50 ; i++ )
         smoothPrice[i] = 0.0;
      DCPhase = 0.0;
      while( today <= endIdx )
      {
         adjustedPrevPeriod = (0.075*period)+0.54;
         todayValue = inReal[today];
         { periodWMASub += todayValue; periodWMASub -= trailingWMAValue; periodWMASum += todayValue*4.0; trailingWMAValue = inReal[trailingWMAIdx++]; smoothedValue = periodWMASum*0.1; periodWMASum -= periodWMASub; } ;
         smoothPrice[smoothPrice_Idx] = smoothedValue;
         if( (today%2) == 0 )
         {
            { hilbertTempReal = a * smoothedValue; detrender = -detrender_Even [hilbertIdx]; detrender_Even [hilbertIdx] = hilbertTempReal; detrender += hilbertTempReal; detrender -= prev_detrender_Even ; prev_detrender_Even = b * prev_detrender_input_Even ; detrender += prev_detrender_Even ; prev_detrender_input_Even = smoothedValue; detrender *= adjustedPrevPeriod; } ;
            { hilbertTempReal = a * detrender; Q1 = -Q1_Even [hilbertIdx]; Q1_Even [hilbertIdx] = hilbertTempReal; Q1 += hilbertTempReal; Q1 -= prev_Q1_Even ; prev_Q1_Even = b * prev_Q1_input_Even ; Q1 += prev_Q1_Even ; prev_Q1_input_Even = detrender; Q1 *= adjustedPrevPeriod; } ;
            { hilbertTempReal = a * I1ForEvenPrev3; jI = -jI_Even [hilbertIdx]; jI_Even [hilbertIdx] = hilbertTempReal; jI += hilbertTempReal; jI -= prev_jI_Even ; prev_jI_Even = b * prev_jI_input_Even ; jI += prev_jI_Even ; prev_jI_input_Even = I1ForEvenPrev3; jI *= adjustedPrevPeriod; } ;
            { hilbertTempReal = a * Q1; jQ = -jQ_Even [hilbertIdx]; jQ_Even [hilbertIdx] = hilbertTempReal; jQ += hilbertTempReal; jQ -= prev_jQ_Even ; prev_jQ_Even = b * prev_jQ_input_Even ; jQ += prev_jQ_Even ; prev_jQ_input_Even = Q1; jQ *= adjustedPrevPeriod; } ;
            if( ++hilbertIdx == 3 )
               hilbertIdx = 0;
            Q2 = (0.2*(Q1 + jI)) + (0.8*prevQ2);
            I2 = (0.2*(I1ForEvenPrev3 - jQ)) + (0.8*prevI2);
            I1ForOddPrev3 = I1ForOddPrev2;
            I1ForOddPrev2 = detrender;
         }
         else
         {
            { hilbertTempReal = a * smoothedValue; detrender = -detrender_Odd [hilbertIdx]; detrender_Odd [hilbertIdx] = hilbertTempReal; detrender += hilbertTempReal; detrender -= prev_detrender_Odd ; prev_detrender_Odd = b * prev_detrender_input_Odd ; detrender += prev_detrender_Odd ; prev_detrender_input_Odd = smoothedValue; detrender *= adjustedPrevPeriod; } ;
            { hilbertTempReal = a * detrender; Q1 = -Q1_Odd [hilbertIdx]; Q1_Odd [hilbertIdx] = hilbertTempReal; Q1 += hilbertTempReal; Q1 -= prev_Q1_Odd ; prev_Q1_Odd = b * prev_Q1_input_Odd ; Q1 += prev_Q1_Odd ; prev_Q1_input_Odd = detrender; Q1 *= adjustedPrevPeriod; } ;
            { hilbertTempReal = a * I1ForOddPrev3; jI = -jI_Odd [hilbertIdx]; jI_Odd [hilbertIdx] = hilbertTempReal; jI += hilbertTempReal; jI -= prev_jI_Odd ; prev_jI_Odd = b * prev_jI_input_Odd ; jI += prev_jI_Odd ; prev_jI_input_Odd = I1ForOddPrev3; jI *= adjustedPrevPeriod; } ;
            { hilbertTempReal = a * Q1; jQ = -jQ_Odd [hilbertIdx]; jQ_Odd [hilbertIdx] = hilbertTempReal; jQ += hilbertTempReal; jQ -= prev_jQ_Odd ; prev_jQ_Odd = b * prev_jQ_input_Odd ; jQ += prev_jQ_Odd ; prev_jQ_input_Odd = Q1; jQ *= adjustedPrevPeriod; } ;
            Q2 = (0.2*(Q1 + jI)) + (0.8*prevQ2);
            I2 = (0.2*(I1ForOddPrev3 - jQ)) + (0.8*prevI2);
            I1ForEvenPrev3 = I1ForEvenPrev2;
            I1ForEvenPrev2 = detrender;
         }
         Re = (0.2*((I2*prevI2)+(Q2*prevQ2)))+(0.8*Re);
         Im = (0.2*((I2*prevQ2)-(Q2*prevI2)))+(0.8*Im);
         prevQ2 = Q2;
         prevI2 = I2;
         tempReal = period;
         if( (Im != 0.0) && (Re != 0.0) )
            period = 360.0 / ( Math.atan (Im/Re)*rad2Deg);
         tempReal2 = 1.5*tempReal;
         if( period > tempReal2)
            period = tempReal2;
         tempReal2 = 0.67*tempReal;
         if( period < tempReal2 )
            period = tempReal2;
         if( period < 6 )
            period = 6;
         else if( period > 50 )
            period = 50;
         period = (0.2*period) + (0.8 * tempReal);
         smoothPeriod = (0.33*period)+(0.67*smoothPeriod);
         prevDCPhase = DCPhase;
         DCPeriod = smoothPeriod+0.5;
         DCPeriodInt = (int)DCPeriod;
         realPart = 0.0;
         imagPart = 0.0;
         idx = smoothPrice_Idx;
         for( i=0; i < DCPeriodInt; i++ )
         {
            tempReal = ((double)i*constDeg2RadBy360)/(double)DCPeriodInt;
            tempReal2 = smoothPrice[idx];
            realPart += Math.sin (tempReal)*tempReal2;
            imagPart += Math.cos (tempReal)*tempReal2;
            if( idx == 0 )
               idx = 50 -1;
            else
               idx--;
         }
         tempReal = Math.abs (imagPart);
         if( tempReal > 0.0 )
            DCPhase = Math.atan (realPart/imagPart)*rad2Deg;
         else if( tempReal <= 0.01 )
         {
            if( realPart < 0.0 )
               DCPhase -= 90.0;
            else if( realPart > 0.0 )
               DCPhase += 90.0;
         }
         DCPhase += 90.0;
         DCPhase += 360.0 / smoothPeriod;
         if( imagPart < 0.0 )
            DCPhase += 180.0;
         if( DCPhase > 315.0 )
            DCPhase -= 360.0;
         prevSine = sine;
         prevLeadSine = leadSine;
         sine = Math.sin (DCPhase*deg2Rad);
         leadSine = Math.sin ((DCPhase+45)*deg2Rad);
         DCPeriod = smoothPeriod+0.5;
         DCPeriodInt = (int)DCPeriod;
         idx = today;
         tempReal = 0.0;
         for( i=0; i < DCPeriodInt; i++ )
            tempReal += inReal[idx--];
         if( DCPeriodInt > 0 )
            tempReal = tempReal/(double)DCPeriodInt;
         trendline = (4.0*tempReal + 3.0*iTrend1 + 2.0*iTrend2 + iTrend3) / 10.0;
         iTrend3 = iTrend2;
         iTrend2 = iTrend1;
         iTrend1 = tempReal;
         trend = 1;
         if( ((sine > leadSine) && (prevSine <= prevLeadSine)) ||
            ((sine < leadSine) && (prevSine >= prevLeadSine)) )
         {
            daysInTrend = 0;
            trend = 0;
         }
         daysInTrend++;
         if( daysInTrend < (0.5*smoothPeriod) )
            trend = 0;
         tempReal = DCPhase - prevDCPhase;
         if( (smoothPeriod != 0.0) &&
            ((tempReal > (0.67*360.0/smoothPeriod)) && (tempReal < (1.5*360.0/smoothPeriod))) )
         {
            trend = 0;
         }
         tempReal = smoothPrice[smoothPrice_Idx];
         if( (trendline != 0.0) && ( Math.abs ( (tempReal - trendline)/trendline ) >= 0.015) )
            trend = 1;
         if( today >= startIdx )
         {
            outInteger[outIdx++] = trend;
         }
         { smoothPrice_Idx ++; if( smoothPrice_Idx > maxIdx_smoothPrice ) smoothPrice_Idx = 0; } ;
         today++;
      }
      outNBElement.value = outIdx;
      return RetCode.Success ;
   }
   public int htTrendModeStateInit( struct TA_htTrendMode_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct htTrendMode ));
      _state.value .value .mem_index = 0;
      _state.value .value .mem_size = htTrendModeLookback ();
      if ( _state.value .value .mem_size > 0)
         _state.value .value .memory = TA_Calloc( _state.value .value .mem_size , sizeof(struct TA_HT_TRENDMODE_Data));
      else
         _state.value .value .memory = NULL;
      return RetCode.Success ;
   }
   public int htTrendModeState( struct TA_htTrendMode_State* _state,
      double inReal,
      int *outInteger )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      size_t _cur_idx = _state.value .mem_index++;
      if ( _state.value .mem_size > 0) _cur_idx %= _state.value .mem_size ;
      if ( _state.value .mem_size > _state.value .mem_index - 1 ) {
         ( _state.value .memory+_cur_idx).value .inReal = inReal ;
         return RetCode.NeedMoreData ; }
      return RetCode.Success ;
   }
   public int htTrendModeStateFree( struct TA_htTrendMode_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if ( _state.value != NULL) {
         if ( _state.value .value .memory != NULL) TA_Free( _state.value .value .memory );
         TA_Free( _state.value ); _state.value = NULL;}
      return RetCode.Success ;
   }
   public RetCode htTrendMode( int startIdx,
      int endIdx,
      float inReal[],
      MInteger outBegIdx,
      MInteger outNBElement,
      int outInteger[] )
   {
      int outIdx, i;
      int lookbackTotal, today;
      double tempReal, tempReal2;
      double adjustedPrevPeriod, period;
      int trailingWMAIdx;
      double periodWMASum, periodWMASub, trailingWMAValue;
      double smoothedValue;
      double iTrend1, iTrend2, iTrend3;
      final double a = 0.0962;
      final double b = 0.5769;
      double hilbertTempReal;
      int hilbertIdx;
      double []detrender_Odd = new double[3] ; double []detrender_Even = new double[3] ; double detrender; double prev_detrender_Odd ; double prev_detrender_Even ; double prev_detrender_input_Odd ; double prev_detrender_input_Even ;
      double []Q1_Odd = new double[3] ; double []Q1_Even = new double[3] ; double Q1; double prev_Q1_Odd ; double prev_Q1_Even ; double prev_Q1_input_Odd ; double prev_Q1_input_Even ;
      double []jI_Odd = new double[3] ; double []jI_Even = new double[3] ; double jI; double prev_jI_Odd ; double prev_jI_Even ; double prev_jI_input_Odd ; double prev_jI_input_Even ;
      double []jQ_Odd = new double[3] ; double []jQ_Even = new double[3] ; double jQ; double prev_jQ_Odd ; double prev_jQ_Even ; double prev_jQ_input_Odd ; double prev_jQ_input_Even ;
      double Q2, I2, prevQ2, prevI2, Re, Im;
      double I1ForOddPrev2, I1ForOddPrev3;
      double I1ForEvenPrev2, I1ForEvenPrev3;
      double rad2Deg, deg2Rad, constDeg2RadBy360;
      double todayValue, smoothPeriod;
      int smoothPrice_Idx = 0; double []smoothPrice; int maxIdx_smoothPrice = ( 50 -1) ;
      int idx;
      int DCPeriodInt;
      double DCPhase, DCPeriod, imagPart, realPart;
      int daysInTrend, trend;
      double prevDCPhase, trendline;
      double prevSine, prevLeadSine, sine, leadSine;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      { smoothPrice = new double[maxIdx_smoothPrice +1]; } ;
      iTrend1 = iTrend2 = iTrend3 = 0.0;
      daysInTrend = 0;
      prevDCPhase = DCPhase = 0.0;
      prevSine = sine = 0.0;
      prevLeadSine = leadSine = 0.0;
      tempReal = Math.atan (1);
      rad2Deg = 45.0/tempReal;
      deg2Rad = 1.0/rad2Deg;
      constDeg2RadBy360 = tempReal*8.0;
      lookbackTotal = 63 + (this.unstablePeriod[FuncUnstId.HtTrendMode.ordinal()]) ;
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      outBegIdx.value = startIdx;
      trailingWMAIdx = startIdx - lookbackTotal;
      today = trailingWMAIdx;
      tempReal = inReal[today++];
      periodWMASub = tempReal;
      periodWMASum = tempReal;
      tempReal = inReal[today++];
      periodWMASub += tempReal;
      periodWMASum += tempReal*2.0;
      tempReal = inReal[today++];
      periodWMASub += tempReal;
      periodWMASum += tempReal*3.0;
      trailingWMAValue = 0.0;
      i = 34;
      do
      {
         tempReal = inReal[today++];
         { periodWMASub += tempReal; periodWMASub -= trailingWMAValue; periodWMASum += tempReal*4.0; trailingWMAValue = inReal[trailingWMAIdx++]; smoothedValue = periodWMASum*0.1; periodWMASum -= periodWMASub; } ;
      } while( --i != 0);
      hilbertIdx = 0;
      { detrender_Odd [0] = 0.0; detrender_Odd [1] = 0.0; detrender_Odd [2] = 0.0; detrender_Even [0] = 0.0; detrender_Even [1] = 0.0; detrender_Even [2] = 0.0; detrender = 0.0; prev_detrender_Odd = 0.0; prev_detrender_Even = 0.0; prev_detrender_input_Odd = 0.0; prev_detrender_input_Even = 0.0; } ;
      { Q1_Odd [0] = 0.0; Q1_Odd [1] = 0.0; Q1_Odd [2] = 0.0; Q1_Even [0] = 0.0; Q1_Even [1] = 0.0; Q1_Even [2] = 0.0; Q1 = 0.0; prev_Q1_Odd = 0.0; prev_Q1_Even = 0.0; prev_Q1_input_Odd = 0.0; prev_Q1_input_Even = 0.0; } ;
      { jI_Odd [0] = 0.0; jI_Odd [1] = 0.0; jI_Odd [2] = 0.0; jI_Even [0] = 0.0; jI_Even [1] = 0.0; jI_Even [2] = 0.0; jI = 0.0; prev_jI_Odd = 0.0; prev_jI_Even = 0.0; prev_jI_input_Odd = 0.0; prev_jI_input_Even = 0.0; } ;
      { jQ_Odd [0] = 0.0; jQ_Odd [1] = 0.0; jQ_Odd [2] = 0.0; jQ_Even [0] = 0.0; jQ_Even [1] = 0.0; jQ_Even [2] = 0.0; jQ = 0.0; prev_jQ_Odd = 0.0; prev_jQ_Even = 0.0; prev_jQ_input_Odd = 0.0; prev_jQ_input_Even = 0.0; } ;
      period = 0.0;
      outIdx = 0;
      prevI2 = prevQ2 = 0.0;
      Re = Im = 0.0;
      I1ForOddPrev3 = I1ForEvenPrev3 = 0.0;
      I1ForOddPrev2 = I1ForEvenPrev2 = 0.0;
      smoothPeriod = 0.0;
      for( i=0; i < 50 ; i++ )
         smoothPrice[i] = 0.0;
      DCPhase = 0.0;
      while( today <= endIdx )
      {
         adjustedPrevPeriod = (0.075*period)+0.54;
         todayValue = inReal[today];
         { periodWMASub += todayValue; periodWMASub -= trailingWMAValue; periodWMASum += todayValue*4.0; trailingWMAValue = inReal[trailingWMAIdx++]; smoothedValue = periodWMASum*0.1; periodWMASum -= periodWMASub; } ;
         smoothPrice[smoothPrice_Idx] = smoothedValue;
         if( (today%2) == 0 )
         {
            { hilbertTempReal = a * smoothedValue; detrender = -detrender_Even [hilbertIdx]; detrender_Even [hilbertIdx] = hilbertTempReal; detrender += hilbertTempReal; detrender -= prev_detrender_Even ; prev_detrender_Even = b * prev_detrender_input_Even ; detrender += prev_detrender_Even ; prev_detrender_input_Even = smoothedValue; detrender *= adjustedPrevPeriod; } ;
            { hilbertTempReal = a * detrender; Q1 = -Q1_Even [hilbertIdx]; Q1_Even [hilbertIdx] = hilbertTempReal; Q1 += hilbertTempReal; Q1 -= prev_Q1_Even ; prev_Q1_Even = b * prev_Q1_input_Even ; Q1 += prev_Q1_Even ; prev_Q1_input_Even = detrender; Q1 *= adjustedPrevPeriod; } ;
            { hilbertTempReal = a * I1ForEvenPrev3; jI = -jI_Even [hilbertIdx]; jI_Even [hilbertIdx] = hilbertTempReal; jI += hilbertTempReal; jI -= prev_jI_Even ; prev_jI_Even = b * prev_jI_input_Even ; jI += prev_jI_Even ; prev_jI_input_Even = I1ForEvenPrev3; jI *= adjustedPrevPeriod; } ;
            { hilbertTempReal = a * Q1; jQ = -jQ_Even [hilbertIdx]; jQ_Even [hilbertIdx] = hilbertTempReal; jQ += hilbertTempReal; jQ -= prev_jQ_Even ; prev_jQ_Even = b * prev_jQ_input_Even ; jQ += prev_jQ_Even ; prev_jQ_input_Even = Q1; jQ *= adjustedPrevPeriod; } ;
            if( ++hilbertIdx == 3 )
               hilbertIdx = 0;
            Q2 = (0.2*(Q1 + jI)) + (0.8*prevQ2);
            I2 = (0.2*(I1ForEvenPrev3 - jQ)) + (0.8*prevI2);
            I1ForOddPrev3 = I1ForOddPrev2;
            I1ForOddPrev2 = detrender;
         }
         else
         {
            { hilbertTempReal = a * smoothedValue; detrender = -detrender_Odd [hilbertIdx]; detrender_Odd [hilbertIdx] = hilbertTempReal; detrender += hilbertTempReal; detrender -= prev_detrender_Odd ; prev_detrender_Odd = b * prev_detrender_input_Odd ; detrender += prev_detrender_Odd ; prev_detrender_input_Odd = smoothedValue; detrender *= adjustedPrevPeriod; } ;
            { hilbertTempReal = a * detrender; Q1 = -Q1_Odd [hilbertIdx]; Q1_Odd [hilbertIdx] = hilbertTempReal; Q1 += hilbertTempReal; Q1 -= prev_Q1_Odd ; prev_Q1_Odd = b * prev_Q1_input_Odd ; Q1 += prev_Q1_Odd ; prev_Q1_input_Odd = detrender; Q1 *= adjustedPrevPeriod; } ;
            { hilbertTempReal = a * I1ForOddPrev3; jI = -jI_Odd [hilbertIdx]; jI_Odd [hilbertIdx] = hilbertTempReal; jI += hilbertTempReal; jI -= prev_jI_Odd ; prev_jI_Odd = b * prev_jI_input_Odd ; jI += prev_jI_Odd ; prev_jI_input_Odd = I1ForOddPrev3; jI *= adjustedPrevPeriod; } ;
            { hilbertTempReal = a * Q1; jQ = -jQ_Odd [hilbertIdx]; jQ_Odd [hilbertIdx] = hilbertTempReal; jQ += hilbertTempReal; jQ -= prev_jQ_Odd ; prev_jQ_Odd = b * prev_jQ_input_Odd ; jQ += prev_jQ_Odd ; prev_jQ_input_Odd = Q1; jQ *= adjustedPrevPeriod; } ;
            Q2 = (0.2*(Q1 + jI)) + (0.8*prevQ2);
            I2 = (0.2*(I1ForOddPrev3 - jQ)) + (0.8*prevI2);
            I1ForEvenPrev3 = I1ForEvenPrev2;
            I1ForEvenPrev2 = detrender;
         }
         Re = (0.2*((I2*prevI2)+(Q2*prevQ2)))+(0.8*Re);
         Im = (0.2*((I2*prevQ2)-(Q2*prevI2)))+(0.8*Im);
         prevQ2 = Q2;
         prevI2 = I2;
         tempReal = period;
         if( (Im != 0.0) && (Re != 0.0) )
            period = 360.0 / ( Math.atan (Im/Re)*rad2Deg);
         tempReal2 = 1.5*tempReal;
         if( period > tempReal2)
            period = tempReal2;
         tempReal2 = 0.67*tempReal;
         if( period < tempReal2 )
            period = tempReal2;
         if( period < 6 )
            period = 6;
         else if( period > 50 )
            period = 50;
         period = (0.2*period) + (0.8 * tempReal);
         smoothPeriod = (0.33*period)+(0.67*smoothPeriod);
         prevDCPhase = DCPhase;
         DCPeriod = smoothPeriod+0.5;
         DCPeriodInt = (int)DCPeriod;
         realPart = 0.0;
         imagPart = 0.0;
         idx = smoothPrice_Idx;
         for( i=0; i < DCPeriodInt; i++ )
         {
            tempReal = ((double)i*constDeg2RadBy360)/(double)DCPeriodInt;
            tempReal2 = smoothPrice[idx];
            realPart += Math.sin (tempReal)*tempReal2;
            imagPart += Math.cos (tempReal)*tempReal2;
            if( idx == 0 )
               idx = 50 -1;
            else
               idx--;
         }
         tempReal = Math.abs (imagPart);
         if( tempReal > 0.0 )
            DCPhase = Math.atan (realPart/imagPart)*rad2Deg;
         else if( tempReal <= 0.01 )
         {
            if( realPart < 0.0 )
               DCPhase -= 90.0;
            else if( realPart > 0.0 )
               DCPhase += 90.0;
         }
         DCPhase += 90.0;
         DCPhase += 360.0 / smoothPeriod;
         if( imagPart < 0.0 )
            DCPhase += 180.0;
         if( DCPhase > 315.0 )
            DCPhase -= 360.0;
         prevSine = sine;
         prevLeadSine = leadSine;
         sine = Math.sin (DCPhase*deg2Rad);
         leadSine = Math.sin ((DCPhase+45)*deg2Rad);
         DCPeriod = smoothPeriod+0.5;
         DCPeriodInt = (int)DCPeriod;
         idx = today;
         tempReal = 0.0;
         for( i=0; i < DCPeriodInt; i++ )
            tempReal += inReal[idx--];
         if( DCPeriodInt > 0 )
            tempReal = tempReal/(double)DCPeriodInt;
         trendline = (4.0*tempReal + 3.0*iTrend1 + 2.0*iTrend2 + iTrend3) / 10.0;
         iTrend3 = iTrend2;
         iTrend2 = iTrend1;
         iTrend1 = tempReal;
         trend = 1;
         if( ((sine > leadSine) && (prevSine <= prevLeadSine)) ||
            ((sine < leadSine) && (prevSine >= prevLeadSine)) )
         {
            daysInTrend = 0;
            trend = 0;
         }
         daysInTrend++;
         if( daysInTrend < (0.5*smoothPeriod) )
            trend = 0;
         tempReal = DCPhase - prevDCPhase;
         if( (smoothPeriod != 0.0) &&
            ((tempReal > (0.67*360.0/smoothPeriod)) && (tempReal < (1.5*360.0/smoothPeriod))) )
         {
            trend = 0;
         }
         tempReal = smoothPrice[smoothPrice_Idx];
         if( (trendline != 0.0) && ( Math.abs ( (tempReal - trendline)/trendline ) >= 0.015) )
            trend = 1;
         if( today >= startIdx )
         {
            outInteger[outIdx++] = trend;
         }
         { smoothPrice_Idx ++; if( smoothPrice_Idx > maxIdx_smoothPrice ) smoothPrice_Idx = 0; } ;
         today++;
      }
      outNBElement.value = outIdx;
      return RetCode.Success ;
   }
   /* Generated */
   public int imiLookback( int optInTimePeriod )
   {
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 14;
      else if( ((int)optInTimePeriod < 2) || ((int)optInTimePeriod > 100000) )
         return -1;
      return optInTimePeriod + (this.unstablePeriod[FuncUnstId.Imi.ordinal()]) - 1;
   }
   public RetCode imi( int startIdx,
      int endIdx,
      double inOpen[],
      double inClose[],
      int optInTimePeriod,
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      int lookback, outIdx = 0;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 14;
      else if( ((int)optInTimePeriod < 2) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      lookback = imiLookback ( optInTimePeriod );
      if(startIdx < lookback)
         startIdx = lookback;
      if( startIdx > endIdx ) {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      outBegIdx.value = startIdx;
      while (startIdx <= endIdx) {
         double upsum = .0, downsum = .0;
         int i;
         for (i = startIdx - lookback; i <= startIdx; i++) {
            double close = inClose[i];
            double open = inOpen[i];
            if (close > open) {
               upsum += (close - open);
            } else {
               downsum += (open - close);
            }
            outReal[outIdx] = 100.0*(upsum/(upsum + downsum));
         }
         startIdx++;
         outIdx++;
      }
      outNBElement.value = outIdx;
      return RetCode.Success ;
   }
   public int imiStateInit( struct TA_imi_State** _state,
      int optInTimePeriod )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 14;
      else if( ((int)optInTimePeriod < 2) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct imi ));
      _state.value .value .mem_index = 0;
      _state.value .value .optInTimePeriod = optInTimePeriod;
      _state.value .value .mem_size = imiLookback (optInTimePeriod );
      if ( _state.value .value .mem_size > 0)
         _state.value .value .memory = TA_Calloc( _state.value .value .mem_size , sizeof(struct TA_IMI_Data));
      else
         _state.value .value .memory = NULL;
      return RetCode.Success ;
   }
   public int imiState( struct TA_imi_State* _state,
      double inOpen,
      double inClose,
      double *outReal )
   {
      double tempClose, tempOpen;
      if (_state == NULL)
         return RetCode.BadParam ;
      size_t _cur_idx = _state.value .mem_index++;
      if ( _state.value .mem_size > 0) _cur_idx %= _state.value .mem_size ;
      if ( _state.value .mem_size > _state.value .mem_index - 1 )
      {
         if (inClose > inOpen) {
            _state.value .upsum += (inClose - inOpen);
         } else {
            _state.value .downsum += (inOpen - inClose);
         }
         ( _state.value .memory+_cur_idx).value .inOpen = inOpen ;
         ( _state.value .memory+_cur_idx).value .inClose = inClose ;
         return RetCode.NeedMoreData ;
      }
      if (inClose > inOpen) {
         _state.value .upsum += (inClose - inOpen);
      } else {
         _state.value .downsum += (inOpen - inClose);
      }
      outReal.value = 100.0*( _state.value .upsum/( _state.value .upsum + _state.value .downsum));
      tempClose = ( _state.value .memory+_cur_idx).value .inClose ;
      tempOpen = ( _state.value .memory+_cur_idx).value .inOpen ;
      if (tempClose > tempOpen) {
         _state.value .upsum -= (tempClose - tempOpen);
      } else {
         _state.value .downsum -= (tempOpen - tempClose);
      }
      ( _state.value .memory+_cur_idx).value .inOpen = inOpen ;
      ( _state.value .memory+_cur_idx).value .inClose = inClose ;
      return RetCode.Success ;
   }
   public int imiStateFree( struct TA_imi_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if ( _state.value != NULL) {
         if ( _state.value .value .memory != NULL) TA_Free( _state.value .value .memory );
         TA_Free( _state.value ); _state.value = NULL;}
      return RetCode.Success ;
   }
   public RetCode imi( int startIdx,
      int endIdx,
      float inOpen[],
      float inClose[],
      int optInTimePeriod,
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      int lookback, outIdx = 0;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 14;
      else if( ((int)optInTimePeriod < 2) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      lookback = imiLookback ( optInTimePeriod );
      if(startIdx < lookback)
         startIdx = lookback;
      if( startIdx > endIdx ) {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      outBegIdx.value = startIdx;
      while (startIdx <= endIdx) {
         double upsum = .0, downsum = .0;
         int i;
         for (i = startIdx - lookback; i <= startIdx; i++) {
            double close = inClose[i];
            double open = inOpen[i];
            if (close > open) {
               upsum += (close - open);
            } else {
               downsum += (open - close);
            }
            outReal[outIdx] = 100.0*(upsum/(upsum + downsum));
         }
         startIdx++;
         outIdx++;
      }
      outNBElement.value = outIdx;
      return RetCode.Success ;
   }
   /* Generated */
   public int kamaLookback( int optInTimePeriod )
   {
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 30;
      else if( ((int)optInTimePeriod < 2) || ((int)optInTimePeriod > 100000) )
         return -1;
      return optInTimePeriod + (this.unstablePeriod[FuncUnstId.Kama.ordinal()]) ;
   }
   public RetCode kama( int startIdx,
      int endIdx,
      double inReal[],
      int optInTimePeriod,
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      final double constMax = 2.0/(30.0+1.0);
      final double constDiff = 2.0/(2.0+1.0) - constMax;
      double tempReal, tempReal2;
      double sumROC1, periodROC, prevKAMA;
      int i, today, outIdx, lookbackTotal;
      int trailingIdx;
      double trailingValue;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 30;
      else if( ((int)optInTimePeriod < 2) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      outBegIdx.value = 0 ;
      outNBElement.value = 0 ;
      lookbackTotal = optInTimePeriod + (this.unstablePeriod[FuncUnstId.Kama.ordinal()]) ;
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      sumROC1 = 0.0;
      today = startIdx-lookbackTotal;
      trailingIdx = today;
      i = optInTimePeriod;
      while( i-- > 0 )
      {
         tempReal = inReal[today++];
         tempReal -= inReal[today];
         sumROC1 += Math.abs (tempReal);
      }
      prevKAMA = inReal[today-1];
      tempReal = inReal[today];
      tempReal2 = inReal[trailingIdx++];
      periodROC = tempReal-tempReal2;
      trailingValue = tempReal2;
      if( (sumROC1 <= periodROC) || (((- (0.00000000000001) )<sumROC1)&&(sumROC1< (0.00000000000001) )) )
         tempReal = 1.0;
      else
         tempReal = Math.abs (periodROC/sumROC1);
      tempReal = (tempReal*constDiff)+constMax;
      tempReal *= tempReal;
      prevKAMA = ((inReal[today++]-prevKAMA)*tempReal) + prevKAMA;
      while( today <= startIdx )
      {
         tempReal = inReal[today];
         tempReal2 = inReal[trailingIdx++];
         periodROC = tempReal-tempReal2;
         sumROC1 -= Math.abs (trailingValue-tempReal2);
         sumROC1 += Math.abs (tempReal-inReal[today-1]);
         trailingValue = tempReal2;
         if( (sumROC1 <= periodROC) || (((- (0.00000000000001) )<sumROC1)&&(sumROC1< (0.00000000000001) )) )
            tempReal = 1.0;
         else
            tempReal = Math.abs (periodROC/sumROC1);
         tempReal = (tempReal*constDiff)+constMax;
         tempReal *= tempReal;
         prevKAMA = ((inReal[today++]-prevKAMA)*tempReal) + prevKAMA;
      }
      outReal[0] = prevKAMA;
      outIdx = 1;
      outBegIdx.value = today-1;
      while( today <= endIdx )
      {
         tempReal = inReal[today];
         tempReal2 = inReal[trailingIdx++];
         periodROC = tempReal-tempReal2;
         sumROC1 -= Math.abs (trailingValue-tempReal2);
         sumROC1 += Math.abs (tempReal-inReal[today-1]);
         trailingValue = tempReal2;
         if( (sumROC1 <= periodROC) || (((- (0.00000000000001) )<sumROC1)&&(sumROC1< (0.00000000000001) )) )
            tempReal = 1.0;
         else
            tempReal = Math.abs (periodROC / sumROC1);
         tempReal = (tempReal*constDiff)+constMax;
         tempReal *= tempReal;
         prevKAMA = ((inReal[today++]-prevKAMA)*tempReal) + prevKAMA;
         outReal[outIdx++] = prevKAMA;
      }
      outNBElement.value = outIdx;
      return RetCode.Success ;
   }
   public int kamaStateInit( struct TA_kama_State** _state,
      int optInTimePeriod )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 30;
      else if( ((int)optInTimePeriod < 2) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct kama ));
      _state.value .value .mem_index = 0;
      _state.value .value .optInTimePeriod = optInTimePeriod;
      _state.value .value .mem_size = kamaLookback (optInTimePeriod );
      if ( _state.value .value .mem_size > 0)
         _state.value .value .memory = TA_Calloc( _state.value .value .mem_size , sizeof(struct TA_KAMA_Data));
      else
         _state.value .value .memory = NULL;
      return RetCode.Success ;
   }
   public int kamaState( struct TA_kama_State* _state,
      double inReal,
      double *outReal )
   {
      final double constMax = 2.0/(30.0+1.0);
      final double constDiff = 2.0/(2.0+1.0) - constMax;
      double tempReal;
      double periodROC;
      if (_state == NULL)
         return RetCode.BadParam ;
      size_t _cur_idx = _state.value .mem_index++;
      if ( _state.value .mem_size > 0) _cur_idx %= _state.value .mem_size ;
      if ( ( _state.value .mem_index == 1) )
      {
         _state.value .sumROC1 = 0.0;
         _state.value .trailingValue = 0.0;
         _state.value .yestReal = inReal;
         _state.value .prevKAMA = inReal;
         ( _state.value .memory+_cur_idx).value .inReal = inReal ;
         return RetCode.NeedMoreData ;
      } else
         if ( ((int) _state.value .mem_index-1) <= _state.value .optInTimePeriod)
      {
         _state.value .sumROC1 += Math.abs ( _state.value .yestReal - inReal);
         _state.value .yestReal = inReal;
         if (((int) _state.value .mem_index-1) < _state.value .optInTimePeriod)
         {
            _state.value .prevKAMA = inReal;
            ( _state.value .memory+_cur_idx).value .inReal = inReal ;
            return RetCode.NeedMoreData ;
         }
      }
      if (((int) _state.value .mem_index-1) > _state.value .optInTimePeriod)
      {
         _state.value .sumROC1 -= Math.abs ( _state.value .trailingValue- ( _state.value .memory+_cur_idx).value .inReal );
         _state.value .sumROC1 += Math.abs (inReal- _state.value .yestReal);
      }
      _state.value .trailingValue = ( _state.value .memory+_cur_idx).value .inReal ;
      periodROC = inReal - _state.value .trailingValue;
      if( ( _state.value .sumROC1 <= periodROC) || (((- (0.00000000000001) )< _state.value .sumROC1)&&( _state.value .sumROC1< (0.00000000000001) )) )
         tempReal = 1.0;
      else
         tempReal = Math.abs (periodROC/ _state.value .sumROC1);
      tempReal = (tempReal*constDiff)+constMax;
      tempReal *= tempReal;
      _state.value .prevKAMA = ((inReal- _state.value .prevKAMA)*tempReal) + _state.value .prevKAMA;
      ( _state.value .memory+_cur_idx).value .inReal = inReal ;
      _state.value .yestReal = inReal;
      if ( _state.value .mem_size > _state.value .mem_index - 1 )
         return RetCode.NeedMoreData ;
      outReal.value = _state.value .prevKAMA;
      return RetCode.Success ;
   }
   public int kamaStateFree( struct TA_kama_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if ( _state.value != NULL) {
         if ( _state.value .value .memory != NULL) TA_Free( _state.value .value .memory );
         TA_Free( _state.value ); _state.value = NULL;}
      return RetCode.Success ;
   }
   public RetCode kama( int startIdx,
      int endIdx,
      float inReal[],
      int optInTimePeriod,
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      final double constMax = 2.0/(30.0+1.0);
      final double constDiff = 2.0/(2.0+1.0) - constMax;
      double tempReal, tempReal2;
      double sumROC1, periodROC, prevKAMA;
      int i, today, outIdx, lookbackTotal;
      int trailingIdx;
      double trailingValue;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 30;
      else if( ((int)optInTimePeriod < 2) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      outBegIdx.value = 0 ;
      outNBElement.value = 0 ;
      lookbackTotal = optInTimePeriod + (this.unstablePeriod[FuncUnstId.Kama.ordinal()]) ;
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      sumROC1 = 0.0;
      today = startIdx-lookbackTotal;
      trailingIdx = today;
      i = optInTimePeriod;
      while( i-- > 0 )
      {
         tempReal = inReal[today++];
         tempReal -= inReal[today];
         sumROC1 += Math.abs (tempReal);
      }
      prevKAMA = inReal[today-1];
      tempReal = inReal[today];
      tempReal2 = inReal[trailingIdx++];
      periodROC = tempReal-tempReal2;
      trailingValue = tempReal2;
      if( (sumROC1 <= periodROC) || (((- (0.00000000000001) )<sumROC1)&&(sumROC1< (0.00000000000001) )) )
         tempReal = 1.0;
      else
         tempReal = Math.abs (periodROC/sumROC1);
      tempReal = (tempReal*constDiff)+constMax;
      tempReal *= tempReal;
      prevKAMA = ((inReal[today++]-prevKAMA)*tempReal) + prevKAMA;
      while( today <= startIdx )
      {
         tempReal = inReal[today];
         tempReal2 = inReal[trailingIdx++];
         periodROC = tempReal-tempReal2;
         sumROC1 -= Math.abs (trailingValue-tempReal2);
         sumROC1 += Math.abs (tempReal-inReal[today-1]);
         trailingValue = tempReal2;
         if( (sumROC1 <= periodROC) || (((- (0.00000000000001) )<sumROC1)&&(sumROC1< (0.00000000000001) )) )
            tempReal = 1.0;
         else
            tempReal = Math.abs (periodROC/sumROC1);
         tempReal = (tempReal*constDiff)+constMax;
         tempReal *= tempReal;
         prevKAMA = ((inReal[today++]-prevKAMA)*tempReal) + prevKAMA;
      }
      outReal[0] = prevKAMA;
      outIdx = 1;
      outBegIdx.value = today-1;
      while( today <= endIdx )
      {
         tempReal = inReal[today];
         tempReal2 = inReal[trailingIdx++];
         periodROC = tempReal-tempReal2;
         sumROC1 -= Math.abs (trailingValue-tempReal2);
         sumROC1 += Math.abs (tempReal-inReal[today-1]);
         trailingValue = tempReal2;
         if( (sumROC1 <= periodROC) || (((- (0.00000000000001) )<sumROC1)&&(sumROC1< (0.00000000000001) )) )
            tempReal = 1.0;
         else
            tempReal = Math.abs (periodROC / sumROC1);
         tempReal = (tempReal*constDiff)+constMax;
         tempReal *= tempReal;
         prevKAMA = ((inReal[today++]-prevKAMA)*tempReal) + prevKAMA;
         outReal[outIdx++] = prevKAMA;
      }
      outNBElement.value = outIdx;
      return RetCode.Success ;
   }
   /* Generated */
   public int linearRegLookback( int optInTimePeriod )
   {
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 14;
      else if( ((int)optInTimePeriod < 2) || ((int)optInTimePeriod > 100000) )
         return -1;
      return optInTimePeriod-1;
   }
   public RetCode linearReg( int startIdx,
      int endIdx,
      double inReal[],
      int optInTimePeriod,
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      int outIdx;
      int today, lookbackTotal;
      double SumX, SumXY, SumY, SumXSqr, Divisor;
      double m, b;
      int i;
      double tempValue1;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 14;
      else if( ((int)optInTimePeriod < 2) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      lookbackTotal = linearRegLookback ( optInTimePeriod );
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      outIdx = 0;
      today = startIdx;
      SumX = optInTimePeriod * ( optInTimePeriod - 1 ) * 0.5;
      SumXSqr = optInTimePeriod * ( optInTimePeriod - 1 ) * ( 2 * optInTimePeriod - 1 ) / 6;
      Divisor = SumX * SumX - optInTimePeriod * SumXSqr;
      while( today <= endIdx )
      {
         SumXY = 0;
         SumY = 0;
         for( i = optInTimePeriod; i-- != 0; )
         {
            SumY += tempValue1 = inReal[today - i];
            SumXY += (double)i * tempValue1;
         }
         m = ( optInTimePeriod * SumXY - SumX * SumY) / Divisor;
         b = ( SumY - m * SumX ) / (double)optInTimePeriod;
         outReal[outIdx++] = b + m * (double)(optInTimePeriod-1);
         today++;
      }
      outBegIdx.value = startIdx;
      outNBElement.value = outIdx;
      return RetCode.Success ;
   }
   public int linearRegStateInit( struct TA_linearReg_State** _state,
      int optInTimePeriod )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 14;
      else if( ((int)optInTimePeriod < 2) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct linearReg ));
      _state.value .value .mem_index = 0;
      _state.value .value .optInTimePeriod = optInTimePeriod;
      _state.value .value .mem_size = linearRegLookback (optInTimePeriod );
      if ( _state.value .value .mem_size > 0)
         _state.value .value .memory = TA_Calloc( _state.value .value .mem_size , sizeof(struct TA_LINEARREG_Data));
      else
         _state.value .value .memory = NULL;
      return RetCode.Success ;
   }
   public int linearRegState( struct TA_linearReg_State* _state,
      double inReal,
      double *outReal )
   {
      double m, b, tempReal;
      if (_state == NULL)
         return RetCode.BadParam ;
      size_t _cur_idx = _state.value .mem_index++;
      if ( _state.value .mem_size > 0) _cur_idx %= _state.value .mem_size ;
      if ( ( _state.value .mem_index == 1) )
      {
         _state.value .SumX = _state.value .optInTimePeriod * ( _state.value .optInTimePeriod - 1 ) * 0.5;
         _state.value .SumXSqr = _state.value .optInTimePeriod * ( _state.value .optInTimePeriod - 1 ) * ( 2 * _state.value .optInTimePeriod - 1 ) / 6;
         _state.value .Divisor = _state.value .SumX * _state.value .SumX - _state.value .optInTimePeriod * _state.value .SumXSqr;
         _state.value .SumXY = 0;
         _state.value .SumY = 0;
      }
      if ( _state.value .mem_size > _state.value .mem_index - 1 )
      {
         _state.value .SumY += inReal;
         _state.value .SumXY += _state.value .SumY;
         ( _state.value .memory+_cur_idx).value .inReal = inReal ;
         return RetCode.NeedMoreData ;
      }
      _state.value .SumY += inReal;
      _state.value .SumXY += _state.value .SumY;
      m = ( _state.value .optInTimePeriod * _state.value .SumXY - _state.value .SumX * _state.value .SumY) / _state.value .Divisor;
      b = ( _state.value .SumY - m * _state.value .SumX ) / (double) _state.value .optInTimePeriod;
      outReal.value = b + m * (double)( _state.value .optInTimePeriod-1);
      tempReal = ( _state.value .memory+_cur_idx).value .inReal ;
      _state.value .SumY -= tempReal;
      _state.value .SumXY -= tempReal* _state.value .optInTimePeriod;
      ( _state.value .memory+_cur_idx).value .inReal = inReal ;
      return RetCode.Success ;
   }
   public int linearRegStateFree( struct TA_linearReg_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if ( _state.value != NULL) {
         if ( _state.value .value .memory != NULL) TA_Free( _state.value .value .memory );
         TA_Free( _state.value ); _state.value = NULL;}
      return RetCode.Success ;
   }
   public RetCode linearReg( int startIdx,
      int endIdx,
      float inReal[],
      int optInTimePeriod,
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      int outIdx;
      int today, lookbackTotal;
      double SumX, SumXY, SumY, SumXSqr, Divisor;
      double m, b;
      int i;
      double tempValue1;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 14;
      else if( ((int)optInTimePeriod < 2) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      lookbackTotal = linearRegLookback ( optInTimePeriod );
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      outIdx = 0;
      today = startIdx;
      SumX = optInTimePeriod * ( optInTimePeriod - 1 ) * 0.5;
      SumXSqr = optInTimePeriod * ( optInTimePeriod - 1 ) * ( 2 * optInTimePeriod - 1 ) / 6;
      Divisor = SumX * SumX - optInTimePeriod * SumXSqr;
      while( today <= endIdx )
      {
         SumXY = 0;
         SumY = 0;
         for( i = optInTimePeriod; i-- != 0; )
         {
            SumY += tempValue1 = inReal[today - i];
            SumXY += (double)i * tempValue1;
         }
         m = ( optInTimePeriod * SumXY - SumX * SumY) / Divisor;
         b = ( SumY - m * SumX ) / (double)optInTimePeriod;
         outReal[outIdx++] = b + m * (double)(optInTimePeriod-1);
         today++;
      }
      outBegIdx.value = startIdx;
      outNBElement.value = outIdx;
      return RetCode.Success ;
   }
   /* Generated */
   public int linearRegAngleLookback( int optInTimePeriod )
   {
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 14;
      else if( ((int)optInTimePeriod < 2) || ((int)optInTimePeriod > 100000) )
         return -1;
      return optInTimePeriod-1;
   }
   public RetCode linearRegAngle( int startIdx,
      int endIdx,
      double inReal[],
      int optInTimePeriod,
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      int outIdx;
      int today, lookbackTotal;
      double SumX, SumXY, SumY, SumXSqr, Divisor;
      double m;
      int i;
      double tempValue1;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 14;
      else if( ((int)optInTimePeriod < 2) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      lookbackTotal = linearRegAngleLookback ( optInTimePeriod );
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      outIdx = 0;
      today = startIdx;
      SumX = optInTimePeriod * ( optInTimePeriod - 1 ) * 0.5;
      SumXSqr = optInTimePeriod * ( optInTimePeriod - 1 ) * ( 2 * optInTimePeriod - 1 ) / 6;
      Divisor = SumX * SumX - optInTimePeriod * SumXSqr;
      while( today <= endIdx )
      {
         SumXY = 0;
         SumY = 0;
         for( i = optInTimePeriod; i-- != 0; )
         {
            SumY += tempValue1 = inReal[today - i];
            SumXY += (double)i * tempValue1;
         }
         m = ( optInTimePeriod * SumXY - SumX * SumY) / Divisor;
         outReal[outIdx++] = Math.atan (m) * ( 180.0 / 3.14159265358979323846 );
         today++;
      }
      outBegIdx.value = startIdx;
      outNBElement.value = outIdx;
      return RetCode.Success ;
   }
   public int linearRegAngleStateInit( struct TA_linearRegAngle_State** _state,
      int optInTimePeriod )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 14;
      else if( ((int)optInTimePeriod < 2) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct linearRegAngle ));
      _state.value .value .mem_index = 0;
      _state.value .value .optInTimePeriod = optInTimePeriod;
      _state.value .value .mem_size = linearRegAngleLookback (optInTimePeriod );
      if ( _state.value .value .mem_size > 0)
         _state.value .value .memory = TA_Calloc( _state.value .value .mem_size , sizeof(struct TA_LINEARREG_ANGLE_Data));
      else
         _state.value .value .memory = NULL;
      return RetCode.Success ;
   }
   public int linearRegAngleState( struct TA_linearRegAngle_State* _state,
      double inReal,
      double *outReal )
   {
      double m, tempReal;
      if (_state == NULL)
         return RetCode.BadParam ;
      size_t _cur_idx = _state.value .mem_index++;
      if ( _state.value .mem_size > 0) _cur_idx %= _state.value .mem_size ;
      if ( _state.value .mem_size > _state.value .mem_index - 1 ) {
         ( _state.value .memory+_cur_idx).value .inReal = inReal ;
         return RetCode.NeedMoreData ; }
      if ( ( _state.value .mem_index == 1) )
      {
         _state.value .SumX = _state.value .optInTimePeriod * ( _state.value .optInTimePeriod - 1 ) * 0.5;
         _state.value .SumXSqr = _state.value .optInTimePeriod * ( _state.value .optInTimePeriod - 1 ) * ( 2 * _state.value .optInTimePeriod - 1 ) / 6;
         _state.value .Divisor = _state.value .SumX * _state.value .SumX - _state.value .optInTimePeriod * _state.value .SumXSqr;
         _state.value .SumXY = 0;
         _state.value .SumY = 0;
      }
      if ( _state.value .mem_size > _state.value .mem_index - 1 )
      {
         _state.value .SumY += inReal;
         _state.value .SumXY += _state.value .SumY;
         ( _state.value .memory+_cur_idx).value .inReal = inReal ;
         return RetCode.NeedMoreData ;
      }
      _state.value .SumY += inReal;
      _state.value .SumXY += _state.value .SumY;
      m = ( _state.value .optInTimePeriod * _state.value .SumXY - _state.value .SumX * _state.value .SumY) / _state.value .Divisor;
      outReal.value = Math.atan (m) * ( 180.0 / 3.14159265358979323846 );
      tempReal = ( _state.value .memory+_cur_idx).value .inReal ;
      _state.value .SumY -= tempReal;
      _state.value .SumXY -= tempReal* _state.value .optInTimePeriod;
      ( _state.value .memory+_cur_idx).value .inReal = inReal ;
      return RetCode.Success ;
   }
   public int linearRegAngleStateFree( struct TA_linearRegAngle_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if ( _state.value != NULL) {
         if ( _state.value .value .memory != NULL) TA_Free( _state.value .value .memory );
         TA_Free( _state.value ); _state.value = NULL;}
      return RetCode.Success ;
   }
   public RetCode linearRegAngle( int startIdx,
      int endIdx,
      float inReal[],
      int optInTimePeriod,
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      int outIdx;
      int today, lookbackTotal;
      double SumX, SumXY, SumY, SumXSqr, Divisor;
      double m;
      int i;
      double tempValue1;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 14;
      else if( ((int)optInTimePeriod < 2) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      lookbackTotal = linearRegAngleLookback ( optInTimePeriod );
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      outIdx = 0;
      today = startIdx;
      SumX = optInTimePeriod * ( optInTimePeriod - 1 ) * 0.5;
      SumXSqr = optInTimePeriod * ( optInTimePeriod - 1 ) * ( 2 * optInTimePeriod - 1 ) / 6;
      Divisor = SumX * SumX - optInTimePeriod * SumXSqr;
      while( today <= endIdx )
      {
         SumXY = 0;
         SumY = 0;
         for( i = optInTimePeriod; i-- != 0; )
         {
            SumY += tempValue1 = inReal[today - i];
            SumXY += (double)i * tempValue1;
         }
         m = ( optInTimePeriod * SumXY - SumX * SumY) / Divisor;
         outReal[outIdx++] = Math.atan (m) * ( 180.0 / 3.14159265358979323846 );
         today++;
      }
      outBegIdx.value = startIdx;
      outNBElement.value = outIdx;
      return RetCode.Success ;
   }
   /* Generated */
   public int linearRegInterceptLookback( int optInTimePeriod )
   {
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 14;
      else if( ((int)optInTimePeriod < 2) || ((int)optInTimePeriod > 100000) )
         return -1;
      return optInTimePeriod-1;
   }
   public RetCode linearRegIntercept( int startIdx,
      int endIdx,
      double inReal[],
      int optInTimePeriod,
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      int outIdx;
      int today, lookbackTotal;
      double SumX, SumXY, SumY, SumXSqr, Divisor;
      double m;
      int i;
      double tempValue1;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 14;
      else if( ((int)optInTimePeriod < 2) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      lookbackTotal = linearRegInterceptLookback ( optInTimePeriod );
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      outIdx = 0;
      today = startIdx;
      SumX = optInTimePeriod * ( optInTimePeriod - 1 ) * 0.5;
      SumXSqr = optInTimePeriod * ( optInTimePeriod - 1 ) * ( 2 * optInTimePeriod - 1 ) / 6;
      Divisor = SumX * SumX - optInTimePeriod * SumXSqr;
      while( today <= endIdx )
      {
         SumXY = 0;
         SumY = 0;
         for( i = optInTimePeriod; i-- != 0; )
         {
            SumY += tempValue1 = inReal[today - i];
            SumXY += (double)i * tempValue1;
         }
         m = ( optInTimePeriod * SumXY - SumX * SumY) / Divisor;
         outReal[outIdx++] = ( SumY - m * SumX ) / (double)optInTimePeriod;
         today++;
      }
      outBegIdx.value = startIdx;
      outNBElement.value = outIdx;
      return RetCode.Success ;
   }
   public int linearRegInterceptStateInit( struct TA_linearRegIntercept_State** _state,
      int optInTimePeriod )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 14;
      else if( ((int)optInTimePeriod < 2) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct linearRegIntercept ));
      _state.value .value .mem_index = 0;
      _state.value .value .optInTimePeriod = optInTimePeriod;
      _state.value .value .mem_size = linearRegInterceptLookback (optInTimePeriod );
      if ( _state.value .value .mem_size > 0)
         _state.value .value .memory = TA_Calloc( _state.value .value .mem_size , sizeof(struct TA_LINEARREG_INTERCEPT_Data));
      else
         _state.value .value .memory = NULL;
      return RetCode.Success ;
   }
   public int linearRegInterceptState( struct TA_linearRegIntercept_State* _state,
      double inReal,
      double *outReal )
   {
      double m, tempReal;
      if (_state == NULL)
         return RetCode.BadParam ;
      size_t _cur_idx = _state.value .mem_index++;
      if ( _state.value .mem_size > 0) _cur_idx %= _state.value .mem_size ;
      if ( _state.value .mem_size > _state.value .mem_index - 1 ) {
         ( _state.value .memory+_cur_idx).value .inReal = inReal ;
         return RetCode.NeedMoreData ; }
      if ( ( _state.value .mem_index == 1) )
      {
         _state.value .SumX = _state.value .optInTimePeriod * ( _state.value .optInTimePeriod - 1 ) * 0.5;
         _state.value .SumXSqr = _state.value .optInTimePeriod * ( _state.value .optInTimePeriod - 1 ) * ( 2 * _state.value .optInTimePeriod - 1 ) / 6;
         _state.value .Divisor = _state.value .SumX * _state.value .SumX - _state.value .optInTimePeriod * _state.value .SumXSqr;
         _state.value .SumXY = 0;
         _state.value .SumY = 0;
      }
      if ( _state.value .mem_size > _state.value .mem_index - 1 )
      {
         _state.value .SumY += inReal;
         _state.value .SumXY += _state.value .SumY;
         ( _state.value .memory+_cur_idx).value .inReal = inReal ;
         return RetCode.NeedMoreData ;
      }
      _state.value .SumY += inReal;
      _state.value .SumXY += _state.value .SumY;
      m = ( _state.value .optInTimePeriod * _state.value .SumXY - _state.value .SumX * _state.value .SumY) / _state.value .Divisor;
      outReal.value = ( _state.value .SumY - m * _state.value .SumX ) / (double) _state.value .optInTimePeriod;
      tempReal = ( _state.value .memory+_cur_idx).value .inReal ;
      _state.value .SumY -= tempReal;
      _state.value .SumXY -= tempReal* _state.value .optInTimePeriod;
      ( _state.value .memory+_cur_idx).value .inReal = inReal ;
      return RetCode.Success ;
   }
   public int linearRegInterceptStateFree( struct TA_linearRegIntercept_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if ( _state.value != NULL) {
         if ( _state.value .value .memory != NULL) TA_Free( _state.value .value .memory );
         TA_Free( _state.value ); _state.value = NULL;}
      return RetCode.Success ;
   }
   public RetCode linearRegIntercept( int startIdx,
      int endIdx,
      float inReal[],
      int optInTimePeriod,
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      int outIdx;
      int today, lookbackTotal;
      double SumX, SumXY, SumY, SumXSqr, Divisor;
      double m;
      int i;
      double tempValue1;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 14;
      else if( ((int)optInTimePeriod < 2) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      lookbackTotal = linearRegInterceptLookback ( optInTimePeriod );
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      outIdx = 0;
      today = startIdx;
      SumX = optInTimePeriod * ( optInTimePeriod - 1 ) * 0.5;
      SumXSqr = optInTimePeriod * ( optInTimePeriod - 1 ) * ( 2 * optInTimePeriod - 1 ) / 6;
      Divisor = SumX * SumX - optInTimePeriod * SumXSqr;
      while( today <= endIdx )
      {
         SumXY = 0;
         SumY = 0;
         for( i = optInTimePeriod; i-- != 0; )
         {
            SumY += tempValue1 = inReal[today - i];
            SumXY += (double)i * tempValue1;
         }
         m = ( optInTimePeriod * SumXY - SumX * SumY) / Divisor;
         outReal[outIdx++] = ( SumY - m * SumX ) / (double)optInTimePeriod;
         today++;
      }
      outBegIdx.value = startIdx;
      outNBElement.value = outIdx;
      return RetCode.Success ;
   }
   /* Generated */
   public int linearRegSlopeLookback( int optInTimePeriod )
   {
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 14;
      else if( ((int)optInTimePeriod < 2) || ((int)optInTimePeriod > 100000) )
         return -1;
      return optInTimePeriod-1;
   }
   public RetCode linearRegSlope( int startIdx,
      int endIdx,
      double inReal[],
      int optInTimePeriod,
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      int outIdx;
      int today, lookbackTotal;
      double SumX, SumXY, SumY, SumXSqr, Divisor;
      int i;
      double tempValue1;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 14;
      else if( ((int)optInTimePeriod < 2) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      lookbackTotal = linearRegSlopeLookback ( optInTimePeriod );
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      outIdx = 0;
      today = startIdx;
      SumX = optInTimePeriod * ( optInTimePeriod - 1 ) * 0.5;
      SumXSqr = optInTimePeriod * ( optInTimePeriod - 1 ) * ( 2 * optInTimePeriod - 1 ) / 6;
      Divisor = SumX * SumX - optInTimePeriod * SumXSqr;
      while( today <= endIdx )
      {
         SumXY = 0;
         SumY = 0;
         for( i = optInTimePeriod; i-- != 0; )
         {
            SumY += tempValue1 = inReal[today - i];
            SumXY += (double)i * tempValue1;
         }
         outReal[outIdx++] = ( optInTimePeriod * SumXY - SumX * SumY) / Divisor;
         today++;
      }
      outBegIdx.value = startIdx;
      outNBElement.value = outIdx;
      return RetCode.Success ;
   }
   public int linearRegSlopeStateInit( struct TA_linearRegSlope_State** _state,
      int optInTimePeriod )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 14;
      else if( ((int)optInTimePeriod < 2) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct linearRegSlope ));
      _state.value .value .mem_index = 0;
      _state.value .value .optInTimePeriod = optInTimePeriod;
      _state.value .value .mem_size = linearRegSlopeLookback (optInTimePeriod );
      if ( _state.value .value .mem_size > 0)
         _state.value .value .memory = TA_Calloc( _state.value .value .mem_size , sizeof(struct TA_LINEARREG_SLOPE_Data));
      else
         _state.value .value .memory = NULL;
      return RetCode.Success ;
   }
   public int linearRegSlopeState( struct TA_linearRegSlope_State* _state,
      double inReal,
      double *outReal )
   {
      double tempReal;
      if (_state == NULL)
         return RetCode.BadParam ;
      size_t _cur_idx = _state.value .mem_index++;
      if ( _state.value .mem_size > 0) _cur_idx %= _state.value .mem_size ;
      if ( _state.value .mem_size > _state.value .mem_index - 1 ) {
         ( _state.value .memory+_cur_idx).value .inReal = inReal ;
         return RetCode.NeedMoreData ; }
      if ( ( _state.value .mem_index == 1) )
      {
         _state.value .SumX = _state.value .optInTimePeriod * ( _state.value .optInTimePeriod - 1 ) * 0.5;
         _state.value .SumXSqr = _state.value .optInTimePeriod * ( _state.value .optInTimePeriod - 1 ) * ( 2 * _state.value .optInTimePeriod - 1 ) / 6;
         _state.value .Divisor = _state.value .SumX * _state.value .SumX - _state.value .optInTimePeriod * _state.value .SumXSqr;
         _state.value .SumXY = 0;
         _state.value .SumY = 0;
      }
      if ( _state.value .mem_size > _state.value .mem_index - 1 )
      {
         _state.value .SumY += inReal;
         _state.value .SumXY += _state.value .SumY;
         ( _state.value .memory+_cur_idx).value .inReal = inReal ;
         return RetCode.NeedMoreData ;
      }
      _state.value .SumY += inReal;
      _state.value .SumXY += _state.value .SumY;
      outReal.value = ( _state.value .optInTimePeriod * _state.value .SumXY - _state.value .SumX * _state.value .SumY) / _state.value .Divisor;
      tempReal = ( _state.value .memory+_cur_idx).value .inReal ;
      _state.value .SumY -= tempReal;
      _state.value .SumXY -= tempReal* _state.value .optInTimePeriod;
      ( _state.value .memory+_cur_idx).value .inReal = inReal ;
      return RetCode.Success ;
   }
   public int linearRegSlopeStateFree( struct TA_linearRegSlope_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if ( _state.value != NULL) {
         if ( _state.value .value .memory != NULL) TA_Free( _state.value .value .memory );
         TA_Free( _state.value ); _state.value = NULL;}
      return RetCode.Success ;
   }
   public RetCode linearRegSlope( int startIdx,
      int endIdx,
      float inReal[],
      int optInTimePeriod,
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      int outIdx;
      int today, lookbackTotal;
      double SumX, SumXY, SumY, SumXSqr, Divisor;
      int i;
      double tempValue1;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 14;
      else if( ((int)optInTimePeriod < 2) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      lookbackTotal = linearRegSlopeLookback ( optInTimePeriod );
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      outIdx = 0;
      today = startIdx;
      SumX = optInTimePeriod * ( optInTimePeriod - 1 ) * 0.5;
      SumXSqr = optInTimePeriod * ( optInTimePeriod - 1 ) * ( 2 * optInTimePeriod - 1 ) / 6;
      Divisor = SumX * SumX - optInTimePeriod * SumXSqr;
      while( today <= endIdx )
      {
         SumXY = 0;
         SumY = 0;
         for( i = optInTimePeriod; i-- != 0; )
         {
            SumY += tempValue1 = inReal[today - i];
            SumXY += (double)i * tempValue1;
         }
         outReal[outIdx++] = ( optInTimePeriod * SumXY - SumX * SumY) / Divisor;
         today++;
      }
      outBegIdx.value = startIdx;
      outNBElement.value = outIdx;
      return RetCode.Success ;
   }
   /* Generated */
   public int lnLookback( )
   {
      return RetCode.Success ;
   }
   public RetCode ln( int startIdx,
      int endIdx,
      double inReal[],
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      int outIdx;
      int i;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      for( i=startIdx, outIdx=0; i <= endIdx; i++, outIdx++ )
      {
         outReal[outIdx] = Math.log (inReal[i]);
      }
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   public int lnStateInit( struct TA_ln_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct ln ));
      _state.value .value .mem_index = 0;
      _state.value .value .mem_size = lnLookback ();
      if ( _state.value .value .mem_size > 0)
         _state.value .value .memory = TA_Calloc( _state.value .value .mem_size , sizeof(struct TA_LN_Data));
      else
         _state.value .value .memory = NULL;
      return RetCode.Success ;
   }
   public int lnState( struct TA_ln_State* _state,
      double inReal,
      double *outReal )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      size_t _cur_idx = _state.value .mem_index++;
      if ( _state.value .mem_size > 0) _cur_idx %= _state.value .mem_size ;
      if ( _state.value .mem_size > _state.value .mem_index - 1 ) {
         ( _state.value .memory+_cur_idx).value .inReal = inReal ;
         return RetCode.NeedMoreData ; }
      outReal.value = Math.log (inReal);
      return RetCode.Success ;
   }
   public int lnStateFree( struct TA_ln_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if ( _state.value != NULL) {
         if ( _state.value .value .memory != NULL) TA_Free( _state.value .value .memory );
         TA_Free( _state.value ); _state.value = NULL;}
      return RetCode.Success ;
   }
   public RetCode ln( int startIdx,
      int endIdx,
      float inReal[],
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      int outIdx;
      int i;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      for( i=startIdx, outIdx=0; i <= endIdx; i++, outIdx++ )
      {
         outReal[outIdx] = Math.log (inReal[i]);
      }
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   /* Generated */
   public int log10Lookback( )
   {
      return RetCode.Success ;
   }
   public RetCode log10( int startIdx,
      int endIdx,
      double inReal[],
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      int outIdx;
      int i;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      for( i=startIdx, outIdx=0; i <= endIdx; i++, outIdx++ )
      {
         outReal[outIdx] = Math.log10 (inReal[i]);
      }
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   public int log10StateInit( struct TA_log10_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct log10 ));
      _state.value .value .mem_index = 0;
      _state.value .value .mem_size = log10Lookback ();
      if ( _state.value .value .mem_size > 0)
         _state.value .value .memory = TA_Calloc( _state.value .value .mem_size , sizeof(struct TA_LOG10_Data));
      else
         _state.value .value .memory = NULL;
      return RetCode.Success ;
   }
   public int log10State( struct TA_log10_State* _state,
      double inReal,
      double *outReal )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      size_t _cur_idx = _state.value .mem_index++;
      if ( _state.value .mem_size > 0) _cur_idx %= _state.value .mem_size ;
      if ( _state.value .mem_size > _state.value .mem_index - 1 ) {
         ( _state.value .memory+_cur_idx).value .inReal = inReal ;
         return RetCode.NeedMoreData ; }
      outReal.value = Math.log10 (inReal);
      return RetCode.Success ;
   }
   public int log10StateFree( struct TA_log10_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if ( _state.value != NULL) {
         if ( _state.value .value .memory != NULL) TA_Free( _state.value .value .memory );
         TA_Free( _state.value ); _state.value = NULL;}
      return RetCode.Success ;
   }
   public RetCode log10( int startIdx,
      int endIdx,
      float inReal[],
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      int outIdx;
      int i;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      for( i=startIdx, outIdx=0; i <= endIdx; i++, outIdx++ )
      {
         outReal[outIdx] = Math.log10 (inReal[i]);
      }
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   /* Generated */
   public int movingAverageLookback( int optInTimePeriod,
      MAType optInMAType )
   {
      int retValue;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 30;
      else if( ((int)optInTimePeriod < 1) || ((int)optInTimePeriod > 100000) )
         return -1;
      if( optInTimePeriod <= 1 )
         return RetCode.Success ;
      switch( optInMAType )
      {
         case Sma :
            retValue = smaLookback ( optInTimePeriod );
         break;
         case Ema :
            retValue = emaLookback ( optInTimePeriod );
         break;
         case Wma :
            retValue = wmaLookback ( optInTimePeriod );
         break;
         case Dema :
            retValue = demaLookback ( optInTimePeriod );
         break;
         case Tema :
            retValue = temaLookback ( optInTimePeriod );
         break;
         case Trima :
            retValue = trimaLookback ( optInTimePeriod );
         break;
         case Kama :
            retValue = kamaLookback ( optInTimePeriod );
         break;
         case Mama :
            retValue = mamaLookback ( 0.5, 0.05 );
         break;
         case T3 :
            retValue = t3Lookback ( optInTimePeriod, 0.7 );
         break;
         default:
            retValue = 0;
      }
      return retValue;
   }
   public RetCode movingAverage( int startIdx,
      int endIdx,
      double inReal[],
      int optInTimePeriod,
      MAType optInMAType, MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      double []dummyBuffer ;
      RetCode retCode;
      int nbElement;
      int outIdx, todayIdx;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 30;
      else if( ((int)optInTimePeriod < 1) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      if( optInTimePeriod == 1 )
      {
         nbElement = endIdx-startIdx+1;
         outNBElement.value = nbElement;
         for( todayIdx=startIdx, outIdx=0; outIdx < nbElement; outIdx++, todayIdx++ )
            outReal[outIdx] = inReal[todayIdx];
         outBegIdx.value = startIdx;
         return RetCode.Success ;
      }
      switch( optInMAType )
      {
         case Sma :
            retCode = sma ( startIdx, endIdx, inReal, optInTimePeriod,
            outBegIdx, outNBElement, outReal );
         break;
         case Ema :
            retCode = ema ( startIdx, endIdx, inReal, optInTimePeriod,
            outBegIdx, outNBElement, outReal );
         break;
         case Wma :
            retCode = wma ( startIdx, endIdx, inReal, optInTimePeriod,
            outBegIdx, outNBElement, outReal );
         break;
         case Dema :
            retCode = dema ( startIdx, endIdx, inReal, optInTimePeriod,
            outBegIdx, outNBElement, outReal );
         break;
         case Tema :
            retCode = tema ( startIdx, endIdx, inReal, optInTimePeriod,
            outBegIdx, outNBElement, outReal );
         break;
         case Trima :
            retCode = trima ( startIdx, endIdx, inReal, optInTimePeriod,
            outBegIdx, outNBElement, outReal );
         break;
         case Kama :
            retCode = kama ( startIdx, endIdx, inReal, optInTimePeriod,
            outBegIdx, outNBElement, outReal );
         break;
         case Mama :
            dummyBuffer = new double[(endIdx-startIdx+1)] ;
         retCode = mama ( startIdx, endIdx, inReal, 0.5, 0.05,
            outBegIdx, outNBElement,
            outReal, dummyBuffer );
         break;
         case T3 :
            retCode = t3 ( startIdx, endIdx, inReal,
            optInTimePeriod, 0.7,
            outBegIdx, outNBElement, outReal );
         break;
         default:
            retCode = RetCode.BadParam ;
         break;
      }
      return retCode;
   }
   public int movingAverageStateInit( struct TA_movingAverage_State** _state,
      int optInTimePeriod,
      MAType optInMAType )
   {
      RetCode retValue;
      if (_state == NULL)
         return RetCode.BadParam ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 30;
      else if( ((int)optInTimePeriod < 1) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct movingAverage ));
      _state.value .value .mem_index = 0;
      _state.value .value .optInTimePeriod = optInTimePeriod;
      _state.value .value .optInMAType = optInMAType;
      _state.value .value .mem_size = movingAverageLookback (optInTimePeriod, optInMAType );
      _state.value .value .memory = NULL;
      switch( optInMAType )
      {
         case Sma :
            retValue = sma ( (struct sma **) & _state.value .value .ta_state, optInTimePeriod );
         break;
         case Ema :
            retValue = ema ( (struct ema **) & _state.value .value .ta_state, optInTimePeriod );
         break;
         case Wma :
            retValue = wma ( (struct wma **) & _state.value .value .ta_state, optInTimePeriod );
         break;
         case Dema :
            retValue = dema ( (struct dema **) & _state.value .value .ta_state, optInTimePeriod );
         break;
         case Tema :
            retValue = tema ( (struct tema **) & _state.value .value .ta_state, optInTimePeriod );
         break;
         case Trima :
            retValue = trima ( (struct trima **) & _state.value .value .ta_state, optInTimePeriod );
         break;
         case Kama :
            retValue = kama ( (struct kama **) & _state.value .value .ta_state, optInTimePeriod );
         break;
         case Mama :
            retValue = mama ( (struct mama **) & _state.value .value .ta_state, 0.5, 0.05 );
         break;
         case T3 :
            retValue = t3 ( (struct t3 **) & _state.value .value .ta_state, optInTimePeriod, 0.7 );
         break;
         default:
            retValue = RetCode.BadParam ;
      }
      return retValue;
   }
   public int movingAverageState( struct TA_movingAverage_State* _state,
      double inReal,
      double *outReal )
   {
      RetCode retValue;
      if (_state == NULL)
         return RetCode.BadParam ;
      size_t _cur_idx = _state.value .mem_index++;
      if ( _state.value .mem_size > 0) _cur_idx %= _state.value .mem_size ;
      if( _state.value .optInTimePeriod == 1 )
      {
         outReal.value = inReal;
         return RetCode.Success ;
      }
      switch( _state.value .optInMAType )
      {
         case Sma :
            retValue = sma ( (struct sma *) _state.value .ta_state, inReal, outReal );
         break;
         case Ema :
            retValue = ema ( (struct ema *) _state.value .ta_state, inReal, outReal );
         break;
         case Wma :
            retValue = wma ( (struct wma *) _state.value .ta_state, inReal, outReal );
         break;
         case Dema :
            retValue = dema ( (struct dema *) _state.value .ta_state, inReal, outReal );
         break;
         case Tema :
            retValue = tema ( (struct tema *) _state.value .ta_state, inReal, outReal );
         break;
         case Trima :
            retValue = trima ( (struct trima *) _state.value .ta_state, inReal, outReal );
         break;
         case Kama :
            retValue = kama ( (struct kama *) _state.value .ta_state, inReal, outReal );
         break;
         case Mama :
         {
            double dummy;
            retValue = mama ( (struct mama *) _state.value .ta_state, inReal, outReal, &dummy );
         }
         break;
         case T3 :
            retValue = t3 ( (struct t3 *) _state.value .ta_state, inReal, outReal );
         break;
         default:
            retValue = RetCode.BadParam ;
      }
      return retValue;
   }
   public int movingAverageStateFree( struct TA_movingAverage_State** _state )
   {
      RetCode retValue;
      switch( _state.value .value .optInMAType )
      {
         case Sma :
            retValue = sma ( (struct sma **) & _state.value .value .ta_state);
         break;
         case Ema :
            retValue = ema ( (struct ema **) & _state.value .value .ta_state);
         break;
         case Wma :
            retValue = wma ( (struct wma **) & _state.value .value .ta_state);
         break;
         case Dema :
            retValue = dema ( (struct dema **) & _state.value .value .ta_state);
         break;
         case Tema :
            retValue = tema ( (struct tema **) & _state.value .value .ta_state);
         break;
         case Trima :
            retValue = trima ( (struct trima **) & _state.value .value .ta_state);
         break;
         case Kama :
            retValue = kama ( (struct kama **) & _state.value .value .ta_state);
         break;
         case Mama :
            retValue = mama ( (struct mama **) & _state.value .value .ta_state);
         break;
         case T3 :
            retValue = t3 ( (struct t3 **) & _state.value .value .ta_state);
         break;
         default:
            retValue = RetCode.BadParam ;
      }
      if (retValue != RetCode.Success )
         return retValue;
      if (_state == NULL)
         return RetCode.BadParam ;
      if ( _state.value != NULL) {
         if ( _state.value .value .memory != NULL) TA_Free( _state.value .value .memory );
         TA_Free( _state.value ); _state.value = NULL;}
      return RetCode.Success ;
   }
   public RetCode movingAverage( int startIdx,
      int endIdx,
      float inReal[],
      int optInTimePeriod,
      MAType optInMAType, MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      double []dummyBuffer ;
      RetCode retCode;
      int nbElement;
      int outIdx, todayIdx;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 30;
      else if( ((int)optInTimePeriod < 1) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      if( optInTimePeriod == 1 )
      {
         nbElement = endIdx-startIdx+1;
         outNBElement.value = nbElement;
         for( todayIdx=startIdx, outIdx=0; outIdx < nbElement; outIdx++, todayIdx++ )
            outReal[outIdx] = inReal[todayIdx];
         outBegIdx.value = startIdx;
         return RetCode.Success ;
      }
      switch( optInMAType )
      {
         case Sma :
            retCode = sma ( startIdx, endIdx, inReal, optInTimePeriod,
            outBegIdx, outNBElement, outReal );
         break;
         case Ema :
            retCode = ema ( startIdx, endIdx, inReal, optInTimePeriod,
            outBegIdx, outNBElement, outReal );
         break;
         case Wma :
            retCode = wma ( startIdx, endIdx, inReal, optInTimePeriod,
            outBegIdx, outNBElement, outReal );
         break;
         case Dema :
            retCode = dema ( startIdx, endIdx, inReal, optInTimePeriod,
            outBegIdx, outNBElement, outReal );
         break;
         case Tema :
            retCode = tema ( startIdx, endIdx, inReal, optInTimePeriod,
            outBegIdx, outNBElement, outReal );
         break;
         case Trima :
            retCode = trima ( startIdx, endIdx, inReal, optInTimePeriod,
            outBegIdx, outNBElement, outReal );
         break;
         case Kama :
            retCode = kama ( startIdx, endIdx, inReal, optInTimePeriod,
            outBegIdx, outNBElement, outReal );
         break;
         case Mama :
            dummyBuffer = new double[(endIdx-startIdx+1)] ;
         retCode = mama ( startIdx, endIdx, inReal, 0.5, 0.05,
            outBegIdx, outNBElement,
            outReal, dummyBuffer );
         break;
         case T3 :
            retCode = t3 ( startIdx, endIdx, inReal,
            optInTimePeriod, 0.7,
            outBegIdx, outNBElement, outReal );
         break;
         default:
            retCode = RetCode.BadParam ;
         break;
      }
      return retCode;
   }
   /* Generated */
   public int macdLookback( int optInFastPeriod,
      int optInSlowPeriod,
      int optInSignalPeriod )
   {
      int tempInteger;
      if( (int)optInFastPeriod == ( Integer.MIN_VALUE ) )
         optInFastPeriod = 12;
      else if( ((int)optInFastPeriod < 2) || ((int)optInFastPeriod > 100000) )
         return -1;
      if( (int)optInSlowPeriod == ( Integer.MIN_VALUE ) )
         optInSlowPeriod = 26;
      else if( ((int)optInSlowPeriod < 2) || ((int)optInSlowPeriod > 100000) )
         return -1;
      if( (int)optInSignalPeriod == ( Integer.MIN_VALUE ) )
         optInSignalPeriod = 9;
      else if( ((int)optInSignalPeriod < 1) || ((int)optInSignalPeriod > 100000) )
         return -1;
      if( optInSlowPeriod < optInFastPeriod )
      {
         tempInteger = optInSlowPeriod;
         optInSlowPeriod = optInFastPeriod;
         optInFastPeriod = tempInteger;
      }
      return emaLookback ( optInSlowPeriod )
         + emaLookback ( optInSignalPeriod );
   }
   public RetCode macd( int startIdx,
      int endIdx,
      double inReal[],
      int optInFastPeriod,
      int optInSlowPeriod,
      int optInSignalPeriod,
      MInteger outBegIdx,
      MInteger outNBElement,
      double outMACD[],
      double outMACDSignal[],
      double outMACDHist[] )
   {
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      if( (int)optInFastPeriod == ( Integer.MIN_VALUE ) )
         optInFastPeriod = 12;
      else if( ((int)optInFastPeriod < 2) || ((int)optInFastPeriod > 100000) )
         return RetCode.BadParam ;
      if( (int)optInSlowPeriod == ( Integer.MIN_VALUE ) )
         optInSlowPeriod = 26;
      else if( ((int)optInSlowPeriod < 2) || ((int)optInSlowPeriod > 100000) )
         return RetCode.BadParam ;
      if( (int)optInSignalPeriod == ( Integer.MIN_VALUE ) )
         optInSignalPeriod = 9;
      else if( ((int)optInSignalPeriod < 1) || ((int)optInSignalPeriod > 100000) )
         return RetCode.BadParam ;
      return TA_INT_MACD ( startIdx, endIdx, inReal,
         optInFastPeriod,
         optInSlowPeriod,
         optInSignalPeriod,
         outBegIdx,
         outNBElement,
         outMACD,
         outMACDSignal,
         outMACDHist );
   }
   RetCode TA_INT_MACD( int startIdx,
      int endIdx,
      double inReal[],
      int optInFastPeriod,
      int optInSlowPeriod,
      int optInSignalPeriod_2,
      MInteger outBegIdx,
      MInteger outNBElement,
      double outMACD[],
      double outMACDSignal[],
      double outMACDHist[] )
   {
      double []slowEMABuffer ;
      double []fastEMABuffer ;
      double k1, k2;
      RetCode retCode;
      int tempInteger;
      MInteger outBegIdx1 = new MInteger() ;
      MInteger outNbElement1 = new MInteger() ;
      MInteger outBegIdx2 = new MInteger() ;
      MInteger outNbElement2 = new MInteger() ;
      int lookbackTotal, lookbackSignal;
      int i;
      if( optInSlowPeriod < optInFastPeriod )
      {
         tempInteger = optInSlowPeriod;
         optInSlowPeriod = optInFastPeriod;
         optInFastPeriod = tempInteger;
      }
      if( optInSlowPeriod != 0 )
         k1 = ((double)2.0 / ((double)(optInSlowPeriod + 1))) ;
      else
      {
         optInSlowPeriod = 26;
         k1 = (double)0.075;
      }
      if( optInFastPeriod != 0 )
         k2 = ((double)2.0 / ((double)(optInFastPeriod + 1))) ;
      else
      {
         optInFastPeriod = 12;
         k2 = (double)0.15;
      }
      lookbackSignal = emaLookback ( optInSignalPeriod_2 );
      lookbackTotal = lookbackSignal;
      lookbackTotal += emaLookback ( optInSlowPeriod );
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      tempInteger = (endIdx-startIdx)+1+lookbackSignal;
      fastEMABuffer = new double[tempInteger] ;
      slowEMABuffer = new double[tempInteger] ;
      tempInteger = startIdx-lookbackSignal;
      retCode = TA_INT_EMA ( tempInteger, endIdx,
         inReal, optInSlowPeriod, k1,
         outBegIdx1 , outNbElement1 , slowEMABuffer );
      if( retCode != RetCode.Success )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return retCode;
      }
      retCode = TA_INT_EMA ( tempInteger, endIdx,
         inReal, optInFastPeriod, k2,
         outBegIdx2 , outNbElement2 , fastEMABuffer );
      if( retCode != RetCode.Success )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return retCode;
      }
      if( ( outBegIdx1.value != tempInteger) ||
         ( outBegIdx2.value != tempInteger) ||
         ( outNbElement1.value != outNbElement2.value ) ||
         ( outNbElement1.value != (endIdx-startIdx)+1+lookbackSignal) )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return (RetCode.InternalError) ;
      }
      for( i=0; i < outNbElement1.value ; i++ )
         fastEMABuffer[i] = fastEMABuffer[i] - slowEMABuffer[i];
      System.arraycopy(fastEMABuffer,lookbackSignal,outMACD,0,(endIdx-startIdx)+1) ;
      retCode = TA_INT_EMA ( 0, outNbElement1.value -1,
         fastEMABuffer, optInSignalPeriod_2, ((double)2.0 / ((double)(optInSignalPeriod_2 + 1))) ,
         outBegIdx2 , outNbElement2 , outMACDSignal );
      if( retCode != RetCode.Success )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return retCode;
      }
      for( i=0; i < outNbElement2.value ; i++ )
         outMACDHist[i] = outMACD[i]-outMACDSignal[i];
      outBegIdx.value = startIdx;
      outNBElement.value = outNbElement2.value ;
      return RetCode.Success ;
   }
   public int macdStateInit( struct TA_macd_State** _state,
      int optInFastPeriod,
      int optInSlowPeriod,
      int optInSignalPeriod )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if( (int)optInFastPeriod == ( Integer.MIN_VALUE ) )
         optInFastPeriod = 12;
      else if( ((int)optInFastPeriod < 2) || ((int)optInFastPeriod > 100000) )
         return RetCode.BadParam ;
      if( (int)optInSlowPeriod == ( Integer.MIN_VALUE ) )
         optInSlowPeriod = 26;
      else if( ((int)optInSlowPeriod < 2) || ((int)optInSlowPeriod > 100000) )
         return RetCode.BadParam ;
      if( (int)optInSignalPeriod == ( Integer.MIN_VALUE ) )
         optInSignalPeriod = 9;
      else if( ((int)optInSignalPeriod < 1) || ((int)optInSignalPeriod > 100000) )
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct macd ));
      _state.value .value .mem_index = 0;
      _state.value .value .optInFastPeriod = optInFastPeriod;
      _state.value .value .optInSlowPeriod = optInSlowPeriod;
      _state.value .value .optInSignalPeriod = optInSignalPeriod;
      _state.value .value .mem_size = macdLookback (optInFastPeriod, optInSlowPeriod, optInSignalPeriod );
      if ( _state.value .value .mem_size > 0)
         _state.value .value .memory = TA_Calloc( _state.value .value .mem_size , sizeof(struct TA_MACD_Data));
      else
         _state.value .value .memory = NULL;
      return RetCode.Success ;
   }
   public int macdState( struct TA_macd_State* _state,
      double inReal,
      double *outMACD,
      double *outMACDSignal,
      double *outMACDHist )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      size_t _cur_idx = _state.value .mem_index++;
      if ( _state.value .mem_size > 0) _cur_idx %= _state.value .mem_size ;
      if ( _state.value .mem_size > _state.value .mem_index - 1 ) {
         ( _state.value .memory+_cur_idx).value .inReal = inReal ;
         return RetCode.NeedMoreData ; }
      return RetCode.Success ;
   }
   public int macdStateFree( struct TA_macd_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if ( _state.value != NULL) {
         if ( _state.value .value .memory != NULL) TA_Free( _state.value .value .memory );
         TA_Free( _state.value ); _state.value = NULL;}
      return RetCode.Success ;
   }
   public RetCode macd( int startIdx,
      int endIdx,
      float inReal[],
      int optInFastPeriod,
      int optInSlowPeriod,
      int optInSignalPeriod,
      MInteger outBegIdx,
      MInteger outNBElement,
      double outMACD[],
      double outMACDSignal[],
      double outMACDHist[] )
   {
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      if( (int)optInFastPeriod == ( Integer.MIN_VALUE ) )
         optInFastPeriod = 12;
      else if( ((int)optInFastPeriod < 2) || ((int)optInFastPeriod > 100000) )
         return RetCode.BadParam ;
      if( (int)optInSlowPeriod == ( Integer.MIN_VALUE ) )
         optInSlowPeriod = 26;
      else if( ((int)optInSlowPeriod < 2) || ((int)optInSlowPeriod > 100000) )
         return RetCode.BadParam ;
      if( (int)optInSignalPeriod == ( Integer.MIN_VALUE ) )
         optInSignalPeriod = 9;
      else if( ((int)optInSignalPeriod < 1) || ((int)optInSignalPeriod > 100000) )
         return RetCode.BadParam ;
      return TA_INT_MACD ( startIdx, endIdx, inReal,
         optInFastPeriod,
         optInSlowPeriod,
         optInSignalPeriod,
         outBegIdx,
         outNBElement,
         outMACD,
         outMACDSignal,
         outMACDHist );
   }
   RetCode TA_INT_MACD( int startIdx,
      int endIdx,
      float inReal[],
      int optInFastPeriod,
      int optInSlowPeriod,
      int optInSignalPeriod_2,
      MInteger outBegIdx,
      MInteger outNBElement,
      double outMACD[],
      double outMACDSignal[],
      double outMACDHist[] )
   {
      double []slowEMABuffer ;
      double []fastEMABuffer ;
      double k1, k2;
      RetCode retCode;
      int tempInteger;
      MInteger outBegIdx1 = new MInteger() ;
      MInteger outNbElement1 = new MInteger() ;
      MInteger outBegIdx2 = new MInteger() ;
      MInteger outNbElement2 = new MInteger() ;
      int lookbackTotal, lookbackSignal;
      int i;
      if( optInSlowPeriod < optInFastPeriod )
      {
         tempInteger = optInSlowPeriod;
         optInSlowPeriod = optInFastPeriod;
         optInFastPeriod = tempInteger;
      }
      if( optInSlowPeriod != 0 )
         k1 = ((double)2.0 / ((double)(optInSlowPeriod + 1))) ;
      else
      {
         optInSlowPeriod = 26;
         k1 = (double)0.075;
      }
      if( optInFastPeriod != 0 )
         k2 = ((double)2.0 / ((double)(optInFastPeriod + 1))) ;
      else
      {
         optInFastPeriod = 12;
         k2 = (double)0.15;
      }
      lookbackSignal = emaLookback ( optInSignalPeriod_2 );
      lookbackTotal = lookbackSignal;
      lookbackTotal += emaLookback ( optInSlowPeriod );
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      tempInteger = (endIdx-startIdx)+1+lookbackSignal;
      fastEMABuffer = new double[tempInteger] ;
      slowEMABuffer = new double[tempInteger] ;
      tempInteger = startIdx-lookbackSignal;
      retCode = TA_INT_EMA ( tempInteger, endIdx,
         inReal, optInSlowPeriod, k1,
         outBegIdx1 , outNbElement1 , slowEMABuffer );
      if( retCode != RetCode.Success )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return retCode;
      }
      retCode = TA_INT_EMA ( tempInteger, endIdx,
         inReal, optInFastPeriod, k2,
         outBegIdx2 , outNbElement2 , fastEMABuffer );
      if( retCode != RetCode.Success )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return retCode;
      }
      if( ( outBegIdx1.value != tempInteger) ||
         ( outBegIdx2.value != tempInteger) ||
         ( outNbElement1.value != outNbElement2.value ) ||
         ( outNbElement1.value != (endIdx-startIdx)+1+lookbackSignal) )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return (RetCode.InternalError) ;
      }
      for( i=0; i < outNbElement1.value ; i++ )
         fastEMABuffer[i] = fastEMABuffer[i] - slowEMABuffer[i];
      System.arraycopy(fastEMABuffer,lookbackSignal,outMACD,0,(endIdx-startIdx)+1) ;
      retCode = TA_INT_EMA ( 0, outNbElement1.value -1,
         fastEMABuffer, optInSignalPeriod_2, ((double)2.0 / ((double)(optInSignalPeriod_2 + 1))) ,
         outBegIdx2 , outNbElement2 , outMACDSignal );
      if( retCode != RetCode.Success )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return retCode;
      }
      for( i=0; i < outNbElement2.value ; i++ )
         outMACDHist[i] = outMACD[i]-outMACDSignal[i];
      outBegIdx.value = startIdx;
      outNBElement.value = outNbElement2.value ;
      return RetCode.Success ;
   }
   /* Generated */
   public int macdExtLookback( int optInFastPeriod,
      MAType optInFastMAType, int optInSlowPeriod,
      MAType optInSlowMAType, int optInSignalPeriod,
      MAType optInSignalMAType )
   {
      int tempInteger, lookbackLargest;
      if( (int)optInFastPeriod == ( Integer.MIN_VALUE ) )
         optInFastPeriod = 12;
      else if( ((int)optInFastPeriod < 2) || ((int)optInFastPeriod > 100000) )
         return -1;
      if( (int)optInSlowPeriod == ( Integer.MIN_VALUE ) )
         optInSlowPeriod = 26;
      else if( ((int)optInSlowPeriod < 2) || ((int)optInSlowPeriod > 100000) )
         return -1;
      if( (int)optInSignalPeriod == ( Integer.MIN_VALUE ) )
         optInSignalPeriod = 9;
      else if( ((int)optInSignalPeriod < 1) || ((int)optInSignalPeriod > 100000) )
         return -1;
      lookbackLargest = movingAverageLookback ( optInFastPeriod, optInFastMAType );
      tempInteger = movingAverageLookback ( optInSlowPeriod, optInSlowMAType );
      if( tempInteger > lookbackLargest )
         lookbackLargest = tempInteger;
      return lookbackLargest + movingAverageLookback ( optInSignalPeriod, optInSignalMAType );
   }
   public RetCode macdExt( int startIdx,
      int endIdx,
      double inReal[],
      int optInFastPeriod,
      MAType optInFastMAType, int optInSlowPeriod,
      MAType optInSlowMAType, int optInSignalPeriod,
      MAType optInSignalMAType, MInteger outBegIdx,
      MInteger outNBElement,
      double outMACD[],
      double outMACDSignal[],
      double outMACDHist[] )
   {
      double []slowMABuffer ;
      double []fastMABuffer ;
      RetCode retCode;
      int tempInteger;
      MInteger outBegIdx1 = new MInteger() ;
      MInteger outNbElement1 = new MInteger() ;
      MInteger outBegIdx2 = new MInteger() ;
      MInteger outNbElement2 = new MInteger() ;
      int lookbackTotal, lookbackSignal, lookbackLargest;
      int i;
      MAType tempMAType;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      if( (int)optInFastPeriod == ( Integer.MIN_VALUE ) )
         optInFastPeriod = 12;
      else if( ((int)optInFastPeriod < 2) || ((int)optInFastPeriod > 100000) )
         return RetCode.BadParam ;
      if( (int)optInSlowPeriod == ( Integer.MIN_VALUE ) )
         optInSlowPeriod = 26;
      else if( ((int)optInSlowPeriod < 2) || ((int)optInSlowPeriod > 100000) )
         return RetCode.BadParam ;
      if( (int)optInSignalPeriod == ( Integer.MIN_VALUE ) )
         optInSignalPeriod = 9;
      else if( ((int)optInSignalPeriod < 1) || ((int)optInSignalPeriod > 100000) )
         return RetCode.BadParam ;
      if( optInSlowPeriod < optInFastPeriod )
      {
         tempInteger = optInSlowPeriod;
         optInSlowPeriod = optInFastPeriod;
         optInFastPeriod = tempInteger;
         tempMAType = optInSlowMAType;
         optInSlowMAType = optInFastMAType;
         optInFastMAType = tempMAType;
      }
      lookbackLargest = movingAverageLookback ( optInFastPeriod, optInFastMAType );
      tempInteger = movingAverageLookback ( optInSlowPeriod, optInSlowMAType );
      if( tempInteger > lookbackLargest )
         lookbackLargest = tempInteger;
      lookbackSignal = movingAverageLookback ( optInSignalPeriod, optInSignalMAType );
      lookbackTotal = lookbackSignal+lookbackLargest;
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      tempInteger = (endIdx-startIdx)+1+lookbackSignal;
      fastMABuffer = new double[tempInteger] ;
      slowMABuffer = new double[tempInteger] ;
      tempInteger = startIdx-lookbackSignal;
      retCode = movingAverage ( tempInteger, endIdx,
         inReal, optInSlowPeriod, optInSlowMAType,
         outBegIdx1 , outNbElement1 ,
         slowMABuffer );
      if( retCode != RetCode.Success )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return retCode;
      }
      retCode = movingAverage ( tempInteger, endIdx,
         inReal, optInFastPeriod, optInFastMAType,
         outBegIdx2 , outNbElement2 ,
         fastMABuffer );
      if( retCode != RetCode.Success )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return retCode;
      }
      if( ( outBegIdx1.value != tempInteger) ||
         ( outBegIdx2.value != tempInteger) ||
         ( outNbElement1.value != outNbElement2.value ) ||
         ( outNbElement1.value != (endIdx-startIdx)+1+lookbackSignal) )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return (RetCode.InternalError) ;
      }
      for( i=0; i < outNbElement1.value ; i++ )
         fastMABuffer[i] = fastMABuffer[i] - slowMABuffer[i];
      System.arraycopy(fastMABuffer,lookbackSignal,outMACD,0,(endIdx-startIdx)+1) ;
      retCode = movingAverage ( 0, outNbElement1.value -1,
         fastMABuffer, optInSignalPeriod, optInSignalMAType,
         outBegIdx2 , outNbElement2 , outMACDSignal );
      if( retCode != RetCode.Success )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return retCode;
      }
      for( i=0; i < outNbElement2.value ; i++ )
         outMACDHist[i] = outMACD[i]-outMACDSignal[i];
      outBegIdx.value = startIdx;
      outNBElement.value = outNbElement2.value ;
      return RetCode.Success ;
   }
   public int macdExtStateInit( struct TA_macdExt_State** _state,
      int optInFastPeriod,
      MAType optInFastMAType, int optInSlowPeriod,
      MAType optInSlowMAType, int optInSignalPeriod,
      MAType optInSignalMAType )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if( (int)optInFastPeriod == ( Integer.MIN_VALUE ) )
         optInFastPeriod = 12;
      else if( ((int)optInFastPeriod < 2) || ((int)optInFastPeriod > 100000) )
         return RetCode.BadParam ;
      if( (int)optInSlowPeriod == ( Integer.MIN_VALUE ) )
         optInSlowPeriod = 26;
      else if( ((int)optInSlowPeriod < 2) || ((int)optInSlowPeriod > 100000) )
         return RetCode.BadParam ;
      if( (int)optInSignalPeriod == ( Integer.MIN_VALUE ) )
         optInSignalPeriod = 9;
      else if( ((int)optInSignalPeriod < 1) || ((int)optInSignalPeriod > 100000) )
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct macdExt ));
      _state.value .value .mem_index = 0;
      _state.value .value .optInFastPeriod = optInFastPeriod;
      _state.value .value .optInFastMAType = optInFastMAType;
      _state.value .value .optInSlowPeriod = optInSlowPeriod;
      _state.value .value .optInSlowMAType = optInSlowMAType;
      _state.value .value .optInSignalPeriod = optInSignalPeriod;
      _state.value .value .optInSignalMAType = optInSignalMAType;
      _state.value .value .mem_size = macdExtLookback (optInFastPeriod, optInFastMAType, optInSlowPeriod, optInSlowMAType, optInSignalPeriod, optInSignalMAType );
      if ( _state.value .value .mem_size > 0)
         _state.value .value .memory = TA_Calloc( _state.value .value .mem_size , sizeof(struct TA_MACDEXT_Data));
      else
         _state.value .value .memory = NULL;
      return RetCode.Success ;
   }
   public int macdExtState( struct TA_macdExt_State* _state,
      double inReal,
      double *outMACD,
      double *outMACDSignal,
      double *outMACDHist )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      size_t _cur_idx = _state.value .mem_index++;
      if ( _state.value .mem_size > 0) _cur_idx %= _state.value .mem_size ;
      if ( _state.value .mem_size > _state.value .mem_index - 1 ) {
         ( _state.value .memory+_cur_idx).value .inReal = inReal ;
         return RetCode.NeedMoreData ; }
      return RetCode.Success ;
   }
   public int macdExtStateFree( struct TA_macdExt_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if ( _state.value != NULL) {
         if ( _state.value .value .memory != NULL) TA_Free( _state.value .value .memory );
         TA_Free( _state.value ); _state.value = NULL;}
      return RetCode.Success ;
   }
   public RetCode macdExt( int startIdx,
      int endIdx,
      float inReal[],
      int optInFastPeriod,
      MAType optInFastMAType, int optInSlowPeriod,
      MAType optInSlowMAType, int optInSignalPeriod,
      MAType optInSignalMAType, MInteger outBegIdx,
      MInteger outNBElement,
      double outMACD[],
      double outMACDSignal[],
      double outMACDHist[] )
   {
      double []slowMABuffer ;
      double []fastMABuffer ;
      RetCode retCode;
      int tempInteger;
      MInteger outBegIdx1 = new MInteger() ;
      MInteger outNbElement1 = new MInteger() ;
      MInteger outBegIdx2 = new MInteger() ;
      MInteger outNbElement2 = new MInteger() ;
      int lookbackTotal, lookbackSignal, lookbackLargest;
      int i;
      MAType tempMAType;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      if( (int)optInFastPeriod == ( Integer.MIN_VALUE ) )
         optInFastPeriod = 12;
      else if( ((int)optInFastPeriod < 2) || ((int)optInFastPeriod > 100000) )
         return RetCode.BadParam ;
      if( (int)optInSlowPeriod == ( Integer.MIN_VALUE ) )
         optInSlowPeriod = 26;
      else if( ((int)optInSlowPeriod < 2) || ((int)optInSlowPeriod > 100000) )
         return RetCode.BadParam ;
      if( (int)optInSignalPeriod == ( Integer.MIN_VALUE ) )
         optInSignalPeriod = 9;
      else if( ((int)optInSignalPeriod < 1) || ((int)optInSignalPeriod > 100000) )
         return RetCode.BadParam ;
      if( optInSlowPeriod < optInFastPeriod )
      {
         tempInteger = optInSlowPeriod;
         optInSlowPeriod = optInFastPeriod;
         optInFastPeriod = tempInteger;
         tempMAType = optInSlowMAType;
         optInSlowMAType = optInFastMAType;
         optInFastMAType = tempMAType;
      }
      lookbackLargest = movingAverageLookback ( optInFastPeriod, optInFastMAType );
      tempInteger = movingAverageLookback ( optInSlowPeriod, optInSlowMAType );
      if( tempInteger > lookbackLargest )
         lookbackLargest = tempInteger;
      lookbackSignal = movingAverageLookback ( optInSignalPeriod, optInSignalMAType );
      lookbackTotal = lookbackSignal+lookbackLargest;
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      tempInteger = (endIdx-startIdx)+1+lookbackSignal;
      fastMABuffer = new double[tempInteger] ;
      slowMABuffer = new double[tempInteger] ;
      tempInteger = startIdx-lookbackSignal;
      retCode = movingAverage ( tempInteger, endIdx,
         inReal, optInSlowPeriod, optInSlowMAType,
         outBegIdx1 , outNbElement1 ,
         slowMABuffer );
      if( retCode != RetCode.Success )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return retCode;
      }
      retCode = movingAverage ( tempInteger, endIdx,
         inReal, optInFastPeriod, optInFastMAType,
         outBegIdx2 , outNbElement2 ,
         fastMABuffer );
      if( retCode != RetCode.Success )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return retCode;
      }
      if( ( outBegIdx1.value != tempInteger) ||
         ( outBegIdx2.value != tempInteger) ||
         ( outNbElement1.value != outNbElement2.value ) ||
         ( outNbElement1.value != (endIdx-startIdx)+1+lookbackSignal) )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return (RetCode.InternalError) ;
      }
      for( i=0; i < outNbElement1.value ; i++ )
         fastMABuffer[i] = fastMABuffer[i] - slowMABuffer[i];
      System.arraycopy(fastMABuffer,lookbackSignal,outMACD,0,(endIdx-startIdx)+1) ;
      retCode = movingAverage ( 0, outNbElement1.value -1,
         fastMABuffer, optInSignalPeriod, optInSignalMAType,
         outBegIdx2 , outNbElement2 , outMACDSignal );
      if( retCode != RetCode.Success )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return retCode;
      }
      for( i=0; i < outNbElement2.value ; i++ )
         outMACDHist[i] = outMACD[i]-outMACDSignal[i];
      outBegIdx.value = startIdx;
      outNBElement.value = outNbElement2.value ;
      return RetCode.Success ;
   }
   /* Generated */
   public int macdFixLookback( int optInSignalPeriod )
   {
      if( (int)optInSignalPeriod == ( Integer.MIN_VALUE ) )
         optInSignalPeriod = 9;
      else if( ((int)optInSignalPeriod < 1) || ((int)optInSignalPeriod > 100000) )
         return -1;
      return emaLookback ( 26 )
         + emaLookback ( optInSignalPeriod );
   }
   public RetCode macdFix( int startIdx,
      int endIdx,
      double inReal[],
      int optInSignalPeriod,
      MInteger outBegIdx,
      MInteger outNBElement,
      double outMACD[],
      double outMACDSignal[],
      double outMACDHist[] )
   {
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      if( (int)optInSignalPeriod == ( Integer.MIN_VALUE ) )
         optInSignalPeriod = 9;
      else if( ((int)optInSignalPeriod < 1) || ((int)optInSignalPeriod > 100000) )
         return RetCode.BadParam ;
      return TA_INT_MACD ( startIdx, endIdx, inReal,
         0,
         0,
         optInSignalPeriod,
         outBegIdx,
         outNBElement,
         outMACD,
         outMACDSignal,
         outMACDHist );
   }
   public int macdFixStateInit( struct TA_macdFix_State** _state,
      int optInSignalPeriod )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if( (int)optInSignalPeriod == ( Integer.MIN_VALUE ) )
         optInSignalPeriod = 9;
      else if( ((int)optInSignalPeriod < 1) || ((int)optInSignalPeriod > 100000) )
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct macdFix ));
      _state.value .value .mem_index = 0;
      _state.value .value .optInSignalPeriod = optInSignalPeriod;
      _state.value .value .mem_size = macdFixLookback (optInSignalPeriod );
      if ( _state.value .value .mem_size > 0)
         _state.value .value .memory = TA_Calloc( _state.value .value .mem_size , sizeof(struct TA_MACDFIX_Data));
      else
         _state.value .value .memory = NULL;
      return RetCode.Success ;
   }
   public int macdFixState( struct TA_macdFix_State* _state,
      double inReal,
      double *outMACD,
      double *outMACDSignal,
      double *outMACDHist )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      size_t _cur_idx = _state.value .mem_index++;
      if ( _state.value .mem_size > 0) _cur_idx %= _state.value .mem_size ;
      if ( _state.value .mem_size > _state.value .mem_index - 1 ) {
         ( _state.value .memory+_cur_idx).value .inReal = inReal ;
         return RetCode.NeedMoreData ; }
      return RetCode.Success ;
   }
   public int macdFixStateFree( struct TA_macdFix_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if ( _state.value != NULL) {
         if ( _state.value .value .memory != NULL) TA_Free( _state.value .value .memory );
         TA_Free( _state.value ); _state.value = NULL;}
      return RetCode.Success ;
   }
   public RetCode macdFix( int startIdx,
      int endIdx,
      float inReal[],
      int optInSignalPeriod,
      MInteger outBegIdx,
      MInteger outNBElement,
      double outMACD[],
      double outMACDSignal[],
      double outMACDHist[] )
   {
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      if( (int)optInSignalPeriod == ( Integer.MIN_VALUE ) )
         optInSignalPeriod = 9;
      else if( ((int)optInSignalPeriod < 1) || ((int)optInSignalPeriod > 100000) )
         return RetCode.BadParam ;
      return TA_INT_MACD ( startIdx, endIdx, inReal,
         0,
         0,
         optInSignalPeriod,
         outBegIdx,
         outNBElement,
         outMACD,
         outMACDSignal,
         outMACDHist );
   }
   /* Generated */
   public int mamaLookback( double optInFastLimit,
      double optInSlowLimit )
   {
      if( optInFastLimit == (-4e+37) )
         optInFastLimit = 5.000000e-1;
      else if( (optInFastLimit < 1.000000e-2) || (optInFastLimit > 9.900000e-1) )
         return -1;
      if( optInSlowLimit == (-4e+37) )
         optInSlowLimit = 5.000000e-2;
      else if( (optInSlowLimit < 1.000000e-2) || (optInSlowLimit > 9.900000e-1) )
         return -1;
      return 32 + (this.unstablePeriod[FuncUnstId.Mama.ordinal()]) ;
   }
   public RetCode mama( int startIdx,
      int endIdx,
      double inReal[],
      double optInFastLimit,
      double optInSlowLimit,
      MInteger outBegIdx,
      MInteger outNBElement,
      double outMAMA[],
      double outFAMA[] )
   {
      int outIdx, i;
      int lookbackTotal, today;
      double tempReal, tempReal2;
      double adjustedPrevPeriod, period;
      int trailingWMAIdx;
      double periodWMASum, periodWMASub, trailingWMAValue;
      double smoothedValue;
      final double a = 0.0962;
      final double b = 0.5769;
      double hilbertTempReal;
      int hilbertIdx;
      double []detrender_Odd = new double[3] ; double []detrender_Even = new double[3] ; double detrender; double prev_detrender_Odd ; double prev_detrender_Even ; double prev_detrender_input_Odd ; double prev_detrender_input_Even ;
      double []Q1_Odd = new double[3] ; double []Q1_Even = new double[3] ; double Q1; double prev_Q1_Odd ; double prev_Q1_Even ; double prev_Q1_input_Odd ; double prev_Q1_input_Even ;
      double []jI_Odd = new double[3] ; double []jI_Even = new double[3] ; double jI; double prev_jI_Odd ; double prev_jI_Even ; double prev_jI_input_Odd ; double prev_jI_input_Even ;
      double []jQ_Odd = new double[3] ; double []jQ_Even = new double[3] ; double jQ; double prev_jQ_Odd ; double prev_jQ_Even ; double prev_jQ_input_Odd ; double prev_jQ_input_Even ;
      double Q2, I2, prevQ2, prevI2, Re, Im;
      double I1ForOddPrev2, I1ForOddPrev3;
      double I1ForEvenPrev2, I1ForEvenPrev3;
      double rad2Deg;
      double mama,fama,todayValue,prevPhase;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      if( optInFastLimit == (-4e+37) )
         optInFastLimit = 5.000000e-1;
      else if( (optInFastLimit < 1.000000e-2) || (optInFastLimit > 9.900000e-1) )
         return RetCode.BadParam ;
      if( optInSlowLimit == (-4e+37) )
         optInSlowLimit = 5.000000e-2;
      else if( (optInSlowLimit < 1.000000e-2) || (optInSlowLimit > 9.900000e-1) )
         return RetCode.BadParam ;
      rad2Deg = 180.0 / (4.0 * Math.atan (1));
      lookbackTotal = 32 + (this.unstablePeriod[FuncUnstId.Mama.ordinal()]) ;
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      outBegIdx.value = startIdx;
      trailingWMAIdx = startIdx - lookbackTotal;
      today = trailingWMAIdx;
      tempReal = inReal[today++];
      periodWMASub = tempReal;
      periodWMASum = tempReal;
      tempReal = inReal[today++];
      periodWMASub += tempReal;
      periodWMASum += tempReal*2.0;
      tempReal = inReal[today++];
      periodWMASub += tempReal;
      periodWMASum += tempReal*3.0;
      trailingWMAValue = 0.0;
      i = 9;
      do
      {
         tempReal = inReal[today++];
         { periodWMASub += tempReal; periodWMASub -= trailingWMAValue; periodWMASum += tempReal*4.0; trailingWMAValue = inReal[trailingWMAIdx++]; smoothedValue = periodWMASum*0.1; periodWMASum -= periodWMASub; } ;
      } while( --i != 0);
      hilbertIdx = 0;
      { detrender_Odd [0] = 0.0; detrender_Odd [1] = 0.0; detrender_Odd [2] = 0.0; detrender_Even [0] = 0.0; detrender_Even [1] = 0.0; detrender_Even [2] = 0.0; detrender = 0.0; prev_detrender_Odd = 0.0; prev_detrender_Even = 0.0; prev_detrender_input_Odd = 0.0; prev_detrender_input_Even = 0.0; } ;
      { Q1_Odd [0] = 0.0; Q1_Odd [1] = 0.0; Q1_Odd [2] = 0.0; Q1_Even [0] = 0.0; Q1_Even [1] = 0.0; Q1_Even [2] = 0.0; Q1 = 0.0; prev_Q1_Odd = 0.0; prev_Q1_Even = 0.0; prev_Q1_input_Odd = 0.0; prev_Q1_input_Even = 0.0; } ;
      { jI_Odd [0] = 0.0; jI_Odd [1] = 0.0; jI_Odd [2] = 0.0; jI_Even [0] = 0.0; jI_Even [1] = 0.0; jI_Even [2] = 0.0; jI = 0.0; prev_jI_Odd = 0.0; prev_jI_Even = 0.0; prev_jI_input_Odd = 0.0; prev_jI_input_Even = 0.0; } ;
      { jQ_Odd [0] = 0.0; jQ_Odd [1] = 0.0; jQ_Odd [2] = 0.0; jQ_Even [0] = 0.0; jQ_Even [1] = 0.0; jQ_Even [2] = 0.0; jQ = 0.0; prev_jQ_Odd = 0.0; prev_jQ_Even = 0.0; prev_jQ_input_Odd = 0.0; prev_jQ_input_Even = 0.0; } ;
      period = 0.0;
      outIdx = 0;
      prevI2 = prevQ2 = 0.0;
      Re = Im = 0.0;
      mama = fama = 0.0;
      I1ForOddPrev3 = I1ForEvenPrev3 = 0.0;
      I1ForOddPrev2 = I1ForEvenPrev2 = 0.0;
      prevPhase = 0.0;
      while( today <= endIdx )
      {
         adjustedPrevPeriod = (0.075*period)+0.54;
         todayValue = inReal[today];
         { periodWMASub += todayValue; periodWMASub -= trailingWMAValue; periodWMASum += todayValue*4.0; trailingWMAValue = inReal[trailingWMAIdx++]; smoothedValue = periodWMASum*0.1; periodWMASum -= periodWMASub; } ;
         if( (today%2) == 0 )
         {
            { hilbertTempReal = a * smoothedValue; detrender = -detrender_Even [hilbertIdx]; detrender_Even [hilbertIdx] = hilbertTempReal; detrender += hilbertTempReal; detrender -= prev_detrender_Even ; prev_detrender_Even = b * prev_detrender_input_Even ; detrender += prev_detrender_Even ; prev_detrender_input_Even = smoothedValue; detrender *= adjustedPrevPeriod; } ;
            { hilbertTempReal = a * detrender; Q1 = -Q1_Even [hilbertIdx]; Q1_Even [hilbertIdx] = hilbertTempReal; Q1 += hilbertTempReal; Q1 -= prev_Q1_Even ; prev_Q1_Even = b * prev_Q1_input_Even ; Q1 += prev_Q1_Even ; prev_Q1_input_Even = detrender; Q1 *= adjustedPrevPeriod; } ;
            { hilbertTempReal = a * I1ForEvenPrev3; jI = -jI_Even [hilbertIdx]; jI_Even [hilbertIdx] = hilbertTempReal; jI += hilbertTempReal; jI -= prev_jI_Even ; prev_jI_Even = b * prev_jI_input_Even ; jI += prev_jI_Even ; prev_jI_input_Even = I1ForEvenPrev3; jI *= adjustedPrevPeriod; } ;
            { hilbertTempReal = a * Q1; jQ = -jQ_Even [hilbertIdx]; jQ_Even [hilbertIdx] = hilbertTempReal; jQ += hilbertTempReal; jQ -= prev_jQ_Even ; prev_jQ_Even = b * prev_jQ_input_Even ; jQ += prev_jQ_Even ; prev_jQ_input_Even = Q1; jQ *= adjustedPrevPeriod; } ;
            if( ++hilbertIdx == 3 )
               hilbertIdx = 0;
            Q2 = (0.2*(Q1 + jI)) + (0.8*prevQ2);
            I2 = (0.2*(I1ForEvenPrev3 - jQ)) + (0.8*prevI2);
            I1ForOddPrev3 = I1ForOddPrev2;
            I1ForOddPrev2 = detrender;
            if( I1ForEvenPrev3 != 0.0 )
               tempReal2 = ( Math.atan (Q1/I1ForEvenPrev3)*rad2Deg);
            else
               tempReal2 = 0.0;
         }
         else
         {
            { hilbertTempReal = a * smoothedValue; detrender = -detrender_Odd [hilbertIdx]; detrender_Odd [hilbertIdx] = hilbertTempReal; detrender += hilbertTempReal; detrender -= prev_detrender_Odd ; prev_detrender_Odd = b * prev_detrender_input_Odd ; detrender += prev_detrender_Odd ; prev_detrender_input_Odd = smoothedValue; detrender *= adjustedPrevPeriod; } ;
            { hilbertTempReal = a * detrender; Q1 = -Q1_Odd [hilbertIdx]; Q1_Odd [hilbertIdx] = hilbertTempReal; Q1 += hilbertTempReal; Q1 -= prev_Q1_Odd ; prev_Q1_Odd = b * prev_Q1_input_Odd ; Q1 += prev_Q1_Odd ; prev_Q1_input_Odd = detrender; Q1 *= adjustedPrevPeriod; } ;
            { hilbertTempReal = a * I1ForOddPrev3; jI = -jI_Odd [hilbertIdx]; jI_Odd [hilbertIdx] = hilbertTempReal; jI += hilbertTempReal; jI -= prev_jI_Odd ; prev_jI_Odd = b * prev_jI_input_Odd ; jI += prev_jI_Odd ; prev_jI_input_Odd = I1ForOddPrev3; jI *= adjustedPrevPeriod; } ;
            { hilbertTempReal = a * Q1; jQ = -jQ_Odd [hilbertIdx]; jQ_Odd [hilbertIdx] = hilbertTempReal; jQ += hilbertTempReal; jQ -= prev_jQ_Odd ; prev_jQ_Odd = b * prev_jQ_input_Odd ; jQ += prev_jQ_Odd ; prev_jQ_input_Odd = Q1; jQ *= adjustedPrevPeriod; } ;
            Q2 = (0.2*(Q1 + jI)) + (0.8*prevQ2);
            I2 = (0.2*(I1ForOddPrev3 - jQ)) + (0.8*prevI2);
            I1ForEvenPrev3 = I1ForEvenPrev2;
            I1ForEvenPrev2 = detrender;
            if( I1ForOddPrev3 != 0.0 )
               tempReal2 = ( Math.atan (Q1/I1ForOddPrev3)*rad2Deg);
            else
               tempReal2 = 0.0;
         }
         tempReal = prevPhase - tempReal2;
         prevPhase = tempReal2;
         if( tempReal < 1.0 )
            tempReal = 1.0;
         if( tempReal > 1.0 )
         {
            tempReal = optInFastLimit/tempReal;
            if( tempReal < optInSlowLimit )
               tempReal = optInSlowLimit;
         }
         else
         {
            tempReal = optInFastLimit;
         }
         mama = (tempReal*todayValue)+((1-tempReal)*mama);
         tempReal *= 0.5;
         fama = (tempReal*mama)+((1-tempReal)*fama);
         if( today >= startIdx )
         {
            outMAMA[outIdx] = mama;
            outFAMA[outIdx++] = fama;
         }
         Re = (0.2*((I2*prevI2)+(Q2*prevQ2)))+(0.8*Re);
         Im = (0.2*((I2*prevQ2)-(Q2*prevI2)))+(0.8*Im);
         prevQ2 = Q2;
         prevI2 = I2;
         tempReal = period;
         if( (Im != 0.0) && (Re != 0.0) )
            period = 360.0 / ( Math.atan (Im/Re)*rad2Deg);
         tempReal2 = 1.5*tempReal;
         if( period > tempReal2)
            period = tempReal2;
         tempReal2 = 0.67*tempReal;
         if( period < tempReal2 )
            period = tempReal2;
         if( period < 6 )
            period = 6;
         else if( period > 50 )
            period = 50;
         period = (0.2*period) + (0.8 * tempReal);
         today++;
      }
      outNBElement.value = outIdx;
      return RetCode.Success ;
   }
   struct TA_MAMA_HILBERT_STRUCT { double []_Odd = new double[3] ; double []_Even = new double[3] ; double var; double prev_Odd; double prev_Even; double prev_input_Odd; double prev_input_Even; };
   public int mamaStateInit( struct TA_mama_State** _state,
      double optInFastLimit,
      double optInSlowLimit )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if( optInFastLimit == (-4e+37) )
         optInFastLimit = 5.000000e-1;
      else if( (optInFastLimit < 1.000000e-2) || (optInFastLimit > 9.900000e-1) )
         return RetCode.BadParam ;
      if( optInSlowLimit == (-4e+37) )
         optInSlowLimit = 5.000000e-2;
      else if( (optInSlowLimit < 1.000000e-2) || (optInSlowLimit > 9.900000e-1) )
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct mama ));
      _state.value .value .mem_index = 0;
      _state.value .value .optInFastLimit = optInFastLimit;
      _state.value .value .optInSlowLimit = optInSlowLimit;
      _state.value .value .mem_size = mamaLookback (optInFastLimit, optInSlowLimit );
      if ( _state.value .value .mem_size > 0)
         _state.value .value .memory = TA_Calloc( _state.value .value .mem_size , sizeof(struct TA_MAMA_Data));
      else
         _state.value .value .memory = NULL;
      { _state.value .value .detrender = calloc(1, sizeof(struct TA_MAMA_HILBERT_STRUCT )); if ( _state.value .value .detrender == NULL) return RetCode.AllocErr ; } ;
      { _state.value .value .Q1 = calloc(1, sizeof(struct TA_MAMA_HILBERT_STRUCT )); if ( _state.value .value .Q1 == NULL) return RetCode.AllocErr ; } ;
      { _state.value .value .jI = calloc(1, sizeof(struct TA_MAMA_HILBERT_STRUCT )); if ( _state.value .value .jI == NULL) return RetCode.AllocErr ; } ;
      { _state.value .value .jQ = calloc(1, sizeof(struct TA_MAMA_HILBERT_STRUCT )); if ( _state.value .value .jQ == NULL) return RetCode.AllocErr ; } ;
      return RetCode.Success ;
   }
   public int mamaState( struct TA_mama_State* _state,
      double inReal,
      double *outMAMA,
      double *outFAMA )
   {
      double hilbertTempReal, smoothedValue;
      double adjustedPrevPeriod;
      double Q2, I2;
      double tempReal, tempReal2;
      if (_state == NULL)
         return RetCode.BadParam ;
      size_t _cur_idx = _state.value .mem_index++;
      if ( _state.value .mem_size > 0) _cur_idx %= _state.value .mem_size ;
      if ( ( _state.value .mem_index == 1) )
      {
         _state.value .periodWMASub = 0.;
         _state.value .periodWMASum = 0.;
         _state.value .hilbertIdx = 0;
         _state.value .period = 0;
         _state.value .prevI2 = 0.;
         _state.value .prevQ2 = 0.;
         _state.value .I1ForOddPrev2 = 0;
         _state.value .I1ForEvenPrev2 = 0;
         _state.value .I1ForOddPrev3 = 0;
         _state.value .I1ForEvenPrev3 = 0;
         _state.value .prevPhase = 0.;
         _state.value .mama = 0.;
         _state.value .fama = 0.;
         _state.value .Im = 0.;
         _state.value .Re = 0.;
         _state.value .trailingWMAValue = 0.;
         _state.value .rad2Deg = 180.0 / (4.0 * Math.atan (1));
         _state.value .a = 0.0962;
         _state.value .b = 0.5769;
         { struct TA_MAMA_HILBERT_STRUCT * ref; ref = (struct TA_MAMA_HILBERT_STRUCT *) _state.value .detrender; ref.value ._Odd [0] = 0.0; ref.value ._Odd [1] = 0.0; ref.value ._Odd [2] = 0.0; ref.value ._Even[0] = 0.0; ref.value ._Even[1] = 0.0; ref.value ._Even[2] = 0.0; ref.value .var = 0.0; ref.value .prev_Odd = 0.0; ref.value .prev_Even = 0.0; ref.value .prev_input_Odd = 0.0; ref.value .prev_input_Even = 0.0; } ;
         { struct TA_MAMA_HILBERT_STRUCT * ref; ref = (struct TA_MAMA_HILBERT_STRUCT *) _state.value .Q1; ref.value ._Odd [0] = 0.0; ref.value ._Odd [1] = 0.0; ref.value ._Odd [2] = 0.0; ref.value ._Even[0] = 0.0; ref.value ._Even[1] = 0.0; ref.value ._Even[2] = 0.0; ref.value .var = 0.0; ref.value .prev_Odd = 0.0; ref.value .prev_Even = 0.0; ref.value .prev_input_Odd = 0.0; ref.value .prev_input_Even = 0.0; } ;
         { struct TA_MAMA_HILBERT_STRUCT * ref; ref = (struct TA_MAMA_HILBERT_STRUCT *) _state.value .jI; ref.value ._Odd [0] = 0.0; ref.value ._Odd [1] = 0.0; ref.value ._Odd [2] = 0.0; ref.value ._Even[0] = 0.0; ref.value ._Even[1] = 0.0; ref.value ._Even[2] = 0.0; ref.value .var = 0.0; ref.value .prev_Odd = 0.0; ref.value .prev_Even = 0.0; ref.value .prev_input_Odd = 0.0; ref.value .prev_input_Even = 0.0; } ;
         { struct TA_MAMA_HILBERT_STRUCT * ref; ref = (struct TA_MAMA_HILBERT_STRUCT *) _state.value .jQ; ref.value ._Odd [0] = 0.0; ref.value ._Odd [1] = 0.0; ref.value ._Odd [2] = 0.0; ref.value ._Even[0] = 0.0; ref.value ._Even[1] = 0.0; ref.value ._Even[2] = 0.0; ref.value .var = 0.0; ref.value .prev_Odd = 0.0; ref.value .prev_Even = 0.0; ref.value .prev_input_Odd = 0.0; ref.value .prev_input_Even = 0.0; } ;
      }
      if ( _state.value .mem_index < 4)
      {
         _state.value .periodWMASub += inReal;
         _state.value .periodWMASum += _state.value .mem_index*inReal;
         ( _state.value .memory+_cur_idx).value .inReal = inReal ;
         return RetCode.NeedMoreData ;
      } else
         if ( _state.value .mem_index <= 12)
      {
         { _state.value .periodWMASub += inReal; _state.value .periodWMASub -= _state.value .trailingWMAValue; _state.value .periodWMASum += inReal*4.0; _state.value .trailingWMAValue = ( _state.value .memory+( _state.value .mem_index-4) % _state.value .mem_size ).value .inReal ; smoothedValue = _state.value .periodWMASum*0.1; _state.value .periodWMASum -= _state.value .periodWMASub; } ;
         ( _state.value .memory+_cur_idx).value .inReal = inReal ;
         return RetCode.NeedMoreData ;
      }
      adjustedPrevPeriod = (0.075* _state.value .period)+0.54;
      { _state.value .periodWMASub += inReal; _state.value .periodWMASub -= _state.value .trailingWMAValue; _state.value .periodWMASum += inReal*4.0; _state.value .trailingWMAValue = ( _state.value .memory+( _state.value .mem_index-4) % _state.value .mem_size ).value .inReal ; smoothedValue = _state.value .periodWMASum*0.1; _state.value .periodWMASum -= _state.value .periodWMASub; } ;
      if( (( _state.value .mem_index+1)%2) == 0 )
      {
         { struct TA_MAMA_HILBERT_STRUCT * ref; ref = (struct TA_MAMA_HILBERT_STRUCT *) _state.value .detrender; hilbertTempReal = _state.value .a * smoothedValue; ref.value .var = - ref.value ._Even [ _state.value .hilbertIdx]; ref.value ._Even [ _state.value .hilbertIdx] = hilbertTempReal; ref.value .var += hilbertTempReal; ref.value .var -= ref.value .prev_Even ; ref.value .prev_Even = _state.value .b * ref.value .prev_input_Even ; ref.value .var += ref.value .prev_Even ; ref.value .prev_input_Even = smoothedValue; ref.value .var *= adjustedPrevPeriod; } ;
         { struct TA_MAMA_HILBERT_STRUCT * ref; ref = (struct TA_MAMA_HILBERT_STRUCT *) _state.value .Q1; hilbertTempReal = _state.value .a * (struct TA_MAMA_HILBERT_STRUCT *) _state.value .detrender.value .var ; ref.value .var = - ref.value ._Even [ _state.value .hilbertIdx]; ref.value ._Even [ _state.value .hilbertIdx] = hilbertTempReal; ref.value .var += hilbertTempReal; ref.value .var -= ref.value .prev_Even ; ref.value .prev_Even = _state.value .b * ref.value .prev_input_Even ; ref.value .var += ref.value .prev_Even ; ref.value .prev_input_Even = (struct TA_MAMA_HILBERT_STRUCT *) _state.value .detrender.value .var ; ref.value .var *= adjustedPrevPeriod; } ;
         { struct TA_MAMA_HILBERT_STRUCT * ref; ref = (struct TA_MAMA_HILBERT_STRUCT *) _state.value .jI; hilbertTempReal = _state.value .a * _state.value .I1ForEvenPrev3; ref.value .var = - ref.value ._Even [ _state.value .hilbertIdx]; ref.value ._Even [ _state.value .hilbertIdx] = hilbertTempReal; ref.value .var += hilbertTempReal; ref.value .var -= ref.value .prev_Even ; ref.value .prev_Even = _state.value .b * ref.value .prev_input_Even ; ref.value .var += ref.value .prev_Even ; ref.value .prev_input_Even = _state.value .I1ForEvenPrev3; ref.value .var *= adjustedPrevPeriod; } ;
         { struct TA_MAMA_HILBERT_STRUCT * ref; ref = (struct TA_MAMA_HILBERT_STRUCT *) _state.value .jQ; hilbertTempReal = _state.value .a * (struct TA_MAMA_HILBERT_STRUCT *) _state.value .Q1.value .var ; ref.value .var = - ref.value ._Even [ _state.value .hilbertIdx]; ref.value ._Even [ _state.value .hilbertIdx] = hilbertTempReal; ref.value .var += hilbertTempReal; ref.value .var -= ref.value .prev_Even ; ref.value .prev_Even = _state.value .b * ref.value .prev_input_Even ; ref.value .var += ref.value .prev_Even ; ref.value .prev_input_Even = (struct TA_MAMA_HILBERT_STRUCT *) _state.value .Q1.value .var ; ref.value .var *= adjustedPrevPeriod; } ;
         if( ++ _state.value .hilbertIdx == 3 )
            _state.value .hilbertIdx = 0;
         Q2 = (0.2*( (struct TA_MAMA_HILBERT_STRUCT *) _state.value .Q1.value .var + (struct TA_MAMA_HILBERT_STRUCT *) _state.value .jI.value .var )) + (0.8* _state.value .prevQ2);
         I2 = (0.2*( _state.value .I1ForEvenPrev3 - (struct TA_MAMA_HILBERT_STRUCT *) _state.value .jQ.value .var )) + (0.8* _state.value .prevI2);
         _state.value .I1ForOddPrev3 = _state.value .I1ForOddPrev2;
         _state.value .I1ForOddPrev2 = (struct TA_MAMA_HILBERT_STRUCT *) _state.value .detrender.value .var ;
         if( _state.value .I1ForEvenPrev3 != 0.0 )
            tempReal2 = ( Math.atan ( (struct TA_MAMA_HILBERT_STRUCT *) _state.value .Q1.value .var / _state.value .I1ForEvenPrev3)* _state.value .rad2Deg);
         else
            tempReal2 = 0.0;
      } else {
         { struct TA_MAMA_HILBERT_STRUCT * ref; ref = (struct TA_MAMA_HILBERT_STRUCT *) _state.value .detrender; hilbertTempReal = _state.value .a * smoothedValue; ref.value .var = - ref.value ._Odd [ _state.value .hilbertIdx]; ref.value ._Odd [ _state.value .hilbertIdx] = hilbertTempReal; ref.value .var += hilbertTempReal; ref.value .var -= ref.value .prev_Odd ; ref.value .prev_Odd = _state.value .b * ref.value .prev_input_Odd ; ref.value .var += ref.value .prev_Odd ; ref.value .prev_input_Odd = smoothedValue; ref.value .var *= adjustedPrevPeriod; } ;
         { struct TA_MAMA_HILBERT_STRUCT * ref; ref = (struct TA_MAMA_HILBERT_STRUCT *) _state.value .Q1; hilbertTempReal = _state.value .a * (struct TA_MAMA_HILBERT_STRUCT *) _state.value .detrender.value .var ; ref.value .var = - ref.value ._Odd [ _state.value .hilbertIdx]; ref.value ._Odd [ _state.value .hilbertIdx] = hilbertTempReal; ref.value .var += hilbertTempReal; ref.value .var -= ref.value .prev_Odd ; ref.value .prev_Odd = _state.value .b * ref.value .prev_input_Odd ; ref.value .var += ref.value .prev_Odd ; ref.value .prev_input_Odd = (struct TA_MAMA_HILBERT_STRUCT *) _state.value .detrender.value .var ; ref.value .var *= adjustedPrevPeriod; } ;
         { struct TA_MAMA_HILBERT_STRUCT * ref; ref = (struct TA_MAMA_HILBERT_STRUCT *) _state.value .jI; hilbertTempReal = _state.value .a * _state.value .I1ForOddPrev3; ref.value .var = - ref.value ._Odd [ _state.value .hilbertIdx]; ref.value ._Odd [ _state.value .hilbertIdx] = hilbertTempReal; ref.value .var += hilbertTempReal; ref.value .var -= ref.value .prev_Odd ; ref.value .prev_Odd = _state.value .b * ref.value .prev_input_Odd ; ref.value .var += ref.value .prev_Odd ; ref.value .prev_input_Odd = _state.value .I1ForOddPrev3; ref.value .var *= adjustedPrevPeriod; } ;
         { struct TA_MAMA_HILBERT_STRUCT * ref; ref = (struct TA_MAMA_HILBERT_STRUCT *) _state.value .jQ; hilbertTempReal = _state.value .a * (struct TA_MAMA_HILBERT_STRUCT *) _state.value .Q1.value .var ; ref.value .var = - ref.value ._Odd [ _state.value .hilbertIdx]; ref.value ._Odd [ _state.value .hilbertIdx] = hilbertTempReal; ref.value .var += hilbertTempReal; ref.value .var -= ref.value .prev_Odd ; ref.value .prev_Odd = _state.value .b * ref.value .prev_input_Odd ; ref.value .var += ref.value .prev_Odd ; ref.value .prev_input_Odd = (struct TA_MAMA_HILBERT_STRUCT *) _state.value .Q1.value .var ; ref.value .var *= adjustedPrevPeriod; } ;
         Q2 = (0.2*( (struct TA_MAMA_HILBERT_STRUCT *) _state.value .Q1.value .var + (struct TA_MAMA_HILBERT_STRUCT *) _state.value .jI.value .var )) + (0.8* _state.value .prevQ2);
         I2 = (0.2*( _state.value .I1ForOddPrev3 - (struct TA_MAMA_HILBERT_STRUCT *) _state.value .jQ.value .var )) + (0.8* _state.value .prevI2);
         _state.value .I1ForEvenPrev3 = _state.value .I1ForEvenPrev2;
         _state.value .I1ForEvenPrev2 = (struct TA_MAMA_HILBERT_STRUCT *) _state.value .detrender.value .var ;
         if( _state.value .I1ForOddPrev3 != 0.0 )
            tempReal2 = ( Math.atan ( (struct TA_MAMA_HILBERT_STRUCT *) _state.value .Q1.value .var / _state.value .I1ForOddPrev3)* _state.value .rad2Deg);
         else
            tempReal2 = 0.0;
      }
      tempReal = _state.value .prevPhase - tempReal2;
      _state.value .prevPhase = tempReal2;
      if( tempReal < 1.0 )
         tempReal = 1.0;
      if( tempReal > 1.0 )
      {
         tempReal = _state.value .optInFastLimit/tempReal;
         if( tempReal < _state.value .optInSlowLimit )
            tempReal = _state.value .optInSlowLimit;
      }
      else
      {
         tempReal = _state.value .optInFastLimit;
      }
      _state.value .mama = (tempReal*inReal)+((1-tempReal)* _state.value .mama);
      tempReal *= 0.5;
      _state.value .fama = (tempReal* _state.value .mama)+((1-tempReal)* _state.value .fama);
      if (!( _state.value .mem_size > _state.value .mem_index - 1 ))
      {
         outMAMA.value = _state.value .mama;
         outFAMA.value = _state.value .fama;
      }
      _state.value .Re = (0.2*((I2* _state.value .prevI2)+(Q2* _state.value .prevQ2)))+(0.8* _state.value .Re);
      _state.value .Im = (0.2*((I2* _state.value .prevQ2)-(Q2* _state.value .prevI2)))+(0.8* _state.value .Im);
      _state.value .prevQ2 = Q2;
      _state.value .prevI2 = I2;
      tempReal = _state.value .period;
      if( ( _state.value .Im != 0.0) && ( _state.value .Re != 0.0) )
         _state.value .period = 360.0 / ( Math.atan ( _state.value .Im/ _state.value .Re)* _state.value .rad2Deg);
      tempReal2 = 1.5*tempReal;
      if( _state.value .period > tempReal2)
         _state.value .period = tempReal2;
      tempReal2 = 0.67*tempReal;
      if( _state.value .period < tempReal2 )
         _state.value .period = tempReal2;
      if( _state.value .period < 6 )
         _state.value .period = 6;
      else if( _state.value .period > 50 )
         _state.value .period = 50;
      _state.value .period = (0.2* _state.value .period) + (0.8 * tempReal);
      ( _state.value .memory+_cur_idx).value .inReal = inReal ;
      if ( _state.value .mem_size > _state.value .mem_index - 1 )
         return RetCode.NeedMoreData ;
      else
         return RetCode.Success ;
   }
   public int mamaStateFree( struct TA_mama_State** _state )
   {
      { if ( _state.value .value .detrender != NULL) { free ( _state.value .value .detrender); _state.value .value .detrender = NULL; } } ;
      { if ( _state.value .value .Q1 != NULL) { free ( _state.value .value .Q1); _state.value .value .Q1 = NULL; } } ;
      { if ( _state.value .value .jI != NULL) { free ( _state.value .value .jI); _state.value .value .jI = NULL; } } ;
      { if ( _state.value .value .jQ != NULL) { free ( _state.value .value .jQ); _state.value .value .jQ = NULL; } } ;
      if (_state == NULL)
         return RetCode.BadParam ;
      if ( _state.value != NULL) {
         if ( _state.value .value .memory != NULL) TA_Free( _state.value .value .memory );
         TA_Free( _state.value ); _state.value = NULL;}
      return RetCode.Success ;
   }
   public RetCode mama( int startIdx,
      int endIdx,
      float inReal[],
      double optInFastLimit,
      double optInSlowLimit,
      MInteger outBegIdx,
      MInteger outNBElement,
      double outMAMA[],
      double outFAMA[] )
   {
      int outIdx, i;
      int lookbackTotal, today;
      double tempReal, tempReal2;
      double adjustedPrevPeriod, period;
      int trailingWMAIdx;
      double periodWMASum, periodWMASub, trailingWMAValue;
      double smoothedValue;
      final double a = 0.0962;
      final double b = 0.5769;
      double hilbertTempReal;
      int hilbertIdx;
      double []detrender_Odd = new double[3] ; double []detrender_Even = new double[3] ; double detrender; double prev_detrender_Odd ; double prev_detrender_Even ; double prev_detrender_input_Odd ; double prev_detrender_input_Even ;
      double []Q1_Odd = new double[3] ; double []Q1_Even = new double[3] ; double Q1; double prev_Q1_Odd ; double prev_Q1_Even ; double prev_Q1_input_Odd ; double prev_Q1_input_Even ;
      double []jI_Odd = new double[3] ; double []jI_Even = new double[3] ; double jI; double prev_jI_Odd ; double prev_jI_Even ; double prev_jI_input_Odd ; double prev_jI_input_Even ;
      double []jQ_Odd = new double[3] ; double []jQ_Even = new double[3] ; double jQ; double prev_jQ_Odd ; double prev_jQ_Even ; double prev_jQ_input_Odd ; double prev_jQ_input_Even ;
      double Q2, I2, prevQ2, prevI2, Re, Im;
      double I1ForOddPrev2, I1ForOddPrev3;
      double I1ForEvenPrev2, I1ForEvenPrev3;
      double rad2Deg;
      double mama,fama,todayValue,prevPhase;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      if( optInFastLimit == (-4e+37) )
         optInFastLimit = 5.000000e-1;
      else if( (optInFastLimit < 1.000000e-2) || (optInFastLimit > 9.900000e-1) )
         return RetCode.BadParam ;
      if( optInSlowLimit == (-4e+37) )
         optInSlowLimit = 5.000000e-2;
      else if( (optInSlowLimit < 1.000000e-2) || (optInSlowLimit > 9.900000e-1) )
         return RetCode.BadParam ;
      rad2Deg = 180.0 / (4.0 * Math.atan (1));
      lookbackTotal = 32 + (this.unstablePeriod[FuncUnstId.Mama.ordinal()]) ;
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      outBegIdx.value = startIdx;
      trailingWMAIdx = startIdx - lookbackTotal;
      today = trailingWMAIdx;
      tempReal = inReal[today++];
      periodWMASub = tempReal;
      periodWMASum = tempReal;
      tempReal = inReal[today++];
      periodWMASub += tempReal;
      periodWMASum += tempReal*2.0;
      tempReal = inReal[today++];
      periodWMASub += tempReal;
      periodWMASum += tempReal*3.0;
      trailingWMAValue = 0.0;
      i = 9;
      do
      {
         tempReal = inReal[today++];
         { periodWMASub += tempReal; periodWMASub -= trailingWMAValue; periodWMASum += tempReal*4.0; trailingWMAValue = inReal[trailingWMAIdx++]; smoothedValue = periodWMASum*0.1; periodWMASum -= periodWMASub; } ;
      } while( --i != 0);
      hilbertIdx = 0;
      { detrender_Odd [0] = 0.0; detrender_Odd [1] = 0.0; detrender_Odd [2] = 0.0; detrender_Even [0] = 0.0; detrender_Even [1] = 0.0; detrender_Even [2] = 0.0; detrender = 0.0; prev_detrender_Odd = 0.0; prev_detrender_Even = 0.0; prev_detrender_input_Odd = 0.0; prev_detrender_input_Even = 0.0; } ;
      { Q1_Odd [0] = 0.0; Q1_Odd [1] = 0.0; Q1_Odd [2] = 0.0; Q1_Even [0] = 0.0; Q1_Even [1] = 0.0; Q1_Even [2] = 0.0; Q1 = 0.0; prev_Q1_Odd = 0.0; prev_Q1_Even = 0.0; prev_Q1_input_Odd = 0.0; prev_Q1_input_Even = 0.0; } ;
      { jI_Odd [0] = 0.0; jI_Odd [1] = 0.0; jI_Odd [2] = 0.0; jI_Even [0] = 0.0; jI_Even [1] = 0.0; jI_Even [2] = 0.0; jI = 0.0; prev_jI_Odd = 0.0; prev_jI_Even = 0.0; prev_jI_input_Odd = 0.0; prev_jI_input_Even = 0.0; } ;
      { jQ_Odd [0] = 0.0; jQ_Odd [1] = 0.0; jQ_Odd [2] = 0.0; jQ_Even [0] = 0.0; jQ_Even [1] = 0.0; jQ_Even [2] = 0.0; jQ = 0.0; prev_jQ_Odd = 0.0; prev_jQ_Even = 0.0; prev_jQ_input_Odd = 0.0; prev_jQ_input_Even = 0.0; } ;
      period = 0.0;
      outIdx = 0;
      prevI2 = prevQ2 = 0.0;
      Re = Im = 0.0;
      mama = fama = 0.0;
      I1ForOddPrev3 = I1ForEvenPrev3 = 0.0;
      I1ForOddPrev2 = I1ForEvenPrev2 = 0.0;
      prevPhase = 0.0;
      while( today <= endIdx )
      {
         adjustedPrevPeriod = (0.075*period)+0.54;
         todayValue = inReal[today];
         { periodWMASub += todayValue; periodWMASub -= trailingWMAValue; periodWMASum += todayValue*4.0; trailingWMAValue = inReal[trailingWMAIdx++]; smoothedValue = periodWMASum*0.1; periodWMASum -= periodWMASub; } ;
         if( (today%2) == 0 )
         {
            { hilbertTempReal = a * smoothedValue; detrender = -detrender_Even [hilbertIdx]; detrender_Even [hilbertIdx] = hilbertTempReal; detrender += hilbertTempReal; detrender -= prev_detrender_Even ; prev_detrender_Even = b * prev_detrender_input_Even ; detrender += prev_detrender_Even ; prev_detrender_input_Even = smoothedValue; detrender *= adjustedPrevPeriod; } ;
            { hilbertTempReal = a * detrender; Q1 = -Q1_Even [hilbertIdx]; Q1_Even [hilbertIdx] = hilbertTempReal; Q1 += hilbertTempReal; Q1 -= prev_Q1_Even ; prev_Q1_Even = b * prev_Q1_input_Even ; Q1 += prev_Q1_Even ; prev_Q1_input_Even = detrender; Q1 *= adjustedPrevPeriod; } ;
            { hilbertTempReal = a * I1ForEvenPrev3; jI = -jI_Even [hilbertIdx]; jI_Even [hilbertIdx] = hilbertTempReal; jI += hilbertTempReal; jI -= prev_jI_Even ; prev_jI_Even = b * prev_jI_input_Even ; jI += prev_jI_Even ; prev_jI_input_Even = I1ForEvenPrev3; jI *= adjustedPrevPeriod; } ;
            { hilbertTempReal = a * Q1; jQ = -jQ_Even [hilbertIdx]; jQ_Even [hilbertIdx] = hilbertTempReal; jQ += hilbertTempReal; jQ -= prev_jQ_Even ; prev_jQ_Even = b * prev_jQ_input_Even ; jQ += prev_jQ_Even ; prev_jQ_input_Even = Q1; jQ *= adjustedPrevPeriod; } ;
            if( ++hilbertIdx == 3 )
               hilbertIdx = 0;
            Q2 = (0.2*(Q1 + jI)) + (0.8*prevQ2);
            I2 = (0.2*(I1ForEvenPrev3 - jQ)) + (0.8*prevI2);
            I1ForOddPrev3 = I1ForOddPrev2;
            I1ForOddPrev2 = detrender;
            if( I1ForEvenPrev3 != 0.0 )
               tempReal2 = ( Math.atan (Q1/I1ForEvenPrev3)*rad2Deg);
            else
               tempReal2 = 0.0;
         }
         else
         {
            { hilbertTempReal = a * smoothedValue; detrender = -detrender_Odd [hilbertIdx]; detrender_Odd [hilbertIdx] = hilbertTempReal; detrender += hilbertTempReal; detrender -= prev_detrender_Odd ; prev_detrender_Odd = b * prev_detrender_input_Odd ; detrender += prev_detrender_Odd ; prev_detrender_input_Odd = smoothedValue; detrender *= adjustedPrevPeriod; } ;
            { hilbertTempReal = a * detrender; Q1 = -Q1_Odd [hilbertIdx]; Q1_Odd [hilbertIdx] = hilbertTempReal; Q1 += hilbertTempReal; Q1 -= prev_Q1_Odd ; prev_Q1_Odd = b * prev_Q1_input_Odd ; Q1 += prev_Q1_Odd ; prev_Q1_input_Odd = detrender; Q1 *= adjustedPrevPeriod; } ;
            { hilbertTempReal = a * I1ForOddPrev3; jI = -jI_Odd [hilbertIdx]; jI_Odd [hilbertIdx] = hilbertTempReal; jI += hilbertTempReal; jI -= prev_jI_Odd ; prev_jI_Odd = b * prev_jI_input_Odd ; jI += prev_jI_Odd ; prev_jI_input_Odd = I1ForOddPrev3; jI *= adjustedPrevPeriod; } ;
            { hilbertTempReal = a * Q1; jQ = -jQ_Odd [hilbertIdx]; jQ_Odd [hilbertIdx] = hilbertTempReal; jQ += hilbertTempReal; jQ -= prev_jQ_Odd ; prev_jQ_Odd = b * prev_jQ_input_Odd ; jQ += prev_jQ_Odd ; prev_jQ_input_Odd = Q1; jQ *= adjustedPrevPeriod; } ;
            Q2 = (0.2*(Q1 + jI)) + (0.8*prevQ2);
            I2 = (0.2*(I1ForOddPrev3 - jQ)) + (0.8*prevI2);
            I1ForEvenPrev3 = I1ForEvenPrev2;
            I1ForEvenPrev2 = detrender;
            if( I1ForOddPrev3 != 0.0 )
               tempReal2 = ( Math.atan (Q1/I1ForOddPrev3)*rad2Deg);
            else
               tempReal2 = 0.0;
         }
         tempReal = prevPhase - tempReal2;
         prevPhase = tempReal2;
         if( tempReal < 1.0 )
            tempReal = 1.0;
         if( tempReal > 1.0 )
         {
            tempReal = optInFastLimit/tempReal;
            if( tempReal < optInSlowLimit )
               tempReal = optInSlowLimit;
         }
         else
         {
            tempReal = optInFastLimit;
         }
         mama = (tempReal*todayValue)+((1-tempReal)*mama);
         tempReal *= 0.5;
         fama = (tempReal*mama)+((1-tempReal)*fama);
         if( today >= startIdx )
         {
            outMAMA[outIdx] = mama;
            outFAMA[outIdx++] = fama;
         }
         Re = (0.2*((I2*prevI2)+(Q2*prevQ2)))+(0.8*Re);
         Im = (0.2*((I2*prevQ2)-(Q2*prevI2)))+(0.8*Im);
         prevQ2 = Q2;
         prevI2 = I2;
         tempReal = period;
         if( (Im != 0.0) && (Re != 0.0) )
            period = 360.0 / ( Math.atan (Im/Re)*rad2Deg);
         tempReal2 = 1.5*tempReal;
         if( period > tempReal2)
            period = tempReal2;
         tempReal2 = 0.67*tempReal;
         if( period < tempReal2 )
            period = tempReal2;
         if( period < 6 )
            period = 6;
         else if( period > 50 )
            period = 50;
         period = (0.2*period) + (0.8 * tempReal);
         today++;
      }
      outNBElement.value = outIdx;
      return RetCode.Success ;
   }
   /* Generated */
   public int movingAverageVariablePeriodLookback( int optInMinPeriod,
      int optInMaxPeriod,
      MAType optInMAType )
   {
      if( (int)optInMinPeriod == ( Integer.MIN_VALUE ) )
         optInMinPeriod = 2;
      else if( ((int)optInMinPeriod < 2) || ((int)optInMinPeriod > 100000) )
         return -1;
      if( (int)optInMaxPeriod == ( Integer.MIN_VALUE ) )
         optInMaxPeriod = 30;
      else if( ((int)optInMaxPeriod < 2) || ((int)optInMaxPeriod > 100000) )
         return -1;
      return movingAverageLookback (optInMaxPeriod, optInMAType);
   }
   public RetCode movingAverageVariablePeriod( int startIdx,
      int endIdx,
      double inReal[],
      double inPeriods[],
      int optInMinPeriod,
      int optInMaxPeriod,
      MAType optInMAType, MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      int i, j, lookbackTotal, outputSize, tempInt, curPeriod;
      int []localPeriodArray ;
      double []localOutputArray ;
      MInteger localBegIdx = new MInteger() ;
      MInteger localNbElement = new MInteger() ;
      RetCode retCode;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      if( (int)optInMinPeriod == ( Integer.MIN_VALUE ) )
         optInMinPeriod = 2;
      else if( ((int)optInMinPeriod < 2) || ((int)optInMinPeriod > 100000) )
         return RetCode.BadParam ;
      if( (int)optInMaxPeriod == ( Integer.MIN_VALUE ) )
         optInMaxPeriod = 30;
      else if( ((int)optInMaxPeriod < 2) || ((int)optInMaxPeriod > 100000) )
         return RetCode.BadParam ;
      lookbackTotal = movingAverageLookback (optInMaxPeriod,optInMAType);
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      if( lookbackTotal > startIdx )
         tempInt = lookbackTotal;
      else
         tempInt = startIdx;
      if( tempInt > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      outputSize = endIdx - tempInt + 1;
      localOutputArray = new double[outputSize] ;
      localPeriodArray = new int[outputSize] ;
      for( i=0; i < outputSize; i++ )
      {
         tempInt = (int)(inPeriods[startIdx+i]);
         if( tempInt < optInMinPeriod )
            tempInt = optInMinPeriod;
         else if( tempInt > optInMaxPeriod )
            tempInt = optInMaxPeriod;
         localPeriodArray[i] = tempInt;
      }
      for( i=0; i < outputSize; i++ )
      {
         curPeriod = localPeriodArray[i];
         if( curPeriod != 0 )
         {
            retCode = movingAverage ( startIdx, endIdx, inReal,
               curPeriod, optInMAType,
               localBegIdx , localNbElement ,localOutputArray );
            if( retCode != RetCode.Success )
            {
               outBegIdx.value = 0 ;
               outNBElement.value = 0 ;
               return retCode;
            }
            outReal[i] = localOutputArray[i];
            for( j=i+1; j < outputSize; j++ )
            {
               if( localPeriodArray[j] == curPeriod )
               {
                  localPeriodArray[j] = 0;
                  outReal[j] = localOutputArray[j];
               }
            }
         }
      }
      outBegIdx.value = startIdx;
      outNBElement.value = outputSize;
      return RetCode.Success ;
   }
   public int movingAverageVariablePeriodStateInit( struct TA_movingAverageVariablePeriod_State** _state,
      int optInMinPeriod,
      int optInMaxPeriod,
      MAType optInMAType )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if( (int)optInMinPeriod == ( Integer.MIN_VALUE ) )
         optInMinPeriod = 2;
      else if( ((int)optInMinPeriod < 2) || ((int)optInMinPeriod > 100000) )
         return RetCode.BadParam ;
      if( (int)optInMaxPeriod == ( Integer.MIN_VALUE ) )
         optInMaxPeriod = 30;
      else if( ((int)optInMaxPeriod < 2) || ((int)optInMaxPeriod > 100000) )
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct movingAverageVariablePeriod ));
      _state.value .value .mem_index = 0;
      _state.value .value .optInMinPeriod = optInMinPeriod;
      _state.value .value .optInMaxPeriod = optInMaxPeriod;
      _state.value .value .optInMAType = optInMAType;
      _state.value .value .mem_size = movingAverageVariablePeriodLookback (optInMinPeriod, optInMaxPeriod, optInMAType );
      if ( _state.value .value .mem_size > 0)
         _state.value .value .memory = TA_Calloc( _state.value .value .mem_size , sizeof(struct TA_MAVP_Data));
      else
         _state.value .value .memory = NULL;
      return RetCode.Success ;
   }
   public int movingAverageVariablePeriodState( struct TA_movingAverageVariablePeriod_State* _state,
      double inReal,
      double inPeriods,
      double *outReal )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      size_t _cur_idx = _state.value .mem_index++;
      if ( _state.value .mem_size > 0) _cur_idx %= _state.value .mem_size ;
      if ( _state.value .mem_size > _state.value .mem_index - 1 ) {
         ( _state.value .memory+_cur_idx).value .inReal = inReal ;
         ( _state.value .memory+_cur_idx).value .inPeriods = inPeriods ;
         return RetCode.NeedMoreData ; }
      return RetCode.Success ;
   }
   public int movingAverageVariablePeriodStateFree( struct TA_movingAverageVariablePeriod_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if ( _state.value != NULL) {
         if ( _state.value .value .memory != NULL) TA_Free( _state.value .value .memory );
         TA_Free( _state.value ); _state.value = NULL;}
      return RetCode.Success ;
   }
   public RetCode movingAverageVariablePeriod( int startIdx,
      int endIdx,
      float inReal[],
      float inPeriods[],
      int optInMinPeriod,
      int optInMaxPeriod,
      MAType optInMAType, MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      int i, j, lookbackTotal, outputSize, tempInt, curPeriod;
      int []localPeriodArray ;
      double []localOutputArray ;
      MInteger localBegIdx = new MInteger() ;
      MInteger localNbElement = new MInteger() ;
      RetCode retCode;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      if( (int)optInMinPeriod == ( Integer.MIN_VALUE ) )
         optInMinPeriod = 2;
      else if( ((int)optInMinPeriod < 2) || ((int)optInMinPeriod > 100000) )
         return RetCode.BadParam ;
      if( (int)optInMaxPeriod == ( Integer.MIN_VALUE ) )
         optInMaxPeriod = 30;
      else if( ((int)optInMaxPeriod < 2) || ((int)optInMaxPeriod > 100000) )
         return RetCode.BadParam ;
      lookbackTotal = movingAverageLookback (optInMaxPeriod,optInMAType);
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      if( lookbackTotal > startIdx )
         tempInt = lookbackTotal;
      else
         tempInt = startIdx;
      if( tempInt > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      outputSize = endIdx - tempInt + 1;
      localOutputArray = new double[outputSize] ;
      localPeriodArray = new int[outputSize] ;
      for( i=0; i < outputSize; i++ )
      {
         tempInt = (int)(inPeriods[startIdx+i]);
         if( tempInt < optInMinPeriod )
            tempInt = optInMinPeriod;
         else if( tempInt > optInMaxPeriod )
            tempInt = optInMaxPeriod;
         localPeriodArray[i] = tempInt;
      }
      for( i=0; i < outputSize; i++ )
      {
         curPeriod = localPeriodArray[i];
         if( curPeriod != 0 )
         {
            retCode = movingAverage ( startIdx, endIdx, inReal,
               curPeriod, optInMAType,
               localBegIdx , localNbElement ,localOutputArray );
            if( retCode != RetCode.Success )
            {
               outBegIdx.value = 0 ;
               outNBElement.value = 0 ;
               return retCode;
            }
            outReal[i] = localOutputArray[i];
            for( j=i+1; j < outputSize; j++ )
            {
               if( localPeriodArray[j] == curPeriod )
               {
                  localPeriodArray[j] = 0;
                  outReal[j] = localOutputArray[j];
               }
            }
         }
      }
      outBegIdx.value = startIdx;
      outNBElement.value = outputSize;
      return RetCode.Success ;
   }
   /* Generated */
   public int maxLookback( int optInTimePeriod )
   {
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 30;
      else if( ((int)optInTimePeriod < 2) || ((int)optInTimePeriod > 100000) )
         return -1;
      return (optInTimePeriod-1);
   }
   public RetCode max( int startIdx,
      int endIdx,
      double inReal[],
      int optInTimePeriod,
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      double highest, tmp;
      int outIdx, nbInitialElementNeeded;
      int trailingIdx, today, i, highestIdx;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 30;
      else if( ((int)optInTimePeriod < 2) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      nbInitialElementNeeded = (optInTimePeriod-1);
      if( startIdx < nbInitialElementNeeded )
         startIdx = nbInitialElementNeeded;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      outIdx = 0;
      today = startIdx;
      trailingIdx = startIdx-nbInitialElementNeeded;
      highestIdx = -1;
      highest = 0.0;
      while( today <= endIdx )
      {
         tmp = inReal[today];
         if( highestIdx < trailingIdx )
         {
            highestIdx = trailingIdx;
            highest = inReal[highestIdx];
            i = highestIdx;
            while( ++i<=today )
            {
               tmp = inReal[i];
               if( tmp > highest )
               {
                  highestIdx = i;
                  highest = tmp;
               }
            }
         }
         else if( tmp >= highest )
         {
            highestIdx = today;
            highest = tmp;
         }
         outReal[outIdx++] = highest;
         trailingIdx++;
         today++;
      }
      outBegIdx.value = startIdx;
      outNBElement.value = outIdx;
      return RetCode.Success ;
   }
   public int maxStateInit( struct TA_max_State** _state,
      int optInTimePeriod )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 30;
      else if( ((int)optInTimePeriod < 2) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct max ));
      _state.value .value .mem_index = 0;
      _state.value .value .optInTimePeriod = optInTimePeriod;
      _state.value .value .mem_size = maxLookback (optInTimePeriod );
      _state.value .value .memory = NULL;
      return RetCode.Success ;
   }
   public int maxState( struct TA_max_State* _state,
      double inReal,
      double *outReal )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      size_t _cur_idx = _state.value .mem_index++;
      if ( _state.value .mem_size > 0) _cur_idx %= _state.value .mem_size ;
      if ( ( _state.value .mem_index == 1) )
         _state.value .max = inReal;
      else
         if( _state.value .max < inReal )
         _state.value .max = inReal;
      if ( _state.value .mem_size > _state.value .mem_index - 1 ) return RetCode.NeedMoreData ;
      outReal.value = _state.value .max;
      return RetCode.Success ;
   }
   public int maxStateFree( struct TA_max_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if ( _state.value != NULL) {
         if ( _state.value .value .memory != NULL) TA_Free( _state.value .value .memory );
         TA_Free( _state.value ); _state.value = NULL;}
      return RetCode.Success ;
   }
   public RetCode max( int startIdx,
      int endIdx,
      float inReal[],
      int optInTimePeriod,
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      double highest, tmp;
      int outIdx, nbInitialElementNeeded;
      int trailingIdx, today, i, highestIdx;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 30;
      else if( ((int)optInTimePeriod < 2) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      nbInitialElementNeeded = (optInTimePeriod-1);
      if( startIdx < nbInitialElementNeeded )
         startIdx = nbInitialElementNeeded;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      outIdx = 0;
      today = startIdx;
      trailingIdx = startIdx-nbInitialElementNeeded;
      highestIdx = -1;
      highest = 0.0;
      while( today <= endIdx )
      {
         tmp = inReal[today];
         if( highestIdx < trailingIdx )
         {
            highestIdx = trailingIdx;
            highest = inReal[highestIdx];
            i = highestIdx;
            while( ++i<=today )
            {
               tmp = inReal[i];
               if( tmp > highest )
               {
                  highestIdx = i;
                  highest = tmp;
               }
            }
         }
         else if( tmp >= highest )
         {
            highestIdx = today;
            highest = tmp;
         }
         outReal[outIdx++] = highest;
         trailingIdx++;
         today++;
      }
      outBegIdx.value = startIdx;
      outNBElement.value = outIdx;
      return RetCode.Success ;
   }
   /* Generated */
   public int maxIndexLookback( int optInTimePeriod )
   {
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 30;
      else if( ((int)optInTimePeriod < 2) || ((int)optInTimePeriod > 100000) )
         return -1;
      return (optInTimePeriod-1);
   }
   public RetCode maxIndex( int startIdx,
      int endIdx,
      double inReal[],
      int optInTimePeriod,
      MInteger outBegIdx,
      MInteger outNBElement,
      int outInteger[] )
   {
      double highest, tmp;
      int outIdx, nbInitialElementNeeded;
      int trailingIdx, today, i, highestIdx;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 30;
      else if( ((int)optInTimePeriod < 2) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      nbInitialElementNeeded = (optInTimePeriod-1);
      if( startIdx < nbInitialElementNeeded )
         startIdx = nbInitialElementNeeded;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      outIdx = 0;
      today = startIdx;
      trailingIdx = startIdx-nbInitialElementNeeded;
      highestIdx = -1;
      highest = 0.0;
      while( today <= endIdx )
      {
         tmp = inReal[today];
         if( highestIdx < trailingIdx )
         {
            highestIdx = trailingIdx;
            highest = inReal[highestIdx];
            i = highestIdx;
            while( ++i<=today )
            {
               tmp = inReal[i];
               if( tmp > highest )
               {
                  highestIdx = i;
                  highest = tmp;
               }
            }
         }
         else if( tmp >= highest )
         {
            highestIdx = today;
            highest = tmp;
         }
         outInteger[outIdx++] = highestIdx;
         trailingIdx++;
         today++;
      }
      outBegIdx.value = startIdx;
      outNBElement.value = outIdx;
      return RetCode.Success ;
   }
   public int maxIndexStateInit( struct TA_maxIndex_State** _state,
      int optInTimePeriod )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 30;
      else if( ((int)optInTimePeriod < 2) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct maxIndex ));
      _state.value .value .mem_index = 0;
      _state.value .value .optInTimePeriod = optInTimePeriod;
      _state.value .value .mem_size = maxIndexLookback (optInTimePeriod );
      _state.value .value .memory = NULL;
      return RetCode.Success ;
   }
   public int maxIndexState( struct TA_maxIndex_State* _state,
      double inReal,
      int *outInteger )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      size_t _cur_idx = _state.value .mem_index++;
      if ( _state.value .mem_size > 0) _cur_idx %= _state.value .mem_size ;
      if ( ( _state.value .mem_index == 1) )
      {
         _state.value .max = inReal;
         _state.value .maxIdx = 0;
         _state.value .currentIdx = 0;
      } else
         ++ _state.value .currentIdx;
      if( _state.value .max < inReal )
      {
         _state.value .max = inReal;
         _state.value .maxIdx = _state.value .currentIdx;
      } else
         if( _state.value .max == inReal )
         _state.value .maxIdx = _state.value .currentIdx;
      if ( _state.value .mem_size > _state.value .mem_index - 1 ) return RetCode.NeedMoreData ;
      outInteger.value = _state.value .max;
      return RetCode.Success ;
   }
   public int maxIndexStateFree( struct TA_maxIndex_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if ( _state.value != NULL) {
         if ( _state.value .value .memory != NULL) TA_Free( _state.value .value .memory );
         TA_Free( _state.value ); _state.value = NULL;}
      return RetCode.Success ;
   }
   public RetCode maxIndex( int startIdx,
      int endIdx,
      float inReal[],
      int optInTimePeriod,
      MInteger outBegIdx,
      MInteger outNBElement,
      int outInteger[] )
   {
      double highest, tmp;
      int outIdx, nbInitialElementNeeded;
      int trailingIdx, today, i, highestIdx;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 30;
      else if( ((int)optInTimePeriod < 2) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      nbInitialElementNeeded = (optInTimePeriod-1);
      if( startIdx < nbInitialElementNeeded )
         startIdx = nbInitialElementNeeded;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      outIdx = 0;
      today = startIdx;
      trailingIdx = startIdx-nbInitialElementNeeded;
      highestIdx = -1;
      highest = 0.0;
      while( today <= endIdx )
      {
         tmp = inReal[today];
         if( highestIdx < trailingIdx )
         {
            highestIdx = trailingIdx;
            highest = inReal[highestIdx];
            i = highestIdx;
            while( ++i<=today )
            {
               tmp = inReal[i];
               if( tmp > highest )
               {
                  highestIdx = i;
                  highest = tmp;
               }
            }
         }
         else if( tmp >= highest )
         {
            highestIdx = today;
            highest = tmp;
         }
         outInteger[outIdx++] = highestIdx;
         trailingIdx++;
         today++;
      }
      outBegIdx.value = startIdx;
      outNBElement.value = outIdx;
      return RetCode.Success ;
   }
   /* Generated */
   public int medPriceLookback( )
   {
      return RetCode.Success ;
   }
   public RetCode medPrice( int startIdx,
      int endIdx,
      double inHigh[],
      double inLow[],
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      int outIdx, i;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      outIdx = 0;
      for( i=startIdx; i <= endIdx; i++ )
      {
         outReal[outIdx++] = (inHigh[i]+inLow[i])/2.0;
      }
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   public int medPriceStateInit( struct TA_medPrice_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct medPrice ));
      _state.value .value .mem_index = 0;
      _state.value .value .mem_size = medPriceLookback ();
      if ( _state.value .value .mem_size > 0)
         _state.value .value .memory = TA_Calloc( _state.value .value .mem_size , sizeof(struct TA_MEDPRICE_Data));
      else
         _state.value .value .memory = NULL;
      return RetCode.Success ;
   }
   public int medPriceState( struct TA_medPrice_State* _state,
      double inHigh,
      double inLow,
      double *outReal )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      size_t _cur_idx = _state.value .mem_index++;
      if ( _state.value .mem_size > 0) _cur_idx %= _state.value .mem_size ;
      if ( _state.value .mem_size > _state.value .mem_index - 1 ) {
         ( _state.value .memory+_cur_idx).value .inHigh = inHigh ;
         ( _state.value .memory+_cur_idx).value .inLow = inLow ;
         return RetCode.NeedMoreData ; }
      outReal.value = (inHigh+inLow)/2.0;
      return RetCode.Success ;
   }
   public int medPriceStateFree( struct TA_medPrice_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if ( _state.value != NULL) {
         if ( _state.value .value .memory != NULL) TA_Free( _state.value .value .memory );
         TA_Free( _state.value ); _state.value = NULL;}
      return RetCode.Success ;
   }
   public RetCode medPrice( int startIdx,
      int endIdx,
      float inHigh[],
      float inLow[],
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      int outIdx, i;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      outIdx = 0;
      for( i=startIdx; i <= endIdx; i++ )
      {
         outReal[outIdx++] = (inHigh[i]+inLow[i])/2.0;
      }
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   /* Generated */
   public int mfiLookback( int optInTimePeriod )
   {
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 14;
      else if( ((int)optInTimePeriod < 2) || ((int)optInTimePeriod > 100000) )
         return -1;
      return optInTimePeriod + (this.unstablePeriod[FuncUnstId.Mfi.ordinal()]) ;
   }
   public RetCode mfi( int startIdx,
      int endIdx,
      double inHigh[],
      double inLow[],
      double inClose[],
      double inVolume[],
      int optInTimePeriod,
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      double posSumMF, negSumMF, prevValue;
      double tempValue1, tempValue2;
      int lookbackTotal, outIdx, i, today;
      int mflow_Idx = 0; MoneyFlow []mflow; int maxIdx_mflow = (50-1) ;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 14;
      else if( ((int)optInTimePeriod < 2) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      { if( optInTimePeriod <= 0 ) return RetCode.AllocErr ; mflow = new MoneyFlow[optInTimePeriod]; for( int _mflow_index =0; _mflow_index <mflow.length; _mflow_index ++) { mflow[_mflow_index ]=new MoneyFlow(); } maxIdx_mflow = (optInTimePeriod-1); } ;
      outBegIdx.value = 0 ;
      outNBElement.value = 0 ;
      lookbackTotal = optInTimePeriod + (this.unstablePeriod[FuncUnstId.Mfi.ordinal()]) ;
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         return RetCode.Success ;
      }
      outIdx = 0;
      today = startIdx-lookbackTotal;
      prevValue = (inHigh[today]+inLow[today]+inClose[today])/3.0;
      posSumMF = 0.0;
      negSumMF = 0.0;
      today++;
      for( i=optInTimePeriod; i > 0; i-- )
      {
         tempValue1 = (inHigh[today]+inLow[today]+inClose[today])/3.0;
         tempValue2 = tempValue1 - prevValue;
         prevValue = tempValue1;
         tempValue1 *= inVolume[today++];
         if( tempValue2 < 0 )
         {
            (mflow[mflow_Idx]). negative = tempValue1;
            negSumMF += tempValue1;
            (mflow[mflow_Idx]). positive = 0.0;
         }
         else if( tempValue2 > 0 )
         {
            (mflow[mflow_Idx]). positive = tempValue1;
            posSumMF += tempValue1;
            (mflow[mflow_Idx]). negative = 0.0;
         }
         else
         {
            (mflow[mflow_Idx]). positive = 0.0;
            (mflow[mflow_Idx]). negative = 0.0;
         }
         { mflow_Idx ++; if( mflow_Idx > maxIdx_mflow ) mflow_Idx = 0; } ;
      }
      if( today > startIdx )
      {
         tempValue1 = posSumMF+negSumMF;
         if( tempValue1 < 1.0 )
            outReal[outIdx++] = 0.0;
         else
            outReal[outIdx++] = 100.0*(posSumMF/tempValue1);
      }
      else
      {
         while( today < startIdx )
         {
            posSumMF -= (mflow[mflow_Idx]). positive;
            negSumMF -= (mflow[mflow_Idx]). negative;
            tempValue1 = (inHigh[today]+inLow[today]+inClose[today])/3.0;
            tempValue2 = tempValue1 - prevValue;
            prevValue = tempValue1;
            tempValue1 *= inVolume[today++];
            if( tempValue2 < 0 )
            {
               (mflow[mflow_Idx]). negative = tempValue1;
               negSumMF += tempValue1;
               (mflow[mflow_Idx]). positive = 0.0;
            }
            else if( tempValue2 > 0 )
            {
               (mflow[mflow_Idx]). positive = tempValue1;
               posSumMF += tempValue1;
               (mflow[mflow_Idx]). negative = 0.0;
            }
            else
            {
               (mflow[mflow_Idx]). positive = 0.0;
               (mflow[mflow_Idx]). negative = 0.0;
            }
            { mflow_Idx ++; if( mflow_Idx > maxIdx_mflow ) mflow_Idx = 0; } ;
         }
      }
      while( today <= endIdx )
      {
         posSumMF -= (mflow[mflow_Idx]). positive;
         negSumMF -= (mflow[mflow_Idx]). negative;
         tempValue1 = (inHigh[today]+inLow[today]+inClose[today])/3.0;
         tempValue2 = tempValue1 - prevValue;
         prevValue = tempValue1;
         tempValue1 *= inVolume[today++];
         if( tempValue2 < 0 )
         {
            (mflow[mflow_Idx]). negative = tempValue1;
            negSumMF += tempValue1;
            (mflow[mflow_Idx]). positive = 0.0;
         }
         else if( tempValue2 > 0 )
         {
            (mflow[mflow_Idx]). positive = tempValue1;
            posSumMF += tempValue1;
            (mflow[mflow_Idx]). negative = 0.0;
         }
         else
         {
            (mflow[mflow_Idx]). positive = 0.0;
            (mflow[mflow_Idx]). negative = 0.0;
         }
         tempValue1 = posSumMF+negSumMF;
         if( tempValue1 < 1.0 )
            outReal[outIdx++] = 0.0;
         else
            outReal[outIdx++] = 100.0*(posSumMF/tempValue1);
         { mflow_Idx ++; if( mflow_Idx > maxIdx_mflow ) mflow_Idx = 0; } ;
      }
      outBegIdx.value = startIdx;
      outNBElement.value = outIdx;
      return RetCode.Success ;
   }
   public int mfiStateInit( struct TA_mfi_State** _state,
      int optInTimePeriod )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 14;
      else if( ((int)optInTimePeriod < 2) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct mfi ));
      _state.value .value .mem_index = 0;
      _state.value .value .optInTimePeriod = optInTimePeriod;
      _state.value .value .mem_size = mfiLookback (optInTimePeriod );
      if ( _state.value .value .mem_size > 0)
         _state.value .value .memory = TA_Calloc( _state.value .value .mem_size , sizeof(struct TA_MFI_Data));
      else
         _state.value .value .memory = NULL;
      return RetCode.Success ;
   }
   public int mfiState( struct TA_mfi_State* _state,
      double inHigh,
      double inLow,
      double inClose,
      double inVolume,
      double *outReal )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      size_t _cur_idx = _state.value .mem_index++;
      if ( _state.value .mem_size > 0) _cur_idx %= _state.value .mem_size ;
      if ( _state.value .mem_size > _state.value .mem_index - 1 ) {
         ( _state.value .memory+_cur_idx).value .inHigh = inHigh ;
         ( _state.value .memory+_cur_idx).value .inLow = inLow ;
         ( _state.value .memory+_cur_idx).value .inClose = inClose ;
         ( _state.value .memory+_cur_idx).value .inVolume = inVolume ;
         return RetCode.NeedMoreData ; }
      return RetCode.Success ;
   }
   public int mfiStateFree( struct TA_mfi_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if ( _state.value != NULL) {
         if ( _state.value .value .memory != NULL) TA_Free( _state.value .value .memory );
         TA_Free( _state.value ); _state.value = NULL;}
      return RetCode.Success ;
   }
   public RetCode mfi( int startIdx,
      int endIdx,
      float inHigh[],
      float inLow[],
      float inClose[],
      float inVolume[],
      int optInTimePeriod,
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      double posSumMF, negSumMF, prevValue;
      double tempValue1, tempValue2;
      int lookbackTotal, outIdx, i, today;
      int mflow_Idx = 0; MoneyFlow []mflow; int maxIdx_mflow = (50-1) ;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 14;
      else if( ((int)optInTimePeriod < 2) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      { if( optInTimePeriod <= 0 ) return RetCode.AllocErr ; mflow = new MoneyFlow[optInTimePeriod]; for( int _mflow_index =0; _mflow_index <mflow.length; _mflow_index ++) { mflow[_mflow_index ]=new MoneyFlow(); } maxIdx_mflow = (optInTimePeriod-1); } ;
      outBegIdx.value = 0 ;
      outNBElement.value = 0 ;
      lookbackTotal = optInTimePeriod + (this.unstablePeriod[FuncUnstId.Mfi.ordinal()]) ;
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         return RetCode.Success ;
      }
      outIdx = 0;
      today = startIdx-lookbackTotal;
      prevValue = (inHigh[today]+inLow[today]+inClose[today])/3.0;
      posSumMF = 0.0;
      negSumMF = 0.0;
      today++;
      for( i=optInTimePeriod; i > 0; i-- )
      {
         tempValue1 = (inHigh[today]+inLow[today]+inClose[today])/3.0;
         tempValue2 = tempValue1 - prevValue;
         prevValue = tempValue1;
         tempValue1 *= inVolume[today++];
         if( tempValue2 < 0 )
         {
            (mflow[mflow_Idx]). negative = tempValue1;
            negSumMF += tempValue1;
            (mflow[mflow_Idx]). positive = 0.0;
         }
         else if( tempValue2 > 0 )
         {
            (mflow[mflow_Idx]). positive = tempValue1;
            posSumMF += tempValue1;
            (mflow[mflow_Idx]). negative = 0.0;
         }
         else
         {
            (mflow[mflow_Idx]). positive = 0.0;
            (mflow[mflow_Idx]). negative = 0.0;
         }
         { mflow_Idx ++; if( mflow_Idx > maxIdx_mflow ) mflow_Idx = 0; } ;
      }
      if( today > startIdx )
      {
         tempValue1 = posSumMF+negSumMF;
         if( tempValue1 < 1.0 )
            outReal[outIdx++] = 0.0;
         else
            outReal[outIdx++] = 100.0*(posSumMF/tempValue1);
      }
      else
      {
         while( today < startIdx )
         {
            posSumMF -= (mflow[mflow_Idx]). positive;
            negSumMF -= (mflow[mflow_Idx]). negative;
            tempValue1 = (inHigh[today]+inLow[today]+inClose[today])/3.0;
            tempValue2 = tempValue1 - prevValue;
            prevValue = tempValue1;
            tempValue1 *= inVolume[today++];
            if( tempValue2 < 0 )
            {
               (mflow[mflow_Idx]). negative = tempValue1;
               negSumMF += tempValue1;
               (mflow[mflow_Idx]). positive = 0.0;
            }
            else if( tempValue2 > 0 )
            {
               (mflow[mflow_Idx]). positive = tempValue1;
               posSumMF += tempValue1;
               (mflow[mflow_Idx]). negative = 0.0;
            }
            else
            {
               (mflow[mflow_Idx]). positive = 0.0;
               (mflow[mflow_Idx]). negative = 0.0;
            }
            { mflow_Idx ++; if( mflow_Idx > maxIdx_mflow ) mflow_Idx = 0; } ;
         }
      }
      while( today <= endIdx )
      {
         posSumMF -= (mflow[mflow_Idx]). positive;
         negSumMF -= (mflow[mflow_Idx]). negative;
         tempValue1 = (inHigh[today]+inLow[today]+inClose[today])/3.0;
         tempValue2 = tempValue1 - prevValue;
         prevValue = tempValue1;
         tempValue1 *= inVolume[today++];
         if( tempValue2 < 0 )
         {
            (mflow[mflow_Idx]). negative = tempValue1;
            negSumMF += tempValue1;
            (mflow[mflow_Idx]). positive = 0.0;
         }
         else if( tempValue2 > 0 )
         {
            (mflow[mflow_Idx]). positive = tempValue1;
            posSumMF += tempValue1;
            (mflow[mflow_Idx]). negative = 0.0;
         }
         else
         {
            (mflow[mflow_Idx]). positive = 0.0;
            (mflow[mflow_Idx]). negative = 0.0;
         }
         tempValue1 = posSumMF+negSumMF;
         if( tempValue1 < 1.0 )
            outReal[outIdx++] = 0.0;
         else
            outReal[outIdx++] = 100.0*(posSumMF/tempValue1);
         { mflow_Idx ++; if( mflow_Idx > maxIdx_mflow ) mflow_Idx = 0; } ;
      }
      outBegIdx.value = startIdx;
      outNBElement.value = outIdx;
      return RetCode.Success ;
   }
   /* Generated */
   public int midPointLookback( int optInTimePeriod )
   {
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 14;
      else if( ((int)optInTimePeriod < 2) || ((int)optInTimePeriod > 100000) )
         return -1;
      return (optInTimePeriod-1);
   }
   public RetCode midPoint( int startIdx,
      int endIdx,
      double inReal[],
      int optInTimePeriod,
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      double lowest, highest, tmp;
      int outIdx, nbInitialElementNeeded;
      int trailingIdx, today, i;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 14;
      else if( ((int)optInTimePeriod < 2) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      nbInitialElementNeeded = (optInTimePeriod-1);
      if( startIdx < nbInitialElementNeeded )
         startIdx = nbInitialElementNeeded;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      outIdx = 0;
      today = startIdx;
      trailingIdx = startIdx-nbInitialElementNeeded;
      while( today <= endIdx )
      {
         lowest = inReal[trailingIdx++];
         highest = lowest;
         for( i=trailingIdx; i <= today; i++ )
         {
            tmp = inReal[i];
            if( tmp < lowest ) lowest= tmp;
            else if( tmp > highest) highest = tmp;
         }
         outReal[outIdx++] = (highest+lowest)/2.0;
         today++;
      }
      outBegIdx.value = startIdx;
      outNBElement.value = outIdx;
      return RetCode.Success ;
   }
   public int midPointStateInit( struct TA_midPoint_State** _state,
      int optInTimePeriod )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 14;
      else if( ((int)optInTimePeriod < 2) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct midPoint ));
      _state.value .value .mem_index = 0;
      _state.value .value .optInTimePeriod = optInTimePeriod;
      _state.value .value .mem_size = midPointLookback (optInTimePeriod );
      _state.value .value .memory = NULL;
      return RetCode.Success ;
   }
   public int midPointState( struct TA_midPoint_State* _state,
      double inReal,
      double *outReal )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      size_t _cur_idx = _state.value .mem_index++;
      if ( _state.value .mem_size > 0) _cur_idx %= _state.value .mem_size ;
      if ( ( _state.value .mem_index == 1) )
      {
         _state.value .highest = inReal;
         _state.value .lowest = inReal;
      } else {
         if( _state.value .lowest > inReal )
            _state.value .lowest = inReal;
         if( _state.value .highest < inReal )
            _state.value .highest = inReal;
      }
      if ( _state.value .mem_size > _state.value .mem_index - 1 ) return RetCode.NeedMoreData ;
      outReal.value = ( _state.value .highest+ _state.value .lowest)/2.0;
      return RetCode.Success ;
   }
   public int midPointStateFree( struct TA_midPoint_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if ( _state.value != NULL) {
         if ( _state.value .value .memory != NULL) TA_Free( _state.value .value .memory );
         TA_Free( _state.value ); _state.value = NULL;}
      return RetCode.Success ;
   }
   public RetCode midPoint( int startIdx,
      int endIdx,
      float inReal[],
      int optInTimePeriod,
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      double lowest, highest, tmp;
      int outIdx, nbInitialElementNeeded;
      int trailingIdx, today, i;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 14;
      else if( ((int)optInTimePeriod < 2) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      nbInitialElementNeeded = (optInTimePeriod-1);
      if( startIdx < nbInitialElementNeeded )
         startIdx = nbInitialElementNeeded;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      outIdx = 0;
      today = startIdx;
      trailingIdx = startIdx-nbInitialElementNeeded;
      while( today <= endIdx )
      {
         lowest = inReal[trailingIdx++];
         highest = lowest;
         for( i=trailingIdx; i <= today; i++ )
         {
            tmp = inReal[i];
            if( tmp < lowest ) lowest= tmp;
            else if( tmp > highest) highest = tmp;
         }
         outReal[outIdx++] = (highest+lowest)/2.0;
         today++;
      }
      outBegIdx.value = startIdx;
      outNBElement.value = outIdx;
      return RetCode.Success ;
   }
   /* Generated */
   public int midPriceLookback( int optInTimePeriod )
   {
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 14;
      else if( ((int)optInTimePeriod < 2) || ((int)optInTimePeriod > 100000) )
         return -1;
      return (optInTimePeriod-1);
   }
   public RetCode midPrice( int startIdx,
      int endIdx,
      double inHigh[],
      double inLow[],
      int optInTimePeriod,
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      double lowest, highest, tmp;
      int outIdx, nbInitialElementNeeded;
      int trailingIdx, today, i;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 14;
      else if( ((int)optInTimePeriod < 2) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      nbInitialElementNeeded = (optInTimePeriod-1);
      if( startIdx < nbInitialElementNeeded )
         startIdx = nbInitialElementNeeded;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      outIdx = 0;
      today = startIdx;
      trailingIdx = startIdx-nbInitialElementNeeded;
      while( today <= endIdx )
      {
         lowest = inLow[trailingIdx];
         highest = inHigh[trailingIdx];
         trailingIdx++;
         for( i=trailingIdx; i <= today; i++ )
         {
            tmp = inLow[i];
            if( tmp < lowest ) lowest= tmp;
            tmp = inHigh[i];
            if( tmp > highest) highest = tmp;
         }
         outReal[outIdx++] = (highest+lowest)/2.0;
         today++;
      }
      outBegIdx.value = startIdx;
      outNBElement.value = outIdx;
      return RetCode.Success ;
   }
   public int midPriceStateInit( struct TA_midPrice_State** _state,
      int optInTimePeriod )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 14;
      else if( ((int)optInTimePeriod < 2) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct midPrice ));
      _state.value .value .mem_index = 0;
      _state.value .value .optInTimePeriod = optInTimePeriod;
      _state.value .value .mem_size = midPriceLookback (optInTimePeriod );
      _state.value .value .memory = NULL;
      return RetCode.Success ;
   }
   public int midPriceState( struct TA_midPrice_State* _state,
      double inHigh,
      double inLow,
      double *outReal )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      size_t _cur_idx = _state.value .mem_index++;
      if ( _state.value .mem_size > 0) _cur_idx %= _state.value .mem_size ;
      if ( ( _state.value .mem_index == 1) )
      {
         _state.value .highest = inHigh;
         _state.value .lowest = inLow;
      } else {
         if( _state.value .lowest > inLow )
            _state.value .lowest = inLow;
         if( _state.value .highest < inHigh )
            _state.value .highest = inHigh;
      }
      if ( _state.value .mem_size > _state.value .mem_index - 1 ) return RetCode.NeedMoreData ;
      outReal.value = ( _state.value .highest+ _state.value .lowest)/2.0;
      return RetCode.Success ;
   }
   public int midPriceStateFree( struct TA_midPrice_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if ( _state.value != NULL) {
         if ( _state.value .value .memory != NULL) TA_Free( _state.value .value .memory );
         TA_Free( _state.value ); _state.value = NULL;}
      return RetCode.Success ;
   }
   public RetCode midPrice( int startIdx,
      int endIdx,
      float inHigh[],
      float inLow[],
      int optInTimePeriod,
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      double lowest, highest, tmp;
      int outIdx, nbInitialElementNeeded;
      int trailingIdx, today, i;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 14;
      else if( ((int)optInTimePeriod < 2) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      nbInitialElementNeeded = (optInTimePeriod-1);
      if( startIdx < nbInitialElementNeeded )
         startIdx = nbInitialElementNeeded;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      outIdx = 0;
      today = startIdx;
      trailingIdx = startIdx-nbInitialElementNeeded;
      while( today <= endIdx )
      {
         lowest = inLow[trailingIdx];
         highest = inHigh[trailingIdx];
         trailingIdx++;
         for( i=trailingIdx; i <= today; i++ )
         {
            tmp = inLow[i];
            if( tmp < lowest ) lowest= tmp;
            tmp = inHigh[i];
            if( tmp > highest) highest = tmp;
         }
         outReal[outIdx++] = (highest+lowest)/2.0;
         today++;
      }
      outBegIdx.value = startIdx;
      outNBElement.value = outIdx;
      return RetCode.Success ;
   }
   /* Generated */
   public int minLookback( int optInTimePeriod )
   {
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 30;
      else if( ((int)optInTimePeriod < 2) || ((int)optInTimePeriod > 100000) )
         return -1;
      return (optInTimePeriod-1);
   }
   public RetCode min( int startIdx,
      int endIdx,
      double inReal[],
      int optInTimePeriod,
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      double lowest, tmp;
      int outIdx, nbInitialElementNeeded;
      int trailingIdx, lowestIdx, today, i;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 30;
      else if( ((int)optInTimePeriod < 2) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      nbInitialElementNeeded = (optInTimePeriod-1);
      if( startIdx < nbInitialElementNeeded )
         startIdx = nbInitialElementNeeded;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      outIdx = 0;
      today = startIdx;
      trailingIdx = startIdx-nbInitialElementNeeded;
      lowestIdx = -1;
      lowest = 0.0;
      while( today <= endIdx )
      {
         tmp = inReal[today];
         if( lowestIdx < trailingIdx )
         {
            lowestIdx = trailingIdx;
            lowest = inReal[lowestIdx];
            i = lowestIdx;
            while( ++i<=today )
            {
               tmp = inReal[i];
               if( tmp < lowest )
               {
                  lowestIdx = i;
                  lowest = tmp;
               }
            }
         }
         else if( tmp <= lowest )
         {
            lowestIdx = today;
            lowest = tmp;
         }
         outReal[outIdx++] = lowest;
         trailingIdx++;
         today++;
      }
      outBegIdx.value = startIdx;
      outNBElement.value = outIdx;
      return RetCode.Success ;
   }
   public int minStateInit( struct TA_min_State** _state,
      int optInTimePeriod )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 30;
      else if( ((int)optInTimePeriod < 2) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct min ));
      _state.value .value .mem_index = 0;
      _state.value .value .optInTimePeriod = optInTimePeriod;
      _state.value .value .mem_size = minLookback (optInTimePeriod );
      _state.value .value .memory = NULL;
      return RetCode.Success ;
   }
   public int minState( struct TA_min_State* _state,
      double inReal,
      double *outReal )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      size_t _cur_idx = _state.value .mem_index++;
      if ( _state.value .mem_size > 0) _cur_idx %= _state.value .mem_size ;
      if ( ( _state.value .mem_index == 1) )
         _state.value .min = inReal;
      else
         if( _state.value .min > inReal )
         _state.value .min = inReal;
      if ( _state.value .mem_size > _state.value .mem_index - 1 ) return RetCode.NeedMoreData ;
      outReal.value = _state.value .min;
      return RetCode.Success ;
   }
   public int minStateFree( struct TA_min_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if ( _state.value != NULL) {
         if ( _state.value .value .memory != NULL) TA_Free( _state.value .value .memory );
         TA_Free( _state.value ); _state.value = NULL;}
      return RetCode.Success ;
   }
   public RetCode min( int startIdx,
      int endIdx,
      float inReal[],
      int optInTimePeriod,
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      double lowest, tmp;
      int outIdx, nbInitialElementNeeded;
      int trailingIdx, lowestIdx, today, i;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 30;
      else if( ((int)optInTimePeriod < 2) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      nbInitialElementNeeded = (optInTimePeriod-1);
      if( startIdx < nbInitialElementNeeded )
         startIdx = nbInitialElementNeeded;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      outIdx = 0;
      today = startIdx;
      trailingIdx = startIdx-nbInitialElementNeeded;
      lowestIdx = -1;
      lowest = 0.0;
      while( today <= endIdx )
      {
         tmp = inReal[today];
         if( lowestIdx < trailingIdx )
         {
            lowestIdx = trailingIdx;
            lowest = inReal[lowestIdx];
            i = lowestIdx;
            while( ++i<=today )
            {
               tmp = inReal[i];
               if( tmp < lowest )
               {
                  lowestIdx = i;
                  lowest = tmp;
               }
            }
         }
         else if( tmp <= lowest )
         {
            lowestIdx = today;
            lowest = tmp;
         }
         outReal[outIdx++] = lowest;
         trailingIdx++;
         today++;
      }
      outBegIdx.value = startIdx;
      outNBElement.value = outIdx;
      return RetCode.Success ;
   }
   /* Generated */
   public int minIndexLookback( int optInTimePeriod )
   {
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 30;
      else if( ((int)optInTimePeriod < 2) || ((int)optInTimePeriod > 100000) )
         return -1;
      return (optInTimePeriod-1);
   }
   public RetCode minIndex( int startIdx,
      int endIdx,
      double inReal[],
      int optInTimePeriod,
      MInteger outBegIdx,
      MInteger outNBElement,
      int outInteger[] )
   {
      double lowest, tmp;
      int outIdx, nbInitialElementNeeded;
      int trailingIdx, lowestIdx, today, i;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 30;
      else if( ((int)optInTimePeriod < 2) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      nbInitialElementNeeded = (optInTimePeriod-1);
      if( startIdx < nbInitialElementNeeded )
         startIdx = nbInitialElementNeeded;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      outIdx = 0;
      today = startIdx;
      trailingIdx = startIdx-nbInitialElementNeeded;
      lowestIdx = -1;
      lowest = 0.0;
      while( today <= endIdx )
      {
         tmp = inReal[today];
         if( lowestIdx < trailingIdx )
         {
            lowestIdx = trailingIdx;
            lowest = inReal[lowestIdx];
            i = lowestIdx;
            while( ++i<=today )
            {
               tmp = inReal[i];
               if( tmp < lowest )
               {
                  lowestIdx = i;
                  lowest = tmp;
               }
            }
         }
         else if( tmp <= lowest )
         {
            lowestIdx = today;
            lowest = tmp;
         }
         outInteger[outIdx++] = lowestIdx;
         trailingIdx++;
         today++;
      }
      outBegIdx.value = startIdx;
      outNBElement.value = outIdx;
      return RetCode.Success ;
   }
   public int minIndexStateInit( struct TA_minIndex_State** _state,
      int optInTimePeriod )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 30;
      else if( ((int)optInTimePeriod < 2) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct minIndex ));
      _state.value .value .mem_index = 0;
      _state.value .value .optInTimePeriod = optInTimePeriod;
      _state.value .value .mem_size = minIndexLookback (optInTimePeriod );
      _state.value .value .memory = NULL;
      return RetCode.Success ;
   }
   public int minIndexState( struct TA_minIndex_State* _state,
      double inReal,
      int *outInteger )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      size_t _cur_idx = _state.value .mem_index++;
      if ( _state.value .mem_size > 0) _cur_idx %= _state.value .mem_size ;
      if ( ( _state.value .mem_index == 1) )
      {
         _state.value .min = inReal;
         _state.value .minIdx = 0;
         _state.value .currentIdx = 0;
      } else
         ++ _state.value .currentIdx;
      if( _state.value .min > inReal )
      {
         _state.value .min = inReal;
         _state.value .minIdx = _state.value .currentIdx;
      } else
         if( _state.value .min == inReal )
         _state.value .minIdx = _state.value .currentIdx;
      if ( _state.value .mem_size > _state.value .mem_index - 1 ) return RetCode.NeedMoreData ;
      outInteger.value = _state.value .min;
      return RetCode.Success ;
   }
   public int minIndexStateFree( struct TA_minIndex_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if ( _state.value != NULL) {
         if ( _state.value .value .memory != NULL) TA_Free( _state.value .value .memory );
         TA_Free( _state.value ); _state.value = NULL;}
      return RetCode.Success ;
   }
   public RetCode minIndex( int startIdx,
      int endIdx,
      float inReal[],
      int optInTimePeriod,
      MInteger outBegIdx,
      MInteger outNBElement,
      int outInteger[] )
   {
      double lowest, tmp;
      int outIdx, nbInitialElementNeeded;
      int trailingIdx, lowestIdx, today, i;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 30;
      else if( ((int)optInTimePeriod < 2) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      nbInitialElementNeeded = (optInTimePeriod-1);
      if( startIdx < nbInitialElementNeeded )
         startIdx = nbInitialElementNeeded;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      outIdx = 0;
      today = startIdx;
      trailingIdx = startIdx-nbInitialElementNeeded;
      lowestIdx = -1;
      lowest = 0.0;
      while( today <= endIdx )
      {
         tmp = inReal[today];
         if( lowestIdx < trailingIdx )
         {
            lowestIdx = trailingIdx;
            lowest = inReal[lowestIdx];
            i = lowestIdx;
            while( ++i<=today )
            {
               tmp = inReal[i];
               if( tmp < lowest )
               {
                  lowestIdx = i;
                  lowest = tmp;
               }
            }
         }
         else if( tmp <= lowest )
         {
            lowestIdx = today;
            lowest = tmp;
         }
         outInteger[outIdx++] = lowestIdx;
         trailingIdx++;
         today++;
      }
      outBegIdx.value = startIdx;
      outNBElement.value = outIdx;
      return RetCode.Success ;
   }
   /* Generated */
   public int minMaxLookback( int optInTimePeriod )
   {
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 30;
      else if( ((int)optInTimePeriod < 2) || ((int)optInTimePeriod > 100000) )
         return -1;
      return (optInTimePeriod-1);
   }
   public RetCode minMax( int startIdx,
      int endIdx,
      double inReal[],
      int optInTimePeriod,
      MInteger outBegIdx,
      MInteger outNBElement,
      double outMin[],
      double outMax[] )
   {
      double highest, lowest, tmpHigh, tmpLow;
      int outIdx, nbInitialElementNeeded;
      int trailingIdx, today, i, highestIdx, lowestIdx;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 30;
      else if( ((int)optInTimePeriod < 2) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      nbInitialElementNeeded = (optInTimePeriod-1);
      if( startIdx < nbInitialElementNeeded )
         startIdx = nbInitialElementNeeded;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      outIdx = 0;
      today = startIdx;
      trailingIdx = startIdx-nbInitialElementNeeded;
      highestIdx = -1;
      highest = 0.0;
      lowestIdx = -1;
      lowest = 0.0;
      while( today <= endIdx )
      {
         tmpLow = tmpHigh = inReal[today];
         if( highestIdx < trailingIdx )
         {
            highestIdx = trailingIdx;
            highest = inReal[highestIdx];
            i = highestIdx;
            while( ++i<=today )
            {
               tmpHigh = inReal[i];
               if( tmpHigh > highest )
               {
                  highestIdx = i;
                  highest = tmpHigh;
               }
            }
         }
         else if( tmpHigh >= highest )
         {
            highestIdx = today;
            highest = tmpHigh;
         }
         if( lowestIdx < trailingIdx )
         {
            lowestIdx = trailingIdx;
            lowest = inReal[lowestIdx];
            i = lowestIdx;
            while( ++i<=today )
            {
               tmpLow = inReal[i];
               if( tmpLow < lowest )
               {
                  lowestIdx = i;
                  lowest = tmpLow;
               }
            }
         }
         else if( tmpLow <= lowest )
         {
            lowestIdx = today;
            lowest = tmpLow;
         }
         outMax[outIdx] = highest;
         outMin[outIdx] = lowest;
         outIdx++;
         trailingIdx++;
         today++;
      }
      outBegIdx.value = startIdx;
      outNBElement.value = outIdx;
      return RetCode.Success ;
   }
   public int minMaxStateInit( struct TA_minMax_State** _state,
      int optInTimePeriod )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 30;
      else if( ((int)optInTimePeriod < 2) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct minMax ));
      _state.value .value .mem_index = 0;
      _state.value .value .optInTimePeriod = optInTimePeriod;
      _state.value .value .mem_size = minMaxLookback (optInTimePeriod );
      _state.value .value .memory = NULL;
      return RetCode.Success ;
   }
   public int minMaxState( struct TA_minMax_State* _state,
      double inReal,
      double *outMin,
      double *outMax )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      size_t _cur_idx = _state.value .mem_index++;
      if ( _state.value .mem_size > 0) _cur_idx %= _state.value .mem_size ;
      if ( ( _state.value .mem_index == 1) )
      {
         _state.value .min = inReal;
         _state.value .max = inReal;
      } else {
         if( _state.value .min > inReal )
            _state.value .min = inReal;
         if( _state.value .max < inReal )
            _state.value .max = inReal;
      }
      if ( _state.value .mem_size > _state.value .mem_index - 1 ) return RetCode.NeedMoreData ;
      outMin.value = _state.value .min;
      outMax.value = _state.value .max;
      return RetCode.Success ;
   }
   public int minMaxStateFree( struct TA_minMax_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if ( _state.value != NULL) {
         if ( _state.value .value .memory != NULL) TA_Free( _state.value .value .memory );
         TA_Free( _state.value ); _state.value = NULL;}
      return RetCode.Success ;
   }
   public RetCode minMax( int startIdx,
      int endIdx,
      float inReal[],
      int optInTimePeriod,
      MInteger outBegIdx,
      MInteger outNBElement,
      double outMin[],
      double outMax[] )
   {
      double highest, lowest, tmpHigh, tmpLow;
      int outIdx, nbInitialElementNeeded;
      int trailingIdx, today, i, highestIdx, lowestIdx;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 30;
      else if( ((int)optInTimePeriod < 2) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      nbInitialElementNeeded = (optInTimePeriod-1);
      if( startIdx < nbInitialElementNeeded )
         startIdx = nbInitialElementNeeded;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      outIdx = 0;
      today = startIdx;
      trailingIdx = startIdx-nbInitialElementNeeded;
      highestIdx = -1;
      highest = 0.0;
      lowestIdx = -1;
      lowest = 0.0;
      while( today <= endIdx )
      {
         tmpLow = tmpHigh = inReal[today];
         if( highestIdx < trailingIdx )
         {
            highestIdx = trailingIdx;
            highest = inReal[highestIdx];
            i = highestIdx;
            while( ++i<=today )
            {
               tmpHigh = inReal[i];
               if( tmpHigh > highest )
               {
                  highestIdx = i;
                  highest = tmpHigh;
               }
            }
         }
         else if( tmpHigh >= highest )
         {
            highestIdx = today;
            highest = tmpHigh;
         }
         if( lowestIdx < trailingIdx )
         {
            lowestIdx = trailingIdx;
            lowest = inReal[lowestIdx];
            i = lowestIdx;
            while( ++i<=today )
            {
               tmpLow = inReal[i];
               if( tmpLow < lowest )
               {
                  lowestIdx = i;
                  lowest = tmpLow;
               }
            }
         }
         else if( tmpLow <= lowest )
         {
            lowestIdx = today;
            lowest = tmpLow;
         }
         outMax[outIdx] = highest;
         outMin[outIdx] = lowest;
         outIdx++;
         trailingIdx++;
         today++;
      }
      outBegIdx.value = startIdx;
      outNBElement.value = outIdx;
      return RetCode.Success ;
   }
   /* Generated */
   public int minMaxIndexLookback( int optInTimePeriod )
   {
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 30;
      else if( ((int)optInTimePeriod < 2) || ((int)optInTimePeriod > 100000) )
         return -1;
      return (optInTimePeriod-1);
   }
   public RetCode minMaxIndex( int startIdx,
      int endIdx,
      double inReal[],
      int optInTimePeriod,
      MInteger outBegIdx,
      MInteger outNBElement,
      int outMinIdx[],
      int outMaxIdx[] )
   {
      double highest, lowest, tmpHigh, tmpLow;
      int outIdx, nbInitialElementNeeded;
      int trailingIdx, today, i, highestIdx, lowestIdx;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 30;
      else if( ((int)optInTimePeriod < 2) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      nbInitialElementNeeded = (optInTimePeriod-1);
      if( startIdx < nbInitialElementNeeded )
         startIdx = nbInitialElementNeeded;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      outIdx = 0;
      today = startIdx;
      trailingIdx = startIdx-nbInitialElementNeeded;
      highestIdx = -1;
      highest = 0.0;
      lowestIdx = -1;
      lowest = 0.0;
      while( today <= endIdx )
      {
         tmpLow = tmpHigh = inReal[today];
         if( highestIdx < trailingIdx )
         {
            highestIdx = trailingIdx;
            highest = inReal[highestIdx];
            i = highestIdx;
            while( ++i<=today )
            {
               tmpHigh = inReal[i];
               if( tmpHigh > highest )
               {
                  highestIdx = i;
                  highest = tmpHigh;
               }
            }
         }
         else if( tmpHigh >= highest )
         {
            highestIdx = today;
            highest = tmpHigh;
         }
         if( lowestIdx < trailingIdx )
         {
            lowestIdx = trailingIdx;
            lowest = inReal[lowestIdx];
            i = lowestIdx;
            while( ++i<=today )
            {
               tmpLow = inReal[i];
               if( tmpLow < lowest )
               {
                  lowestIdx = i;
                  lowest = tmpLow;
               }
            }
         }
         else if( tmpLow <= lowest )
         {
            lowestIdx = today;
            lowest = tmpLow;
         }
         outMaxIdx[outIdx] = highestIdx;
         outMinIdx[outIdx] = lowestIdx;
         outIdx++;
         trailingIdx++;
         today++;
      }
      outBegIdx.value = startIdx;
      outNBElement.value = outIdx;
      return RetCode.Success ;
   }
   public int minMaxIndexStateInit( struct TA_minMaxIndex_State** _state,
      int optInTimePeriod )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 30;
      else if( ((int)optInTimePeriod < 2) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct minMaxIndex ));
      _state.value .value .mem_index = 0;
      _state.value .value .optInTimePeriod = optInTimePeriod;
      _state.value .value .mem_size = minMaxIndexLookback (optInTimePeriod );
      _state.value .value .memory = NULL;
      return RetCode.Success ;
   }
   public int minMaxIndexState( struct TA_minMaxIndex_State* _state,
      double inReal,
      int *outMinIdx,
      int *outMaxIdx )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      size_t _cur_idx = _state.value .mem_index++;
      if ( _state.value .mem_size > 0) _cur_idx %= _state.value .mem_size ;
      if ( ( _state.value .mem_index == 1) )
      {
         _state.value .max = inReal;
         _state.value .min = inReal;
         _state.value .maxIdx = 0;
         _state.value .minIdx = 0;
         _state.value .currentIdx = 0;
      } else
         ++ _state.value .currentIdx;
      if( _state.value .max < inReal )
      {
         _state.value .max = inReal;
         _state.value .maxIdx = _state.value .currentIdx;
      }
      if( _state.value .min > inReal )
      {
         _state.value .min = inReal;
         _state.value .minIdx = _state.value .currentIdx;
      }
      if ( _state.value .mem_size > _state.value .mem_index - 1 ) return RetCode.NeedMoreData ;
      outMaxIdx.value = _state.value .maxIdx;
      outMinIdx.value = _state.value .minIdx;
      return RetCode.Success ;
   }
   public int minMaxIndexStateFree( struct TA_minMaxIndex_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if ( _state.value != NULL) {
         if ( _state.value .value .memory != NULL) TA_Free( _state.value .value .memory );
         TA_Free( _state.value ); _state.value = NULL;}
      return RetCode.Success ;
   }
   public RetCode minMaxIndex( int startIdx,
      int endIdx,
      float inReal[],
      int optInTimePeriod,
      MInteger outBegIdx,
      MInteger outNBElement,
      int outMinIdx[],
      int outMaxIdx[] )
   {
      double highest, lowest, tmpHigh, tmpLow;
      int outIdx, nbInitialElementNeeded;
      int trailingIdx, today, i, highestIdx, lowestIdx;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 30;
      else if( ((int)optInTimePeriod < 2) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      nbInitialElementNeeded = (optInTimePeriod-1);
      if( startIdx < nbInitialElementNeeded )
         startIdx = nbInitialElementNeeded;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      outIdx = 0;
      today = startIdx;
      trailingIdx = startIdx-nbInitialElementNeeded;
      highestIdx = -1;
      highest = 0.0;
      lowestIdx = -1;
      lowest = 0.0;
      while( today <= endIdx )
      {
         tmpLow = tmpHigh = inReal[today];
         if( highestIdx < trailingIdx )
         {
            highestIdx = trailingIdx;
            highest = inReal[highestIdx];
            i = highestIdx;
            while( ++i<=today )
            {
               tmpHigh = inReal[i];
               if( tmpHigh > highest )
               {
                  highestIdx = i;
                  highest = tmpHigh;
               }
            }
         }
         else if( tmpHigh >= highest )
         {
            highestIdx = today;
            highest = tmpHigh;
         }
         if( lowestIdx < trailingIdx )
         {
            lowestIdx = trailingIdx;
            lowest = inReal[lowestIdx];
            i = lowestIdx;
            while( ++i<=today )
            {
               tmpLow = inReal[i];
               if( tmpLow < lowest )
               {
                  lowestIdx = i;
                  lowest = tmpLow;
               }
            }
         }
         else if( tmpLow <= lowest )
         {
            lowestIdx = today;
            lowest = tmpLow;
         }
         outMaxIdx[outIdx] = highestIdx;
         outMinIdx[outIdx] = lowestIdx;
         outIdx++;
         trailingIdx++;
         today++;
      }
      outBegIdx.value = startIdx;
      outNBElement.value = outIdx;
      return RetCode.Success ;
   }
   /* Generated */
   public int minusDILookback( int optInTimePeriod )
   {
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 14;
      else if( ((int)optInTimePeriod < 1) || ((int)optInTimePeriod > 100000) )
         return -1;
      if( optInTimePeriod > 1 )
         return optInTimePeriod + (this.unstablePeriod[FuncUnstId.MinusDI.ordinal()]) ;
      else
         return 1;
   }
   public RetCode minusDI( int startIdx,
      int endIdx,
      double inHigh[],
      double inLow[],
      double inClose[],
      int optInTimePeriod,
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      int today, lookbackTotal, outIdx;
      double prevHigh, prevLow, prevClose;
      double prevMinusDM, prevTR;
      double tempReal, tempReal2, diffP, diffM;
      int i;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 14;
      else if( ((int)optInTimePeriod < 1) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      if( optInTimePeriod > 1 )
         lookbackTotal = optInTimePeriod + (this.unstablePeriod[FuncUnstId.MinusDI.ordinal()]) ;
      else
         lookbackTotal = 1;
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      outIdx = 0;
      if( optInTimePeriod <= 1 )
      {
         outBegIdx.value = startIdx;
         today = startIdx-1;
         prevHigh = inHigh[today];
         prevLow = inLow[today];
         prevClose = inClose[today];
         while( today < endIdx )
         {
            today++;
            tempReal = inHigh[today];
            diffP = tempReal-prevHigh;
            prevHigh = tempReal;
            tempReal = inLow[today];
            diffM = prevLow-tempReal;
            prevLow = tempReal;
            if( (diffM > 0) && (diffP < diffM) )
            {
               { tempReal = prevHigh-prevLow; tempReal2 = Math.abs (prevHigh-prevClose); if( tempReal2 > tempReal ) tempReal = tempReal2; tempReal2 = Math.abs (prevLow-prevClose); if( tempReal2 > tempReal ) tempReal = tempReal2; } ;
               if( (((- (0.00000000000001) )<tempReal)&&(tempReal< (0.00000000000001) )) )
                  outReal[outIdx++] = (double)0.0;
               else
                  outReal[outIdx++] = diffM/tempReal;
            }
            else
               outReal[outIdx++] = (double)0.0;
            prevClose = inClose[today];
         }
         outNBElement.value = outIdx;
         return RetCode.Success ;
      }
      outBegIdx.value = today = startIdx;
      prevMinusDM = 0.0;
      prevTR = 0.0;
      today = startIdx - lookbackTotal;
      prevHigh = inHigh[today];
      prevLow = inLow[today];
      prevClose = inClose[today];
      i = optInTimePeriod-1;
      while( i-- > 0 )
      {
         today++;
         tempReal = inHigh[today];
         diffP = tempReal-prevHigh;
         prevHigh = tempReal;
         tempReal = inLow[today];
         diffM = prevLow-tempReal;
         prevLow = tempReal;
         if( (diffM > 0) && (diffP < diffM) )
         {
            prevMinusDM += diffM;
         }
         { tempReal = prevHigh-prevLow; tempReal2 = Math.abs (prevHigh-prevClose); if( tempReal2 > tempReal ) tempReal = tempReal2; tempReal2 = Math.abs (prevLow-prevClose); if( tempReal2 > tempReal ) tempReal = tempReal2; } ;
         prevTR += tempReal;
         prevClose = inClose[today];
      }
      i = (this.unstablePeriod[FuncUnstId.MinusDI.ordinal()]) + 1;
      while( i-- != 0 )
      {
         today++;
         tempReal = inHigh[today];
         diffP = tempReal-prevHigh;
         prevHigh = tempReal;
         tempReal = inLow[today];
         diffM = prevLow-tempReal;
         prevLow = tempReal;
         if( (diffM > 0) && (diffP < diffM) )
         {
            prevMinusDM = prevMinusDM - (prevMinusDM/optInTimePeriod) + diffM;
         }
         else
         {
            prevMinusDM = prevMinusDM - (prevMinusDM/optInTimePeriod);
         }
         { tempReal = prevHigh-prevLow; tempReal2 = Math.abs (prevHigh-prevClose); if( tempReal2 > tempReal ) tempReal = tempReal2; tempReal2 = Math.abs (prevLow-prevClose); if( tempReal2 > tempReal ) tempReal = tempReal2; } ;
         prevTR = prevTR - (prevTR/optInTimePeriod) + tempReal;
         prevClose = inClose[today];
      }
      if( ! (((- (0.00000000000001) )<prevTR)&&(prevTR< (0.00000000000001) )) )
         outReal[0] = (100.0*(prevMinusDM/prevTR)) ;
      else
         outReal[0] = 0.0;
      outIdx = 1;
      while( today < endIdx )
      {
         today++;
         tempReal = inHigh[today];
         diffP = tempReal-prevHigh;
         prevHigh = tempReal;
         tempReal = inLow[today];
         diffM = prevLow-tempReal;
         prevLow = tempReal;
         if( (diffM > 0) && (diffP < diffM) )
         {
            prevMinusDM = prevMinusDM - (prevMinusDM/optInTimePeriod) + diffM;
         }
         else
         {
            prevMinusDM = prevMinusDM - (prevMinusDM/optInTimePeriod);
         }
         { tempReal = prevHigh-prevLow; tempReal2 = Math.abs (prevHigh-prevClose); if( tempReal2 > tempReal ) tempReal = tempReal2; tempReal2 = Math.abs (prevLow-prevClose); if( tempReal2 > tempReal ) tempReal = tempReal2; } ;
         prevTR = prevTR - (prevTR/optInTimePeriod) + tempReal;
         prevClose = inClose[today];
         if( ! (((- (0.00000000000001) )<prevTR)&&(prevTR< (0.00000000000001) )) )
            outReal[outIdx++] = (100.0*(prevMinusDM/prevTR)) ;
         else
            outReal[outIdx++] = 0.0;
      }
      outNBElement.value = outIdx;
      return RetCode.Success ;
   }
   public int minusDIStateInit( struct TA_minusDI_State** _state,
      int optInTimePeriod )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 14;
      else if( ((int)optInTimePeriod < 1) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct minusDI ));
      _state.value .value .mem_index = 0;
      _state.value .value .optInTimePeriod = optInTimePeriod;
      _state.value .value .mem_size = minusDILookback (optInTimePeriod );
      if ( _state.value .value .mem_size > 0)
         _state.value .value .memory = TA_Calloc( _state.value .value .mem_size , sizeof(struct TA_MINUS_DI_Data));
      else
         _state.value .value .memory = NULL;
      return RetCode.Success ;
   }
   public int minusDIState( struct TA_minusDI_State* _state,
      double inHigh,
      double inLow,
      double inClose,
      double *outReal )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      size_t _cur_idx = _state.value .mem_index++;
      if ( _state.value .mem_size > 0) _cur_idx %= _state.value .mem_size ;
      if ( _state.value .mem_size > _state.value .mem_index - 1 ) {
         ( _state.value .memory+_cur_idx).value .inHigh = inHigh ;
         ( _state.value .memory+_cur_idx).value .inLow = inLow ;
         ( _state.value .memory+_cur_idx).value .inClose = inClose ;
         return RetCode.NeedMoreData ; }
      return RetCode.Success ;
   }
   public int minusDIStateFree( struct TA_minusDI_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if ( _state.value != NULL) {
         if ( _state.value .value .memory != NULL) TA_Free( _state.value .value .memory );
         TA_Free( _state.value ); _state.value = NULL;}
      return RetCode.Success ;
   }
   public RetCode minusDI( int startIdx,
      int endIdx,
      float inHigh[],
      float inLow[],
      float inClose[],
      int optInTimePeriod,
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      int today, lookbackTotal, outIdx;
      double prevHigh, prevLow, prevClose;
      double prevMinusDM, prevTR;
      double tempReal, tempReal2, diffP, diffM;
      int i;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 14;
      else if( ((int)optInTimePeriod < 1) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      if( optInTimePeriod > 1 )
         lookbackTotal = optInTimePeriod + (this.unstablePeriod[FuncUnstId.MinusDI.ordinal()]) ;
      else
         lookbackTotal = 1;
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      outIdx = 0;
      if( optInTimePeriod <= 1 )
      {
         outBegIdx.value = startIdx;
         today = startIdx-1;
         prevHigh = inHigh[today];
         prevLow = inLow[today];
         prevClose = inClose[today];
         while( today < endIdx )
         {
            today++;
            tempReal = inHigh[today];
            diffP = tempReal-prevHigh;
            prevHigh = tempReal;
            tempReal = inLow[today];
            diffM = prevLow-tempReal;
            prevLow = tempReal;
            if( (diffM > 0) && (diffP < diffM) )
            {
               { tempReal = prevHigh-prevLow; tempReal2 = Math.abs (prevHigh-prevClose); if( tempReal2 > tempReal ) tempReal = tempReal2; tempReal2 = Math.abs (prevLow-prevClose); if( tempReal2 > tempReal ) tempReal = tempReal2; } ;
               if( (((- (0.00000000000001) )<tempReal)&&(tempReal< (0.00000000000001) )) )
                  outReal[outIdx++] = (double)0.0;
               else
                  outReal[outIdx++] = diffM/tempReal;
            }
            else
               outReal[outIdx++] = (double)0.0;
            prevClose = inClose[today];
         }
         outNBElement.value = outIdx;
         return RetCode.Success ;
      }
      outBegIdx.value = today = startIdx;
      prevMinusDM = 0.0;
      prevTR = 0.0;
      today = startIdx - lookbackTotal;
      prevHigh = inHigh[today];
      prevLow = inLow[today];
      prevClose = inClose[today];
      i = optInTimePeriod-1;
      while( i-- > 0 )
      {
         today++;
         tempReal = inHigh[today];
         diffP = tempReal-prevHigh;
         prevHigh = tempReal;
         tempReal = inLow[today];
         diffM = prevLow-tempReal;
         prevLow = tempReal;
         if( (diffM > 0) && (diffP < diffM) )
         {
            prevMinusDM += diffM;
         }
         { tempReal = prevHigh-prevLow; tempReal2 = Math.abs (prevHigh-prevClose); if( tempReal2 > tempReal ) tempReal = tempReal2; tempReal2 = Math.abs (prevLow-prevClose); if( tempReal2 > tempReal ) tempReal = tempReal2; } ;
         prevTR += tempReal;
         prevClose = inClose[today];
      }
      i = (this.unstablePeriod[FuncUnstId.MinusDI.ordinal()]) + 1;
      while( i-- != 0 )
      {
         today++;
         tempReal = inHigh[today];
         diffP = tempReal-prevHigh;
         prevHigh = tempReal;
         tempReal = inLow[today];
         diffM = prevLow-tempReal;
         prevLow = tempReal;
         if( (diffM > 0) && (diffP < diffM) )
         {
            prevMinusDM = prevMinusDM - (prevMinusDM/optInTimePeriod) + diffM;
         }
         else
         {
            prevMinusDM = prevMinusDM - (prevMinusDM/optInTimePeriod);
         }
         { tempReal = prevHigh-prevLow; tempReal2 = Math.abs (prevHigh-prevClose); if( tempReal2 > tempReal ) tempReal = tempReal2; tempReal2 = Math.abs (prevLow-prevClose); if( tempReal2 > tempReal ) tempReal = tempReal2; } ;
         prevTR = prevTR - (prevTR/optInTimePeriod) + tempReal;
         prevClose = inClose[today];
      }
      if( ! (((- (0.00000000000001) )<prevTR)&&(prevTR< (0.00000000000001) )) )
         outReal[0] = (100.0*(prevMinusDM/prevTR)) ;
      else
         outReal[0] = 0.0;
      outIdx = 1;
      while( today < endIdx )
      {
         today++;
         tempReal = inHigh[today];
         diffP = tempReal-prevHigh;
         prevHigh = tempReal;
         tempReal = inLow[today];
         diffM = prevLow-tempReal;
         prevLow = tempReal;
         if( (diffM > 0) && (diffP < diffM) )
         {
            prevMinusDM = prevMinusDM - (prevMinusDM/optInTimePeriod) + diffM;
         }
         else
         {
            prevMinusDM = prevMinusDM - (prevMinusDM/optInTimePeriod);
         }
         { tempReal = prevHigh-prevLow; tempReal2 = Math.abs (prevHigh-prevClose); if( tempReal2 > tempReal ) tempReal = tempReal2; tempReal2 = Math.abs (prevLow-prevClose); if( tempReal2 > tempReal ) tempReal = tempReal2; } ;
         prevTR = prevTR - (prevTR/optInTimePeriod) + tempReal;
         prevClose = inClose[today];
         if( ! (((- (0.00000000000001) )<prevTR)&&(prevTR< (0.00000000000001) )) )
            outReal[outIdx++] = (100.0*(prevMinusDM/prevTR)) ;
         else
            outReal[outIdx++] = 0.0;
      }
      outNBElement.value = outIdx;
      return RetCode.Success ;
   }
   /* Generated */
   public int minusDMLookback( int optInTimePeriod )
   {
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 14;
      else if( ((int)optInTimePeriod < 1) || ((int)optInTimePeriod > 100000) )
         return -1;
      if( optInTimePeriod > 1 )
         return optInTimePeriod + (this.unstablePeriod[FuncUnstId.MinusDM.ordinal()]) - 1;
      else
         return 1;
   }
   public RetCode minusDM( int startIdx,
      int endIdx,
      double inHigh[],
      double inLow[],
      int optInTimePeriod,
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      int today, lookbackTotal, outIdx;
      double prevHigh, prevLow, tempReal;
      double prevMinusDM;
      double diffP, diffM;
      int i;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 14;
      else if( ((int)optInTimePeriod < 1) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      if( optInTimePeriod > 1 )
         lookbackTotal = optInTimePeriod + (this.unstablePeriod[FuncUnstId.MinusDM.ordinal()]) - 1;
      else
         lookbackTotal = 1;
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      outIdx = 0;
      if( optInTimePeriod <= 1 )
      {
         outBegIdx.value = startIdx;
         today = startIdx-1;
         prevHigh = inHigh[today];
         prevLow = inLow[today];
         while( today < endIdx )
         {
            today++;
            tempReal = inHigh[today];
            diffP = tempReal-prevHigh;
            prevHigh = tempReal;
            tempReal = inLow[today];
            diffM = prevLow-tempReal;
            prevLow = tempReal;
            if( (diffM > 0) && (diffP < diffM) )
            {
               outReal[outIdx++] = diffM;
            }
            else
               outReal[outIdx++] = 0;
         }
         outNBElement.value = outIdx;
         return RetCode.Success ;
      }
      outBegIdx.value = startIdx;
      prevMinusDM = 0.0;
      today = startIdx - lookbackTotal;
      prevHigh = inHigh[today];
      prevLow = inLow[today];
      i = optInTimePeriod-1;
      while( i-- > 0 )
      {
         today++;
         tempReal = inHigh[today];
         diffP = tempReal-prevHigh;
         prevHigh = tempReal;
         tempReal = inLow[today];
         diffM = prevLow-tempReal;
         prevLow = tempReal;
         if( (diffM > 0) && (diffP < diffM) )
         {
            prevMinusDM += diffM;
         }
      }
      i = (this.unstablePeriod[FuncUnstId.MinusDM.ordinal()]) ;
      while( i-- != 0 )
      {
         today++;
         tempReal = inHigh[today];
         diffP = tempReal-prevHigh;
         prevHigh = tempReal;
         tempReal = inLow[today];
         diffM = prevLow-tempReal;
         prevLow = tempReal;
         if( (diffM > 0) && (diffP < diffM) )
         {
            prevMinusDM = prevMinusDM - (prevMinusDM/optInTimePeriod) + diffM;
         }
         else
         {
            prevMinusDM = prevMinusDM - (prevMinusDM/optInTimePeriod);
         }
      }
      outReal[0] = prevMinusDM;
      outIdx = 1;
      while( today < endIdx )
      {
         today++;
         tempReal = inHigh[today];
         diffP = tempReal-prevHigh;
         prevHigh = tempReal;
         tempReal = inLow[today];
         diffM = prevLow-tempReal;
         prevLow = tempReal;
         if( (diffM > 0) && (diffP < diffM) )
         {
            prevMinusDM = prevMinusDM - (prevMinusDM/optInTimePeriod) + diffM;
         }
         else
         {
            prevMinusDM = prevMinusDM - (prevMinusDM/optInTimePeriod);
         }
         outReal[outIdx++] = prevMinusDM;
      }
      outNBElement.value = outIdx;
      return RetCode.Success ;
   }
   public int minusDMStateInit( struct TA_minusDM_State** _state,
      int optInTimePeriod )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 14;
      else if( ((int)optInTimePeriod < 1) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct minusDM ));
      _state.value .value .mem_index = 0;
      _state.value .value .optInTimePeriod = optInTimePeriod;
      _state.value .value .mem_size = minusDMLookback (optInTimePeriod );
      if ( _state.value .value .mem_size > 0)
         _state.value .value .memory = TA_Calloc( _state.value .value .mem_size , sizeof(struct TA_MINUS_DM_Data));
      else
         _state.value .value .memory = NULL;
      return RetCode.Success ;
   }
   public int minusDMState( struct TA_minusDM_State* _state,
      double inHigh,
      double inLow,
      double *outReal )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      size_t _cur_idx = _state.value .mem_index++;
      if ( _state.value .mem_size > 0) _cur_idx %= _state.value .mem_size ;
      if ( _state.value .mem_size > _state.value .mem_index - 1 ) {
         ( _state.value .memory+_cur_idx).value .inHigh = inHigh ;
         ( _state.value .memory+_cur_idx).value .inLow = inLow ;
         return RetCode.NeedMoreData ; }
      return RetCode.Success ;
   }
   public int minusDMStateFree( struct TA_minusDM_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if ( _state.value != NULL) {
         if ( _state.value .value .memory != NULL) TA_Free( _state.value .value .memory );
         TA_Free( _state.value ); _state.value = NULL;}
      return RetCode.Success ;
   }
   public RetCode minusDM( int startIdx,
      int endIdx,
      float inHigh[],
      float inLow[],
      int optInTimePeriod,
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      int today, lookbackTotal, outIdx;
      double prevHigh, prevLow, tempReal;
      double prevMinusDM;
      double diffP, diffM;
      int i;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 14;
      else if( ((int)optInTimePeriod < 1) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      if( optInTimePeriod > 1 )
         lookbackTotal = optInTimePeriod + (this.unstablePeriod[FuncUnstId.MinusDM.ordinal()]) - 1;
      else
         lookbackTotal = 1;
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      outIdx = 0;
      if( optInTimePeriod <= 1 )
      {
         outBegIdx.value = startIdx;
         today = startIdx-1;
         prevHigh = inHigh[today];
         prevLow = inLow[today];
         while( today < endIdx )
         {
            today++;
            tempReal = inHigh[today];
            diffP = tempReal-prevHigh;
            prevHigh = tempReal;
            tempReal = inLow[today];
            diffM = prevLow-tempReal;
            prevLow = tempReal;
            if( (diffM > 0) && (diffP < diffM) )
            {
               outReal[outIdx++] = diffM;
            }
            else
               outReal[outIdx++] = 0;
         }
         outNBElement.value = outIdx;
         return RetCode.Success ;
      }
      outBegIdx.value = startIdx;
      prevMinusDM = 0.0;
      today = startIdx - lookbackTotal;
      prevHigh = inHigh[today];
      prevLow = inLow[today];
      i = optInTimePeriod-1;
      while( i-- > 0 )
      {
         today++;
         tempReal = inHigh[today];
         diffP = tempReal-prevHigh;
         prevHigh = tempReal;
         tempReal = inLow[today];
         diffM = prevLow-tempReal;
         prevLow = tempReal;
         if( (diffM > 0) && (diffP < diffM) )
         {
            prevMinusDM += diffM;
         }
      }
      i = (this.unstablePeriod[FuncUnstId.MinusDM.ordinal()]) ;
      while( i-- != 0 )
      {
         today++;
         tempReal = inHigh[today];
         diffP = tempReal-prevHigh;
         prevHigh = tempReal;
         tempReal = inLow[today];
         diffM = prevLow-tempReal;
         prevLow = tempReal;
         if( (diffM > 0) && (diffP < diffM) )
         {
            prevMinusDM = prevMinusDM - (prevMinusDM/optInTimePeriod) + diffM;
         }
         else
         {
            prevMinusDM = prevMinusDM - (prevMinusDM/optInTimePeriod);
         }
      }
      outReal[0] = prevMinusDM;
      outIdx = 1;
      while( today < endIdx )
      {
         today++;
         tempReal = inHigh[today];
         diffP = tempReal-prevHigh;
         prevHigh = tempReal;
         tempReal = inLow[today];
         diffM = prevLow-tempReal;
         prevLow = tempReal;
         if( (diffM > 0) && (diffP < diffM) )
         {
            prevMinusDM = prevMinusDM - (prevMinusDM/optInTimePeriod) + diffM;
         }
         else
         {
            prevMinusDM = prevMinusDM - (prevMinusDM/optInTimePeriod);
         }
         outReal[outIdx++] = prevMinusDM;
      }
      outNBElement.value = outIdx;
      return RetCode.Success ;
   }
   /* Generated */
   public int momLookback( int optInTimePeriod )
   {
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 10;
      else if( ((int)optInTimePeriod < 1) || ((int)optInTimePeriod > 100000) )
         return -1;
      return optInTimePeriod;
   }
   public RetCode mom( int startIdx,
      int endIdx,
      double inReal[],
      int optInTimePeriod,
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      int inIdx, outIdx, trailingIdx;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 10;
      else if( ((int)optInTimePeriod < 1) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      if( startIdx < optInTimePeriod )
         startIdx = optInTimePeriod;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      outIdx = 0;
      inIdx = startIdx;
      trailingIdx = startIdx - optInTimePeriod;
      while( inIdx <= endIdx )
         outReal[outIdx++] = inReal[inIdx++] - inReal[trailingIdx++];
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   public int momStateInit( struct TA_mom_State** _state,
      int optInTimePeriod )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 10;
      else if( ((int)optInTimePeriod < 1) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct mom ));
      _state.value .value .mem_index = 0;
      _state.value .value .optInTimePeriod = optInTimePeriod;
      _state.value .value .mem_size = momLookback (optInTimePeriod );
      if ( _state.value .value .mem_size > 0)
         _state.value .value .memory = TA_Calloc( _state.value .value .mem_size , sizeof(struct TA_MOM_Data));
      else
         _state.value .value .memory = NULL;
      return RetCode.Success ;
   }
   public int momState( struct TA_mom_State* _state,
      double inReal,
      double *outReal )
   {
      double temp;
      if (_state == NULL)
         return RetCode.BadParam ;
      size_t _cur_idx = _state.value .mem_index++;
      if ( _state.value .mem_size > 0) _cur_idx %= _state.value .mem_size ;
      if ( _state.value .mem_size > _state.value .mem_index - 1 ) {
         ( _state.value .memory+_cur_idx).value .inReal = inReal ;
         return RetCode.NeedMoreData ; }
      temp = ( _state.value .memory+_cur_idx).value .inReal ;
      ( _state.value .memory+_cur_idx).value .inReal = inReal ;
      outReal.value = inReal - temp;
      return RetCode.Success ;
   }
   public int momStateFree( struct TA_mom_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if ( _state.value != NULL) {
         if ( _state.value .value .memory != NULL) TA_Free( _state.value .value .memory );
         TA_Free( _state.value ); _state.value = NULL;}
      return RetCode.Success ;
   }
   public RetCode mom( int startIdx,
      int endIdx,
      float inReal[],
      int optInTimePeriod,
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      int inIdx, outIdx, trailingIdx;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 10;
      else if( ((int)optInTimePeriod < 1) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      if( startIdx < optInTimePeriod )
         startIdx = optInTimePeriod;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      outIdx = 0;
      inIdx = startIdx;
      trailingIdx = startIdx - optInTimePeriod;
      while( inIdx <= endIdx )
         outReal[outIdx++] = inReal[inIdx++] - inReal[trailingIdx++];
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   /* Generated */
   public int multLookback( )
   {
      return RetCode.Success ;
   }
   public RetCode mult( int startIdx,
      int endIdx,
      double inReal0[],
      double inReal1[],
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      int outIdx;
      int i;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      for( i=startIdx, outIdx=0; i <= endIdx; i++, outIdx++ )
      {
         outReal[outIdx] = inReal0[i]*inReal1[i];
      }
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   public int multStateInit( struct TA_mult_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct mult ));
      _state.value .value .mem_index = 0;
      _state.value .value .mem_size = multLookback ();
      if ( _state.value .value .mem_size > 0)
         _state.value .value .memory = TA_Calloc( _state.value .value .mem_size , sizeof(struct TA_MULT_Data));
      else
         _state.value .value .memory = NULL;
      return RetCode.Success ;
   }
   public int multState( struct TA_mult_State* _state,
      double inReal0,
      double inReal1,
      double *outReal )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      size_t _cur_idx = _state.value .mem_index++;
      if ( _state.value .mem_size > 0) _cur_idx %= _state.value .mem_size ;
      if ( _state.value .mem_size > _state.value .mem_index - 1 ) {
         ( _state.value .memory+_cur_idx).value .inReal0 = inReal0 ;
         ( _state.value .memory+_cur_idx).value .inReal1 = inReal1 ;
         return RetCode.NeedMoreData ; }
      outReal.value = inReal0*inReal1;
      return RetCode.Success ;
   }
   public int multStateFree( struct TA_mult_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if ( _state.value != NULL) {
         if ( _state.value .value .memory != NULL) TA_Free( _state.value .value .memory );
         TA_Free( _state.value ); _state.value = NULL;}
      return RetCode.Success ;
   }
   public RetCode mult( int startIdx,
      int endIdx,
      float inReal0[],
      float inReal1[],
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      int outIdx;
      int i;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      for( i=startIdx, outIdx=0; i <= endIdx; i++, outIdx++ )
      {
         outReal[outIdx] = inReal0[i]*inReal1[i];
      }
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   /* Generated */
   public int natrLookback( int optInTimePeriod )
   {
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 14;
      else if( ((int)optInTimePeriod < 1) || ((int)optInTimePeriod > 100000) )
         return -1;
      return optInTimePeriod + (this.unstablePeriod[FuncUnstId.Natr.ordinal()]) ;
   }
   public RetCode natr( int startIdx,
      int endIdx,
      double inHigh[],
      double inLow[],
      double inClose[],
      int optInTimePeriod,
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      RetCode retCode;
      int outIdx, today, lookbackTotal;
      int nbATR;
      MInteger outBegIdx1 = new MInteger() ;
      MInteger outNbElement1 = new MInteger() ;
      double prevATR, tempValue;
      double []tempBuffer ;
      double []prevATRTemp = new double[1] ;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 14;
      else if( ((int)optInTimePeriod < 1) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      outBegIdx.value = 0 ;
      outNBElement.value = 0 ;
      lookbackTotal = natrLookback ( optInTimePeriod );
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
         return RetCode.Success ;
      if( optInTimePeriod <= 1 )
      {
         return trueRange ( startIdx, endIdx,
            inHigh, inLow, inClose,
            outBegIdx, outNBElement, outReal );
      }
      tempBuffer = new double[lookbackTotal+(endIdx-startIdx)+1] ;
      retCode = trueRange ( (startIdx-lookbackTotal+1), endIdx,
         inHigh, inLow, inClose,
         outBegIdx1 , outNbElement1 ,
         tempBuffer );
      if( retCode != RetCode.Success )
      {
         return retCode;
      }
      retCode = TA_INT_SMA ( optInTimePeriod-1,
         optInTimePeriod-1,
         tempBuffer, optInTimePeriod,
         outBegIdx1 , outNbElement1 ,
         prevATRTemp );
      if( retCode != RetCode.Success )
      {
         return retCode;
      }
      prevATR = prevATRTemp[0];
      today = optInTimePeriod;
      outIdx = (this.unstablePeriod[FuncUnstId.Natr.ordinal()]) ;
      while( outIdx != 0 )
      {
         prevATR *= optInTimePeriod - 1;
         prevATR += tempBuffer[today++];
         prevATR /= optInTimePeriod;
         outIdx--;
      }
      outIdx = 1;
      tempValue = inClose[today];
      if( ! (((- (0.00000000000001) )<tempValue)&&(tempValue< (0.00000000000001) )) )
         outReal[0] = (prevATR/tempValue)*100.0;
      else
         outReal[0] = 0.0;
      nbATR = (endIdx - startIdx)+1;
      while( --nbATR != 0 )
      {
         prevATR *= optInTimePeriod - 1;
         prevATR += tempBuffer[today++];
         prevATR /= optInTimePeriod;
         tempValue = inClose[today];
         if( ! (((- (0.00000000000001) )<tempValue)&&(tempValue< (0.00000000000001) )) )
            outReal[outIdx] = (prevATR/tempValue)*100.0;
         else
            outReal[0] = 0.0;
         outIdx++;
      }
      outBegIdx.value = startIdx;
      outNBElement.value = outIdx;
      return retCode;
   }
   public int natrStateInit( struct TA_natr_State** _state,
      int optInTimePeriod )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 14;
      else if( ((int)optInTimePeriod < 1) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct natr ));
      _state.value .value .mem_index = 0;
      _state.value .value .optInTimePeriod = optInTimePeriod;
      _state.value .value .mem_size = natrLookback (optInTimePeriod );
      if ( _state.value .value .mem_size > 0)
         _state.value .value .memory = TA_Calloc( _state.value .value .mem_size , sizeof(struct TA_NATR_Data));
      else
         _state.value .value .memory = NULL;
      return RetCode.Success ;
   }
   public int natrState( struct TA_natr_State* _state,
      double inHigh,
      double inLow,
      double inClose,
      double *outReal )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      size_t _cur_idx = _state.value .mem_index++;
      if ( _state.value .mem_size > 0) _cur_idx %= _state.value .mem_size ;
      if ( _state.value .mem_size > _state.value .mem_index - 1 ) {
         ( _state.value .memory+_cur_idx).value .inHigh = inHigh ;
         ( _state.value .memory+_cur_idx).value .inLow = inLow ;
         ( _state.value .memory+_cur_idx).value .inClose = inClose ;
         return RetCode.NeedMoreData ; }
      return RetCode.Success ;
   }
   public int natrStateFree( struct TA_natr_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if ( _state.value != NULL) {
         if ( _state.value .value .memory != NULL) TA_Free( _state.value .value .memory );
         TA_Free( _state.value ); _state.value = NULL;}
      return RetCode.Success ;
   }
   public RetCode natr( int startIdx,
      int endIdx,
      float inHigh[],
      float inLow[],
      float inClose[],
      int optInTimePeriod,
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      RetCode retCode;
      int outIdx, today, lookbackTotal;
      int nbATR;
      MInteger outBegIdx1 = new MInteger() ;
      MInteger outNbElement1 = new MInteger() ;
      double prevATR, tempValue;
      double []tempBuffer ;
      double []prevATRTemp = new double[1] ;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 14;
      else if( ((int)optInTimePeriod < 1) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      outBegIdx.value = 0 ;
      outNBElement.value = 0 ;
      lookbackTotal = natrLookback ( optInTimePeriod );
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
         return RetCode.Success ;
      if( optInTimePeriod <= 1 )
      {
         return trueRange ( startIdx, endIdx,
            inHigh, inLow, inClose,
            outBegIdx, outNBElement, outReal );
      }
      tempBuffer = new double[lookbackTotal+(endIdx-startIdx)+1] ;
      retCode = trueRange ( (startIdx-lookbackTotal+1), endIdx,
         inHigh, inLow, inClose,
         outBegIdx1 , outNbElement1 ,
         tempBuffer );
      if( retCode != RetCode.Success )
      {
         return retCode;
      }
      retCode = TA_INT_SMA ( optInTimePeriod-1,
         optInTimePeriod-1,
         tempBuffer, optInTimePeriod,
         outBegIdx1 , outNbElement1 ,
         prevATRTemp );
      if( retCode != RetCode.Success )
      {
         return retCode;
      }
      prevATR = prevATRTemp[0];
      today = optInTimePeriod;
      outIdx = (this.unstablePeriod[FuncUnstId.Natr.ordinal()]) ;
      while( outIdx != 0 )
      {
         prevATR *= optInTimePeriod - 1;
         prevATR += tempBuffer[today++];
         prevATR /= optInTimePeriod;
         outIdx--;
      }
      outIdx = 1;
      tempValue = inClose[today];
      if( ! (((- (0.00000000000001) )<tempValue)&&(tempValue< (0.00000000000001) )) )
         outReal[0] = (prevATR/tempValue)*100.0;
      else
         outReal[0] = 0.0;
      nbATR = (endIdx - startIdx)+1;
      while( --nbATR != 0 )
      {
         prevATR *= optInTimePeriod - 1;
         prevATR += tempBuffer[today++];
         prevATR /= optInTimePeriod;
         tempValue = inClose[today];
         if( ! (((- (0.00000000000001) )<tempValue)&&(tempValue< (0.00000000000001) )) )
            outReal[outIdx] = (prevATR/tempValue)*100.0;
         else
            outReal[0] = 0.0;
         outIdx++;
      }
      outBegIdx.value = startIdx;
      outNBElement.value = outIdx;
      return retCode;
   }
   /* Generated */
   public int obvLookback( )
   {
      return RetCode.Success ;
   }
   public RetCode obv( int startIdx,
      int endIdx,
      double inClose[],
      double inVolume[],
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      int i;
      int outIdx;
      double prevReal, tempReal, prevOBV;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      prevOBV = inVolume[startIdx];
      prevReal = inClose[startIdx];
      outIdx = 0;
      for(i=startIdx; i <= endIdx; i++ )
      {
         tempReal = inClose[i];
         if( tempReal > prevReal )
            prevOBV += inVolume[i];
         else if( tempReal < prevReal )
            prevOBV -= inVolume[i];
         outReal[outIdx++] = prevOBV;
         prevReal = tempReal;
      }
      outBegIdx.value = startIdx;
      outNBElement.value = outIdx;
      return RetCode.Success ;
   }
   public int obvStateInit( struct TA_obv_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct obv ));
      _state.value .value .mem_index = 0;
      _state.value .value .mem_size = obvLookback ();
      if ( _state.value .value .mem_size > 0)
         _state.value .value .memory = TA_Calloc( _state.value .value .mem_size , sizeof(struct TA_OBV_Data));
      else
         _state.value .value .memory = NULL;
      return RetCode.Success ;
   }
   public int obvState( struct TA_obv_State* _state,
      double inClose,
      double inVolume,
      double *outReal )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      size_t _cur_idx = _state.value .mem_index++;
      if ( _state.value .mem_size > 0) _cur_idx %= _state.value .mem_size ;
      if ( _state.value .mem_size > _state.value .mem_index - 1 ) {
         ( _state.value .memory+_cur_idx).value .inClose = inClose ;
         ( _state.value .memory+_cur_idx).value .inVolume = inVolume ;
         return RetCode.NeedMoreData ; }
      if ( ( _state.value .mem_index == 1) )
      {
         _state.value .prevOBV = inVolume;
         _state.value .prevReal = inClose;
      } else {
         if( inClose > _state.value .prevReal )
            _state.value .prevOBV += inVolume;
         else if( inClose < _state.value .prevReal )
            _state.value .prevOBV -= inVolume;
      }
      outReal.value = _state.value .prevOBV;
      _state.value .prevReal = inClose;
      return RetCode.Success ;
   }
   public int obvStateFree( struct TA_obv_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if ( _state.value != NULL) {
         if ( _state.value .value .memory != NULL) TA_Free( _state.value .value .memory );
         TA_Free( _state.value ); _state.value = NULL;}
      return RetCode.Success ;
   }
   public RetCode obv( int startIdx,
      int endIdx,
      float inClose[],
      float inVolume[],
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      int i;
      int outIdx;
      double prevReal, tempReal, prevOBV;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      prevOBV = inVolume[startIdx];
      prevReal = inClose[startIdx];
      outIdx = 0;
      for(i=startIdx; i <= endIdx; i++ )
      {
         tempReal = inClose[i];
         if( tempReal > prevReal )
            prevOBV += inVolume[i];
         else if( tempReal < prevReal )
            prevOBV -= inVolume[i];
         outReal[outIdx++] = prevOBV;
         prevReal = tempReal;
      }
      outBegIdx.value = startIdx;
      outNBElement.value = outIdx;
      return RetCode.Success ;
   }
   /* Generated */
   public int plusDILookback( int optInTimePeriod )
   {
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 14;
      else if( ((int)optInTimePeriod < 1) || ((int)optInTimePeriod > 100000) )
         return -1;
      if( optInTimePeriod > 1 )
         return optInTimePeriod + (this.unstablePeriod[FuncUnstId.PlusDI.ordinal()]) ;
      else
         return 1;
   }
   public RetCode plusDI( int startIdx,
      int endIdx,
      double inHigh[],
      double inLow[],
      double inClose[],
      int optInTimePeriod,
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      int today, lookbackTotal, outIdx;
      double prevHigh, prevLow, prevClose;
      double prevPlusDM, prevTR;
      double tempReal, tempReal2, diffP, diffM;
      int i;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 14;
      else if( ((int)optInTimePeriod < 1) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      if( optInTimePeriod > 1 )
         lookbackTotal = optInTimePeriod + (this.unstablePeriod[FuncUnstId.PlusDI.ordinal()]) ;
      else
         lookbackTotal = 1;
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      outIdx = 0;
      if( optInTimePeriod <= 1 )
      {
         outBegIdx.value = startIdx;
         today = startIdx-1;
         prevHigh = inHigh[today];
         prevLow = inLow[today];
         prevClose = inClose[today];
         while( today < endIdx )
         {
            today++;
            tempReal = inHigh[today];
            diffP = tempReal-prevHigh;
            prevHigh = tempReal;
            tempReal = inLow[today];
            diffM = prevLow-tempReal;
            prevLow = tempReal;
            if( (diffP > 0) && (diffP > diffM) )
            {
               { tempReal = prevHigh-prevLow; tempReal2 = Math.abs (prevHigh-prevClose); if( tempReal2 > tempReal ) tempReal = tempReal2; tempReal2 = Math.abs (prevLow-prevClose); if( tempReal2 > tempReal ) tempReal = tempReal2; } ;
               if( (((- (0.00000000000001) )<tempReal)&&(tempReal< (0.00000000000001) )) )
                  outReal[outIdx++] = (double)0.0;
               else
                  outReal[outIdx++] = diffP/tempReal;
            }
            else
               outReal[outIdx++] = (double)0.0;
            prevClose = inClose[today];
         }
         outNBElement.value = outIdx;
         return RetCode.Success ;
      }
      outBegIdx.value = today = startIdx;
      prevPlusDM = 0.0;
      prevTR = 0.0;
      today = startIdx - lookbackTotal;
      prevHigh = inHigh[today];
      prevLow = inLow[today];
      prevClose = inClose[today];
      i = optInTimePeriod-1;
      while( i-- > 0 )
      {
         today++;
         tempReal = inHigh[today];
         diffP = tempReal-prevHigh;
         prevHigh = tempReal;
         tempReal = inLow[today];
         diffM = prevLow-tempReal;
         prevLow = tempReal;
         if( (diffP > 0) && (diffP > diffM) )
         {
            prevPlusDM += diffP;
         }
         { tempReal = prevHigh-prevLow; tempReal2 = Math.abs (prevHigh-prevClose); if( tempReal2 > tempReal ) tempReal = tempReal2; tempReal2 = Math.abs (prevLow-prevClose); if( tempReal2 > tempReal ) tempReal = tempReal2; } ;
         prevTR += tempReal;
         prevClose = inClose[today];
      }
      i = (this.unstablePeriod[FuncUnstId.PlusDI.ordinal()]) + 1;
      while( i-- != 0 )
      {
         today++;
         tempReal = inHigh[today];
         diffP = tempReal-prevHigh;
         prevHigh = tempReal;
         tempReal = inLow[today];
         diffM = prevLow-tempReal;
         prevLow = tempReal;
         if( (diffP > 0) && (diffP > diffM) )
         {
            prevPlusDM = prevPlusDM - (prevPlusDM/optInTimePeriod) + diffP;
         }
         else
         {
            prevPlusDM = prevPlusDM - (prevPlusDM/optInTimePeriod);
         }
         { tempReal = prevHigh-prevLow; tempReal2 = Math.abs (prevHigh-prevClose); if( tempReal2 > tempReal ) tempReal = tempReal2; tempReal2 = Math.abs (prevLow-prevClose); if( tempReal2 > tempReal ) tempReal = tempReal2; } ;
         prevTR = prevTR - (prevTR/optInTimePeriod) + tempReal;
         prevClose = inClose[today];
      }
      if( ! (((- (0.00000000000001) )<prevTR)&&(prevTR< (0.00000000000001) )) )
         outReal[0] = (100.0*(prevPlusDM/prevTR)) ;
      else
         outReal[0] = 0.0;
      outIdx = 1;
      while( today < endIdx )
      {
         today++;
         tempReal = inHigh[today];
         diffP = tempReal-prevHigh;
         prevHigh = tempReal;
         tempReal = inLow[today];
         diffM = prevLow-tempReal;
         prevLow = tempReal;
         if( (diffP > 0) && (diffP > diffM) )
         {
            prevPlusDM = prevPlusDM - (prevPlusDM/optInTimePeriod) + diffP;
         }
         else
         {
            prevPlusDM = prevPlusDM - (prevPlusDM/optInTimePeriod);
         }
         { tempReal = prevHigh-prevLow; tempReal2 = Math.abs (prevHigh-prevClose); if( tempReal2 > tempReal ) tempReal = tempReal2; tempReal2 = Math.abs (prevLow-prevClose); if( tempReal2 > tempReal ) tempReal = tempReal2; } ;
         prevTR = prevTR - (prevTR/optInTimePeriod) + tempReal;
         prevClose = inClose[today];
         if( ! (((- (0.00000000000001) )<prevTR)&&(prevTR< (0.00000000000001) )) )
            outReal[outIdx++] = (100.0*(prevPlusDM/prevTR)) ;
         else
            outReal[outIdx++] = 0.0;
      }
      outNBElement.value = outIdx;
      return RetCode.Success ;
   }
   public int plusDIStateInit( struct TA_plusDI_State** _state,
      int optInTimePeriod )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 14;
      else if( ((int)optInTimePeriod < 1) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct plusDI ));
      _state.value .value .mem_index = 0;
      _state.value .value .optInTimePeriod = optInTimePeriod;
      _state.value .value .mem_size = plusDILookback (optInTimePeriod );
      if ( _state.value .value .mem_size > 0)
         _state.value .value .memory = TA_Calloc( _state.value .value .mem_size , sizeof(struct TA_PLUS_DI_Data));
      else
         _state.value .value .memory = NULL;
      return RetCode.Success ;
   }
   public int plusDIState( struct TA_plusDI_State* _state,
      double inHigh,
      double inLow,
      double inClose,
      double *outReal )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      size_t _cur_idx = _state.value .mem_index++;
      if ( _state.value .mem_size > 0) _cur_idx %= _state.value .mem_size ;
      if ( _state.value .mem_size > _state.value .mem_index - 1 ) {
         ( _state.value .memory+_cur_idx).value .inHigh = inHigh ;
         ( _state.value .memory+_cur_idx).value .inLow = inLow ;
         ( _state.value .memory+_cur_idx).value .inClose = inClose ;
         return RetCode.NeedMoreData ; }
      return RetCode.Success ;
   }
   public int plusDIStateFree( struct TA_plusDI_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if ( _state.value != NULL) {
         if ( _state.value .value .memory != NULL) TA_Free( _state.value .value .memory );
         TA_Free( _state.value ); _state.value = NULL;}
      return RetCode.Success ;
   }
   public RetCode plusDI( int startIdx,
      int endIdx,
      float inHigh[],
      float inLow[],
      float inClose[],
      int optInTimePeriod,
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      int today, lookbackTotal, outIdx;
      double prevHigh, prevLow, prevClose;
      double prevPlusDM, prevTR;
      double tempReal, tempReal2, diffP, diffM;
      int i;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 14;
      else if( ((int)optInTimePeriod < 1) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      if( optInTimePeriod > 1 )
         lookbackTotal = optInTimePeriod + (this.unstablePeriod[FuncUnstId.PlusDI.ordinal()]) ;
      else
         lookbackTotal = 1;
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      outIdx = 0;
      if( optInTimePeriod <= 1 )
      {
         outBegIdx.value = startIdx;
         today = startIdx-1;
         prevHigh = inHigh[today];
         prevLow = inLow[today];
         prevClose = inClose[today];
         while( today < endIdx )
         {
            today++;
            tempReal = inHigh[today];
            diffP = tempReal-prevHigh;
            prevHigh = tempReal;
            tempReal = inLow[today];
            diffM = prevLow-tempReal;
            prevLow = tempReal;
            if( (diffP > 0) && (diffP > diffM) )
            {
               { tempReal = prevHigh-prevLow; tempReal2 = Math.abs (prevHigh-prevClose); if( tempReal2 > tempReal ) tempReal = tempReal2; tempReal2 = Math.abs (prevLow-prevClose); if( tempReal2 > tempReal ) tempReal = tempReal2; } ;
               if( (((- (0.00000000000001) )<tempReal)&&(tempReal< (0.00000000000001) )) )
                  outReal[outIdx++] = (double)0.0;
               else
                  outReal[outIdx++] = diffP/tempReal;
            }
            else
               outReal[outIdx++] = (double)0.0;
            prevClose = inClose[today];
         }
         outNBElement.value = outIdx;
         return RetCode.Success ;
      }
      outBegIdx.value = today = startIdx;
      prevPlusDM = 0.0;
      prevTR = 0.0;
      today = startIdx - lookbackTotal;
      prevHigh = inHigh[today];
      prevLow = inLow[today];
      prevClose = inClose[today];
      i = optInTimePeriod-1;
      while( i-- > 0 )
      {
         today++;
         tempReal = inHigh[today];
         diffP = tempReal-prevHigh;
         prevHigh = tempReal;
         tempReal = inLow[today];
         diffM = prevLow-tempReal;
         prevLow = tempReal;
         if( (diffP > 0) && (diffP > diffM) )
         {
            prevPlusDM += diffP;
         }
         { tempReal = prevHigh-prevLow; tempReal2 = Math.abs (prevHigh-prevClose); if( tempReal2 > tempReal ) tempReal = tempReal2; tempReal2 = Math.abs (prevLow-prevClose); if( tempReal2 > tempReal ) tempReal = tempReal2; } ;
         prevTR += tempReal;
         prevClose = inClose[today];
      }
      i = (this.unstablePeriod[FuncUnstId.PlusDI.ordinal()]) + 1;
      while( i-- != 0 )
      {
         today++;
         tempReal = inHigh[today];
         diffP = tempReal-prevHigh;
         prevHigh = tempReal;
         tempReal = inLow[today];
         diffM = prevLow-tempReal;
         prevLow = tempReal;
         if( (diffP > 0) && (diffP > diffM) )
         {
            prevPlusDM = prevPlusDM - (prevPlusDM/optInTimePeriod) + diffP;
         }
         else
         {
            prevPlusDM = prevPlusDM - (prevPlusDM/optInTimePeriod);
         }
         { tempReal = prevHigh-prevLow; tempReal2 = Math.abs (prevHigh-prevClose); if( tempReal2 > tempReal ) tempReal = tempReal2; tempReal2 = Math.abs (prevLow-prevClose); if( tempReal2 > tempReal ) tempReal = tempReal2; } ;
         prevTR = prevTR - (prevTR/optInTimePeriod) + tempReal;
         prevClose = inClose[today];
      }
      if( ! (((- (0.00000000000001) )<prevTR)&&(prevTR< (0.00000000000001) )) )
         outReal[0] = (100.0*(prevPlusDM/prevTR)) ;
      else
         outReal[0] = 0.0;
      outIdx = 1;
      while( today < endIdx )
      {
         today++;
         tempReal = inHigh[today];
         diffP = tempReal-prevHigh;
         prevHigh = tempReal;
         tempReal = inLow[today];
         diffM = prevLow-tempReal;
         prevLow = tempReal;
         if( (diffP > 0) && (diffP > diffM) )
         {
            prevPlusDM = prevPlusDM - (prevPlusDM/optInTimePeriod) + diffP;
         }
         else
         {
            prevPlusDM = prevPlusDM - (prevPlusDM/optInTimePeriod);
         }
         { tempReal = prevHigh-prevLow; tempReal2 = Math.abs (prevHigh-prevClose); if( tempReal2 > tempReal ) tempReal = tempReal2; tempReal2 = Math.abs (prevLow-prevClose); if( tempReal2 > tempReal ) tempReal = tempReal2; } ;
         prevTR = prevTR - (prevTR/optInTimePeriod) + tempReal;
         prevClose = inClose[today];
         if( ! (((- (0.00000000000001) )<prevTR)&&(prevTR< (0.00000000000001) )) )
            outReal[outIdx++] = (100.0*(prevPlusDM/prevTR)) ;
         else
            outReal[outIdx++] = 0.0;
      }
      outNBElement.value = outIdx;
      return RetCode.Success ;
   }
   /* Generated */
   public int plusDMLookback( int optInTimePeriod )
   {
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 14;
      else if( ((int)optInTimePeriod < 1) || ((int)optInTimePeriod > 100000) )
         return -1;
      if( optInTimePeriod > 1 )
         return optInTimePeriod + (this.unstablePeriod[FuncUnstId.PlusDM.ordinal()]) - 1;
      else
         return 1;
   }
   public RetCode plusDM( int startIdx,
      int endIdx,
      double inHigh[],
      double inLow[],
      int optInTimePeriod,
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      int today, lookbackTotal, outIdx;
      double prevHigh, prevLow, tempReal;
      double prevPlusDM;
      double diffP, diffM;
      int i;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 14;
      else if( ((int)optInTimePeriod < 1) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      if( optInTimePeriod > 1 )
         lookbackTotal = optInTimePeriod + (this.unstablePeriod[FuncUnstId.PlusDM.ordinal()]) - 1;
      else
         lookbackTotal = 1;
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      outIdx = 0;
      if( optInTimePeriod <= 1 )
      {
         outBegIdx.value = startIdx;
         today = startIdx-1;
         prevHigh = inHigh[today];
         prevLow = inLow[today];
         while( today < endIdx )
         {
            today++;
            tempReal = inHigh[today];
            diffP = tempReal-prevHigh;
            prevHigh = tempReal;
            tempReal = inLow[today];
            diffM = prevLow-tempReal;
            prevLow = tempReal;
            if( (diffP > 0) && (diffP > diffM) )
            {
               outReal[outIdx++] = diffP;
            }
            else
               outReal[outIdx++] = 0;
         }
         outNBElement.value = outIdx;
         return RetCode.Success ;
      }
      outBegIdx.value = startIdx;
      prevPlusDM = 0.0;
      today = startIdx - lookbackTotal;
      prevHigh = inHigh[today];
      prevLow = inLow[today];
      i = optInTimePeriod-1;
      while( i-- > 0 )
      {
         today++;
         tempReal = inHigh[today];
         diffP = tempReal-prevHigh;
         prevHigh = tempReal;
         tempReal = inLow[today];
         diffM = prevLow-tempReal;
         prevLow = tempReal;
         if( (diffP > 0) && (diffP > diffM) )
         {
            prevPlusDM += diffP;
         }
      }
      i = (this.unstablePeriod[FuncUnstId.PlusDM.ordinal()]) ;
      while( i-- != 0 )
      {
         today++;
         tempReal = inHigh[today];
         diffP = tempReal-prevHigh;
         prevHigh = tempReal;
         tempReal = inLow[today];
         diffM = prevLow-tempReal;
         prevLow = tempReal;
         if( (diffP > 0) && (diffP > diffM) )
         {
            prevPlusDM = prevPlusDM - (prevPlusDM/optInTimePeriod) + diffP;
         }
         else
         {
            prevPlusDM = prevPlusDM - (prevPlusDM/optInTimePeriod);
         }
      }
      outReal[0] = prevPlusDM;
      outIdx = 1;
      while( today < endIdx )
      {
         today++;
         tempReal = inHigh[today];
         diffP = tempReal-prevHigh;
         prevHigh = tempReal;
         tempReal = inLow[today];
         diffM = prevLow-tempReal;
         prevLow = tempReal;
         if( (diffP > 0) && (diffP > diffM) )
         {
            prevPlusDM = prevPlusDM - (prevPlusDM/optInTimePeriod) + diffP;
         }
         else
         {
            prevPlusDM = prevPlusDM - (prevPlusDM/optInTimePeriod);
         }
         outReal[outIdx++] = prevPlusDM;
      }
      outNBElement.value = outIdx;
      return RetCode.Success ;
   }
   public int plusDMStateInit( struct TA_plusDM_State** _state,
      int optInTimePeriod )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 14;
      else if( ((int)optInTimePeriod < 1) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct plusDM ));
      _state.value .value .mem_index = 0;
      _state.value .value .optInTimePeriod = optInTimePeriod;
      _state.value .value .mem_size = plusDMLookback (optInTimePeriod );
      if ( _state.value .value .mem_size > 0)
         _state.value .value .memory = TA_Calloc( _state.value .value .mem_size , sizeof(struct TA_PLUS_DM_Data));
      else
         _state.value .value .memory = NULL;
      return RetCode.Success ;
   }
   public int plusDMState( struct TA_plusDM_State* _state,
      double inHigh,
      double inLow,
      double *outReal )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      size_t _cur_idx = _state.value .mem_index++;
      if ( _state.value .mem_size > 0) _cur_idx %= _state.value .mem_size ;
      if ( _state.value .mem_size > _state.value .mem_index - 1 ) {
         ( _state.value .memory+_cur_idx).value .inHigh = inHigh ;
         ( _state.value .memory+_cur_idx).value .inLow = inLow ;
         return RetCode.NeedMoreData ; }
      return RetCode.Success ;
   }
   public int plusDMStateFree( struct TA_plusDM_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if ( _state.value != NULL) {
         if ( _state.value .value .memory != NULL) TA_Free( _state.value .value .memory );
         TA_Free( _state.value ); _state.value = NULL;}
      return RetCode.Success ;
   }
   public RetCode plusDM( int startIdx,
      int endIdx,
      float inHigh[],
      float inLow[],
      int optInTimePeriod,
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      int today, lookbackTotal, outIdx;
      double prevHigh, prevLow, tempReal;
      double prevPlusDM;
      double diffP, diffM;
      int i;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 14;
      else if( ((int)optInTimePeriod < 1) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      if( optInTimePeriod > 1 )
         lookbackTotal = optInTimePeriod + (this.unstablePeriod[FuncUnstId.PlusDM.ordinal()]) - 1;
      else
         lookbackTotal = 1;
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      outIdx = 0;
      if( optInTimePeriod <= 1 )
      {
         outBegIdx.value = startIdx;
         today = startIdx-1;
         prevHigh = inHigh[today];
         prevLow = inLow[today];
         while( today < endIdx )
         {
            today++;
            tempReal = inHigh[today];
            diffP = tempReal-prevHigh;
            prevHigh = tempReal;
            tempReal = inLow[today];
            diffM = prevLow-tempReal;
            prevLow = tempReal;
            if( (diffP > 0) && (diffP > diffM) )
            {
               outReal[outIdx++] = diffP;
            }
            else
               outReal[outIdx++] = 0;
         }
         outNBElement.value = outIdx;
         return RetCode.Success ;
      }
      outBegIdx.value = startIdx;
      prevPlusDM = 0.0;
      today = startIdx - lookbackTotal;
      prevHigh = inHigh[today];
      prevLow = inLow[today];
      i = optInTimePeriod-1;
      while( i-- > 0 )
      {
         today++;
         tempReal = inHigh[today];
         diffP = tempReal-prevHigh;
         prevHigh = tempReal;
         tempReal = inLow[today];
         diffM = prevLow-tempReal;
         prevLow = tempReal;
         if( (diffP > 0) && (diffP > diffM) )
         {
            prevPlusDM += diffP;
         }
      }
      i = (this.unstablePeriod[FuncUnstId.PlusDM.ordinal()]) ;
      while( i-- != 0 )
      {
         today++;
         tempReal = inHigh[today];
         diffP = tempReal-prevHigh;
         prevHigh = tempReal;
         tempReal = inLow[today];
         diffM = prevLow-tempReal;
         prevLow = tempReal;
         if( (diffP > 0) && (diffP > diffM) )
         {
            prevPlusDM = prevPlusDM - (prevPlusDM/optInTimePeriod) + diffP;
         }
         else
         {
            prevPlusDM = prevPlusDM - (prevPlusDM/optInTimePeriod);
         }
      }
      outReal[0] = prevPlusDM;
      outIdx = 1;
      while( today < endIdx )
      {
         today++;
         tempReal = inHigh[today];
         diffP = tempReal-prevHigh;
         prevHigh = tempReal;
         tempReal = inLow[today];
         diffM = prevLow-tempReal;
         prevLow = tempReal;
         if( (diffP > 0) && (diffP > diffM) )
         {
            prevPlusDM = prevPlusDM - (prevPlusDM/optInTimePeriod) + diffP;
         }
         else
         {
            prevPlusDM = prevPlusDM - (prevPlusDM/optInTimePeriod);
         }
         outReal[outIdx++] = prevPlusDM;
      }
      outNBElement.value = outIdx;
      return RetCode.Success ;
   }
   /* Generated */
   public int ppoLookback( int optInFastPeriod,
      int optInSlowPeriod,
      MAType optInMAType )
   {
      if( (int)optInFastPeriod == ( Integer.MIN_VALUE ) )
         optInFastPeriod = 12;
      else if( ((int)optInFastPeriod < 2) || ((int)optInFastPeriod > 100000) )
         return -1;
      if( (int)optInSlowPeriod == ( Integer.MIN_VALUE ) )
         optInSlowPeriod = 26;
      else if( ((int)optInSlowPeriod < 2) || ((int)optInSlowPeriod > 100000) )
         return -1;
      return movingAverageLookback ( (((optInSlowPeriod) > (optInFastPeriod)) ? (optInSlowPeriod) : (optInFastPeriod)) , optInMAType );
   }
   public RetCode ppo( int startIdx,
      int endIdx,
      double inReal[],
      int optInFastPeriod,
      int optInSlowPeriod,
      MAType optInMAType, MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      double []tempBuffer ;
      RetCode retCode;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      if( (int)optInFastPeriod == ( Integer.MIN_VALUE ) )
         optInFastPeriod = 12;
      else if( ((int)optInFastPeriod < 2) || ((int)optInFastPeriod > 100000) )
         return RetCode.BadParam ;
      if( (int)optInSlowPeriod == ( Integer.MIN_VALUE ) )
         optInSlowPeriod = 26;
      else if( ((int)optInSlowPeriod < 2) || ((int)optInSlowPeriod > 100000) )
         return RetCode.BadParam ;
      tempBuffer = new double[endIdx-startIdx+1] ;
      retCode = TA_INT_PO ( startIdx, endIdx, inReal,
         optInFastPeriod,
         optInSlowPeriod,
         optInMAType,
         outBegIdx,
         outNBElement,
         outReal,
         tempBuffer,
         1 );
      return retCode;
   }
   public int ppoStateInit( struct TA_ppo_State** _state,
      int optInFastPeriod,
      int optInSlowPeriod,
      MAType optInMAType )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if( (int)optInFastPeriod == ( Integer.MIN_VALUE ) )
         optInFastPeriod = 12;
      else if( ((int)optInFastPeriod < 2) || ((int)optInFastPeriod > 100000) )
         return RetCode.BadParam ;
      if( (int)optInSlowPeriod == ( Integer.MIN_VALUE ) )
         optInSlowPeriod = 26;
      else if( ((int)optInSlowPeriod < 2) || ((int)optInSlowPeriod > 100000) )
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct ppo ));
      _state.value .value .mem_index = 0;
      _state.value .value .optInFastPeriod = optInFastPeriod;
      _state.value .value .optInSlowPeriod = optInSlowPeriod;
      _state.value .value .optInMAType = optInMAType;
      _state.value .value .mem_size = ppoLookback (optInFastPeriod, optInSlowPeriod, optInMAType );
      if ( _state.value .value .mem_size > 0)
         _state.value .value .memory = TA_Calloc( _state.value .value .mem_size , sizeof(struct TA_PPO_Data));
      else
         _state.value .value .memory = NULL;
      return RetCode.Success ;
   }
   public int ppoState( struct TA_ppo_State* _state,
      double inReal,
      double *outReal )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      size_t _cur_idx = _state.value .mem_index++;
      if ( _state.value .mem_size > 0) _cur_idx %= _state.value .mem_size ;
      if ( _state.value .mem_size > _state.value .mem_index - 1 ) {
         ( _state.value .memory+_cur_idx).value .inReal = inReal ;
         return RetCode.NeedMoreData ; }
      return RetCode.Success ;
   }
   public int ppoStateFree( struct TA_ppo_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if ( _state.value != NULL) {
         if ( _state.value .value .memory != NULL) TA_Free( _state.value .value .memory );
         TA_Free( _state.value ); _state.value = NULL;}
      return RetCode.Success ;
   }
   public RetCode ppo( int startIdx,
      int endIdx,
      float inReal[],
      int optInFastPeriod,
      int optInSlowPeriod,
      MAType optInMAType, MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      double []tempBuffer ;
      RetCode retCode;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      if( (int)optInFastPeriod == ( Integer.MIN_VALUE ) )
         optInFastPeriod = 12;
      else if( ((int)optInFastPeriod < 2) || ((int)optInFastPeriod > 100000) )
         return RetCode.BadParam ;
      if( (int)optInSlowPeriod == ( Integer.MIN_VALUE ) )
         optInSlowPeriod = 26;
      else if( ((int)optInSlowPeriod < 2) || ((int)optInSlowPeriod > 100000) )
         return RetCode.BadParam ;
      tempBuffer = new double[endIdx-startIdx+1] ;
      retCode = TA_INT_PO ( startIdx, endIdx, inReal,
         optInFastPeriod,
         optInSlowPeriod,
         optInMAType,
         outBegIdx,
         outNBElement,
         outReal,
         tempBuffer,
         1 );
      return retCode;
   }
   /* Generated */
   public int rocLookback( int optInTimePeriod )
   {
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 10;
      else if( ((int)optInTimePeriod < 1) || ((int)optInTimePeriod > 100000) )
         return -1;
      return optInTimePeriod;
   }
   public RetCode roc( int startIdx,
      int endIdx,
      double inReal[],
      int optInTimePeriod,
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      int inIdx, outIdx, trailingIdx;
      double tempReal;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 10;
      else if( ((int)optInTimePeriod < 1) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      if( startIdx < optInTimePeriod )
         startIdx = optInTimePeriod;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      outIdx = 0;
      inIdx = startIdx;
      trailingIdx = startIdx - optInTimePeriod;
      while( inIdx <= endIdx )
      {
         tempReal = inReal[trailingIdx++];
         if( tempReal != 0.0 )
            outReal[outIdx++] = ((inReal[inIdx] / tempReal)-1.0)*100.0;
         else
            outReal[outIdx++] = 0.0;
         inIdx++;
      }
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   public int rocStateInit( struct TA_roc_State** _state,
      int optInTimePeriod )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 10;
      else if( ((int)optInTimePeriod < 1) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct roc ));
      _state.value .value .mem_index = 0;
      _state.value .value .optInTimePeriod = optInTimePeriod;
      _state.value .value .mem_size = rocLookback (optInTimePeriod );
      if ( _state.value .value .mem_size > 0)
         _state.value .value .memory = TA_Calloc( _state.value .value .mem_size , sizeof(struct TA_ROC_Data));
      else
         _state.value .value .memory = NULL;
      return RetCode.Success ;
   }
   public int rocState( struct TA_roc_State* _state,
      double inReal,
      double *outReal )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      size_t _cur_idx = _state.value .mem_index++;
      if ( _state.value .mem_size > 0) _cur_idx %= _state.value .mem_size ;
      if ( _state.value .mem_size > _state.value .mem_index - 1 ) {
         ( _state.value .memory+_cur_idx).value .inReal = inReal ;
         return RetCode.NeedMoreData ; }
      return RetCode.Success ;
   }
   public int rocStateFree( struct TA_roc_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if ( _state.value != NULL) {
         if ( _state.value .value .memory != NULL) TA_Free( _state.value .value .memory );
         TA_Free( _state.value ); _state.value = NULL;}
      return RetCode.Success ;
   }
   public RetCode roc( int startIdx,
      int endIdx,
      float inReal[],
      int optInTimePeriod,
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      int inIdx, outIdx, trailingIdx;
      double tempReal;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 10;
      else if( ((int)optInTimePeriod < 1) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      if( startIdx < optInTimePeriod )
         startIdx = optInTimePeriod;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      outIdx = 0;
      inIdx = startIdx;
      trailingIdx = startIdx - optInTimePeriod;
      while( inIdx <= endIdx )
      {
         tempReal = inReal[trailingIdx++];
         if( tempReal != 0.0 )
            outReal[outIdx++] = ((inReal[inIdx] / tempReal)-1.0)*100.0;
         else
            outReal[outIdx++] = 0.0;
         inIdx++;
      }
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   /* Generated */
   public int rocPLookback( int optInTimePeriod )
   {
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 10;
      else if( ((int)optInTimePeriod < 1) || ((int)optInTimePeriod > 100000) )
         return -1;
      return optInTimePeriod;
   }
   public RetCode rocP( int startIdx,
      int endIdx,
      double inReal[],
      int optInTimePeriod,
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      int inIdx, outIdx, trailingIdx;
      double tempReal;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 10;
      else if( ((int)optInTimePeriod < 1) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      if( startIdx < optInTimePeriod )
         startIdx = optInTimePeriod;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      outIdx = 0;
      inIdx = startIdx;
      trailingIdx = startIdx - optInTimePeriod;
      while( inIdx <= endIdx )
      {
         tempReal = inReal[trailingIdx++];
         if( tempReal != 0.0 )
            outReal[outIdx++] = (inReal[inIdx]-tempReal)/tempReal;
         else
            outReal[outIdx++] = 0.0;
         inIdx++;
      }
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   public int rocPStateInit( struct TA_rocP_State** _state,
      int optInTimePeriod )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 10;
      else if( ((int)optInTimePeriod < 1) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct rocP ));
      _state.value .value .mem_index = 0;
      _state.value .value .optInTimePeriod = optInTimePeriod;
      _state.value .value .mem_size = rocPLookback (optInTimePeriod );
      if ( _state.value .value .mem_size > 0)
         _state.value .value .memory = TA_Calloc( _state.value .value .mem_size , sizeof(struct TA_ROCP_Data));
      else
         _state.value .value .memory = NULL;
      return RetCode.Success ;
   }
   public int rocPState( struct TA_rocP_State* _state,
      double inReal,
      double *outReal )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      size_t _cur_idx = _state.value .mem_index++;
      if ( _state.value .mem_size > 0) _cur_idx %= _state.value .mem_size ;
      if ( _state.value .mem_size > _state.value .mem_index - 1 ) {
         ( _state.value .memory+_cur_idx).value .inReal = inReal ;
         return RetCode.NeedMoreData ; }
      return RetCode.Success ;
   }
   public int rocPStateFree( struct TA_rocP_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if ( _state.value != NULL) {
         if ( _state.value .value .memory != NULL) TA_Free( _state.value .value .memory );
         TA_Free( _state.value ); _state.value = NULL;}
      return RetCode.Success ;
   }
   public RetCode rocP( int startIdx,
      int endIdx,
      float inReal[],
      int optInTimePeriod,
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      int inIdx, outIdx, trailingIdx;
      double tempReal;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 10;
      else if( ((int)optInTimePeriod < 1) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      if( startIdx < optInTimePeriod )
         startIdx = optInTimePeriod;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      outIdx = 0;
      inIdx = startIdx;
      trailingIdx = startIdx - optInTimePeriod;
      while( inIdx <= endIdx )
      {
         tempReal = inReal[trailingIdx++];
         if( tempReal != 0.0 )
            outReal[outIdx++] = (inReal[inIdx]-tempReal)/tempReal;
         else
            outReal[outIdx++] = 0.0;
         inIdx++;
      }
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   /* Generated */
   public int rocRLookback( int optInTimePeriod )
   {
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 10;
      else if( ((int)optInTimePeriod < 1) || ((int)optInTimePeriod > 100000) )
         return -1;
      return optInTimePeriod;
   }
   public RetCode rocR( int startIdx,
      int endIdx,
      double inReal[],
      int optInTimePeriod,
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      int inIdx, outIdx, trailingIdx;
      double tempReal;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 10;
      else if( ((int)optInTimePeriod < 1) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      if( startIdx < optInTimePeriod )
         startIdx = optInTimePeriod;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      outIdx = 0;
      inIdx = startIdx;
      trailingIdx = startIdx - optInTimePeriod;
      while( inIdx <= endIdx )
      {
         tempReal = inReal[trailingIdx++];
         if( tempReal != 0.0 )
            outReal[outIdx++] = (inReal[inIdx] / tempReal);
         else
            outReal[outIdx++] = 0.0;
         inIdx++;
      }
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   public int rocRStateInit( struct TA_rocR_State** _state,
      int optInTimePeriod )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 10;
      else if( ((int)optInTimePeriod < 1) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct rocR ));
      _state.value .value .mem_index = 0;
      _state.value .value .optInTimePeriod = optInTimePeriod;
      _state.value .value .mem_size = rocRLookback (optInTimePeriod );
      if ( _state.value .value .mem_size > 0)
         _state.value .value .memory = TA_Calloc( _state.value .value .mem_size , sizeof(struct TA_ROCR_Data));
      else
         _state.value .value .memory = NULL;
      return RetCode.Success ;
   }
   public int rocRState( struct TA_rocR_State* _state,
      double inReal,
      double *outReal )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      size_t _cur_idx = _state.value .mem_index++;
      if ( _state.value .mem_size > 0) _cur_idx %= _state.value .mem_size ;
      if ( _state.value .mem_size > _state.value .mem_index - 1 ) {
         ( _state.value .memory+_cur_idx).value .inReal = inReal ;
         return RetCode.NeedMoreData ; }
      return RetCode.Success ;
   }
   public int rocRStateFree( struct TA_rocR_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if ( _state.value != NULL) {
         if ( _state.value .value .memory != NULL) TA_Free( _state.value .value .memory );
         TA_Free( _state.value ); _state.value = NULL;}
      return RetCode.Success ;
   }
   public RetCode rocR( int startIdx,
      int endIdx,
      float inReal[],
      int optInTimePeriod,
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      int inIdx, outIdx, trailingIdx;
      double tempReal;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 10;
      else if( ((int)optInTimePeriod < 1) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      if( startIdx < optInTimePeriod )
         startIdx = optInTimePeriod;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      outIdx = 0;
      inIdx = startIdx;
      trailingIdx = startIdx - optInTimePeriod;
      while( inIdx <= endIdx )
      {
         tempReal = inReal[trailingIdx++];
         if( tempReal != 0.0 )
            outReal[outIdx++] = (inReal[inIdx] / tempReal);
         else
            outReal[outIdx++] = 0.0;
         inIdx++;
      }
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   /* Generated */
   public int rocR100Lookback( int optInTimePeriod )
   {
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 10;
      else if( ((int)optInTimePeriod < 1) || ((int)optInTimePeriod > 100000) )
         return -1;
      return optInTimePeriod;
   }
   public RetCode rocR100( int startIdx,
      int endIdx,
      double inReal[],
      int optInTimePeriod,
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      int inIdx, outIdx, trailingIdx;
      double tempReal;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 10;
      else if( ((int)optInTimePeriod < 1) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      if( startIdx < optInTimePeriod )
         startIdx = optInTimePeriod;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      outIdx = 0;
      inIdx = startIdx;
      trailingIdx = startIdx - optInTimePeriod;
      while( inIdx <= endIdx )
      {
         tempReal = inReal[trailingIdx++];
         if( tempReal != 0.0 )
            outReal[outIdx++] = (inReal[inIdx] / tempReal)*100.0;
         else
            outReal[outIdx++] = 0.0;
         inIdx++;
      }
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   public int rocR100StateInit( struct TA_rocR100_State** _state,
      int optInTimePeriod )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 10;
      else if( ((int)optInTimePeriod < 1) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct rocR100 ));
      _state.value .value .mem_index = 0;
      _state.value .value .optInTimePeriod = optInTimePeriod;
      _state.value .value .mem_size = rocR100Lookback (optInTimePeriod );
      if ( _state.value .value .mem_size > 0)
         _state.value .value .memory = TA_Calloc( _state.value .value .mem_size , sizeof(struct TA_ROCR100_Data));
      else
         _state.value .value .memory = NULL;
      return RetCode.Success ;
   }
   public int rocR100State( struct TA_rocR100_State* _state,
      double inReal,
      double *outReal )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      size_t _cur_idx = _state.value .mem_index++;
      if ( _state.value .mem_size > 0) _cur_idx %= _state.value .mem_size ;
      if ( _state.value .mem_size > _state.value .mem_index - 1 ) {
         ( _state.value .memory+_cur_idx).value .inReal = inReal ;
         return RetCode.NeedMoreData ; }
      return RetCode.Success ;
   }
   public int rocR100StateFree( struct TA_rocR100_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if ( _state.value != NULL) {
         if ( _state.value .value .memory != NULL) TA_Free( _state.value .value .memory );
         TA_Free( _state.value ); _state.value = NULL;}
      return RetCode.Success ;
   }
   public RetCode rocR100( int startIdx,
      int endIdx,
      float inReal[],
      int optInTimePeriod,
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      int inIdx, outIdx, trailingIdx;
      double tempReal;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 10;
      else if( ((int)optInTimePeriod < 1) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      if( startIdx < optInTimePeriod )
         startIdx = optInTimePeriod;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      outIdx = 0;
      inIdx = startIdx;
      trailingIdx = startIdx - optInTimePeriod;
      while( inIdx <= endIdx )
      {
         tempReal = inReal[trailingIdx++];
         if( tempReal != 0.0 )
            outReal[outIdx++] = (inReal[inIdx] / tempReal)*100.0;
         else
            outReal[outIdx++] = 0.0;
         inIdx++;
      }
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   /* Generated */
   public int rsiLookback( int optInTimePeriod )
   {
      int retValue;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 14;
      else if( ((int)optInTimePeriod < 2) || ((int)optInTimePeriod > 100000) )
         return -1;
      retValue = optInTimePeriod + (this.unstablePeriod[FuncUnstId.Rsi.ordinal()]) ;
      if( (this.compatibility) == Compatibility.Metastock )
         retValue--;
      return retValue;
   }
   public RetCode rsi( int startIdx,
      int endIdx,
      double inReal[],
      int optInTimePeriod,
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      int outIdx;
      int today, lookbackTotal, unstablePeriod, i;
      double prevGain, prevLoss, prevValue, savePrevValue;
      double tempValue1, tempValue2;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 14;
      else if( ((int)optInTimePeriod < 2) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      outBegIdx.value = 0 ;
      outNBElement.value = 0 ;
      lookbackTotal = rsiLookback ( optInTimePeriod );
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
         return RetCode.Success ;
      outIdx = 0;
      if( optInTimePeriod == 1 )
      {
         outBegIdx.value = startIdx;
         i = (endIdx-startIdx)+1;
         outNBElement.value = i;
         System.arraycopy(inReal,startIdx,outReal,0,i) ;
         return RetCode.Success ;
      }
      today = startIdx-lookbackTotal;
      prevValue = inReal[today];
      unstablePeriod = (this.unstablePeriod[FuncUnstId.Rsi.ordinal()]) ;
      if( (unstablePeriod == 0) &&
         ( (this.compatibility) == Compatibility.Metastock ))
      {
         savePrevValue = prevValue;
         prevGain = 0.0;
         prevLoss = 0.0;
         for( i=optInTimePeriod; i > 0; i-- )
         {
            tempValue1 = inReal[today++];
            tempValue2 = tempValue1 - prevValue;
            prevValue = tempValue1;
            if( tempValue2 < 0 )
               prevLoss -= tempValue2;
            else
               prevGain += tempValue2;
         }
         tempValue1 = prevLoss/optInTimePeriod;
         tempValue2 = prevGain/optInTimePeriod;
         tempValue1 = tempValue2+tempValue1;
         if( ! (((- (0.00000000000001) )<tempValue1)&&(tempValue1< (0.00000000000001) )) )
            outReal[outIdx++] = 100*(tempValue2/tempValue1);
         else
            outReal[outIdx++] = 0.0;
         if( today > endIdx )
         {
            outBegIdx.value = startIdx;
            outNBElement.value = outIdx;
            return RetCode.Success ;
         }
         today -= optInTimePeriod;
         prevValue = savePrevValue;
      }
      prevGain = 0.0;
      prevLoss = 0.0;
      today++;
      for( i=optInTimePeriod; i > 0; i-- )
      {
         tempValue1 = inReal[today++];
         tempValue2 = tempValue1 - prevValue;
         prevValue = tempValue1;
         if( tempValue2 < 0 )
            prevLoss -= tempValue2;
         else
            prevGain += tempValue2;
      }
      prevLoss /= optInTimePeriod;
      prevGain /= optInTimePeriod;
      if( today > startIdx )
      {
         tempValue1 = prevGain+prevLoss;
         if( ! (((- (0.00000000000001) )<tempValue1)&&(tempValue1< (0.00000000000001) )) )
            outReal[outIdx++] = 100.0*(prevGain/tempValue1);
         else
            outReal[outIdx++] = 0.0;
      }
      else
      {
         while( today < startIdx )
         {
            tempValue1 = inReal[today];
            tempValue2 = tempValue1 - prevValue;
            prevValue = tempValue1;
            prevLoss *= (optInTimePeriod-1);
            prevGain *= (optInTimePeriod-1);
            if( tempValue2 < 0 )
               prevLoss -= tempValue2;
            else
               prevGain += tempValue2;
            prevLoss /= optInTimePeriod;
            prevGain /= optInTimePeriod;
            today++;
         }
      }
      while( today <= endIdx )
      {
         tempValue1 = inReal[today++];
         tempValue2 = tempValue1 - prevValue;
         prevValue = tempValue1;
         prevLoss *= (optInTimePeriod-1);
         prevGain *= (optInTimePeriod-1);
         if( tempValue2 < 0 )
            prevLoss -= tempValue2;
         else
            prevGain += tempValue2;
         prevLoss /= optInTimePeriod;
         prevGain /= optInTimePeriod;
         tempValue1 = prevGain+prevLoss;
         if( ! (((- (0.00000000000001) )<tempValue1)&&(tempValue1< (0.00000000000001) )) )
            outReal[outIdx++] = 100.0*(prevGain/tempValue1);
         else
            outReal[outIdx++] = 0.0;
      }
      outBegIdx.value = startIdx;
      outNBElement.value = outIdx;
      return RetCode.Success ;
   }
   public int rsiStateInit( struct TA_rsi_State** _state,
      int optInTimePeriod )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 14;
      else if( ((int)optInTimePeriod < 2) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct rsi ));
      _state.value .value .mem_index = 0;
      _state.value .value .optInTimePeriod = optInTimePeriod;
      _state.value .value .mem_size = rsiLookback (optInTimePeriod );
      if ( _state.value .value .mem_size > 0)
         _state.value .value .memory = TA_Calloc( _state.value .value .mem_size , sizeof(struct TA_RSI_Data));
      else
         _state.value .value .memory = NULL;
      return RetCode.Success ;
   }
   public int rsiState( struct TA_rsi_State* _state,
      double inReal,
      double *outReal )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      size_t _cur_idx = _state.value .mem_index++;
      if ( _state.value .mem_size > 0) _cur_idx %= _state.value .mem_size ;
      if ( _state.value .mem_size > _state.value .mem_index - 1 ) {
         ( _state.value .memory+_cur_idx).value .inReal = inReal ;
         return RetCode.NeedMoreData ; }
      return RetCode.Success ;
   }
   public int rsiStateFree( struct TA_rsi_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if ( _state.value != NULL) {
         if ( _state.value .value .memory != NULL) TA_Free( _state.value .value .memory );
         TA_Free( _state.value ); _state.value = NULL;}
      return RetCode.Success ;
   }
   public RetCode rsi( int startIdx,
      int endIdx,
      float inReal[],
      int optInTimePeriod,
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      int outIdx;
      int today, lookbackTotal, unstablePeriod, i;
      double prevGain, prevLoss, prevValue, savePrevValue;
      double tempValue1, tempValue2;
      int mmmixi, mmmixdestIdx, mmmixsrcIdx ;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 14;
      else if( ((int)optInTimePeriod < 2) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      outBegIdx.value = 0 ;
      outNBElement.value = 0 ;
      lookbackTotal = rsiLookback ( optInTimePeriod );
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
         return RetCode.Success ;
      outIdx = 0;
      if( optInTimePeriod == 1 )
      {
         outBegIdx.value = startIdx;
         i = (endIdx-startIdx)+1;
         outNBElement.value = i;
         { for( mmmixi=0, mmmixdestIdx=0, mmmixsrcIdx=startIdx; mmmixi < i; mmmixi++, mmmixdestIdx++, mmmixsrcIdx++ ) { outReal[mmmixdestIdx] = inReal[mmmixsrcIdx]; } } ;
         return RetCode.Success ;
      }
      today = startIdx-lookbackTotal;
      prevValue = inReal[today];
      unstablePeriod = (this.unstablePeriod[FuncUnstId.Rsi.ordinal()]) ;
      if( (unstablePeriod == 0) &&
         ( (this.compatibility) == Compatibility.Metastock ))
      {
         savePrevValue = prevValue;
         prevGain = 0.0;
         prevLoss = 0.0;
         for( i=optInTimePeriod; i > 0; i-- )
         {
            tempValue1 = inReal[today++];
            tempValue2 = tempValue1 - prevValue;
            prevValue = tempValue1;
            if( tempValue2 < 0 )
               prevLoss -= tempValue2;
            else
               prevGain += tempValue2;
         }
         tempValue1 = prevLoss/optInTimePeriod;
         tempValue2 = prevGain/optInTimePeriod;
         tempValue1 = tempValue2+tempValue1;
         if( ! (((- (0.00000000000001) )<tempValue1)&&(tempValue1< (0.00000000000001) )) )
            outReal[outIdx++] = 100*(tempValue2/tempValue1);
         else
            outReal[outIdx++] = 0.0;
         if( today > endIdx )
         {
            outBegIdx.value = startIdx;
            outNBElement.value = outIdx;
            return RetCode.Success ;
         }
         today -= optInTimePeriod;
         prevValue = savePrevValue;
      }
      prevGain = 0.0;
      prevLoss = 0.0;
      today++;
      for( i=optInTimePeriod; i > 0; i-- )
      {
         tempValue1 = inReal[today++];
         tempValue2 = tempValue1 - prevValue;
         prevValue = tempValue1;
         if( tempValue2 < 0 )
            prevLoss -= tempValue2;
         else
            prevGain += tempValue2;
      }
      prevLoss /= optInTimePeriod;
      prevGain /= optInTimePeriod;
      if( today > startIdx )
      {
         tempValue1 = prevGain+prevLoss;
         if( ! (((- (0.00000000000001) )<tempValue1)&&(tempValue1< (0.00000000000001) )) )
            outReal[outIdx++] = 100.0*(prevGain/tempValue1);
         else
            outReal[outIdx++] = 0.0;
      }
      else
      {
         while( today < startIdx )
         {
            tempValue1 = inReal[today];
            tempValue2 = tempValue1 - prevValue;
            prevValue = tempValue1;
            prevLoss *= (optInTimePeriod-1);
            prevGain *= (optInTimePeriod-1);
            if( tempValue2 < 0 )
               prevLoss -= tempValue2;
            else
               prevGain += tempValue2;
            prevLoss /= optInTimePeriod;
            prevGain /= optInTimePeriod;
            today++;
         }
      }
      while( today <= endIdx )
      {
         tempValue1 = inReal[today++];
         tempValue2 = tempValue1 - prevValue;
         prevValue = tempValue1;
         prevLoss *= (optInTimePeriod-1);
         prevGain *= (optInTimePeriod-1);
         if( tempValue2 < 0 )
            prevLoss -= tempValue2;
         else
            prevGain += tempValue2;
         prevLoss /= optInTimePeriod;
         prevGain /= optInTimePeriod;
         tempValue1 = prevGain+prevLoss;
         if( ! (((- (0.00000000000001) )<tempValue1)&&(tempValue1< (0.00000000000001) )) )
            outReal[outIdx++] = 100.0*(prevGain/tempValue1);
         else
            outReal[outIdx++] = 0.0;
      }
      outBegIdx.value = startIdx;
      outNBElement.value = outIdx;
      return RetCode.Success ;
   }
   /* Generated */
   public int sarLookback( double optInAcceleration,
      double optInMaximum )
   {
      if( optInAcceleration == (-4e+37) )
         optInAcceleration = 2.000000e-2;
      else if( (optInAcceleration < 0.000000e+0) || (optInAcceleration > 3.000000e+37) )
         return -1;
      if( optInMaximum == (-4e+37) )
         optInMaximum = 2.000000e-1;
      else if( (optInMaximum < 0.000000e+0) || (optInMaximum > 3.000000e+37) )
         return -1;
      return 1;
   }
   public RetCode sar( int startIdx,
      int endIdx,
      double inHigh[],
      double inLow[],
      double optInAcceleration,
      double optInMaximum,
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      RetCode retCode;
      int isLong;
      int todayIdx, outIdx;
      MInteger tempInt = new MInteger() ;
      double newHigh, newLow, prevHigh, prevLow;
      double af, ep, sar;
      double []ep_temp = new double[1] ;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      if( optInAcceleration == (-4e+37) )
         optInAcceleration = 2.000000e-2;
      else if( (optInAcceleration < 0.000000e+0) || (optInAcceleration > 3.000000e+37) )
         return RetCode.BadParam ;
      if( optInMaximum == (-4e+37) )
         optInMaximum = 2.000000e-1;
      else if( (optInMaximum < 0.000000e+0) || (optInMaximum > 3.000000e+37) )
         return RetCode.BadParam ;
      if( startIdx < 1 )
         startIdx = 1;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      af = optInAcceleration;
      if( af > optInMaximum )
         af = optInAcceleration = optInMaximum;
      retCode = minusDM ( startIdx, startIdx, inHigh, inLow, 1,
         tempInt , tempInt ,
         ep_temp );
      if( ep_temp[0] > 0 )
         isLong = 0;
      else
         isLong = 1;
      if( retCode != RetCode.Success )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return retCode;
      }
      outBegIdx.value = startIdx;
      outIdx = 0;
      todayIdx = startIdx;
      newHigh = inHigh[todayIdx-1];
      newLow = inLow[todayIdx-1];
      if( isLong == 1 )
      {
         ep = inHigh[todayIdx];
         sar = newLow;
      }
      else
      {
         ep = inLow[todayIdx];
         sar = newHigh;
      }
      newLow = inLow[todayIdx];
      newHigh = inHigh[todayIdx];
      while( todayIdx <= endIdx )
      {
         prevLow = newLow;
         prevHigh = newHigh;
         newLow = inLow[todayIdx];
         newHigh = inHigh[todayIdx];
         todayIdx++;
         if( isLong == 1 )
         {
            if( newLow <= sar )
            {
               isLong = 0;
               sar = ep;
               if( sar < prevHigh )
                  sar = prevHigh;
               if( sar < newHigh )
                  sar = newHigh;
               outReal[outIdx++] = sar;
               af = optInAcceleration;
               ep = newLow;
               sar = sar + af * (ep - sar);
               if( sar < prevHigh )
                  sar = prevHigh;
               if( sar < newHigh )
                  sar = newHigh;
            }
            else
            {
               outReal[outIdx++] = sar;
               if( newHigh > ep )
               {
                  ep = newHigh;
                  af += optInAcceleration;
                  if( af > optInMaximum )
                     af = optInMaximum;
               }
               sar = sar + af * (ep - sar);
               if( sar > prevLow )
                  sar = prevLow;
               if( sar > newLow )
                  sar = newLow;
            }
         }
         else
         {
            if( newHigh >= sar )
            {
               isLong = 1;
               sar = ep;
               if( sar > prevLow )
                  sar = prevLow;
               if( sar > newLow )
                  sar = newLow;
               outReal[outIdx++] = sar;
               af = optInAcceleration;
               ep = newHigh;
               sar = sar + af * (ep - sar);
               if( sar > prevLow )
                  sar = prevLow;
               if( sar > newLow )
                  sar = newLow;
            }
            else
            {
               outReal[outIdx++] = sar;
               if( newLow < ep )
               {
                  ep = newLow;
                  af += optInAcceleration;
                  if( af > optInMaximum )
                     af = optInMaximum;
               }
               sar = sar + af * (ep - sar);
               if( sar < prevHigh )
                  sar = prevHigh;
               if( sar < newHigh )
                  sar = newHigh;
            }
         }
      }
      outNBElement.value = outIdx;
      return RetCode.Success ;
   }
   public int sarStateInit( struct TA_sar_State** _state,
      double optInAcceleration,
      double optInMaximum )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if( optInAcceleration == (-4e+37) )
         optInAcceleration = 2.000000e-2;
      else if( (optInAcceleration < 0.000000e+0) || (optInAcceleration > 3.000000e+37) )
         return RetCode.BadParam ;
      if( optInMaximum == (-4e+37) )
         optInMaximum = 2.000000e-1;
      else if( (optInMaximum < 0.000000e+0) || (optInMaximum > 3.000000e+37) )
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct sar ));
      _state.value .value .mem_index = 0;
      _state.value .value .optInAcceleration = optInAcceleration;
      _state.value .value .optInMaximum = optInMaximum;
      _state.value .value .mem_size = sarLookback (optInAcceleration, optInMaximum );
      if ( _state.value .value .mem_size > 0)
         _state.value .value .memory = TA_Calloc( _state.value .value .mem_size , sizeof(struct TA_SAR_Data));
      else
         _state.value .value .memory = NULL;
      return RetCode.Success ;
   }
   public int sarState( struct TA_sar_State* _state,
      double inHigh,
      double inLow,
      double *outReal )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      size_t _cur_idx = _state.value .mem_index++;
      if ( _state.value .mem_size > 0) _cur_idx %= _state.value .mem_size ;
      if ( _state.value .mem_size > _state.value .mem_index - 1 ) {
         ( _state.value .memory+_cur_idx).value .inHigh = inHigh ;
         ( _state.value .memory+_cur_idx).value .inLow = inLow ;
         return RetCode.NeedMoreData ; }
      return RetCode.Success ;
   }
   public int sarStateFree( struct TA_sar_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if ( _state.value != NULL) {
         if ( _state.value .value .memory != NULL) TA_Free( _state.value .value .memory );
         TA_Free( _state.value ); _state.value = NULL;}
      return RetCode.Success ;
   }
   public RetCode sar( int startIdx,
      int endIdx,
      float inHigh[],
      float inLow[],
      double optInAcceleration,
      double optInMaximum,
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      RetCode retCode;
      int isLong;
      int todayIdx, outIdx;
      MInteger tempInt = new MInteger() ;
      double newHigh, newLow, prevHigh, prevLow;
      double af, ep, sar;
      double []ep_temp = new double[1] ;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      if( optInAcceleration == (-4e+37) )
         optInAcceleration = 2.000000e-2;
      else if( (optInAcceleration < 0.000000e+0) || (optInAcceleration > 3.000000e+37) )
         return RetCode.BadParam ;
      if( optInMaximum == (-4e+37) )
         optInMaximum = 2.000000e-1;
      else if( (optInMaximum < 0.000000e+0) || (optInMaximum > 3.000000e+37) )
         return RetCode.BadParam ;
      if( startIdx < 1 )
         startIdx = 1;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      af = optInAcceleration;
      if( af > optInMaximum )
         af = optInAcceleration = optInMaximum;
      retCode = minusDM ( startIdx, startIdx, inHigh, inLow, 1,
         tempInt , tempInt ,
         ep_temp );
      if( ep_temp[0] > 0 )
         isLong = 0;
      else
         isLong = 1;
      if( retCode != RetCode.Success )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return retCode;
      }
      outBegIdx.value = startIdx;
      outIdx = 0;
      todayIdx = startIdx;
      newHigh = inHigh[todayIdx-1];
      newLow = inLow[todayIdx-1];
      if( isLong == 1 )
      {
         ep = inHigh[todayIdx];
         sar = newLow;
      }
      else
      {
         ep = inLow[todayIdx];
         sar = newHigh;
      }
      newLow = inLow[todayIdx];
      newHigh = inHigh[todayIdx];
      while( todayIdx <= endIdx )
      {
         prevLow = newLow;
         prevHigh = newHigh;
         newLow = inLow[todayIdx];
         newHigh = inHigh[todayIdx];
         todayIdx++;
         if( isLong == 1 )
         {
            if( newLow <= sar )
            {
               isLong = 0;
               sar = ep;
               if( sar < prevHigh )
                  sar = prevHigh;
               if( sar < newHigh )
                  sar = newHigh;
               outReal[outIdx++] = sar;
               af = optInAcceleration;
               ep = newLow;
               sar = sar + af * (ep - sar);
               if( sar < prevHigh )
                  sar = prevHigh;
               if( sar < newHigh )
                  sar = newHigh;
            }
            else
            {
               outReal[outIdx++] = sar;
               if( newHigh > ep )
               {
                  ep = newHigh;
                  af += optInAcceleration;
                  if( af > optInMaximum )
                     af = optInMaximum;
               }
               sar = sar + af * (ep - sar);
               if( sar > prevLow )
                  sar = prevLow;
               if( sar > newLow )
                  sar = newLow;
            }
         }
         else
         {
            if( newHigh >= sar )
            {
               isLong = 1;
               sar = ep;
               if( sar > prevLow )
                  sar = prevLow;
               if( sar > newLow )
                  sar = newLow;
               outReal[outIdx++] = sar;
               af = optInAcceleration;
               ep = newHigh;
               sar = sar + af * (ep - sar);
               if( sar > prevLow )
                  sar = prevLow;
               if( sar > newLow )
                  sar = newLow;
            }
            else
            {
               outReal[outIdx++] = sar;
               if( newLow < ep )
               {
                  ep = newLow;
                  af += optInAcceleration;
                  if( af > optInMaximum )
                     af = optInMaximum;
               }
               sar = sar + af * (ep - sar);
               if( sar < prevHigh )
                  sar = prevHigh;
               if( sar < newHigh )
                  sar = newHigh;
            }
         }
      }
      outNBElement.value = outIdx;
      return RetCode.Success ;
   }
   /* Generated */
   public int sarExtLookback( double optInStartValue,
      double optInOffsetOnReverse,
      double optInAccelerationInitLong,
      double optInAccelerationLong,
      double optInAccelerationMaxLong,
      double optInAccelerationInitShort,
      double optInAccelerationShort,
      double optInAccelerationMaxShort )
   {
      if( optInStartValue == (-4e+37) )
         optInStartValue = 0.000000e+0;
      else if( (optInStartValue < -3.000000e+37) || (optInStartValue > 3.000000e+37) )
         return -1;
      if( optInOffsetOnReverse == (-4e+37) )
         optInOffsetOnReverse = 0.000000e+0;
      else if( (optInOffsetOnReverse < 0.000000e+0) || (optInOffsetOnReverse > 3.000000e+37) )
         return -1;
      if( optInAccelerationInitLong == (-4e+37) )
         optInAccelerationInitLong = 2.000000e-2;
      else if( (optInAccelerationInitLong < 0.000000e+0) || (optInAccelerationInitLong > 3.000000e+37) )
         return -1;
      if( optInAccelerationLong == (-4e+37) )
         optInAccelerationLong = 2.000000e-2;
      else if( (optInAccelerationLong < 0.000000e+0) || (optInAccelerationLong > 3.000000e+37) )
         return -1;
      if( optInAccelerationMaxLong == (-4e+37) )
         optInAccelerationMaxLong = 2.000000e-1;
      else if( (optInAccelerationMaxLong < 0.000000e+0) || (optInAccelerationMaxLong > 3.000000e+37) )
         return -1;
      if( optInAccelerationInitShort == (-4e+37) )
         optInAccelerationInitShort = 2.000000e-2;
      else if( (optInAccelerationInitShort < 0.000000e+0) || (optInAccelerationInitShort > 3.000000e+37) )
         return -1;
      if( optInAccelerationShort == (-4e+37) )
         optInAccelerationShort = 2.000000e-2;
      else if( (optInAccelerationShort < 0.000000e+0) || (optInAccelerationShort > 3.000000e+37) )
         return -1;
      if( optInAccelerationMaxShort == (-4e+37) )
         optInAccelerationMaxShort = 2.000000e-1;
      else if( (optInAccelerationMaxShort < 0.000000e+0) || (optInAccelerationMaxShort > 3.000000e+37) )
         return -1;
      return 1;
   }
   public RetCode sarExt( int startIdx,
      int endIdx,
      double inHigh[],
      double inLow[],
      double optInStartValue,
      double optInOffsetOnReverse,
      double optInAccelerationInitLong,
      double optInAccelerationLong,
      double optInAccelerationMaxLong,
      double optInAccelerationInitShort,
      double optInAccelerationShort,
      double optInAccelerationMaxShort,
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      RetCode retCode;
      int isLong;
      int todayIdx, outIdx;
      MInteger tempInt = new MInteger() ;
      double newHigh, newLow, prevHigh, prevLow;
      double afLong, afShort, ep, sar;
      double []ep_temp = new double[1] ;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      if( optInStartValue == (-4e+37) )
         optInStartValue = 0.000000e+0;
      else if( (optInStartValue < -3.000000e+37) || (optInStartValue > 3.000000e+37) )
         return RetCode.BadParam ;
      if( optInOffsetOnReverse == (-4e+37) )
         optInOffsetOnReverse = 0.000000e+0;
      else if( (optInOffsetOnReverse < 0.000000e+0) || (optInOffsetOnReverse > 3.000000e+37) )
         return RetCode.BadParam ;
      if( optInAccelerationInitLong == (-4e+37) )
         optInAccelerationInitLong = 2.000000e-2;
      else if( (optInAccelerationInitLong < 0.000000e+0) || (optInAccelerationInitLong > 3.000000e+37) )
         return RetCode.BadParam ;
      if( optInAccelerationLong == (-4e+37) )
         optInAccelerationLong = 2.000000e-2;
      else if( (optInAccelerationLong < 0.000000e+0) || (optInAccelerationLong > 3.000000e+37) )
         return RetCode.BadParam ;
      if( optInAccelerationMaxLong == (-4e+37) )
         optInAccelerationMaxLong = 2.000000e-1;
      else if( (optInAccelerationMaxLong < 0.000000e+0) || (optInAccelerationMaxLong > 3.000000e+37) )
         return RetCode.BadParam ;
      if( optInAccelerationInitShort == (-4e+37) )
         optInAccelerationInitShort = 2.000000e-2;
      else if( (optInAccelerationInitShort < 0.000000e+0) || (optInAccelerationInitShort > 3.000000e+37) )
         return RetCode.BadParam ;
      if( optInAccelerationShort == (-4e+37) )
         optInAccelerationShort = 2.000000e-2;
      else if( (optInAccelerationShort < 0.000000e+0) || (optInAccelerationShort > 3.000000e+37) )
         return RetCode.BadParam ;
      if( optInAccelerationMaxShort == (-4e+37) )
         optInAccelerationMaxShort = 2.000000e-1;
      else if( (optInAccelerationMaxShort < 0.000000e+0) || (optInAccelerationMaxShort > 3.000000e+37) )
         return RetCode.BadParam ;
      if( startIdx < 1 )
         startIdx = 1;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      afLong = optInAccelerationInitLong;
      afShort = optInAccelerationInitShort;
      if( afLong > optInAccelerationMaxLong )
         afLong = optInAccelerationInitLong = optInAccelerationMaxLong;
      if( optInAccelerationLong > optInAccelerationMaxLong )
         optInAccelerationLong = optInAccelerationMaxLong;
      if( afShort > optInAccelerationMaxShort)
         afShort = optInAccelerationInitShort = optInAccelerationMaxShort;
      if( optInAccelerationShort > optInAccelerationMaxShort )
         optInAccelerationShort = optInAccelerationMaxShort;
      if(optInStartValue == 0)
      {
         retCode = minusDM ( startIdx, startIdx, inHigh, inLow, 1,
            tempInt , tempInt ,
            ep_temp );
         if( ep_temp[0] > 0 )
            isLong = 0;
         else
            isLong = 1;
         if( retCode != RetCode.Success )
         {
            outBegIdx.value = 0 ;
            outNBElement.value = 0 ;
            return retCode;
         }
      }
      else if( optInStartValue > 0 )
      {
         isLong = 1;
      }
      else
      {
         isLong = 0;
      }
      outBegIdx.value = startIdx;
      outIdx = 0;
      todayIdx = startIdx;
      newHigh = inHigh[todayIdx-1];
      newLow = inLow[todayIdx-1];
      if(optInStartValue == 0)
      {
         if( isLong == 1 )
         {
            ep = inHigh[todayIdx];
            sar = newLow;
         }
         else
         {
            ep = inLow[todayIdx];
            sar = newHigh;
         }
      }
      else if ( optInStartValue > 0 )
      {
         ep = inHigh[todayIdx];
         sar = optInStartValue;
      }
      else
      {
         ep = inLow[todayIdx];
         sar = Math.abs (optInStartValue);
      }
      newLow = inLow[todayIdx];
      newHigh = inHigh[todayIdx];
      while( todayIdx <= endIdx )
      {
         prevLow = newLow;
         prevHigh = newHigh;
         newLow = inLow[todayIdx];
         newHigh = inHigh[todayIdx];
         todayIdx++;
         if( isLong == 1 )
         {
            if( newLow <= sar )
            {
               isLong = 0;
               sar = ep;
               if( sar < prevHigh )
                  sar = prevHigh;
               if( sar < newHigh )
                  sar = newHigh;
               if( optInOffsetOnReverse != 0.0 )
                  sar += sar * optInOffsetOnReverse;
               outReal[outIdx++] = -sar;
               afShort = optInAccelerationInitShort;
               ep = newLow;
               sar = sar + afShort * (ep - sar);
               if( sar < prevHigh )
                  sar = prevHigh;
               if( sar < newHigh )
                  sar = newHigh;
            }
            else
            {
               outReal[outIdx++] = sar;
               if( newHigh > ep )
               {
                  ep = newHigh;
                  afLong += optInAccelerationLong;
                  if( afLong > optInAccelerationMaxLong )
                     afLong = optInAccelerationMaxLong;
               }
               sar = sar + afLong * (ep - sar);
               if( sar > prevLow )
                  sar = prevLow;
               if( sar > newLow )
                  sar = newLow;
            }
         }
         else
         {
            if( newHigh >= sar )
            {
               isLong = 1;
               sar = ep;
               if( sar > prevLow )
                  sar = prevLow;
               if( sar > newLow )
                  sar = newLow;
               if( optInOffsetOnReverse != 0.0 )
                  sar -= sar * optInOffsetOnReverse;
               outReal[outIdx++] = sar;
               afLong = optInAccelerationInitLong;
               ep = newHigh;
               sar = sar + afLong * (ep - sar);
               if( sar > prevLow )
                  sar = prevLow;
               if( sar > newLow )
                  sar = newLow;
            }
            else
            {
               outReal[outIdx++] = -sar;
               if( newLow < ep )
               {
                  ep = newLow;
                  afShort += optInAccelerationShort;
                  if( afShort > optInAccelerationMaxShort )
                     afShort = optInAccelerationMaxShort;
               }
               sar = sar + afShort * (ep - sar);
               if( sar < prevHigh )
                  sar = prevHigh;
               if( sar < newHigh )
                  sar = newHigh;
            }
         }
      }
      outNBElement.value = outIdx;
      return RetCode.Success ;
   }
   public int sarExtStateInit( struct TA_sarExt_State** _state,
      double optInStartValue,
      double optInOffsetOnReverse,
      double optInAccelerationInitLong,
      double optInAccelerationLong,
      double optInAccelerationMaxLong,
      double optInAccelerationInitShort,
      double optInAccelerationShort,
      double optInAccelerationMaxShort )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if( optInStartValue == (-4e+37) )
         optInStartValue = 0.000000e+0;
      else if( (optInStartValue < -3.000000e+37) || (optInStartValue > 3.000000e+37) )
         return RetCode.BadParam ;
      if( optInOffsetOnReverse == (-4e+37) )
         optInOffsetOnReverse = 0.000000e+0;
      else if( (optInOffsetOnReverse < 0.000000e+0) || (optInOffsetOnReverse > 3.000000e+37) )
         return RetCode.BadParam ;
      if( optInAccelerationInitLong == (-4e+37) )
         optInAccelerationInitLong = 2.000000e-2;
      else if( (optInAccelerationInitLong < 0.000000e+0) || (optInAccelerationInitLong > 3.000000e+37) )
         return RetCode.BadParam ;
      if( optInAccelerationLong == (-4e+37) )
         optInAccelerationLong = 2.000000e-2;
      else if( (optInAccelerationLong < 0.000000e+0) || (optInAccelerationLong > 3.000000e+37) )
         return RetCode.BadParam ;
      if( optInAccelerationMaxLong == (-4e+37) )
         optInAccelerationMaxLong = 2.000000e-1;
      else if( (optInAccelerationMaxLong < 0.000000e+0) || (optInAccelerationMaxLong > 3.000000e+37) )
         return RetCode.BadParam ;
      if( optInAccelerationInitShort == (-4e+37) )
         optInAccelerationInitShort = 2.000000e-2;
      else if( (optInAccelerationInitShort < 0.000000e+0) || (optInAccelerationInitShort > 3.000000e+37) )
         return RetCode.BadParam ;
      if( optInAccelerationShort == (-4e+37) )
         optInAccelerationShort = 2.000000e-2;
      else if( (optInAccelerationShort < 0.000000e+0) || (optInAccelerationShort > 3.000000e+37) )
         return RetCode.BadParam ;
      if( optInAccelerationMaxShort == (-4e+37) )
         optInAccelerationMaxShort = 2.000000e-1;
      else if( (optInAccelerationMaxShort < 0.000000e+0) || (optInAccelerationMaxShort > 3.000000e+37) )
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct sarExt ));
      _state.value .value .mem_index = 0;
      _state.value .value .optInStartValue = optInStartValue;
      _state.value .value .optInOffsetOnReverse = optInOffsetOnReverse;
      _state.value .value .optInAccelerationInitLong = optInAccelerationInitLong;
      _state.value .value .optInAccelerationLong = optInAccelerationLong;
      _state.value .value .optInAccelerationMaxLong = optInAccelerationMaxLong;
      _state.value .value .optInAccelerationInitShort = optInAccelerationInitShort;
      _state.value .value .optInAccelerationShort = optInAccelerationShort;
      _state.value .value .optInAccelerationMaxShort = optInAccelerationMaxShort;
      _state.value .value .mem_size = sarExtLookback (optInStartValue, optInOffsetOnReverse, optInAccelerationInitLong, optInAccelerationLong, optInAccelerationMaxLong, optInAccelerationInitShort, optInAccelerationShort, optInAccelerationMaxShort );
      if ( _state.value .value .mem_size > 0)
         _state.value .value .memory = TA_Calloc( _state.value .value .mem_size , sizeof(struct TA_SAREXT_Data));
      else
         _state.value .value .memory = NULL;
      return RetCode.Success ;
   }
   public int sarExtState( struct TA_sarExt_State* _state,
      double inHigh,
      double inLow,
      double *outReal )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      size_t _cur_idx = _state.value .mem_index++;
      if ( _state.value .mem_size > 0) _cur_idx %= _state.value .mem_size ;
      if ( _state.value .mem_size > _state.value .mem_index - 1 ) {
         ( _state.value .memory+_cur_idx).value .inHigh = inHigh ;
         ( _state.value .memory+_cur_idx).value .inLow = inLow ;
         return RetCode.NeedMoreData ; }
      return RetCode.Success ;
   }
   public int sarExtStateFree( struct TA_sarExt_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if ( _state.value != NULL) {
         if ( _state.value .value .memory != NULL) TA_Free( _state.value .value .memory );
         TA_Free( _state.value ); _state.value = NULL;}
      return RetCode.Success ;
   }
   public RetCode sarExt( int startIdx,
      int endIdx,
      float inHigh[],
      float inLow[],
      double optInStartValue,
      double optInOffsetOnReverse,
      double optInAccelerationInitLong,
      double optInAccelerationLong,
      double optInAccelerationMaxLong,
      double optInAccelerationInitShort,
      double optInAccelerationShort,
      double optInAccelerationMaxShort,
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      RetCode retCode;
      int isLong;
      int todayIdx, outIdx;
      MInteger tempInt = new MInteger() ;
      double newHigh, newLow, prevHigh, prevLow;
      double afLong, afShort, ep, sar;
      double []ep_temp = new double[1] ;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      if( optInStartValue == (-4e+37) )
         optInStartValue = 0.000000e+0;
      else if( (optInStartValue < -3.000000e+37) || (optInStartValue > 3.000000e+37) )
         return RetCode.BadParam ;
      if( optInOffsetOnReverse == (-4e+37) )
         optInOffsetOnReverse = 0.000000e+0;
      else if( (optInOffsetOnReverse < 0.000000e+0) || (optInOffsetOnReverse > 3.000000e+37) )
         return RetCode.BadParam ;
      if( optInAccelerationInitLong == (-4e+37) )
         optInAccelerationInitLong = 2.000000e-2;
      else if( (optInAccelerationInitLong < 0.000000e+0) || (optInAccelerationInitLong > 3.000000e+37) )
         return RetCode.BadParam ;
      if( optInAccelerationLong == (-4e+37) )
         optInAccelerationLong = 2.000000e-2;
      else if( (optInAccelerationLong < 0.000000e+0) || (optInAccelerationLong > 3.000000e+37) )
         return RetCode.BadParam ;
      if( optInAccelerationMaxLong == (-4e+37) )
         optInAccelerationMaxLong = 2.000000e-1;
      else if( (optInAccelerationMaxLong < 0.000000e+0) || (optInAccelerationMaxLong > 3.000000e+37) )
         return RetCode.BadParam ;
      if( optInAccelerationInitShort == (-4e+37) )
         optInAccelerationInitShort = 2.000000e-2;
      else if( (optInAccelerationInitShort < 0.000000e+0) || (optInAccelerationInitShort > 3.000000e+37) )
         return RetCode.BadParam ;
      if( optInAccelerationShort == (-4e+37) )
         optInAccelerationShort = 2.000000e-2;
      else if( (optInAccelerationShort < 0.000000e+0) || (optInAccelerationShort > 3.000000e+37) )
         return RetCode.BadParam ;
      if( optInAccelerationMaxShort == (-4e+37) )
         optInAccelerationMaxShort = 2.000000e-1;
      else if( (optInAccelerationMaxShort < 0.000000e+0) || (optInAccelerationMaxShort > 3.000000e+37) )
         return RetCode.BadParam ;
      if( startIdx < 1 )
         startIdx = 1;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      afLong = optInAccelerationInitLong;
      afShort = optInAccelerationInitShort;
      if( afLong > optInAccelerationMaxLong )
         afLong = optInAccelerationInitLong = optInAccelerationMaxLong;
      if( optInAccelerationLong > optInAccelerationMaxLong )
         optInAccelerationLong = optInAccelerationMaxLong;
      if( afShort > optInAccelerationMaxShort)
         afShort = optInAccelerationInitShort = optInAccelerationMaxShort;
      if( optInAccelerationShort > optInAccelerationMaxShort )
         optInAccelerationShort = optInAccelerationMaxShort;
      if(optInStartValue == 0)
      {
         retCode = minusDM ( startIdx, startIdx, inHigh, inLow, 1,
            tempInt , tempInt ,
            ep_temp );
         if( ep_temp[0] > 0 )
            isLong = 0;
         else
            isLong = 1;
         if( retCode != RetCode.Success )
         {
            outBegIdx.value = 0 ;
            outNBElement.value = 0 ;
            return retCode;
         }
      }
      else if( optInStartValue > 0 )
      {
         isLong = 1;
      }
      else
      {
         isLong = 0;
      }
      outBegIdx.value = startIdx;
      outIdx = 0;
      todayIdx = startIdx;
      newHigh = inHigh[todayIdx-1];
      newLow = inLow[todayIdx-1];
      if(optInStartValue == 0)
      {
         if( isLong == 1 )
         {
            ep = inHigh[todayIdx];
            sar = newLow;
         }
         else
         {
            ep = inLow[todayIdx];
            sar = newHigh;
         }
      }
      else if ( optInStartValue > 0 )
      {
         ep = inHigh[todayIdx];
         sar = optInStartValue;
      }
      else
      {
         ep = inLow[todayIdx];
         sar = Math.abs (optInStartValue);
      }
      newLow = inLow[todayIdx];
      newHigh = inHigh[todayIdx];
      while( todayIdx <= endIdx )
      {
         prevLow = newLow;
         prevHigh = newHigh;
         newLow = inLow[todayIdx];
         newHigh = inHigh[todayIdx];
         todayIdx++;
         if( isLong == 1 )
         {
            if( newLow <= sar )
            {
               isLong = 0;
               sar = ep;
               if( sar < prevHigh )
                  sar = prevHigh;
               if( sar < newHigh )
                  sar = newHigh;
               if( optInOffsetOnReverse != 0.0 )
                  sar += sar * optInOffsetOnReverse;
               outReal[outIdx++] = -sar;
               afShort = optInAccelerationInitShort;
               ep = newLow;
               sar = sar + afShort * (ep - sar);
               if( sar < prevHigh )
                  sar = prevHigh;
               if( sar < newHigh )
                  sar = newHigh;
            }
            else
            {
               outReal[outIdx++] = sar;
               if( newHigh > ep )
               {
                  ep = newHigh;
                  afLong += optInAccelerationLong;
                  if( afLong > optInAccelerationMaxLong )
                     afLong = optInAccelerationMaxLong;
               }
               sar = sar + afLong * (ep - sar);
               if( sar > prevLow )
                  sar = prevLow;
               if( sar > newLow )
                  sar = newLow;
            }
         }
         else
         {
            if( newHigh >= sar )
            {
               isLong = 1;
               sar = ep;
               if( sar > prevLow )
                  sar = prevLow;
               if( sar > newLow )
                  sar = newLow;
               if( optInOffsetOnReverse != 0.0 )
                  sar -= sar * optInOffsetOnReverse;
               outReal[outIdx++] = sar;
               afLong = optInAccelerationInitLong;
               ep = newHigh;
               sar = sar + afLong * (ep - sar);
               if( sar > prevLow )
                  sar = prevLow;
               if( sar > newLow )
                  sar = newLow;
            }
            else
            {
               outReal[outIdx++] = -sar;
               if( newLow < ep )
               {
                  ep = newLow;
                  afShort += optInAccelerationShort;
                  if( afShort > optInAccelerationMaxShort )
                     afShort = optInAccelerationMaxShort;
               }
               sar = sar + afShort * (ep - sar);
               if( sar < prevHigh )
                  sar = prevHigh;
               if( sar < newHigh )
                  sar = newHigh;
            }
         }
      }
      outNBElement.value = outIdx;
      return RetCode.Success ;
   }
   /* Generated */
   public int sinLookback( )
   {
      return RetCode.Success ;
   }
   public RetCode sin( int startIdx,
      int endIdx,
      double inReal[],
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      int outIdx;
      int i;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      for( i=startIdx, outIdx=0; i <= endIdx; i++, outIdx++ )
      {
         outReal[outIdx] = Math.sin (inReal[i]);
      }
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   public int sinStateInit( struct TA_sin_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct sin ));
      _state.value .value .mem_index = 0;
      _state.value .value .mem_size = sinLookback ();
      if ( _state.value .value .mem_size > 0)
         _state.value .value .memory = TA_Calloc( _state.value .value .mem_size , sizeof(struct TA_SIN_Data));
      else
         _state.value .value .memory = NULL;
      return RetCode.Success ;
   }
   public int sinState( struct TA_sin_State* _state,
      double inReal,
      double *outReal )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      size_t _cur_idx = _state.value .mem_index++;
      if ( _state.value .mem_size > 0) _cur_idx %= _state.value .mem_size ;
      if ( _state.value .mem_size > _state.value .mem_index - 1 ) {
         ( _state.value .memory+_cur_idx).value .inReal = inReal ;
         return RetCode.NeedMoreData ; }
      outReal.value = Math.sin (inReal);
      return RetCode.Success ;
   }
   public int sinStateFree( struct TA_sin_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if ( _state.value != NULL) {
         if ( _state.value .value .memory != NULL) TA_Free( _state.value .value .memory );
         TA_Free( _state.value ); _state.value = NULL;}
      return RetCode.Success ;
   }
   public RetCode sin( int startIdx,
      int endIdx,
      float inReal[],
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      int outIdx;
      int i;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      for( i=startIdx, outIdx=0; i <= endIdx; i++, outIdx++ )
      {
         outReal[outIdx] = Math.sin (inReal[i]);
      }
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   /* Generated */
   public int sinhLookback( )
   {
      return RetCode.Success ;
   }
   public RetCode sinh( int startIdx,
      int endIdx,
      double inReal[],
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      int outIdx;
      int i;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      for( i=startIdx, outIdx=0; i <= endIdx; i++, outIdx++ )
      {
         outReal[outIdx] = Math.sinh (inReal[i]);
      }
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   public int sinhStateInit( struct TA_sinh_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct sinh ));
      _state.value .value .mem_index = 0;
      _state.value .value .mem_size = sinhLookback ();
      if ( _state.value .value .mem_size > 0)
         _state.value .value .memory = TA_Calloc( _state.value .value .mem_size , sizeof(struct TA_SINH_Data));
      else
         _state.value .value .memory = NULL;
      return RetCode.Success ;
   }
   public int sinhState( struct TA_sinh_State* _state,
      double inReal,
      double *outReal )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      size_t _cur_idx = _state.value .mem_index++;
      if ( _state.value .mem_size > 0) _cur_idx %= _state.value .mem_size ;
      if ( _state.value .mem_size > _state.value .mem_index - 1 ) {
         ( _state.value .memory+_cur_idx).value .inReal = inReal ;
         return RetCode.NeedMoreData ; }
      outReal.value = Math.sinh (inReal);
      return RetCode.Success ;
   }
   public int sinhStateFree( struct TA_sinh_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if ( _state.value != NULL) {
         if ( _state.value .value .memory != NULL) TA_Free( _state.value .value .memory );
         TA_Free( _state.value ); _state.value = NULL;}
      return RetCode.Success ;
   }
   public RetCode sinh( int startIdx,
      int endIdx,
      float inReal[],
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      int outIdx;
      int i;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      for( i=startIdx, outIdx=0; i <= endIdx; i++, outIdx++ )
      {
         outReal[outIdx] = Math.sinh (inReal[i]);
      }
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   /* Generated */
   public int smaLookback( int optInTimePeriod )
   {
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 30;
      else if( ((int)optInTimePeriod < 2) || ((int)optInTimePeriod > 100000) )
         return -1;
      return optInTimePeriod - 1;
   }
   public RetCode sma( int startIdx,
      int endIdx,
      double inReal[],
      int optInTimePeriod,
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 30;
      else if( ((int)optInTimePeriod < 2) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      return TA_INT_SMA ( startIdx, endIdx,
         inReal, optInTimePeriod,
         outBegIdx, outNBElement, outReal );
   }
   RetCode TA_INT_SMA( int startIdx,
      int endIdx,
      double inReal[],
      int optInTimePeriod,
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      double periodTotal, tempReal;
      int i, outIdx, trailingIdx, lookbackTotal;
      lookbackTotal = (optInTimePeriod-1);
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      periodTotal = 0;
      trailingIdx = startIdx-lookbackTotal;
      i=trailingIdx;
      if( optInTimePeriod > 1 )
      {
         while( i < startIdx )
            periodTotal += inReal[i++];
      }
      outIdx = 0;
      do
      {
         periodTotal += inReal[i++];
         tempReal = periodTotal;
         periodTotal -= inReal[trailingIdx++];
         outReal[outIdx++] = tempReal / optInTimePeriod;
      } while( i <= endIdx );
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   public int smaStateInit( struct TA_sma_State** _state,
      int optInTimePeriod )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 30;
      else if( ((int)optInTimePeriod < 2) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct sma ));
      _state.value .value .mem_index = 0;
      _state.value .value .optInTimePeriod = optInTimePeriod;
      _state.value .value .mem_size = smaLookback (optInTimePeriod );
      if ( _state.value .value .mem_size > 0)
         _state.value .value .memory = TA_Calloc( _state.value .value .mem_size , sizeof(struct TA_SMA_Data));
      else
         _state.value .value .memory = NULL;
      return RetCode.Success ;
   }
   public int smaState( struct TA_sma_State* _state,
      double inReal,
      double *outReal )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      size_t _cur_idx = _state.value .mem_index++;
      if ( _state.value .mem_size > 0) _cur_idx %= _state.value .mem_size ;
      if ( ( _state.value .mem_index == 1) )
      {
         _state.value .periodTotal = 0;
      }
      if ( _state.value .mem_size > _state.value .mem_index - 1 ) {
         _state.value .periodTotal += inReal;
         ( _state.value .memory+_cur_idx).value .inReal = inReal ;
         return RetCode.NeedMoreData ; }
      _state.value .periodTotal += inReal;
      outReal.value = _state.value .periodTotal / _state.value .optInTimePeriod;
      _state.value .periodTotal -= ( _state.value .memory+_cur_idx).value .inReal ;
      ( _state.value .memory+_cur_idx).value .inReal = inReal ;
      return RetCode.Success ;
   }
   public int smaStateFree( struct TA_sma_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if ( _state.value != NULL) {
         if ( _state.value .value .memory != NULL) TA_Free( _state.value .value .memory );
         TA_Free( _state.value ); _state.value = NULL;}
      return RetCode.Success ;
   }
   public RetCode sma( int startIdx,
      int endIdx,
      float inReal[],
      int optInTimePeriod,
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 30;
      else if( ((int)optInTimePeriod < 2) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      return TA_INT_SMA ( startIdx, endIdx,
         inReal, optInTimePeriod,
         outBegIdx, outNBElement, outReal );
   }
   RetCode TA_INT_SMA( int startIdx,
      int endIdx,
      float inReal[],
      int optInTimePeriod,
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      double periodTotal, tempReal;
      int i, outIdx, trailingIdx, lookbackTotal;
      lookbackTotal = (optInTimePeriod-1);
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      periodTotal = 0;
      trailingIdx = startIdx-lookbackTotal;
      i=trailingIdx;
      if( optInTimePeriod > 1 )
      {
         while( i < startIdx )
            periodTotal += inReal[i++];
      }
      outIdx = 0;
      do
      {
         periodTotal += inReal[i++];
         tempReal = periodTotal;
         periodTotal -= inReal[trailingIdx++];
         outReal[outIdx++] = tempReal / optInTimePeriod;
      } while( i <= endIdx );
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   /* Generated */
   public int sqrtLookback( )
   {
      return RetCode.Success ;
   }
   public RetCode sqrt( int startIdx,
      int endIdx,
      double inReal[],
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      int outIdx;
      int i;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      for( i=startIdx, outIdx=0; i <= endIdx; i++, outIdx++ )
      {
         outReal[outIdx] = Math.sqrt (inReal[i]);
      }
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   public int sqrtStateInit( struct TA_sqrt_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct sqrt ));
      _state.value .value .mem_index = 0;
      _state.value .value .mem_size = sqrtLookback ();
      if ( _state.value .value .mem_size > 0)
         _state.value .value .memory = TA_Calloc( _state.value .value .mem_size , sizeof(struct TA_SQRT_Data));
      else
         _state.value .value .memory = NULL;
      return RetCode.Success ;
   }
   public int sqrtState( struct TA_sqrt_State* _state,
      double inReal,
      double *outReal )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      size_t _cur_idx = _state.value .mem_index++;
      if ( _state.value .mem_size > 0) _cur_idx %= _state.value .mem_size ;
      if ( _state.value .mem_size > _state.value .mem_index - 1 ) {
         ( _state.value .memory+_cur_idx).value .inReal = inReal ;
         return RetCode.NeedMoreData ; }
      outReal.value = Math.sqrt (inReal);
      return RetCode.Success ;
   }
   public int sqrtStateFree( struct TA_sqrt_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if ( _state.value != NULL) {
         if ( _state.value .value .memory != NULL) TA_Free( _state.value .value .memory );
         TA_Free( _state.value ); _state.value = NULL;}
      return RetCode.Success ;
   }
   public RetCode sqrt( int startIdx,
      int endIdx,
      float inReal[],
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      int outIdx;
      int i;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      for( i=startIdx, outIdx=0; i <= endIdx; i++, outIdx++ )
      {
         outReal[outIdx] = Math.sqrt (inReal[i]);
      }
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   /* Generated */
   public int stdDevLookback( int optInTimePeriod,
      double optInNbDev )
   {
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 5;
      else if( ((int)optInTimePeriod < 2) || ((int)optInTimePeriod > 100000) )
         return -1;
      if( optInNbDev == (-4e+37) )
         optInNbDev = 1.000000e+0;
      else if( (optInNbDev < -3.000000e+37) || (optInNbDev > 3.000000e+37) )
         return -1;
      return varianceLookback ( optInTimePeriod, optInNbDev );
   }
   public RetCode stdDev( int startIdx,
      int endIdx,
      double inReal[],
      int optInTimePeriod,
      double optInNbDev,
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      int i;
      RetCode retCode;
      double tempReal;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 5;
      else if( ((int)optInTimePeriod < 2) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      if( optInNbDev == (-4e+37) )
         optInNbDev = 1.000000e+0;
      else if( (optInNbDev < -3.000000e+37) || (optInNbDev > 3.000000e+37) )
         return RetCode.BadParam ;
      retCode = TA_INT_VAR ( startIdx, endIdx,
         inReal, optInTimePeriod,
         outBegIdx, outNBElement, outReal );
      if( retCode != RetCode.Success )
         return retCode;
      if( optInNbDev != 1.0 )
      {
         for( i=0; i < (int) outNBElement.value ; i++ )
         {
            tempReal = outReal[i];
            if( ! (tempReal< (0.00000000000001) ) )
               outReal[i] = Math.sqrt (tempReal) * optInNbDev;
            else
               outReal[i] = (double)0.0;
         }
      }
      else
      {
         for( i=0; i < (int) outNBElement.value ; i++ )
         {
            tempReal = outReal[i];
            if( ! (tempReal< (0.00000000000001) ) )
               outReal[i] = Math.sqrt (tempReal);
            else
               outReal[i] = (double)0.0;
         }
      }
      return RetCode.Success ;
   }
   void TA_INT_stddev_using_precalc_ma( double inReal[],
      double inMovAvg[],
      int inMovAvgBegIdx,
      int inMovAvgNbElement,
      int timePeriod,
      double output[] )
   {
      double tempReal, periodTotal2, meanValue2;
      int outIdx;
      int startSum, endSum;
      startSum = 1+inMovAvgBegIdx-timePeriod;
      endSum = inMovAvgBegIdx;
      periodTotal2 = 0;
      for( outIdx = startSum; outIdx < endSum; outIdx++)
      {
         tempReal = inReal[outIdx];
         tempReal *= tempReal;
         periodTotal2 += tempReal;
      }
      for( outIdx=0; outIdx < inMovAvgNbElement; outIdx++, startSum++, endSum++ )
      {
         tempReal = inReal[endSum];
         tempReal *= tempReal;
         periodTotal2 += tempReal;
         meanValue2 = periodTotal2/timePeriod;
         tempReal = inReal[startSum];
         tempReal *= tempReal;
         periodTotal2 -= tempReal;
         tempReal = inMovAvg[outIdx];
         tempReal *= tempReal;
         meanValue2 -= tempReal;
         if( ! (meanValue2< (0.00000000000001) ) )
            output[outIdx] = Math.sqrt (meanValue2);
         else
            output[outIdx] = (double)0.0;
      }
   }
   public int stdDevStateInit( struct TA_stdDev_State** _state,
      int optInTimePeriod,
      double optInNbDev )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 5;
      else if( ((int)optInTimePeriod < 2) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      if( optInNbDev == (-4e+37) )
         optInNbDev = 1.000000e+0;
      else if( (optInNbDev < -3.000000e+37) || (optInNbDev > 3.000000e+37) )
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct stdDev ));
      _state.value .value .mem_index = 0;
      _state.value .value .optInTimePeriod = optInTimePeriod;
      _state.value .value .optInNbDev = optInNbDev;
      _state.value .value .mem_size = stdDevLookback (optInTimePeriod, optInNbDev );
      _state.value .value .memory = NULL;
      return variance ((struct variance **)& _state.value .value .var_state, optInTimePeriod, optInNbDev);
   }
   public int stdDevState( struct TA_stdDev_State* _state,
      double inReal,
      double *outReal )
   {
      int retCode;
      double tempReal;
      if (_state == NULL)
         return RetCode.BadParam ;
      size_t _cur_idx = _state.value .mem_index++;
      if ( _state.value .mem_size > 0) _cur_idx %= _state.value .mem_size ;
      retCode = variance ( _state.value .var_state, inReal, outReal );
      if( retCode != RetCode.Success )
         return retCode;
      if( _state.value .optInNbDev != 1.0 )
      {
         tempReal = outReal.value ;
         if( ! (tempReal< (0.00000000000001) ) )
            outReal.value = Math.sqrt (tempReal) * _state.value .optInNbDev;
         else
            outReal.value = (double)0.0;
      }
      else
      {
         tempReal = outReal.value ;
         if( ! (tempReal< (0.00000000000001) ) )
            outReal.value = Math.sqrt (tempReal);
         else
            outReal.value = (double)0.0;
      }
      return RetCode.Success ;
   }
   public int stdDevStateFree( struct TA_stdDev_State** _state )
   {
      variance ((struct variance **)& _state.value .value .var_state);
      if (_state == NULL)
         return RetCode.BadParam ;
      if ( _state.value != NULL) {
         if ( _state.value .value .memory != NULL) TA_Free( _state.value .value .memory );
         TA_Free( _state.value ); _state.value = NULL;}
      return RetCode.Success ;
   }
   public RetCode stdDev( int startIdx,
      int endIdx,
      float inReal[],
      int optInTimePeriod,
      double optInNbDev,
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      int i;
      RetCode retCode;
      double tempReal;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 5;
      else if( ((int)optInTimePeriod < 2) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      if( optInNbDev == (-4e+37) )
         optInNbDev = 1.000000e+0;
      else if( (optInNbDev < -3.000000e+37) || (optInNbDev > 3.000000e+37) )
         return RetCode.BadParam ;
      retCode = TA_INT_VAR ( startIdx, endIdx,
         inReal, optInTimePeriod,
         outBegIdx, outNBElement, outReal );
      if( retCode != RetCode.Success )
         return retCode;
      if( optInNbDev != 1.0 )
      {
         for( i=0; i < (int) outNBElement.value ; i++ )
         {
            tempReal = outReal[i];
            if( ! (tempReal< (0.00000000000001) ) )
               outReal[i] = Math.sqrt (tempReal) * optInNbDev;
            else
               outReal[i] = (double)0.0;
         }
      }
      else
      {
         for( i=0; i < (int) outNBElement.value ; i++ )
         {
            tempReal = outReal[i];
            if( ! (tempReal< (0.00000000000001) ) )
               outReal[i] = Math.sqrt (tempReal);
            else
               outReal[i] = (double)0.0;
         }
      }
      return RetCode.Success ;
   }
   void TA_INT_stddev_using_precalc_ma( float inReal[],
      double inMovAvg[],
      int inMovAvgBegIdx,
      int inMovAvgNbElement,
      int timePeriod,
      double output[] )
   {
      double tempReal, periodTotal2, meanValue2;
      int outIdx;
      int startSum, endSum;
      startSum = 1+inMovAvgBegIdx-timePeriod;
      endSum = inMovAvgBegIdx;
      periodTotal2 = 0;
      for( outIdx = startSum; outIdx < endSum; outIdx++)
      {
         tempReal = inReal[outIdx];
         tempReal *= tempReal;
         periodTotal2 += tempReal;
      }
      for( outIdx=0; outIdx < inMovAvgNbElement; outIdx++, startSum++, endSum++ )
      {
         tempReal = inReal[endSum];
         tempReal *= tempReal;
         periodTotal2 += tempReal;
         meanValue2 = periodTotal2/timePeriod;
         tempReal = inReal[startSum];
         tempReal *= tempReal;
         periodTotal2 -= tempReal;
         tempReal = inMovAvg[outIdx];
         tempReal *= tempReal;
         meanValue2 -= tempReal;
         if( ! (meanValue2< (0.00000000000001) ) )
            output[outIdx] = Math.sqrt (meanValue2);
         else
            output[outIdx] = (double)0.0;
      }
   }
   /* Generated */
   public int stochLookback( int optInFastK_Period,
      int optInSlowK_Period,
      MAType optInSlowK_MAType, int optInSlowD_Period,
      MAType optInSlowD_MAType )
   {
      int retValue;
      if( (int)optInFastK_Period == ( Integer.MIN_VALUE ) )
         optInFastK_Period = 5;
      else if( ((int)optInFastK_Period < 1) || ((int)optInFastK_Period > 100000) )
         return -1;
      if( (int)optInSlowK_Period == ( Integer.MIN_VALUE ) )
         optInSlowK_Period = 3;
      else if( ((int)optInSlowK_Period < 1) || ((int)optInSlowK_Period > 100000) )
         return -1;
      if( (int)optInSlowD_Period == ( Integer.MIN_VALUE ) )
         optInSlowD_Period = 3;
      else if( ((int)optInSlowD_Period < 1) || ((int)optInSlowD_Period > 100000) )
         return -1;
      retValue = (optInFastK_Period - 1);
      retValue += movingAverageLookback ( optInSlowK_Period, optInSlowK_MAType );
      retValue += movingAverageLookback ( optInSlowD_Period, optInSlowD_MAType );
      return retValue;
   }
   public RetCode stoch( int startIdx,
      int endIdx,
      double inHigh[],
      double inLow[],
      double inClose[],
      int optInFastK_Period,
      int optInSlowK_Period,
      MAType optInSlowK_MAType, int optInSlowD_Period,
      MAType optInSlowD_MAType, MInteger outBegIdx,
      MInteger outNBElement,
      double outSlowK[],
      double outSlowD[] )
   {
      RetCode retCode;
      double lowest, highest, tmp, diff;
      double []tempBuffer ;
      int outIdx, lowestIdx, highestIdx;
      int lookbackTotal, lookbackK, lookbackKSlow, lookbackDSlow;
      int trailingIdx, today, i;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      if( (int)optInFastK_Period == ( Integer.MIN_VALUE ) )
         optInFastK_Period = 5;
      else if( ((int)optInFastK_Period < 1) || ((int)optInFastK_Period > 100000) )
         return RetCode.BadParam ;
      if( (int)optInSlowK_Period == ( Integer.MIN_VALUE ) )
         optInSlowK_Period = 3;
      else if( ((int)optInSlowK_Period < 1) || ((int)optInSlowK_Period > 100000) )
         return RetCode.BadParam ;
      if( (int)optInSlowD_Period == ( Integer.MIN_VALUE ) )
         optInSlowD_Period = 3;
      else if( ((int)optInSlowD_Period < 1) || ((int)optInSlowD_Period > 100000) )
         return RetCode.BadParam ;
      lookbackK = optInFastK_Period-1;
      lookbackKSlow = movingAverageLookback ( optInSlowK_Period, optInSlowK_MAType );
      lookbackDSlow = movingAverageLookback ( optInSlowD_Period, optInSlowD_MAType );
      lookbackTotal = lookbackK + lookbackDSlow + lookbackKSlow;
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      outIdx = 0;
      trailingIdx = startIdx-lookbackTotal;
      today = trailingIdx+lookbackK;
      lowestIdx = highestIdx = -1;
      diff = highest = lowest = 0.0;
      if( (outSlowK == inHigh) ||
         (outSlowK == inLow) ||
         (outSlowK == inClose) )
      {
         tempBuffer = outSlowK;
      }
      else if( (outSlowD == inHigh) ||
         (outSlowD == inLow) ||
         (outSlowD == inClose) )
      {
         tempBuffer = outSlowD;
      }
      else
      {
         tempBuffer = new double[endIdx-today+1] ;
      }
      while( today <= endIdx )
      {
         tmp = inLow[today];
         if( lowestIdx < trailingIdx )
         {
            lowestIdx = trailingIdx;
            lowest = inLow[lowestIdx];
            i = lowestIdx;
            while( ++i<=today )
            {
               tmp = inLow[i];
               if( tmp < lowest )
               {
                  lowestIdx = i;
                  lowest = tmp;
               }
            }
            diff = (highest - lowest)/100.0;
         }
         else if( tmp <= lowest )
         {
            lowestIdx = today;
            lowest = tmp;
            diff = (highest - lowest)/100.0;
         }
         tmp = inHigh[today];
         if( highestIdx < trailingIdx )
         {
            highestIdx = trailingIdx;
            highest = inHigh[highestIdx];
            i = highestIdx;
            while( ++i<=today )
            {
               tmp = inHigh[i];
               if( tmp > highest )
               {
                  highestIdx = i;
                  highest = tmp;
               }
            }
            diff = (highest - lowest)/100.0;
         }
         else if( tmp >= highest )
         {
            highestIdx = today;
            highest = tmp;
            diff = (highest - lowest)/100.0;
         }
         if( diff != 0.0 )
            tempBuffer[outIdx++] = (inClose[today]-lowest)/diff;
         else
            tempBuffer[outIdx++] = 0.0;
         trailingIdx++;
         today++;
      }
      retCode = movingAverage ( 0, outIdx-1,
         tempBuffer, optInSlowK_Period,
         optInSlowK_MAType,
         outBegIdx, outNBElement, tempBuffer );
      if( (retCode != RetCode.Success ) || ((int) outNBElement.value == 0) )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return retCode;
      }
      retCode = movingAverage ( 0, (int) outNBElement.value -1,
         tempBuffer, optInSlowD_Period,
         optInSlowD_MAType,
         outBegIdx, outNBElement, outSlowD );
      System.arraycopy(tempBuffer,lookbackDSlow,outSlowK,0,(int) outNBElement.value ) ;
      if( retCode != RetCode.Success )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return retCode;
      }
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   public int stochStateInit( struct TA_stoch_State** _state,
      int optInFastK_Period,
      int optInSlowK_Period,
      MAType optInSlowK_MAType, int optInSlowD_Period,
      MAType optInSlowD_MAType )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if( (int)optInFastK_Period == ( Integer.MIN_VALUE ) )
         optInFastK_Period = 5;
      else if( ((int)optInFastK_Period < 1) || ((int)optInFastK_Period > 100000) )
         return RetCode.BadParam ;
      if( (int)optInSlowK_Period == ( Integer.MIN_VALUE ) )
         optInSlowK_Period = 3;
      else if( ((int)optInSlowK_Period < 1) || ((int)optInSlowK_Period > 100000) )
         return RetCode.BadParam ;
      if( (int)optInSlowD_Period == ( Integer.MIN_VALUE ) )
         optInSlowD_Period = 3;
      else if( ((int)optInSlowD_Period < 1) || ((int)optInSlowD_Period > 100000) )
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct stoch ));
      _state.value .value .mem_index = 0;
      _state.value .value .optInFastK_Period = optInFastK_Period;
      _state.value .value .optInSlowK_Period = optInSlowK_Period;
      _state.value .value .optInSlowK_MAType = optInSlowK_MAType;
      _state.value .value .optInSlowD_Period = optInSlowD_Period;
      _state.value .value .optInSlowD_MAType = optInSlowD_MAType;
      _state.value .value .mem_size = stochLookback (optInFastK_Period, optInSlowK_Period, optInSlowK_MAType, optInSlowD_Period, optInSlowD_MAType );
      if ( _state.value .value .mem_size > 0)
         _state.value .value .memory = TA_Calloc( _state.value .value .mem_size , sizeof(struct TA_STOCH_Data));
      else
         _state.value .value .memory = NULL;
      return RetCode.Success ;
   }
   public int stochState( struct TA_stoch_State* _state,
      double inHigh,
      double inLow,
      double inClose,
      double *outSlowK,
      double *outSlowD )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      size_t _cur_idx = _state.value .mem_index++;
      if ( _state.value .mem_size > 0) _cur_idx %= _state.value .mem_size ;
      if ( _state.value .mem_size > _state.value .mem_index - 1 ) {
         ( _state.value .memory+_cur_idx).value .inHigh = inHigh ;
         ( _state.value .memory+_cur_idx).value .inLow = inLow ;
         ( _state.value .memory+_cur_idx).value .inClose = inClose ;
         return RetCode.NeedMoreData ; }
      return RetCode.Success ;
   }
   public int stochStateFree( struct TA_stoch_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if ( _state.value != NULL) {
         if ( _state.value .value .memory != NULL) TA_Free( _state.value .value .memory );
         TA_Free( _state.value ); _state.value = NULL;}
      return RetCode.Success ;
   }
   public RetCode stoch( int startIdx,
      int endIdx,
      float inHigh[],
      float inLow[],
      float inClose[],
      int optInFastK_Period,
      int optInSlowK_Period,
      MAType optInSlowK_MAType, int optInSlowD_Period,
      MAType optInSlowD_MAType, MInteger outBegIdx,
      MInteger outNBElement,
      double outSlowK[],
      double outSlowD[] )
   {
      RetCode retCode;
      double lowest, highest, tmp, diff;
      double []tempBuffer ;
      int outIdx, lowestIdx, highestIdx;
      int lookbackTotal, lookbackK, lookbackKSlow, lookbackDSlow;
      int trailingIdx, today, i;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      if( (int)optInFastK_Period == ( Integer.MIN_VALUE ) )
         optInFastK_Period = 5;
      else if( ((int)optInFastK_Period < 1) || ((int)optInFastK_Period > 100000) )
         return RetCode.BadParam ;
      if( (int)optInSlowK_Period == ( Integer.MIN_VALUE ) )
         optInSlowK_Period = 3;
      else if( ((int)optInSlowK_Period < 1) || ((int)optInSlowK_Period > 100000) )
         return RetCode.BadParam ;
      if( (int)optInSlowD_Period == ( Integer.MIN_VALUE ) )
         optInSlowD_Period = 3;
      else if( ((int)optInSlowD_Period < 1) || ((int)optInSlowD_Period > 100000) )
         return RetCode.BadParam ;
      lookbackK = optInFastK_Period-1;
      lookbackKSlow = movingAverageLookback ( optInSlowK_Period, optInSlowK_MAType );
      lookbackDSlow = movingAverageLookback ( optInSlowD_Period, optInSlowD_MAType );
      lookbackTotal = lookbackK + lookbackDSlow + lookbackKSlow;
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      outIdx = 0;
      trailingIdx = startIdx-lookbackTotal;
      today = trailingIdx+lookbackK;
      lowestIdx = highestIdx = -1;
      diff = highest = lowest = 0.0;
      tempBuffer = new double[endIdx-today+1] ;
      while( today <= endIdx )
      {
         tmp = inLow[today];
         if( lowestIdx < trailingIdx )
         {
            lowestIdx = trailingIdx;
            lowest = inLow[lowestIdx];
            i = lowestIdx;
            while( ++i<=today )
            {
               tmp = inLow[i];
               if( tmp < lowest )
               {
                  lowestIdx = i;
                  lowest = tmp;
               }
            }
            diff = (highest - lowest)/100.0;
         }
         else if( tmp <= lowest )
         {
            lowestIdx = today;
            lowest = tmp;
            diff = (highest - lowest)/100.0;
         }
         tmp = inHigh[today];
         if( highestIdx < trailingIdx )
         {
            highestIdx = trailingIdx;
            highest = inHigh[highestIdx];
            i = highestIdx;
            while( ++i<=today )
            {
               tmp = inHigh[i];
               if( tmp > highest )
               {
                  highestIdx = i;
                  highest = tmp;
               }
            }
            diff = (highest - lowest)/100.0;
         }
         else if( tmp >= highest )
         {
            highestIdx = today;
            highest = tmp;
            diff = (highest - lowest)/100.0;
         }
         if( diff != 0.0 )
            tempBuffer[outIdx++] = (inClose[today]-lowest)/diff;
         else
            tempBuffer[outIdx++] = 0.0;
         trailingIdx++;
         today++;
      }
      retCode = movingAverage ( 0, outIdx-1,
         tempBuffer, optInSlowK_Period,
         optInSlowK_MAType,
         outBegIdx, outNBElement, tempBuffer );
      if( (retCode != RetCode.Success ) || ((int) outNBElement.value == 0) )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return retCode;
      }
      retCode = movingAverage ( 0, (int) outNBElement.value -1,
         tempBuffer, optInSlowD_Period,
         optInSlowD_MAType,
         outBegIdx, outNBElement, outSlowD );
      System.arraycopy(tempBuffer,lookbackDSlow,outSlowK,0,(int) outNBElement.value ) ;
      if( retCode != RetCode.Success )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return retCode;
      }
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   /* Generated */
   public int stochFLookback( int optInFastK_Period,
      int optInFastD_Period,
      MAType optInFastD_MAType )
   {
      int retValue;
      if( (int)optInFastK_Period == ( Integer.MIN_VALUE ) )
         optInFastK_Period = 5;
      else if( ((int)optInFastK_Period < 1) || ((int)optInFastK_Period > 100000) )
         return -1;
      if( (int)optInFastD_Period == ( Integer.MIN_VALUE ) )
         optInFastD_Period = 3;
      else if( ((int)optInFastD_Period < 1) || ((int)optInFastD_Period > 100000) )
         return -1;
      retValue = (optInFastK_Period - 1);
      retValue += movingAverageLookback ( optInFastD_Period, optInFastD_MAType );
      return retValue;
   }
   public RetCode stochF( int startIdx,
      int endIdx,
      double inHigh[],
      double inLow[],
      double inClose[],
      int optInFastK_Period,
      int optInFastD_Period,
      MAType optInFastD_MAType, MInteger outBegIdx,
      MInteger outNBElement,
      double outFastK[],
      double outFastD[] )
   {
      RetCode retCode;
      double lowest, highest, tmp, diff;
      double []tempBuffer ;
      int outIdx, lowestIdx, highestIdx;
      int lookbackTotal, lookbackK, lookbackFastD;
      int trailingIdx, today, i;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      if( (int)optInFastK_Period == ( Integer.MIN_VALUE ) )
         optInFastK_Period = 5;
      else if( ((int)optInFastK_Period < 1) || ((int)optInFastK_Period > 100000) )
         return RetCode.BadParam ;
      if( (int)optInFastD_Period == ( Integer.MIN_VALUE ) )
         optInFastD_Period = 3;
      else if( ((int)optInFastD_Period < 1) || ((int)optInFastD_Period > 100000) )
         return RetCode.BadParam ;
      lookbackK = optInFastK_Period-1;
      lookbackFastD = movingAverageLookback ( optInFastD_Period, optInFastD_MAType );
      lookbackTotal = lookbackK + lookbackFastD;
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      outIdx = 0;
      trailingIdx = startIdx-lookbackTotal;
      today = trailingIdx+lookbackK;
      lowestIdx = highestIdx = -1;
      diff = highest = lowest = 0.0;
      if( (outFastK == inHigh) ||
         (outFastK == inLow) ||
         (outFastK == inClose) )
      {
         tempBuffer = outFastK;
      }
      else if( (outFastD == inHigh) ||
         (outFastD == inLow) ||
         (outFastD == inClose) )
      {
         tempBuffer = outFastD;
      }
      else
      {
         tempBuffer = new double[endIdx-today+1] ;
      }
      while( today <= endIdx )
      {
         tmp = inLow[today];
         if( lowestIdx < trailingIdx )
         {
            lowestIdx = trailingIdx;
            lowest = inLow[lowestIdx];
            i = lowestIdx;
            while( ++i<=today )
            {
               tmp = inLow[i];
               if( tmp < lowest )
               {
                  lowestIdx = i;
                  lowest = tmp;
               }
            }
            diff = (highest - lowest)/100.0;
         }
         else if( tmp <= lowest )
         {
            lowestIdx = today;
            lowest = tmp;
            diff = (highest - lowest)/100.0;
         }
         tmp = inHigh[today];
         if( highestIdx < trailingIdx )
         {
            highestIdx = trailingIdx;
            highest = inHigh[highestIdx];
            i = highestIdx;
            while( ++i<=today )
            {
               tmp = inHigh[i];
               if( tmp > highest )
               {
                  highestIdx = i;
                  highest = tmp;
               }
            }
            diff = (highest - lowest)/100.0;
         }
         else if( tmp >= highest )
         {
            highestIdx = today;
            highest = tmp;
            diff = (highest - lowest)/100.0;
         }
         if( diff != 0.0 )
            tempBuffer[outIdx++] = (inClose[today]-lowest)/diff;
         else
            tempBuffer[outIdx++] = 0.0;
         trailingIdx++;
         today++;
      }
      retCode = movingAverage ( 0, outIdx-1,
         tempBuffer, optInFastD_Period,
         optInFastD_MAType,
         outBegIdx, outNBElement, outFastD );
      if( (retCode != RetCode.Success ) || ((int) outNBElement.value ) == 0 )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return retCode;
      }
      System.arraycopy(tempBuffer,lookbackFastD,outFastK,0,(int) outNBElement.value ) ;
      if( retCode != RetCode.Success )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return retCode;
      }
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   public int stochFStateInit( struct TA_stochF_State** _state,
      int optInFastK_Period,
      int optInFastD_Period,
      MAType optInFastD_MAType )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if( (int)optInFastK_Period == ( Integer.MIN_VALUE ) )
         optInFastK_Period = 5;
      else if( ((int)optInFastK_Period < 1) || ((int)optInFastK_Period > 100000) )
         return RetCode.BadParam ;
      if( (int)optInFastD_Period == ( Integer.MIN_VALUE ) )
         optInFastD_Period = 3;
      else if( ((int)optInFastD_Period < 1) || ((int)optInFastD_Period > 100000) )
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct stochF ));
      _state.value .value .mem_index = 0;
      _state.value .value .optInFastK_Period = optInFastK_Period;
      _state.value .value .optInFastD_Period = optInFastD_Period;
      _state.value .value .optInFastD_MAType = optInFastD_MAType;
      _state.value .value .mem_size = stochFLookback (optInFastK_Period, optInFastD_Period, optInFastD_MAType );
      if ( _state.value .value .mem_size > 0)
         _state.value .value .memory = TA_Calloc( _state.value .value .mem_size , sizeof(struct TA_STOCHF_Data));
      else
         _state.value .value .memory = NULL;
      return RetCode.Success ;
   }
   public int stochFState( struct TA_stochF_State* _state,
      double inHigh,
      double inLow,
      double inClose,
      double *outFastK,
      double *outFastD )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      size_t _cur_idx = _state.value .mem_index++;
      if ( _state.value .mem_size > 0) _cur_idx %= _state.value .mem_size ;
      if ( _state.value .mem_size > _state.value .mem_index - 1 ) {
         ( _state.value .memory+_cur_idx).value .inHigh = inHigh ;
         ( _state.value .memory+_cur_idx).value .inLow = inLow ;
         ( _state.value .memory+_cur_idx).value .inClose = inClose ;
         return RetCode.NeedMoreData ; }
      return RetCode.Success ;
   }
   public int stochFStateFree( struct TA_stochF_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if ( _state.value != NULL) {
         if ( _state.value .value .memory != NULL) TA_Free( _state.value .value .memory );
         TA_Free( _state.value ); _state.value = NULL;}
      return RetCode.Success ;
   }
   public RetCode stochF( int startIdx,
      int endIdx,
      float inHigh[],
      float inLow[],
      float inClose[],
      int optInFastK_Period,
      int optInFastD_Period,
      MAType optInFastD_MAType, MInteger outBegIdx,
      MInteger outNBElement,
      double outFastK[],
      double outFastD[] )
   {
      RetCode retCode;
      double lowest, highest, tmp, diff;
      double []tempBuffer ;
      int outIdx, lowestIdx, highestIdx;
      int lookbackTotal, lookbackK, lookbackFastD;
      int trailingIdx, today, i;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      if( (int)optInFastK_Period == ( Integer.MIN_VALUE ) )
         optInFastK_Period = 5;
      else if( ((int)optInFastK_Period < 1) || ((int)optInFastK_Period > 100000) )
         return RetCode.BadParam ;
      if( (int)optInFastD_Period == ( Integer.MIN_VALUE ) )
         optInFastD_Period = 3;
      else if( ((int)optInFastD_Period < 1) || ((int)optInFastD_Period > 100000) )
         return RetCode.BadParam ;
      lookbackK = optInFastK_Period-1;
      lookbackFastD = movingAverageLookback ( optInFastD_Period, optInFastD_MAType );
      lookbackTotal = lookbackK + lookbackFastD;
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      outIdx = 0;
      trailingIdx = startIdx-lookbackTotal;
      today = trailingIdx+lookbackK;
      lowestIdx = highestIdx = -1;
      diff = highest = lowest = 0.0;
      tempBuffer = new double[endIdx-today+1] ;
      while( today <= endIdx )
      {
         tmp = inLow[today];
         if( lowestIdx < trailingIdx )
         {
            lowestIdx = trailingIdx;
            lowest = inLow[lowestIdx];
            i = lowestIdx;
            while( ++i<=today )
            {
               tmp = inLow[i];
               if( tmp < lowest )
               {
                  lowestIdx = i;
                  lowest = tmp;
               }
            }
            diff = (highest - lowest)/100.0;
         }
         else if( tmp <= lowest )
         {
            lowestIdx = today;
            lowest = tmp;
            diff = (highest - lowest)/100.0;
         }
         tmp = inHigh[today];
         if( highestIdx < trailingIdx )
         {
            highestIdx = trailingIdx;
            highest = inHigh[highestIdx];
            i = highestIdx;
            while( ++i<=today )
            {
               tmp = inHigh[i];
               if( tmp > highest )
               {
                  highestIdx = i;
                  highest = tmp;
               }
            }
            diff = (highest - lowest)/100.0;
         }
         else if( tmp >= highest )
         {
            highestIdx = today;
            highest = tmp;
            diff = (highest - lowest)/100.0;
         }
         if( diff != 0.0 )
            tempBuffer[outIdx++] = (inClose[today]-lowest)/diff;
         else
            tempBuffer[outIdx++] = 0.0;
         trailingIdx++;
         today++;
      }
      retCode = movingAverage ( 0, outIdx-1,
         tempBuffer, optInFastD_Period,
         optInFastD_MAType,
         outBegIdx, outNBElement, outFastD );
      if( (retCode != RetCode.Success ) || ((int) outNBElement.value ) == 0 )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return retCode;
      }
      System.arraycopy(tempBuffer,lookbackFastD,outFastK,0,(int) outNBElement.value ) ;
      if( retCode != RetCode.Success )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return retCode;
      }
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   /* Generated */
   public int stochRsiLookback( int optInTimePeriod,
      int optInFastK_Period,
      int optInFastD_Period,
      MAType optInFastD_MAType )
   {
      int retValue;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 14;
      else if( ((int)optInTimePeriod < 2) || ((int)optInTimePeriod > 100000) )
         return -1;
      if( (int)optInFastK_Period == ( Integer.MIN_VALUE ) )
         optInFastK_Period = 5;
      else if( ((int)optInFastK_Period < 1) || ((int)optInFastK_Period > 100000) )
         return -1;
      if( (int)optInFastD_Period == ( Integer.MIN_VALUE ) )
         optInFastD_Period = 3;
      else if( ((int)optInFastD_Period < 1) || ((int)optInFastD_Period > 100000) )
         return -1;
      retValue = rsiLookback ( optInTimePeriod ) + stochFLookback ( optInFastK_Period, optInFastD_Period, optInFastD_MAType );
      return retValue;
   }
   public RetCode stochRsi( int startIdx,
      int endIdx,
      double inReal[],
      int optInTimePeriod,
      int optInFastK_Period,
      int optInFastD_Period,
      MAType optInFastD_MAType, MInteger outBegIdx,
      MInteger outNBElement,
      double outFastK[],
      double outFastD[] )
   {
      double []tempRSIBuffer ;
      RetCode retCode;
      int lookbackTotal, lookbackSTOCHF, tempArraySize;
      MInteger outBegIdx1 = new MInteger() ;
      MInteger outBegIdx2 = new MInteger() ;
      MInteger outNbElement1 = new MInteger() ;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 14;
      else if( ((int)optInTimePeriod < 2) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      if( (int)optInFastK_Period == ( Integer.MIN_VALUE ) )
         optInFastK_Period = 5;
      else if( ((int)optInFastK_Period < 1) || ((int)optInFastK_Period > 100000) )
         return RetCode.BadParam ;
      if( (int)optInFastD_Period == ( Integer.MIN_VALUE ) )
         optInFastD_Period = 3;
      else if( ((int)optInFastD_Period < 1) || ((int)optInFastD_Period > 100000) )
         return RetCode.BadParam ;
      outBegIdx.value = 0 ;
      outNBElement.value = 0 ;
      lookbackSTOCHF = stochFLookback ( optInFastK_Period, optInFastD_Period, optInFastD_MAType );
      lookbackTotal = rsiLookback ( optInTimePeriod ) + lookbackSTOCHF;
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      outBegIdx.value = startIdx;
      tempArraySize = (endIdx - startIdx) + 1 + lookbackSTOCHF;
      tempRSIBuffer = new double[tempArraySize] ;
      retCode = rsi (startIdx-lookbackSTOCHF,
         endIdx,
         inReal,
         optInTimePeriod,
         outBegIdx1 ,
         outNbElement1 ,
         tempRSIBuffer);
      if( retCode != RetCode.Success || outNbElement1.value == 0 )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return retCode;
      }
      retCode = stochF (0,
         tempArraySize-1,
         tempRSIBuffer,
         tempRSIBuffer,
         tempRSIBuffer,
         optInFastK_Period,
         optInFastD_Period,
         optInFastD_MAType,
         outBegIdx2 ,
         outNBElement,
         outFastK,
         outFastD);
      if( retCode != RetCode.Success || ((int) outNBElement.value ) == 0 )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return retCode;
      }
      return RetCode.Success ;
   }
   public int stochRsiStateInit( struct TA_stochRsi_State** _state,
      int optInTimePeriod,
      int optInFastK_Period,
      int optInFastD_Period,
      MAType optInFastD_MAType )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 14;
      else if( ((int)optInTimePeriod < 2) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      if( (int)optInFastK_Period == ( Integer.MIN_VALUE ) )
         optInFastK_Period = 5;
      else if( ((int)optInFastK_Period < 1) || ((int)optInFastK_Period > 100000) )
         return RetCode.BadParam ;
      if( (int)optInFastD_Period == ( Integer.MIN_VALUE ) )
         optInFastD_Period = 3;
      else if( ((int)optInFastD_Period < 1) || ((int)optInFastD_Period > 100000) )
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct stochRsi ));
      _state.value .value .mem_index = 0;
      _state.value .value .optInTimePeriod = optInTimePeriod;
      _state.value .value .optInFastK_Period = optInFastK_Period;
      _state.value .value .optInFastD_Period = optInFastD_Period;
      _state.value .value .optInFastD_MAType = optInFastD_MAType;
      _state.value .value .mem_size = stochRsiLookback (optInTimePeriod, optInFastK_Period, optInFastD_Period, optInFastD_MAType );
      if ( _state.value .value .mem_size > 0)
         _state.value .value .memory = TA_Calloc( _state.value .value .mem_size , sizeof(struct TA_STOCHRSI_Data));
      else
         _state.value .value .memory = NULL;
      return RetCode.Success ;
   }
   public int stochRsiState( struct TA_stochRsi_State* _state,
      double inReal,
      double *outFastK,
      double *outFastD )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      size_t _cur_idx = _state.value .mem_index++;
      if ( _state.value .mem_size > 0) _cur_idx %= _state.value .mem_size ;
      if ( _state.value .mem_size > _state.value .mem_index - 1 ) {
         ( _state.value .memory+_cur_idx).value .inReal = inReal ;
         return RetCode.NeedMoreData ; }
      return RetCode.Success ;
   }
   public int stochRsiStateFree( struct TA_stochRsi_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if ( _state.value != NULL) {
         if ( _state.value .value .memory != NULL) TA_Free( _state.value .value .memory );
         TA_Free( _state.value ); _state.value = NULL;}
      return RetCode.Success ;
   }
   public RetCode stochRsi( int startIdx,
      int endIdx,
      float inReal[],
      int optInTimePeriod,
      int optInFastK_Period,
      int optInFastD_Period,
      MAType optInFastD_MAType, MInteger outBegIdx,
      MInteger outNBElement,
      double outFastK[],
      double outFastD[] )
   {
      double []tempRSIBuffer ;
      RetCode retCode;
      int lookbackTotal, lookbackSTOCHF, tempArraySize;
      MInteger outBegIdx1 = new MInteger() ;
      MInteger outBegIdx2 = new MInteger() ;
      MInteger outNbElement1 = new MInteger() ;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 14;
      else if( ((int)optInTimePeriod < 2) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      if( (int)optInFastK_Period == ( Integer.MIN_VALUE ) )
         optInFastK_Period = 5;
      else if( ((int)optInFastK_Period < 1) || ((int)optInFastK_Period > 100000) )
         return RetCode.BadParam ;
      if( (int)optInFastD_Period == ( Integer.MIN_VALUE ) )
         optInFastD_Period = 3;
      else if( ((int)optInFastD_Period < 1) || ((int)optInFastD_Period > 100000) )
         return RetCode.BadParam ;
      outBegIdx.value = 0 ;
      outNBElement.value = 0 ;
      lookbackSTOCHF = stochFLookback ( optInFastK_Period, optInFastD_Period, optInFastD_MAType );
      lookbackTotal = rsiLookback ( optInTimePeriod ) + lookbackSTOCHF;
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      outBegIdx.value = startIdx;
      tempArraySize = (endIdx - startIdx) + 1 + lookbackSTOCHF;
      tempRSIBuffer = new double[tempArraySize] ;
      retCode = rsi (startIdx-lookbackSTOCHF,
         endIdx,
         inReal,
         optInTimePeriod,
         outBegIdx1 ,
         outNbElement1 ,
         tempRSIBuffer);
      if( retCode != RetCode.Success || outNbElement1.value == 0 )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return retCode;
      }
      retCode = stochF (0,
         tempArraySize-1,
         tempRSIBuffer,
         tempRSIBuffer,
         tempRSIBuffer,
         optInFastK_Period,
         optInFastD_Period,
         optInFastD_MAType,
         outBegIdx2 ,
         outNBElement,
         outFastK,
         outFastD);
      if( retCode != RetCode.Success || ((int) outNBElement.value ) == 0 )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return retCode;
      }
      return RetCode.Success ;
   }
   /* Generated */
   public int subLookback( )
   {
      return RetCode.Success ;
   }
   public RetCode sub( int startIdx,
      int endIdx,
      double inReal0[],
      double inReal1[],
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      int outIdx;
      int i;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      for( i=startIdx, outIdx=0; i <= endIdx; i++, outIdx++ )
      {
         outReal[outIdx] = inReal0[i]-inReal1[i];
      }
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   public int subStateInit( struct TA_sub_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct sub ));
      _state.value .value .mem_index = 0;
      _state.value .value .mem_size = subLookback ();
      if ( _state.value .value .mem_size > 0)
         _state.value .value .memory = TA_Calloc( _state.value .value .mem_size , sizeof(struct TA_SUB_Data));
      else
         _state.value .value .memory = NULL;
      return RetCode.Success ;
   }
   public int subState( struct TA_sub_State* _state,
      double inReal0,
      double inReal1,
      double *outReal )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      size_t _cur_idx = _state.value .mem_index++;
      if ( _state.value .mem_size > 0) _cur_idx %= _state.value .mem_size ;
      if ( _state.value .mem_size > _state.value .mem_index - 1 ) {
         ( _state.value .memory+_cur_idx).value .inReal0 = inReal0 ;
         ( _state.value .memory+_cur_idx).value .inReal1 = inReal1 ;
         return RetCode.NeedMoreData ; }
      outReal.value = inReal0-inReal1;
      return RetCode.Success ;
   }
   public int subStateFree( struct TA_sub_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if ( _state.value != NULL) {
         if ( _state.value .value .memory != NULL) TA_Free( _state.value .value .memory );
         TA_Free( _state.value ); _state.value = NULL;}
      return RetCode.Success ;
   }
   public RetCode sub( int startIdx,
      int endIdx,
      float inReal0[],
      float inReal1[],
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      int outIdx;
      int i;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      for( i=startIdx, outIdx=0; i <= endIdx; i++, outIdx++ )
      {
         outReal[outIdx] = inReal0[i]-inReal1[i];
      }
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   /* Generated */
   public int sumLookback( int optInTimePeriod )
   {
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 30;
      else if( ((int)optInTimePeriod < 2) || ((int)optInTimePeriod > 100000) )
         return -1;
      return optInTimePeriod-1;
   }
   public RetCode sum( int startIdx,
      int endIdx,
      double inReal[],
      int optInTimePeriod,
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      double periodTotal, tempReal;
      int i, outIdx, trailingIdx, lookbackTotal;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 30;
      else if( ((int)optInTimePeriod < 2) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      lookbackTotal = (optInTimePeriod-1);
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      periodTotal = 0;
      trailingIdx = startIdx-lookbackTotal;
      i=trailingIdx;
      if( optInTimePeriod > 1 )
      {
         while( i < startIdx )
            periodTotal += inReal[i++];
      }
      outIdx = 0;
      do
      {
         periodTotal += inReal[i++];
         tempReal = periodTotal;
         periodTotal -= inReal[trailingIdx++];
         outReal[outIdx++] = tempReal;
      } while( i <= endIdx );
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   public int sumStateInit( struct TA_sum_State** _state,
      int optInTimePeriod )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 30;
      else if( ((int)optInTimePeriod < 2) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct sum ));
      _state.value .value .mem_index = 0;
      _state.value .value .optInTimePeriod = optInTimePeriod;
      _state.value .value .mem_size = sumLookback (optInTimePeriod );
      if ( _state.value .value .mem_size > 0)
         _state.value .value .memory = TA_Calloc( _state.value .value .mem_size , sizeof(struct TA_SUM_Data));
      else
         _state.value .value .memory = NULL;
      return RetCode.Success ;
   }
   public int sumState( struct TA_sum_State* _state,
      double inReal,
      double *outReal )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      size_t _cur_idx = _state.value .mem_index++;
      if ( _state.value .mem_size > 0) _cur_idx %= _state.value .mem_size ;
      if ( ( _state.value .mem_index == 1) )
         _state->tempSum = 0;
      if ( _state.value .mem_size > _state.value .mem_index - 1 )
      {
         _state->tempSum += inReal;
         ( _state.value .memory+_cur_idx).value .inReal = inReal ;
         outReal.value = 0;
         return RetCode.NeedMoreData ;
      } else {
         _state->tempSum -= ( _state.value .memory+_cur_idx).value .inReal ;
         _state->tempSum += inReal;
         ( _state.value .memory+_cur_idx).value .inReal = inReal ;
         outReal.value = inReal;
         return RetCode.Success ;
      }
   }
   public int sumStateFree( struct TA_sum_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if ( _state.value != NULL) {
         if ( _state.value .value .memory != NULL) TA_Free( _state.value .value .memory );
         TA_Free( _state.value ); _state.value = NULL;}
      return RetCode.Success ;
   }
   public RetCode sum( int startIdx,
      int endIdx,
      float inReal[],
      int optInTimePeriod,
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      double periodTotal, tempReal;
      int i, outIdx, trailingIdx, lookbackTotal;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 30;
      else if( ((int)optInTimePeriod < 2) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      lookbackTotal = (optInTimePeriod-1);
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      periodTotal = 0;
      trailingIdx = startIdx-lookbackTotal;
      i=trailingIdx;
      if( optInTimePeriod > 1 )
      {
         while( i < startIdx )
            periodTotal += inReal[i++];
      }
      outIdx = 0;
      do
      {
         periodTotal += inReal[i++];
         tempReal = periodTotal;
         periodTotal -= inReal[trailingIdx++];
         outReal[outIdx++] = tempReal;
      } while( i <= endIdx );
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   /* Generated */
   public int t3Lookback( int optInTimePeriod,
      double optInVFactor )
   {
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 5;
      else if( ((int)optInTimePeriod < 2) || ((int)optInTimePeriod > 100000) )
         return -1;
      if( optInVFactor == (-4e+37) )
         optInVFactor = 7.000000e-1;
      else if( (optInVFactor < 0.000000e+0) || (optInVFactor > 1.000000e+0) )
         return -1;
      return 6 * (optInTimePeriod-1) + (this.unstablePeriod[FuncUnstId.T3.ordinal()]) ;
   }
   public RetCode t3( int startIdx,
      int endIdx,
      double inReal[],
      int optInTimePeriod,
      double optInVFactor,
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      int outIdx, lookbackTotal;
      int today, i;
      double k, one_minus_k;
      double e1, e2, e3, e4, e5, e6;
      double c1, c2, c3, c4;
      double tempReal;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 5;
      else if( ((int)optInTimePeriod < 2) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      if( optInVFactor == (-4e+37) )
         optInVFactor = 7.000000e-1;
      else if( (optInVFactor < 0.000000e+0) || (optInVFactor > 1.000000e+0) )
         return RetCode.BadParam ;
      lookbackTotal = 6 * (optInTimePeriod - 1) + (this.unstablePeriod[FuncUnstId.T3.ordinal()]) ;
      if( startIdx <= lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outNBElement.value = 0 ;
         outBegIdx.value = 0 ;
         return RetCode.Success ;
      }
      outBegIdx.value = startIdx;
      today = startIdx - lookbackTotal;
      k = 2.0/(optInTimePeriod+1.0);
      one_minus_k = 1.0-k;
      tempReal = inReal[today++];
      for( i=optInTimePeriod-1; i > 0 ; i-- )
         tempReal += inReal[today++];
      e1 = tempReal / optInTimePeriod;
      tempReal = e1;
      for( i=optInTimePeriod-1; i > 0 ; i-- )
      {
         e1 = (k*inReal[today++])+(one_minus_k*e1);
         tempReal += e1;
      }
      e2 = tempReal / optInTimePeriod;
      tempReal = e2;
      for( i=optInTimePeriod-1; i > 0 ; i-- )
      {
         e1 = (k*inReal[today++])+(one_minus_k*e1);
         e2 = (k*e1)+(one_minus_k*e2);
         tempReal += e2;
      }
      e3 = tempReal / optInTimePeriod;
      tempReal = e3;
      for( i=optInTimePeriod-1; i > 0 ; i-- )
      {
         e1 = (k*inReal[today++])+(one_minus_k*e1);
         e2 = (k*e1)+(one_minus_k*e2);
         e3 = (k*e2)+(one_minus_k*e3);
         tempReal += e3;
      }
      e4 = tempReal / optInTimePeriod;
      tempReal = e4;
      for( i=optInTimePeriod-1; i > 0 ; i-- )
      {
         e1 = (k*inReal[today++])+(one_minus_k*e1);
         e2 = (k*e1)+(one_minus_k*e2);
         e3 = (k*e2)+(one_minus_k*e3);
         e4 = (k*e3)+(one_minus_k*e4);
         tempReal += e4;
      }
      e5 = tempReal / optInTimePeriod;
      tempReal = e5;
      for( i=optInTimePeriod-1; i > 0 ; i-- )
      {
         e1 = (k*inReal[today++])+(one_minus_k*e1);
         e2 = (k*e1)+(one_minus_k*e2);
         e3 = (k*e2)+(one_minus_k*e3);
         e4 = (k*e3)+(one_minus_k*e4);
         e5 = (k*e4)+(one_minus_k*e5);
         tempReal += e5;
      }
      e6 = tempReal / optInTimePeriod;
      while( today <= startIdx )
      {
         e1 = (k*inReal[today++])+(one_minus_k*e1);
         e2 = (k*e1)+(one_minus_k*e2);
         e3 = (k*e2)+(one_minus_k*e3);
         e4 = (k*e3)+(one_minus_k*e4);
         e5 = (k*e4)+(one_minus_k*e5);
         e6 = (k*e5)+(one_minus_k*e6);
      }
      tempReal = optInVFactor * optInVFactor;
      c1 = -(tempReal * optInVFactor);
      c2 = 3.0 * (tempReal - c1);
      c3 = -6.0 * tempReal - 3.0 * (optInVFactor-c1);
      c4 = 1.0 + 3.0 * optInVFactor - c1 + 3.0 * tempReal;
      outIdx = 0;
      outReal[outIdx++] = c1*e6+c2*e5+c3*e4+c4*e3;
      while( today <= endIdx )
      {
         e1 = (k*inReal[today++])+(one_minus_k*e1);
         e2 = (k*e1)+(one_minus_k*e2);
         e3 = (k*e2)+(one_minus_k*e3);
         e4 = (k*e3)+(one_minus_k*e4);
         e5 = (k*e4)+(one_minus_k*e5);
         e6 = (k*e5)+(one_minus_k*e6);
         outReal[outIdx++] = c1*e6+c2*e5+c3*e4+c4*e3;
      }
      outNBElement.value = outIdx;
      return RetCode.Success ;
   }
   public int t3StateInit( struct TA_t3_State** _state,
      int optInTimePeriod,
      double optInVFactor )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 5;
      else if( ((int)optInTimePeriod < 2) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      if( optInVFactor == (-4e+37) )
         optInVFactor = 7.000000e-1;
      else if( (optInVFactor < 0.000000e+0) || (optInVFactor > 1.000000e+0) )
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct t3 ));
      _state.value .value .mem_index = 0;
      _state.value .value .optInTimePeriod = optInTimePeriod;
      _state.value .value .optInVFactor = optInVFactor;
      _state.value .value .mem_size = t3Lookback (optInTimePeriod, optInVFactor );
      _state.value .value .memory = NULL;
      return RetCode.Success ;
   }
   public int t3State( struct TA_t3_State* _state,
      double inReal,
      double *outReal )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      size_t _cur_idx = _state.value .mem_index++;
      if ( _state.value .mem_size > 0) _cur_idx %= _state.value .mem_size ;
      _cur_idx = _state.value .mem_index -1;
      if ( ( _state.value .mem_index == 1) )
      {
         _state.value .k = 2.0/( _state.value .optInTimePeriod+1.0);
         _state.value .one_minus_k = 1.0 - _state.value .k;
         _state.value .tempReal = 0.;
         _state.value .firstOutput = 0;
         double t = _state.value .optInVFactor * _state.value .optInVFactor;
         _state.value .c1 = -(t * _state.value .optInVFactor);
         _state.value .c2 = 3.0 * (t - _state.value .c1);
         _state.value .c3 = -6.0 * t - 3.0 * ( _state.value .optInVFactor- _state.value .c1);
         _state.value .c4 = 1.0 + 3.0 * _state.value .optInVFactor - _state.value .c1 + 3.0 * t;
      }
      if ((int)_cur_idx < _state.value .optInTimePeriod)
      {
         _state.value .tempReal += inReal;
         if ((int)_cur_idx == _state.value .optInTimePeriod-1)
         {
            _state.value .e1 = _state.value .tempReal / _state.value .optInTimePeriod;
            _state.value .tempReal = _state.value .e1;
         }
         return RetCode.NeedMoreData ;
      } else
         if ((int)_cur_idx < 2* _state.value .optInTimePeriod-1)
      {
         _state.value .e1 = ( _state.value .k*inReal)+( _state.value .one_minus_k* _state.value .e1);
         _state.value .tempReal += _state.value .e1;
         if ((int)_cur_idx == 2* _state.value .optInTimePeriod-2)
         {
            _state.value .e2 = _state.value .tempReal / _state.value .optInTimePeriod;
            _state.value .tempReal = _state.value .e2;
         }
         return RetCode.NeedMoreData ;
      } else
         if ((int)_cur_idx < 3* _state.value .optInTimePeriod-2)
      {
         _state.value .e1 = ( _state.value .k*inReal)+( _state.value .one_minus_k* _state.value .e1);
         _state.value .e2 = ( _state.value .k* _state.value .e1)+( _state.value .one_minus_k* _state.value .e2);
         _state.value .tempReal += _state.value .e2;
         if ((int)_cur_idx == 3* _state.value .optInTimePeriod-3)
         {
            _state.value .e3 = _state.value .tempReal / _state.value .optInTimePeriod;
            _state.value .tempReal = _state.value .e3;
         }
         return RetCode.NeedMoreData ;
      } else
         if ((int)_cur_idx < 4* _state.value .optInTimePeriod-3)
      {
         _state.value .e1 = ( _state.value .k*inReal)+( _state.value .one_minus_k* _state.value .e1);
         _state.value .e2 = ( _state.value .k* _state.value .e1)+( _state.value .one_minus_k* _state.value .e2);
         _state.value .e3 = ( _state.value .k* _state.value .e2)+( _state.value .one_minus_k* _state.value .e3);
         _state.value .tempReal += _state.value .e3;
         if ((int)_cur_idx == 4* _state.value .optInTimePeriod-4)
         {
            _state.value .e4 = _state.value .tempReal / _state.value .optInTimePeriod;
            _state.value .tempReal = _state.value .e4;
         }
         return RetCode.NeedMoreData ;
      } else
         if ((int)_cur_idx < 5* _state.value .optInTimePeriod-4)
      {
         _state.value .e1 = ( _state.value .k*inReal)+( _state.value .one_minus_k* _state.value .e1);
         _state.value .e2 = ( _state.value .k* _state.value .e1)+( _state.value .one_minus_k* _state.value .e2);
         _state.value .e3 = ( _state.value .k* _state.value .e2)+( _state.value .one_minus_k* _state.value .e3);
         _state.value .e4 = ( _state.value .k* _state.value .e3)+( _state.value .one_minus_k* _state.value .e4);
         _state.value .tempReal += _state.value .e4;
         if ((int)_cur_idx == 5* _state.value .optInTimePeriod-5)
         {
            _state.value .e5 = _state.value .tempReal / _state.value .optInTimePeriod;
            _state.value .tempReal = _state.value .e5;
         }
         return RetCode.NeedMoreData ;
      } else
         if ((int)_cur_idx < 6* _state.value .optInTimePeriod-5)
      {
         _state.value .e1 = ( _state.value .k*inReal)+( _state.value .one_minus_k* _state.value .e1);
         _state.value .e2 = ( _state.value .k* _state.value .e1)+( _state.value .one_minus_k* _state.value .e2);
         _state.value .e3 = ( _state.value .k* _state.value .e2)+( _state.value .one_minus_k* _state.value .e3);
         _state.value .e4 = ( _state.value .k* _state.value .e3)+( _state.value .one_minus_k* _state.value .e4);
         _state.value .e5 = ( _state.value .k* _state.value .e4)+( _state.value .one_minus_k* _state.value .e5);
         _state.value .tempReal += _state.value .e5;
         if ((int)_cur_idx == 6* _state.value .optInTimePeriod-6)
         {
            _state.value .e6 = _state.value .tempReal / _state.value .optInTimePeriod;
            _state.value .tempReal = _state.value .e6;
         } else
            return RetCode.NeedMoreData ;
      }
      if ( _state.value .mem_size > _state.value .mem_index - 1 )
      {
         _state.value .e1 = ( _state.value .k*inReal)+( _state.value .one_minus_k* _state.value .e1);
         _state.value .e2 = ( _state.value .k* _state.value .e1)+( _state.value .one_minus_k* _state.value .e2);
         _state.value .e3 = ( _state.value .k* _state.value .e2)+( _state.value .one_minus_k* _state.value .e3);
         _state.value .e4 = ( _state.value .k* _state.value .e3)+( _state.value .one_minus_k* _state.value .e4);
         _state.value .e5 = ( _state.value .k* _state.value .e4)+( _state.value .one_minus_k* _state.value .e5);
         _state.value .e6 = ( _state.value .k* _state.value .e5)+( _state.value .one_minus_k* _state.value .e6);
         return RetCode.NeedMoreData ;
      } else
         if ( _state.value .firstOutput == 0)
      {
         _state.value .firstOutput = 1;
         outReal.value = _state.value .c1* _state.value .e6+ _state.value .c2* _state.value .e5+ _state.value .c3* _state.value .e4+ _state.value .c4* _state.value .e3;
         return RetCode.Success ;
      }
      _state.value .e1 = ( _state.value .k*inReal)+( _state.value .one_minus_k* _state.value .e1);
      _state.value .e2 = ( _state.value .k* _state.value .e1)+( _state.value .one_minus_k* _state.value .e2);
      _state.value .e3 = ( _state.value .k* _state.value .e2)+( _state.value .one_minus_k* _state.value .e3);
      _state.value .e4 = ( _state.value .k* _state.value .e3)+( _state.value .one_minus_k* _state.value .e4);
      _state.value .e5 = ( _state.value .k* _state.value .e4)+( _state.value .one_minus_k* _state.value .e5);
      _state.value .e6 = ( _state.value .k* _state.value .e5)+( _state.value .one_minus_k* _state.value .e6);
      outReal.value = _state.value .c1* _state.value .e6+ _state.value .c2* _state.value .e5+ _state.value .c3* _state.value .e4+ _state.value .c4* _state.value .e3;
      return RetCode.Success ;
   }
   public int t3StateFree( struct TA_t3_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if ( _state.value != NULL) {
         if ( _state.value .value .memory != NULL) TA_Free( _state.value .value .memory );
         TA_Free( _state.value ); _state.value = NULL;}
      return RetCode.Success ;
   }
   public RetCode t3( int startIdx,
      int endIdx,
      float inReal[],
      int optInTimePeriod,
      double optInVFactor,
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      int outIdx, lookbackTotal;
      int today, i;
      double k, one_minus_k;
      double e1, e2, e3, e4, e5, e6;
      double c1, c2, c3, c4;
      double tempReal;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 5;
      else if( ((int)optInTimePeriod < 2) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      if( optInVFactor == (-4e+37) )
         optInVFactor = 7.000000e-1;
      else if( (optInVFactor < 0.000000e+0) || (optInVFactor > 1.000000e+0) )
         return RetCode.BadParam ;
      lookbackTotal = 6 * (optInTimePeriod - 1) + (this.unstablePeriod[FuncUnstId.T3.ordinal()]) ;
      if( startIdx <= lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outNBElement.value = 0 ;
         outBegIdx.value = 0 ;
         return RetCode.Success ;
      }
      outBegIdx.value = startIdx;
      today = startIdx - lookbackTotal;
      k = 2.0/(optInTimePeriod+1.0);
      one_minus_k = 1.0-k;
      tempReal = inReal[today++];
      for( i=optInTimePeriod-1; i > 0 ; i-- )
         tempReal += inReal[today++];
      e1 = tempReal / optInTimePeriod;
      tempReal = e1;
      for( i=optInTimePeriod-1; i > 0 ; i-- )
      {
         e1 = (k*inReal[today++])+(one_minus_k*e1);
         tempReal += e1;
      }
      e2 = tempReal / optInTimePeriod;
      tempReal = e2;
      for( i=optInTimePeriod-1; i > 0 ; i-- )
      {
         e1 = (k*inReal[today++])+(one_minus_k*e1);
         e2 = (k*e1)+(one_minus_k*e2);
         tempReal += e2;
      }
      e3 = tempReal / optInTimePeriod;
      tempReal = e3;
      for( i=optInTimePeriod-1; i > 0 ; i-- )
      {
         e1 = (k*inReal[today++])+(one_minus_k*e1);
         e2 = (k*e1)+(one_minus_k*e2);
         e3 = (k*e2)+(one_minus_k*e3);
         tempReal += e3;
      }
      e4 = tempReal / optInTimePeriod;
      tempReal = e4;
      for( i=optInTimePeriod-1; i > 0 ; i-- )
      {
         e1 = (k*inReal[today++])+(one_minus_k*e1);
         e2 = (k*e1)+(one_minus_k*e2);
         e3 = (k*e2)+(one_minus_k*e3);
         e4 = (k*e3)+(one_minus_k*e4);
         tempReal += e4;
      }
      e5 = tempReal / optInTimePeriod;
      tempReal = e5;
      for( i=optInTimePeriod-1; i > 0 ; i-- )
      {
         e1 = (k*inReal[today++])+(one_minus_k*e1);
         e2 = (k*e1)+(one_minus_k*e2);
         e3 = (k*e2)+(one_minus_k*e3);
         e4 = (k*e3)+(one_minus_k*e4);
         e5 = (k*e4)+(one_minus_k*e5);
         tempReal += e5;
      }
      e6 = tempReal / optInTimePeriod;
      while( today <= startIdx )
      {
         e1 = (k*inReal[today++])+(one_minus_k*e1);
         e2 = (k*e1)+(one_minus_k*e2);
         e3 = (k*e2)+(one_minus_k*e3);
         e4 = (k*e3)+(one_minus_k*e4);
         e5 = (k*e4)+(one_minus_k*e5);
         e6 = (k*e5)+(one_minus_k*e6);
      }
      tempReal = optInVFactor * optInVFactor;
      c1 = -(tempReal * optInVFactor);
      c2 = 3.0 * (tempReal - c1);
      c3 = -6.0 * tempReal - 3.0 * (optInVFactor-c1);
      c4 = 1.0 + 3.0 * optInVFactor - c1 + 3.0 * tempReal;
      outIdx = 0;
      outReal[outIdx++] = c1*e6+c2*e5+c3*e4+c4*e3;
      while( today <= endIdx )
      {
         e1 = (k*inReal[today++])+(one_minus_k*e1);
         e2 = (k*e1)+(one_minus_k*e2);
         e3 = (k*e2)+(one_minus_k*e3);
         e4 = (k*e3)+(one_minus_k*e4);
         e5 = (k*e4)+(one_minus_k*e5);
         e6 = (k*e5)+(one_minus_k*e6);
         outReal[outIdx++] = c1*e6+c2*e5+c3*e4+c4*e3;
      }
      outNBElement.value = outIdx;
      return RetCode.Success ;
   }
   /* Generated */
   public int tanLookback( )
   {
      return RetCode.Success ;
   }
   public RetCode tan( int startIdx,
      int endIdx,
      double inReal[],
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      int outIdx;
      int i;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      for( i=startIdx, outIdx=0; i <= endIdx; i++, outIdx++ )
      {
         outReal[outIdx] = Math.tan (inReal[i]);
      }
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   public int tanStateInit( struct TA_tan_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct tan ));
      _state.value .value .mem_index = 0;
      _state.value .value .mem_size = tanLookback ();
      if ( _state.value .value .mem_size > 0)
         _state.value .value .memory = TA_Calloc( _state.value .value .mem_size , sizeof(struct TA_TAN_Data));
      else
         _state.value .value .memory = NULL;
      return RetCode.Success ;
   }
   public int tanState( struct TA_tan_State* _state,
      double inReal,
      double *outReal )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      size_t _cur_idx = _state.value .mem_index++;
      if ( _state.value .mem_size > 0) _cur_idx %= _state.value .mem_size ;
      if ( _state.value .mem_size > _state.value .mem_index - 1 ) {
         ( _state.value .memory+_cur_idx).value .inReal = inReal ;
         return RetCode.NeedMoreData ; }
      outReal.value = Math.tan (inReal);
      return RetCode.Success ;
   }
   public int tanStateFree( struct TA_tan_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if ( _state.value != NULL) {
         if ( _state.value .value .memory != NULL) TA_Free( _state.value .value .memory );
         TA_Free( _state.value ); _state.value = NULL;}
      return RetCode.Success ;
   }
   public RetCode tan( int startIdx,
      int endIdx,
      float inReal[],
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      int outIdx;
      int i;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      for( i=startIdx, outIdx=0; i <= endIdx; i++, outIdx++ )
      {
         outReal[outIdx] = Math.tan (inReal[i]);
      }
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   /* Generated */
   public int tanhLookback( )
   {
      return RetCode.Success ;
   }
   public RetCode tanh( int startIdx,
      int endIdx,
      double inReal[],
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      int outIdx;
      int i;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      for( i=startIdx, outIdx=0; i <= endIdx; i++, outIdx++ )
      {
         outReal[outIdx] = Math.tanh (inReal[i]);
      }
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   public int tanhStateInit( struct TA_tanh_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct tanh ));
      _state.value .value .mem_index = 0;
      _state.value .value .mem_size = tanhLookback ();
      if ( _state.value .value .mem_size > 0)
         _state.value .value .memory = TA_Calloc( _state.value .value .mem_size , sizeof(struct TA_TANH_Data));
      else
         _state.value .value .memory = NULL;
      return RetCode.Success ;
   }
   public int tanhState( struct TA_tanh_State* _state,
      double inReal,
      double *outReal )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      size_t _cur_idx = _state.value .mem_index++;
      if ( _state.value .mem_size > 0) _cur_idx %= _state.value .mem_size ;
      if ( _state.value .mem_size > _state.value .mem_index - 1 ) {
         ( _state.value .memory+_cur_idx).value .inReal = inReal ;
         return RetCode.NeedMoreData ; }
      outReal.value = Math.tanh (inReal);
      return RetCode.Success ;
   }
   public int tanhStateFree( struct TA_tanh_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if ( _state.value != NULL) {
         if ( _state.value .value .memory != NULL) TA_Free( _state.value .value .memory );
         TA_Free( _state.value ); _state.value = NULL;}
      return RetCode.Success ;
   }
   public RetCode tanh( int startIdx,
      int endIdx,
      float inReal[],
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      int outIdx;
      int i;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      for( i=startIdx, outIdx=0; i <= endIdx; i++, outIdx++ )
      {
         outReal[outIdx] = Math.tanh (inReal[i]);
      }
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   /* Generated */
   public int temaLookback( int optInTimePeriod )
   {
      int retValue;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 30;
      else if( ((int)optInTimePeriod < 2) || ((int)optInTimePeriod > 100000) )
         return -1;
      retValue = emaLookback ( optInTimePeriod );
      return retValue * 3;
   }
   public RetCode tema( int startIdx,
      int endIdx,
      double inReal[],
      int optInTimePeriod,
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      double []firstEMA ;
      double []secondEMA ;
      double k;
      MInteger firstEMABegIdx = new MInteger() ;
      MInteger firstEMANbElement = new MInteger() ;
      MInteger secondEMABegIdx = new MInteger() ;
      MInteger secondEMANbElement = new MInteger() ;
      MInteger thirdEMABegIdx = new MInteger() ;
      MInteger thirdEMANbElement = new MInteger() ;
      int tempInt, outIdx, lookbackTotal, lookbackEMA;
      int firstEMAIdx, secondEMAIdx;
      RetCode retCode;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 30;
      else if( ((int)optInTimePeriod < 2) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      outNBElement.value = 0 ;
      outBegIdx.value = 0 ;
      lookbackEMA = emaLookback ( optInTimePeriod );
      lookbackTotal = lookbackEMA * 3;
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
         return RetCode.Success ;
      tempInt = lookbackTotal+(endIdx-startIdx)+1;
      firstEMA = new double[tempInt] ;
      k = ((double)2.0 / ((double)(optInTimePeriod + 1))) ;
      retCode = TA_INT_EMA ( startIdx-(lookbackEMA*2), endIdx, inReal,
         optInTimePeriod, k,
         firstEMABegIdx , firstEMANbElement ,
         firstEMA );
      if( (retCode != RetCode.Success ) || ( firstEMANbElement.value == 0) )
      {
         return retCode;
      }
      secondEMA = new double[firstEMANbElement.value ] ;
      retCode = TA_INT_EMA ( 0, firstEMANbElement.value -1, firstEMA,
         optInTimePeriod, k,
         secondEMABegIdx , secondEMANbElement ,
         secondEMA );
      if( (retCode != RetCode.Success ) || ( secondEMANbElement.value == 0) )
      {
         return retCode;
      }
      retCode = TA_INT_EMA ( 0, secondEMANbElement.value -1, secondEMA,
         optInTimePeriod, k,
         thirdEMABegIdx , thirdEMANbElement ,
         outReal );
      if( (retCode != RetCode.Success ) || ( thirdEMANbElement.value == 0) )
      {
         return retCode;
      }
      firstEMAIdx = thirdEMABegIdx.value + secondEMABegIdx.value ;
      secondEMAIdx = thirdEMABegIdx.value ;
      outBegIdx.value = firstEMAIdx + firstEMABegIdx.value ;
      outIdx = 0;
      while( outIdx < thirdEMANbElement.value )
      {
         outReal[outIdx] += (3.0*firstEMA[firstEMAIdx++]) - (3.0*secondEMA[secondEMAIdx++]);
         outIdx++;
      }
      outNBElement.value = outIdx;
      return RetCode.Success ;
   }
   public int temaStateInit( struct TA_tema_State** _state,
      int optInTimePeriod )
   {
      int res;
      if (_state == NULL)
         return RetCode.BadParam ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 30;
      else if( ((int)optInTimePeriod < 2) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct tema ));
      _state.value .value .mem_index = 0;
      _state.value .value .optInTimePeriod = optInTimePeriod;
      _state.value .value .mem_size = temaLookback (optInTimePeriod );
      _state.value .value .memory = NULL;
      res = ema ((struct ema **)& _state.value .value .state_EMA, optInTimePeriod);
      if (res == RetCode.Success )
      {
         res = ema ((struct ema **)& _state.value .value .state_EMA2, optInTimePeriod);
      }
      if (res == RetCode.Success )
      {
         res = ema ((struct ema **)& _state.value .value .state_EMA3, optInTimePeriod);
      }
      return res;
   }
   public int temaState( struct TA_tema_State* _state,
      double inReal,
      double *outReal )
   {
      double ema, ema2, ema3;
      int retCode;
      if (_state == NULL)
         return RetCode.BadParam ;
      size_t _cur_idx = _state.value .mem_index++;
      if ( _state.value .mem_size > 0) _cur_idx %= _state.value .mem_size ;
      retCode = ema ( _state.value .state_EMA, inReal, &ema );
      if( retCode != RetCode.Success )
         return retCode;
      retCode = ema ( _state.value .state_EMA2, ema, &ema2 );
      if( retCode != RetCode.Success )
         return retCode;
      retCode = ema ( _state.value .state_EMA3, ema2, &ema3 );
      if( retCode != RetCode.Success )
         return retCode;
      outReal.value = (3.0*ema) - (3.0*ema2) + ema3;
      return RetCode.Success ;
   }
   public int temaStateFree( struct TA_tema_State** _state )
   {
      int res = ema ((struct ema **)& _state.value .value .state_EMA);
      if (res == RetCode.Success )
      {
         res = ema ((struct ema **)& _state.value .value .state_EMA2);
      }
      if (res == RetCode.Success )
      {
         res = ema ((struct ema **)& _state.value .value .state_EMA3);
      }
      if (_state == NULL)
         return RetCode.BadParam ;
      if ( _state.value != NULL) {
         if ( _state.value .value .memory != NULL) TA_Free( _state.value .value .memory );
         TA_Free( _state.value ); _state.value = NULL;}
      return res;
   }
   public RetCode tema( int startIdx,
      int endIdx,
      float inReal[],
      int optInTimePeriod,
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      double []firstEMA ;
      double []secondEMA ;
      double k;
      MInteger firstEMABegIdx = new MInteger() ;
      MInteger firstEMANbElement = new MInteger() ;
      MInteger secondEMABegIdx = new MInteger() ;
      MInteger secondEMANbElement = new MInteger() ;
      MInteger thirdEMABegIdx = new MInteger() ;
      MInteger thirdEMANbElement = new MInteger() ;
      int tempInt, outIdx, lookbackTotal, lookbackEMA;
      int firstEMAIdx, secondEMAIdx;
      RetCode retCode;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 30;
      else if( ((int)optInTimePeriod < 2) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      outNBElement.value = 0 ;
      outBegIdx.value = 0 ;
      lookbackEMA = emaLookback ( optInTimePeriod );
      lookbackTotal = lookbackEMA * 3;
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
         return RetCode.Success ;
      tempInt = lookbackTotal+(endIdx-startIdx)+1;
      firstEMA = new double[tempInt] ;
      k = ((double)2.0 / ((double)(optInTimePeriod + 1))) ;
      retCode = TA_INT_EMA ( startIdx-(lookbackEMA*2), endIdx, inReal,
         optInTimePeriod, k,
         firstEMABegIdx , firstEMANbElement ,
         firstEMA );
      if( (retCode != RetCode.Success ) || ( firstEMANbElement.value == 0) )
      {
         return retCode;
      }
      secondEMA = new double[firstEMANbElement.value ] ;
      retCode = TA_INT_EMA ( 0, firstEMANbElement.value -1, firstEMA,
         optInTimePeriod, k,
         secondEMABegIdx , secondEMANbElement ,
         secondEMA );
      if( (retCode != RetCode.Success ) || ( secondEMANbElement.value == 0) )
      {
         return retCode;
      }
      retCode = TA_INT_EMA ( 0, secondEMANbElement.value -1, secondEMA,
         optInTimePeriod, k,
         thirdEMABegIdx , thirdEMANbElement ,
         outReal );
      if( (retCode != RetCode.Success ) || ( thirdEMANbElement.value == 0) )
      {
         return retCode;
      }
      firstEMAIdx = thirdEMABegIdx.value + secondEMABegIdx.value ;
      secondEMAIdx = thirdEMABegIdx.value ;
      outBegIdx.value = firstEMAIdx + firstEMABegIdx.value ;
      outIdx = 0;
      while( outIdx < thirdEMANbElement.value )
      {
         outReal[outIdx] += (3.0*firstEMA[firstEMAIdx++]) - (3.0*secondEMA[secondEMAIdx++]);
         outIdx++;
      }
      outNBElement.value = outIdx;
      return RetCode.Success ;
   }
   /* Generated */
   public int trueRangeLookback( )
   {
      return 1;
   }
   public RetCode trueRange( int startIdx,
      int endIdx,
      double inHigh[],
      double inLow[],
      double inClose[],
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      int today, outIdx;
      double val2, val3, greatest;
      double tempCY, tempLT, tempHT;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      if( startIdx < 1 )
         startIdx = 1;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      outIdx = 0;
      today = startIdx;
      while( today <= endIdx )
      {
         tempLT = inLow[today];
         tempHT = inHigh[today];
         tempCY = inClose[today-1];
         greatest = tempHT - tempLT;
         val2 = Math.abs ( tempCY - tempHT );
         if( val2 > greatest )
            greatest = val2;
         val3 = Math.abs ( tempCY - tempLT );
         if( val3 > greatest )
            greatest = val3;
         outReal[outIdx++] = greatest;
         today++;
      }
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   public int trueRangeStateInit( struct TA_trueRange_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct trueRange ));
      _state.value .value .mem_index = 0;
      _state.value .value .mem_size = trueRangeLookback ();
      if ( _state.value .value .mem_size > 0)
         _state.value .value .memory = TA_Calloc( _state.value .value .mem_size , sizeof(struct TA_TRANGE_Data));
      else
         _state.value .value .memory = NULL;
      return RetCode.Success ;
   }
   public int trueRangeState( struct TA_trueRange_State* _state,
      double inHigh,
      double inLow,
      double inClose,
      double *outReal )
   {
      double val2, val3, greatest, tempCY;
      if (_state == NULL)
         return RetCode.BadParam ;
      size_t _cur_idx = _state.value .mem_index++;
      if ( _state.value .mem_size > 0) _cur_idx %= _state.value .mem_size ;
      if ( _state.value .mem_size > _state.value .mem_index - 1 ) {
         ( _state.value .memory+_cur_idx).value .inHigh = inHigh ;
         ( _state.value .memory+_cur_idx).value .inLow = inLow ;
         ( _state.value .memory+_cur_idx).value .inClose = inClose ;
         return RetCode.NeedMoreData ; }
      tempCY = ( _state.value .memory+_cur_idx).value .inClose ;
      greatest = inHigh - inLow;
      val2 = Math.abs ( tempCY - inHigh );
      if( val2 > greatest )
         greatest = val2;
      val3 = Math.abs ( tempCY - inLow );
      if( val3 > greatest )
         greatest = val3;
      outReal.value = greatest;
      return RetCode.Success ;
   }
   public int trueRangeStateFree( struct TA_trueRange_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if ( _state.value != NULL) {
         if ( _state.value .value .memory != NULL) TA_Free( _state.value .value .memory );
         TA_Free( _state.value ); _state.value = NULL;}
      return RetCode.Success ;
   }
   public RetCode trueRange( int startIdx,
      int endIdx,
      float inHigh[],
      float inLow[],
      float inClose[],
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      int today, outIdx;
      double val2, val3, greatest;
      double tempCY, tempLT, tempHT;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      if( startIdx < 1 )
         startIdx = 1;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      outIdx = 0;
      today = startIdx;
      while( today <= endIdx )
      {
         tempLT = inLow[today];
         tempHT = inHigh[today];
         tempCY = inClose[today-1];
         greatest = tempHT - tempLT;
         val2 = Math.abs ( tempCY - tempHT );
         if( val2 > greatest )
            greatest = val2;
         val3 = Math.abs ( tempCY - tempLT );
         if( val3 > greatest )
            greatest = val3;
         outReal[outIdx++] = greatest;
         today++;
      }
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   /* Generated */
   public int trimaLookback( int optInTimePeriod )
   {
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 30;
      else if( ((int)optInTimePeriod < 2) || ((int)optInTimePeriod > 100000) )
         return -1;
      return optInTimePeriod-1;
   }
   public RetCode trima( int startIdx,
      int endIdx,
      double inReal[],
      int optInTimePeriod,
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      int lookbackTotal;
      double numerator;
      double numeratorSub;
      double numeratorAdd;
      int i, outIdx, todayIdx, trailingIdx, middleIdx;
      double factor, tempReal;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 30;
      else if( ((int)optInTimePeriod < 2) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      lookbackTotal = (optInTimePeriod-1);
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      outIdx = 0;
      if( (optInTimePeriod % 2) == 1 )
      {
         i = (optInTimePeriod>>1);
         factor = (i+1)*(i+1);
         factor = 1.0/factor;
         trailingIdx = startIdx-lookbackTotal;
         middleIdx = trailingIdx + i;
         todayIdx = middleIdx + i;
         numerator = 0.0;
         numeratorSub = 0.0;
         for( i=middleIdx; i >= trailingIdx; i-- )
         {
            tempReal = inReal[i];
            numeratorSub += tempReal;
            numerator += numeratorSub;
         }
         numeratorAdd = 0.0;
         middleIdx++;
         for( i=middleIdx; i <= todayIdx; i++ )
         {
            tempReal = inReal[i];
            numeratorAdd += tempReal;
            numerator += numeratorAdd;
         }
         outIdx = 0;
         tempReal = inReal[trailingIdx++];
         outReal[outIdx++] = numerator * factor;
         todayIdx++;
         while( todayIdx <= endIdx )
         {
            numerator -= numeratorSub;
            numeratorSub -= tempReal;
            tempReal = inReal[middleIdx++];
            numeratorSub += tempReal;
            numerator += numeratorAdd;
            numeratorAdd -= tempReal;
            tempReal = inReal[todayIdx++];
            numeratorAdd += tempReal;
            numerator += tempReal;
            tempReal = inReal[trailingIdx++];
            outReal[outIdx++] = numerator * factor;
         }
      }
      else
      {
         i = (optInTimePeriod>>1);
         factor = i*(i+1);
         factor = 1.0/factor;
         trailingIdx = startIdx-lookbackTotal;
         middleIdx = trailingIdx + i - 1;
         todayIdx = middleIdx + i;
         numerator = 0.0;
         numeratorSub = 0.0;
         for( i=middleIdx; i >= trailingIdx; i-- )
         {
            tempReal = inReal[i];
            numeratorSub += tempReal;
            numerator += numeratorSub;
         }
         numeratorAdd = 0.0;
         middleIdx++;
         for( i=middleIdx; i <= todayIdx; i++ )
         {
            tempReal = inReal[i];
            numeratorAdd += tempReal;
            numerator += numeratorAdd;
         }
         outIdx = 0;
         tempReal = inReal[trailingIdx++];
         outReal[outIdx++] = numerator * factor;
         todayIdx++;
         while( todayIdx <= endIdx )
         {
            numerator -= numeratorSub;
            numeratorSub -= tempReal;
            tempReal = inReal[middleIdx++];
            numeratorSub += tempReal;
            numeratorAdd -= tempReal;
            numerator += numeratorAdd;
            tempReal = inReal[todayIdx++];
            numeratorAdd += tempReal;
            numerator += tempReal;
            tempReal = inReal[trailingIdx++];
            outReal[outIdx++] = numerator * factor;
         }
      }
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   public int trimaStateInit( struct TA_trima_State** _state,
      int optInTimePeriod )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 30;
      else if( ((int)optInTimePeriod < 2) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct trima ));
      _state.value .value .mem_index = 0;
      _state.value .value .optInTimePeriod = optInTimePeriod;
      _state.value .value .mem_size = trimaLookback (optInTimePeriod );
      if ( _state.value .value .mem_size > 0)
         _state.value .value .memory = TA_Calloc( _state.value .value .mem_size , sizeof(struct TA_TRIMA_Data));
      else
         _state.value .value .memory = NULL;
      return RetCode.Success ;
   }
   public int trimaState( struct TA_trima_State* _state,
      double inReal,
      double *outReal )
   {
      int i, middle;
      double tempReal;
      if (_state == NULL)
         return RetCode.BadParam ;
      size_t _cur_idx = _state.value .mem_index++;
      if ( _state.value .mem_size > 0) _cur_idx %= _state.value .mem_size ;
      if ( ( _state.value .mem_index == 1) )
      {
         _state.value .numerator = 0;
         _state.value .numeratorSub = 0;
         _state.value .numeratorAdd = 0;
         if( ( _state.value .optInTimePeriod % 2) == 1 )
         {
            i = ( _state.value .optInTimePeriod>>1);
            _state.value .factor = (i+1)*(i+1);
            _state.value .factor = 1.0/ _state.value .factor;
            _state.value .middleIdx = i;
         } else {
            i = ( _state.value .optInTimePeriod>>1);
            _state.value .factor = i*(i+1);
            _state.value .factor = 1.0/ _state.value .factor;
            _state.value .middleIdx = i - 1;
         }
      }
      if ( _state.value .mem_size > _state.value .mem_index - 1 )
      {
         if ((int)_cur_idx <= _state.value .middleIdx)
         {
            _state.value .numerator -= _state.value .numeratorSub;
            _state.value .numeratorSub += inReal;
            _state.value .numerator += ( _state.value .middleIdx+1) * inReal;
         }
         if ((int)_cur_idx > _state.value .middleIdx)
         {
            _state.value .numeratorAdd += inReal;
            _state.value .numerator += _state.value .numeratorAdd;
         }
         ( _state.value .memory+_cur_idx).value .inReal = inReal ;
         return RetCode.NeedMoreData ;
      } else
         if ( _state.value .mem_size == _state.value .mem_index - 1)
         ++ _state.value .middleIdx;
      _state.value .numeratorAdd += inReal;
      if ( _state.value .mem_size == _state.value .mem_index - 1)
         _state.value .numerator += _state.value .numeratorAdd;
      else
         _state.value .numerator += inReal;
      outReal.value = _state.value .numerator * _state.value .factor;
      _state.value .numerator -= _state.value .numeratorSub;
      _state.value .numeratorSub -= ( _state.value .memory+_cur_idx).value .inReal ;
      middle = _state.value .middleIdx++ % _state.value .mem_size;
      tempReal = ( _state.value .memory+middle).value .inReal ;
      _state.value .numeratorSub += tempReal;
      if( ( _state.value .optInTimePeriod % 2) == 1 )
      {
         _state.value .numerator += _state.value .numeratorAdd;
         _state.value .numeratorAdd -= tempReal;
      } else {
         _state.value .numeratorAdd -= tempReal;
         _state.value .numerator += _state.value .numeratorAdd;
      }
      ( _state.value .memory+_cur_idx).value .inReal = inReal ;
      return RetCode.Success ;
   }
   public int trimaStateFree( struct TA_trima_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if ( _state.value != NULL) {
         if ( _state.value .value .memory != NULL) TA_Free( _state.value .value .memory );
         TA_Free( _state.value ); _state.value = NULL;}
      return RetCode.Success ;
   }
   public RetCode trima( int startIdx,
      int endIdx,
      float inReal[],
      int optInTimePeriod,
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      int lookbackTotal;
      double numerator;
      double numeratorSub;
      double numeratorAdd;
      int i, outIdx, todayIdx, trailingIdx, middleIdx;
      double factor, tempReal;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 30;
      else if( ((int)optInTimePeriod < 2) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      lookbackTotal = (optInTimePeriod-1);
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      outIdx = 0;
      if( (optInTimePeriod % 2) == 1 )
      {
         i = (optInTimePeriod>>1);
         factor = (i+1)*(i+1);
         factor = 1.0/factor;
         trailingIdx = startIdx-lookbackTotal;
         middleIdx = trailingIdx + i;
         todayIdx = middleIdx + i;
         numerator = 0.0;
         numeratorSub = 0.0;
         for( i=middleIdx; i >= trailingIdx; i-- )
         {
            tempReal = inReal[i];
            numeratorSub += tempReal;
            numerator += numeratorSub;
         }
         numeratorAdd = 0.0;
         middleIdx++;
         for( i=middleIdx; i <= todayIdx; i++ )
         {
            tempReal = inReal[i];
            numeratorAdd += tempReal;
            numerator += numeratorAdd;
         }
         outIdx = 0;
         tempReal = inReal[trailingIdx++];
         outReal[outIdx++] = numerator * factor;
         todayIdx++;
         while( todayIdx <= endIdx )
         {
            numerator -= numeratorSub;
            numeratorSub -= tempReal;
            tempReal = inReal[middleIdx++];
            numeratorSub += tempReal;
            numerator += numeratorAdd;
            numeratorAdd -= tempReal;
            tempReal = inReal[todayIdx++];
            numeratorAdd += tempReal;
            numerator += tempReal;
            tempReal = inReal[trailingIdx++];
            outReal[outIdx++] = numerator * factor;
         }
      }
      else
      {
         i = (optInTimePeriod>>1);
         factor = i*(i+1);
         factor = 1.0/factor;
         trailingIdx = startIdx-lookbackTotal;
         middleIdx = trailingIdx + i - 1;
         todayIdx = middleIdx + i;
         numerator = 0.0;
         numeratorSub = 0.0;
         for( i=middleIdx; i >= trailingIdx; i-- )
         {
            tempReal = inReal[i];
            numeratorSub += tempReal;
            numerator += numeratorSub;
         }
         numeratorAdd = 0.0;
         middleIdx++;
         for( i=middleIdx; i <= todayIdx; i++ )
         {
            tempReal = inReal[i];
            numeratorAdd += tempReal;
            numerator += numeratorAdd;
         }
         outIdx = 0;
         tempReal = inReal[trailingIdx++];
         outReal[outIdx++] = numerator * factor;
         todayIdx++;
         while( todayIdx <= endIdx )
         {
            numerator -= numeratorSub;
            numeratorSub -= tempReal;
            tempReal = inReal[middleIdx++];
            numeratorSub += tempReal;
            numeratorAdd -= tempReal;
            numerator += numeratorAdd;
            tempReal = inReal[todayIdx++];
            numeratorAdd += tempReal;
            numerator += tempReal;
            tempReal = inReal[trailingIdx++];
            outReal[outIdx++] = numerator * factor;
         }
      }
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   /* Generated */
   public int trixLookback( int optInTimePeriod )
   {
      int emaLookback;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 30;
      else if( ((int)optInTimePeriod < 1) || ((int)optInTimePeriod > 100000) )
         return -1;
      emaLookback = emaLookback ( optInTimePeriod );
      return (emaLookback*3) + rocRLookback ( 1 );
   }
   public RetCode trix( int startIdx,
      int endIdx,
      double inReal[],
      int optInTimePeriod,
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      double k;
      double []tempBuffer ;
      MInteger nbElement = new MInteger() ;
      MInteger begIdx = new MInteger() ;
      int totalLookback;
      int emaLookback, rocLookback;
      RetCode retCode;
      int nbElementToOutput;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 30;
      else if( ((int)optInTimePeriod < 1) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      emaLookback = emaLookback ( optInTimePeriod );
      rocLookback = rocRLookback ( 1 );
      totalLookback = (emaLookback*3) + rocLookback;
      if( startIdx < totalLookback )
         startIdx = totalLookback;
      if( startIdx > endIdx )
      {
         outNBElement.value = 0 ;
         outBegIdx.value = 0 ;
         return RetCode.Success ;
      }
      outBegIdx.value = startIdx;
      nbElementToOutput = (endIdx-startIdx)+1+totalLookback;
      tempBuffer = new double[nbElementToOutput] ;
      k = ((double)2.0 / ((double)(optInTimePeriod + 1))) ;
      retCode = TA_INT_EMA ( (startIdx-totalLookback), endIdx, inReal,
         optInTimePeriod, k,
         begIdx , nbElement ,
         tempBuffer );
      if( (retCode != RetCode.Success ) || ( nbElement.value == 0) )
      {
         outNBElement.value = 0 ;
         outBegIdx.value = 0 ;
         return retCode;
      }
      nbElementToOutput--;
      nbElementToOutput -= emaLookback;
      retCode = TA_INT_EMA ( 0, nbElementToOutput, tempBuffer,
         optInTimePeriod, k,
         begIdx , nbElement ,
         tempBuffer );
      if( (retCode != RetCode.Success ) || ( nbElement.value == 0) )
      {
         outNBElement.value = 0 ;
         outBegIdx.value = 0 ;
         return retCode;
      }
      nbElementToOutput -= emaLookback;
      retCode = TA_INT_EMA ( 0, nbElementToOutput, tempBuffer,
         optInTimePeriod, k,
         begIdx , nbElement ,
         tempBuffer );
      if( (retCode != RetCode.Success ) || ( nbElement.value == 0) )
      {
         outNBElement.value = 0 ;
         outBegIdx.value = 0 ;
         return retCode;
      }
      nbElementToOutput -= emaLookback;
      retCode = roc ( 0, nbElementToOutput,
         tempBuffer,
         1, begIdx , outNBElement,
         outReal );
      if( (retCode != RetCode.Success ) || ((int) outNBElement.value == 0) )
      {
         outNBElement.value = 0 ;
         outBegIdx.value = 0 ;
         return retCode;
      }
      return RetCode.Success ;
   }
   public int trixStateInit( struct TA_trix_State** _state,
      int optInTimePeriod )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 30;
      else if( ((int)optInTimePeriod < 1) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct trix ));
      _state.value .value .mem_index = 0;
      _state.value .value .optInTimePeriod = optInTimePeriod;
      _state.value .value .mem_size = trixLookback (optInTimePeriod );
      if ( _state.value .value .mem_size > 0)
         _state.value .value .memory = TA_Calloc( _state.value .value .mem_size , sizeof(struct TA_TRIX_Data));
      else
         _state.value .value .memory = NULL;
      return RetCode.Success ;
   }
   public int trixState( struct TA_trix_State* _state,
      double inReal,
      double *outReal )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      size_t _cur_idx = _state.value .mem_index++;
      if ( _state.value .mem_size > 0) _cur_idx %= _state.value .mem_size ;
      if ( _state.value .mem_size > _state.value .mem_index - 1 ) {
         ( _state.value .memory+_cur_idx).value .inReal = inReal ;
         return RetCode.NeedMoreData ; }
      return RetCode.Success ;
   }
   public int trixStateFree( struct TA_trix_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if ( _state.value != NULL) {
         if ( _state.value .value .memory != NULL) TA_Free( _state.value .value .memory );
         TA_Free( _state.value ); _state.value = NULL;}
      return RetCode.Success ;
   }
   public RetCode trix( int startIdx,
      int endIdx,
      float inReal[],
      int optInTimePeriod,
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      double k;
      double []tempBuffer ;
      MInteger nbElement = new MInteger() ;
      MInteger begIdx = new MInteger() ;
      int totalLookback;
      int emaLookback, rocLookback;
      RetCode retCode;
      int nbElementToOutput;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 30;
      else if( ((int)optInTimePeriod < 1) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      emaLookback = emaLookback ( optInTimePeriod );
      rocLookback = rocRLookback ( 1 );
      totalLookback = (emaLookback*3) + rocLookback;
      if( startIdx < totalLookback )
         startIdx = totalLookback;
      if( startIdx > endIdx )
      {
         outNBElement.value = 0 ;
         outBegIdx.value = 0 ;
         return RetCode.Success ;
      }
      outBegIdx.value = startIdx;
      nbElementToOutput = (endIdx-startIdx)+1+totalLookback;
      tempBuffer = new double[nbElementToOutput] ;
      k = ((double)2.0 / ((double)(optInTimePeriod + 1))) ;
      retCode = TA_INT_EMA ( (startIdx-totalLookback), endIdx, inReal,
         optInTimePeriod, k,
         begIdx , nbElement ,
         tempBuffer );
      if( (retCode != RetCode.Success ) || ( nbElement.value == 0) )
      {
         outNBElement.value = 0 ;
         outBegIdx.value = 0 ;
         return retCode;
      }
      nbElementToOutput--;
      nbElementToOutput -= emaLookback;
      retCode = TA_INT_EMA ( 0, nbElementToOutput, tempBuffer,
         optInTimePeriod, k,
         begIdx , nbElement ,
         tempBuffer );
      if( (retCode != RetCode.Success ) || ( nbElement.value == 0) )
      {
         outNBElement.value = 0 ;
         outBegIdx.value = 0 ;
         return retCode;
      }
      nbElementToOutput -= emaLookback;
      retCode = TA_INT_EMA ( 0, nbElementToOutput, tempBuffer,
         optInTimePeriod, k,
         begIdx , nbElement ,
         tempBuffer );
      if( (retCode != RetCode.Success ) || ( nbElement.value == 0) )
      {
         outNBElement.value = 0 ;
         outBegIdx.value = 0 ;
         return retCode;
      }
      nbElementToOutput -= emaLookback;
      retCode = roc ( 0, nbElementToOutput,
         tempBuffer,
         1, begIdx , outNBElement,
         outReal );
      if( (retCode != RetCode.Success ) || ((int) outNBElement.value == 0) )
      {
         outNBElement.value = 0 ;
         outBegIdx.value = 0 ;
         return retCode;
      }
      return RetCode.Success ;
   }
   /* Generated */
   public int tsfLookback( int optInTimePeriod )
   {
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 14;
      else if( ((int)optInTimePeriod < 2) || ((int)optInTimePeriod > 100000) )
         return -1;
      return optInTimePeriod-1;
   }
   public RetCode tsf( int startIdx,
      int endIdx,
      double inReal[],
      int optInTimePeriod,
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      int outIdx;
      int today, lookbackTotal;
      double SumX, SumXY, SumY, SumXSqr, Divisor;
      double m, b;
      int i;
      double tempValue1;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 14;
      else if( ((int)optInTimePeriod < 2) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      lookbackTotal = tsfLookback ( optInTimePeriod );
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      outIdx = 0;
      today = startIdx;
      SumX = optInTimePeriod * ( optInTimePeriod - 1 ) * 0.5;
      SumXSqr = optInTimePeriod * ( optInTimePeriod - 1 ) * ( 2 * optInTimePeriod - 1 ) / 6;
      Divisor = SumX * SumX - optInTimePeriod * SumXSqr;
      while( today <= endIdx )
      {
         SumXY = 0;
         SumY = 0;
         for( i = optInTimePeriod; i-- != 0; )
         {
            SumY += tempValue1 = inReal[today - i];
            SumXY += (double)i * tempValue1;
         }
         m = ( optInTimePeriod * SumXY - SumX * SumY) / Divisor;
         b = ( SumY - m * SumX ) / (double)optInTimePeriod;
         outReal[outIdx++] = b + m * (double)optInTimePeriod;
         today++;
      }
      outBegIdx.value = startIdx;
      outNBElement.value = outIdx;
      return RetCode.Success ;
   }
   public int tsfStateInit( struct TA_tsf_State** _state,
      int optInTimePeriod )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 14;
      else if( ((int)optInTimePeriod < 2) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct tsf ));
      _state.value .value .mem_index = 0;
      _state.value .value .optInTimePeriod = optInTimePeriod;
      _state.value .value .mem_size = tsfLookback (optInTimePeriod );
      if ( _state.value .value .mem_size > 0)
         _state.value .value .memory = TA_Calloc( _state.value .value .mem_size , sizeof(struct TA_TSF_Data));
      else
         _state.value .value .memory = NULL;
      return RetCode.Success ;
   }
   public int tsfState( struct TA_tsf_State* _state,
      double inReal,
      double *outReal )
   {
      double m, b, tempReal;
      if (_state == NULL)
         return RetCode.BadParam ;
      size_t _cur_idx = _state.value .mem_index++;
      if ( _state.value .mem_size > 0) _cur_idx %= _state.value .mem_size ;
      if ( _state.value .mem_size > _state.value .mem_index - 1 ) {
         ( _state.value .memory+_cur_idx).value .inReal = inReal ;
         return RetCode.NeedMoreData ; }
      if ( ( _state.value .mem_index == 1) )
      {
         _state.value .SumX = _state.value .optInTimePeriod * ( _state.value .optInTimePeriod - 1 ) * 0.5;
         _state.value .SumXSqr = _state.value .optInTimePeriod * ( _state.value .optInTimePeriod - 1 ) * ( 2 * _state.value .optInTimePeriod - 1 ) / 6;
         _state.value .Divisor = _state.value .SumX * _state.value .SumX - _state.value .optInTimePeriod * _state.value .SumXSqr;
         _state.value .SumXY = 0;
         _state.value .SumY = 0;
      }
      if ( _state.value .mem_size > _state.value .mem_index - 1 )
      {
         _state.value .SumY += inReal;
         _state.value .SumXY += _state.value .SumY;
         ( _state.value .memory+_cur_idx).value .inReal = inReal ;
         return RetCode.NeedMoreData ;
      }
      _state.value .SumY += inReal;
      _state.value .SumXY += _state.value .SumY;
      m = ( _state.value .optInTimePeriod * _state.value .SumXY - _state.value .SumX * _state.value .SumY) / _state.value .Divisor;
      b = ( _state.value .SumY - m * _state.value .SumX ) / (double) _state.value .optInTimePeriod;
      outReal.value = b + m * (double) _state.value .optInTimePeriod;
      tempReal = ( _state.value .memory+_cur_idx).value .inReal ;
      _state.value .SumY -= tempReal;
      _state.value .SumXY -= tempReal* _state.value .optInTimePeriod;
      ( _state.value .memory+_cur_idx).value .inReal = inReal ;
      return RetCode.Success ;
   }
   public int tsfStateFree( struct TA_tsf_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if ( _state.value != NULL) {
         if ( _state.value .value .memory != NULL) TA_Free( _state.value .value .memory );
         TA_Free( _state.value ); _state.value = NULL;}
      return RetCode.Success ;
   }
   public RetCode tsf( int startIdx,
      int endIdx,
      float inReal[],
      int optInTimePeriod,
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      int outIdx;
      int today, lookbackTotal;
      double SumX, SumXY, SumY, SumXSqr, Divisor;
      double m, b;
      int i;
      double tempValue1;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 14;
      else if( ((int)optInTimePeriod < 2) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      lookbackTotal = tsfLookback ( optInTimePeriod );
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      outIdx = 0;
      today = startIdx;
      SumX = optInTimePeriod * ( optInTimePeriod - 1 ) * 0.5;
      SumXSqr = optInTimePeriod * ( optInTimePeriod - 1 ) * ( 2 * optInTimePeriod - 1 ) / 6;
      Divisor = SumX * SumX - optInTimePeriod * SumXSqr;
      while( today <= endIdx )
      {
         SumXY = 0;
         SumY = 0;
         for( i = optInTimePeriod; i-- != 0; )
         {
            SumY += tempValue1 = inReal[today - i];
            SumXY += (double)i * tempValue1;
         }
         m = ( optInTimePeriod * SumXY - SumX * SumY) / Divisor;
         b = ( SumY - m * SumX ) / (double)optInTimePeriod;
         outReal[outIdx++] = b + m * (double)optInTimePeriod;
         today++;
      }
      outBegIdx.value = startIdx;
      outNBElement.value = outIdx;
      return RetCode.Success ;
   }
   /* Generated */
   public int typPriceLookback( )
   {
      return RetCode.Success ;
   }
   public RetCode typPrice( int startIdx,
      int endIdx,
      double inHigh[],
      double inLow[],
      double inClose[],
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      int outIdx, i;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      outIdx = 0;
      for( i= startIdx; i <= endIdx; i++ )
      {
         outReal[outIdx++] = ( inHigh [i] +
            inLow [i] +
            inClose[i] ) / 3.0;
      }
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   public int typPriceStateInit( struct TA_typPrice_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct typPrice ));
      _state.value .value .mem_index = 0;
      _state.value .value .mem_size = typPriceLookback ();
      if ( _state.value .value .mem_size > 0)
         _state.value .value .memory = TA_Calloc( _state.value .value .mem_size , sizeof(struct TA_TYPPRICE_Data));
      else
         _state.value .value .memory = NULL;
      return RetCode.Success ;
   }
   public int typPriceState( struct TA_typPrice_State* _state,
      double inHigh,
      double inLow,
      double inClose,
      double *outReal )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      size_t _cur_idx = _state.value .mem_index++;
      if ( _state.value .mem_size > 0) _cur_idx %= _state.value .mem_size ;
      if ( _state.value .mem_size > _state.value .mem_index - 1 ) {
         ( _state.value .memory+_cur_idx).value .inHigh = inHigh ;
         ( _state.value .memory+_cur_idx).value .inLow = inLow ;
         ( _state.value .memory+_cur_idx).value .inClose = inClose ;
         return RetCode.NeedMoreData ; }
      outReal.value = ( inHigh + inLow + inClose ) / 3.0;
      return RetCode.Success ;
   }
   public int typPriceStateFree( struct TA_typPrice_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if ( _state.value != NULL) {
         if ( _state.value .value .memory != NULL) TA_Free( _state.value .value .memory );
         TA_Free( _state.value ); _state.value = NULL;}
      return RetCode.Success ;
   }
   public RetCode typPrice( int startIdx,
      int endIdx,
      float inHigh[],
      float inLow[],
      float inClose[],
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      int outIdx, i;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      outIdx = 0;
      for( i= startIdx; i <= endIdx; i++ )
      {
         outReal[outIdx++] = ( inHigh [i] +
            inLow [i] +
            inClose[i] ) / 3.0;
      }
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   /* Generated */
   public int ultOscLookback( int optInTimePeriod1,
      int optInTimePeriod2,
      int optInTimePeriod3 )
   {
      int maxPeriod;
      if( (int)optInTimePeriod1 == ( Integer.MIN_VALUE ) )
         optInTimePeriod1 = 7;
      else if( ((int)optInTimePeriod1 < 1) || ((int)optInTimePeriod1 > 100000) )
         return -1;
      if( (int)optInTimePeriod2 == ( Integer.MIN_VALUE ) )
         optInTimePeriod2 = 14;
      else if( ((int)optInTimePeriod2 < 1) || ((int)optInTimePeriod2 > 100000) )
         return -1;
      if( (int)optInTimePeriod3 == ( Integer.MIN_VALUE ) )
         optInTimePeriod3 = 28;
      else if( ((int)optInTimePeriod3 < 1) || ((int)optInTimePeriod3 > 100000) )
         return -1;
      maxPeriod = ((( (((optInTimePeriod1) > (optInTimePeriod2)) ? (optInTimePeriod1) : (optInTimePeriod2)) ) > (optInTimePeriod3)) ? ( (((optInTimePeriod1) > (optInTimePeriod2)) ? (optInTimePeriod1) : (optInTimePeriod2)) ) : (optInTimePeriod3)) ;
      return smaLookback ( maxPeriod ) + 1;
   }
   public RetCode ultOsc( int startIdx,
      int endIdx,
      double inHigh[],
      double inLow[],
      double inClose[],
      int optInTimePeriod1,
      int optInTimePeriod2,
      int optInTimePeriod3,
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      double a1Total, a2Total, a3Total;
      double b1Total, b2Total, b3Total;
      double trueLow, trueRange, closeMinusTrueLow;
      double tempDouble, output, tempHT, tempLT, tempCY;
      int lookbackTotal;
      int longestPeriod, longestIndex;
      int i,j,today,outIdx;
      int trailingIdx1, trailingIdx2, trailingIdx3;
      int []usedFlag = new int[3] ;
      int []periods = new int[3] ;
      int []sortedPeriods = new int[3] ;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      if( (int)optInTimePeriod1 == ( Integer.MIN_VALUE ) )
         optInTimePeriod1 = 7;
      else if( ((int)optInTimePeriod1 < 1) || ((int)optInTimePeriod1 > 100000) )
         return RetCode.BadParam ;
      if( (int)optInTimePeriod2 == ( Integer.MIN_VALUE ) )
         optInTimePeriod2 = 14;
      else if( ((int)optInTimePeriod2 < 1) || ((int)optInTimePeriod2 > 100000) )
         return RetCode.BadParam ;
      if( (int)optInTimePeriod3 == ( Integer.MIN_VALUE ) )
         optInTimePeriod3 = 28;
      else if( ((int)optInTimePeriod3 < 1) || ((int)optInTimePeriod3 > 100000) )
         return RetCode.BadParam ;
      outBegIdx.value = 0 ;
      outNBElement.value = 0 ;
      periods[0] = optInTimePeriod1;
      periods[1] = optInTimePeriod2;
      periods[2] = optInTimePeriod3;
      usedFlag[0] = 0;
      usedFlag[1] = 0;
      usedFlag[2] = 0;
      for ( i = 0; i < 3; ++i )
      {
         longestPeriod = 0;
         longestIndex = 0;
         for ( j = 0; j < 3; ++j )
         {
            if ( (usedFlag[j] == 0) && (periods[j] > longestPeriod) )
            {
               longestPeriod = periods[j];
               longestIndex = j;
            }
         }
         usedFlag[longestIndex] = 1;
         sortedPeriods[i] = longestPeriod;
      }
      optInTimePeriod1 = sortedPeriods[2];
      optInTimePeriod2 = sortedPeriods[1];
      optInTimePeriod3 = sortedPeriods[0];
      lookbackTotal = ultOscLookback ( optInTimePeriod1, optInTimePeriod2, optInTimePeriod3 );
      if( startIdx < lookbackTotal ) startIdx = lookbackTotal;
      if( startIdx > endIdx ) return RetCode.Success ;
      { a1Total = 0; b1Total = 0; for ( i = startIdx-optInTimePeriod1+1; i < startIdx; ++i ) { { tempLT = inLow[i]; tempHT = inHigh[i]; tempCY = inClose[i-1]; trueLow = (((tempLT) < (tempCY)) ? (tempLT) : (tempCY)) ; closeMinusTrueLow = inClose[i] - trueLow; trueRange = tempHT - tempLT; tempDouble = Math.abs ( tempCY - tempHT ); if( tempDouble > trueRange ) trueRange = tempDouble; tempDouble = Math.abs ( tempCY - tempLT ); if( tempDouble > trueRange ) trueRange = tempDouble; } ; a1Total += closeMinusTrueLow; b1Total += trueRange; } } ;
      { a2Total = 0; b2Total = 0; for ( i = startIdx-optInTimePeriod2+1; i < startIdx; ++i ) { { tempLT = inLow[i]; tempHT = inHigh[i]; tempCY = inClose[i-1]; trueLow = (((tempLT) < (tempCY)) ? (tempLT) : (tempCY)) ; closeMinusTrueLow = inClose[i] - trueLow; trueRange = tempHT - tempLT; tempDouble = Math.abs ( tempCY - tempHT ); if( tempDouble > trueRange ) trueRange = tempDouble; tempDouble = Math.abs ( tempCY - tempLT ); if( tempDouble > trueRange ) trueRange = tempDouble; } ; a2Total += closeMinusTrueLow; b2Total += trueRange; } } ;
      { a3Total = 0; b3Total = 0; for ( i = startIdx-optInTimePeriod3+1; i < startIdx; ++i ) { { tempLT = inLow[i]; tempHT = inHigh[i]; tempCY = inClose[i-1]; trueLow = (((tempLT) < (tempCY)) ? (tempLT) : (tempCY)) ; closeMinusTrueLow = inClose[i] - trueLow; trueRange = tempHT - tempLT; tempDouble = Math.abs ( tempCY - tempHT ); if( tempDouble > trueRange ) trueRange = tempDouble; tempDouble = Math.abs ( tempCY - tempLT ); if( tempDouble > trueRange ) trueRange = tempDouble; } ; a3Total += closeMinusTrueLow; b3Total += trueRange; } } ;
      today = startIdx;
      outIdx = 0;
      trailingIdx1 = today - optInTimePeriod1 + 1;
      trailingIdx2 = today - optInTimePeriod2 + 1;
      trailingIdx3 = today - optInTimePeriod3 + 1;
      while( today <= endIdx )
      {
         { tempLT = inLow[today]; tempHT = inHigh[today]; tempCY = inClose[today-1]; trueLow = (((tempLT) < (tempCY)) ? (tempLT) : (tempCY)) ; closeMinusTrueLow = inClose[today] - trueLow; trueRange = tempHT - tempLT; tempDouble = Math.abs ( tempCY - tempHT ); if( tempDouble > trueRange ) trueRange = tempDouble; tempDouble = Math.abs ( tempCY - tempLT ); if( tempDouble > trueRange ) trueRange = tempDouble; } ;
         a1Total += closeMinusTrueLow;
         a2Total += closeMinusTrueLow;
         a3Total += closeMinusTrueLow;
         b1Total += trueRange;
         b2Total += trueRange;
         b3Total += trueRange;
         output = 0.0;
         if( ! (((- (0.00000000000001) )<b1Total)&&(b1Total< (0.00000000000001) )) ) output += 4.0*(a1Total/b1Total);
         if( ! (((- (0.00000000000001) )<b2Total)&&(b2Total< (0.00000000000001) )) ) output += 2.0*(a2Total/b2Total);
         if( ! (((- (0.00000000000001) )<b3Total)&&(b3Total< (0.00000000000001) )) ) output += a3Total/b3Total;
         { tempLT = inLow[trailingIdx1]; tempHT = inHigh[trailingIdx1]; tempCY = inClose[trailingIdx1-1]; trueLow = (((tempLT) < (tempCY)) ? (tempLT) : (tempCY)) ; closeMinusTrueLow = inClose[trailingIdx1] - trueLow; trueRange = tempHT - tempLT; tempDouble = Math.abs ( tempCY - tempHT ); if( tempDouble > trueRange ) trueRange = tempDouble; tempDouble = Math.abs ( tempCY - tempLT ); if( tempDouble > trueRange ) trueRange = tempDouble; } ;
         a1Total -= closeMinusTrueLow;
         b1Total -= trueRange;
         { tempLT = inLow[trailingIdx2]; tempHT = inHigh[trailingIdx2]; tempCY = inClose[trailingIdx2-1]; trueLow = (((tempLT) < (tempCY)) ? (tempLT) : (tempCY)) ; closeMinusTrueLow = inClose[trailingIdx2] - trueLow; trueRange = tempHT - tempLT; tempDouble = Math.abs ( tempCY - tempHT ); if( tempDouble > trueRange ) trueRange = tempDouble; tempDouble = Math.abs ( tempCY - tempLT ); if( tempDouble > trueRange ) trueRange = tempDouble; } ;
         a2Total -= closeMinusTrueLow;
         b2Total -= trueRange;
         { tempLT = inLow[trailingIdx3]; tempHT = inHigh[trailingIdx3]; tempCY = inClose[trailingIdx3-1]; trueLow = (((tempLT) < (tempCY)) ? (tempLT) : (tempCY)) ; closeMinusTrueLow = inClose[trailingIdx3] - trueLow; trueRange = tempHT - tempLT; tempDouble = Math.abs ( tempCY - tempHT ); if( tempDouble > trueRange ) trueRange = tempDouble; tempDouble = Math.abs ( tempCY - tempLT ); if( tempDouble > trueRange ) trueRange = tempDouble; } ;
         a3Total -= closeMinusTrueLow;
         b3Total -= trueRange;
         outReal[outIdx] = 100.0 * (output / 7.0);
         outIdx++;
         today++;
         trailingIdx1++;
         trailingIdx2++;
         trailingIdx3++;
      }
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   public int ultOscStateInit( struct TA_ultOsc_State** _state,
      int optInTimePeriod1,
      int optInTimePeriod2,
      int optInTimePeriod3 )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if( (int)optInTimePeriod1 == ( Integer.MIN_VALUE ) )
         optInTimePeriod1 = 7;
      else if( ((int)optInTimePeriod1 < 1) || ((int)optInTimePeriod1 > 100000) )
         return RetCode.BadParam ;
      if( (int)optInTimePeriod2 == ( Integer.MIN_VALUE ) )
         optInTimePeriod2 = 14;
      else if( ((int)optInTimePeriod2 < 1) || ((int)optInTimePeriod2 > 100000) )
         return RetCode.BadParam ;
      if( (int)optInTimePeriod3 == ( Integer.MIN_VALUE ) )
         optInTimePeriod3 = 28;
      else if( ((int)optInTimePeriod3 < 1) || ((int)optInTimePeriod3 > 100000) )
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct ultOsc ));
      _state.value .value .mem_index = 0;
      _state.value .value .optInTimePeriod1 = optInTimePeriod1;
      _state.value .value .optInTimePeriod2 = optInTimePeriod2;
      _state.value .value .optInTimePeriod3 = optInTimePeriod3;
      _state.value .value .mem_size = ultOscLookback (optInTimePeriod1, optInTimePeriod2, optInTimePeriod3 );
      if ( _state.value .value .mem_size > 0)
         _state.value .value .memory = TA_Calloc( _state.value .value .mem_size , sizeof(struct TA_ULTOSC_Data));
      else
         _state.value .value .memory = NULL;
      return RetCode.Success ;
   }
   public int ultOscState( struct TA_ultOsc_State* _state,
      double inHigh,
      double inLow,
      double inClose,
      double *outReal )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      size_t _cur_idx = _state.value .mem_index++;
      if ( _state.value .mem_size > 0) _cur_idx %= _state.value .mem_size ;
      if ( _state.value .mem_size > _state.value .mem_index - 1 ) {
         ( _state.value .memory+_cur_idx).value .inHigh = inHigh ;
         ( _state.value .memory+_cur_idx).value .inLow = inLow ;
         ( _state.value .memory+_cur_idx).value .inClose = inClose ;
         return RetCode.NeedMoreData ; }
      return RetCode.Success ;
   }
   public int ultOscStateFree( struct TA_ultOsc_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if ( _state.value != NULL) {
         if ( _state.value .value .memory != NULL) TA_Free( _state.value .value .memory );
         TA_Free( _state.value ); _state.value = NULL;}
      return RetCode.Success ;
   }
   public RetCode ultOsc( int startIdx,
      int endIdx,
      float inHigh[],
      float inLow[],
      float inClose[],
      int optInTimePeriod1,
      int optInTimePeriod2,
      int optInTimePeriod3,
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      double a1Total, a2Total, a3Total;
      double b1Total, b2Total, b3Total;
      double trueLow, trueRange, closeMinusTrueLow;
      double tempDouble, output, tempHT, tempLT, tempCY;
      int lookbackTotal;
      int longestPeriod, longestIndex;
      int i,j,today,outIdx;
      int trailingIdx1, trailingIdx2, trailingIdx3;
      int []usedFlag = new int[3] ;
      int []periods = new int[3] ;
      int []sortedPeriods = new int[3] ;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      if( (int)optInTimePeriod1 == ( Integer.MIN_VALUE ) )
         optInTimePeriod1 = 7;
      else if( ((int)optInTimePeriod1 < 1) || ((int)optInTimePeriod1 > 100000) )
         return RetCode.BadParam ;
      if( (int)optInTimePeriod2 == ( Integer.MIN_VALUE ) )
         optInTimePeriod2 = 14;
      else if( ((int)optInTimePeriod2 < 1) || ((int)optInTimePeriod2 > 100000) )
         return RetCode.BadParam ;
      if( (int)optInTimePeriod3 == ( Integer.MIN_VALUE ) )
         optInTimePeriod3 = 28;
      else if( ((int)optInTimePeriod3 < 1) || ((int)optInTimePeriod3 > 100000) )
         return RetCode.BadParam ;
      outBegIdx.value = 0 ;
      outNBElement.value = 0 ;
      periods[0] = optInTimePeriod1;
      periods[1] = optInTimePeriod2;
      periods[2] = optInTimePeriod3;
      usedFlag[0] = 0;
      usedFlag[1] = 0;
      usedFlag[2] = 0;
      for ( i = 0; i < 3; ++i )
      {
         longestPeriod = 0;
         longestIndex = 0;
         for ( j = 0; j < 3; ++j )
         {
            if ( (usedFlag[j] == 0) && (periods[j] > longestPeriod) )
            {
               longestPeriod = periods[j];
               longestIndex = j;
            }
         }
         usedFlag[longestIndex] = 1;
         sortedPeriods[i] = longestPeriod;
      }
      optInTimePeriod1 = sortedPeriods[2];
      optInTimePeriod2 = sortedPeriods[1];
      optInTimePeriod3 = sortedPeriods[0];
      lookbackTotal = ultOscLookback ( optInTimePeriod1, optInTimePeriod2, optInTimePeriod3 );
      if( startIdx < lookbackTotal ) startIdx = lookbackTotal;
      if( startIdx > endIdx ) return RetCode.Success ;
      { a1Total = 0; b1Total = 0; for ( i = startIdx-optInTimePeriod1+1; i < startIdx; ++i ) { { tempLT = inLow[i]; tempHT = inHigh[i]; tempCY = inClose[i-1]; trueLow = (((tempLT) < (tempCY)) ? (tempLT) : (tempCY)) ; closeMinusTrueLow = inClose[i] - trueLow; trueRange = tempHT - tempLT; tempDouble = Math.abs ( tempCY - tempHT ); if( tempDouble > trueRange ) trueRange = tempDouble; tempDouble = Math.abs ( tempCY - tempLT ); if( tempDouble > trueRange ) trueRange = tempDouble; } ; a1Total += closeMinusTrueLow; b1Total += trueRange; } } ;
      { a2Total = 0; b2Total = 0; for ( i = startIdx-optInTimePeriod2+1; i < startIdx; ++i ) { { tempLT = inLow[i]; tempHT = inHigh[i]; tempCY = inClose[i-1]; trueLow = (((tempLT) < (tempCY)) ? (tempLT) : (tempCY)) ; closeMinusTrueLow = inClose[i] - trueLow; trueRange = tempHT - tempLT; tempDouble = Math.abs ( tempCY - tempHT ); if( tempDouble > trueRange ) trueRange = tempDouble; tempDouble = Math.abs ( tempCY - tempLT ); if( tempDouble > trueRange ) trueRange = tempDouble; } ; a2Total += closeMinusTrueLow; b2Total += trueRange; } } ;
      { a3Total = 0; b3Total = 0; for ( i = startIdx-optInTimePeriod3+1; i < startIdx; ++i ) { { tempLT = inLow[i]; tempHT = inHigh[i]; tempCY = inClose[i-1]; trueLow = (((tempLT) < (tempCY)) ? (tempLT) : (tempCY)) ; closeMinusTrueLow = inClose[i] - trueLow; trueRange = tempHT - tempLT; tempDouble = Math.abs ( tempCY - tempHT ); if( tempDouble > trueRange ) trueRange = tempDouble; tempDouble = Math.abs ( tempCY - tempLT ); if( tempDouble > trueRange ) trueRange = tempDouble; } ; a3Total += closeMinusTrueLow; b3Total += trueRange; } } ;
      today = startIdx;
      outIdx = 0;
      trailingIdx1 = today - optInTimePeriod1 + 1;
      trailingIdx2 = today - optInTimePeriod2 + 1;
      trailingIdx3 = today - optInTimePeriod3 + 1;
      while( today <= endIdx )
      {
         { tempLT = inLow[today]; tempHT = inHigh[today]; tempCY = inClose[today-1]; trueLow = (((tempLT) < (tempCY)) ? (tempLT) : (tempCY)) ; closeMinusTrueLow = inClose[today] - trueLow; trueRange = tempHT - tempLT; tempDouble = Math.abs ( tempCY - tempHT ); if( tempDouble > trueRange ) trueRange = tempDouble; tempDouble = Math.abs ( tempCY - tempLT ); if( tempDouble > trueRange ) trueRange = tempDouble; } ;
         a1Total += closeMinusTrueLow;
         a2Total += closeMinusTrueLow;
         a3Total += closeMinusTrueLow;
         b1Total += trueRange;
         b2Total += trueRange;
         b3Total += trueRange;
         output = 0.0;
         if( ! (((- (0.00000000000001) )<b1Total)&&(b1Total< (0.00000000000001) )) ) output += 4.0*(a1Total/b1Total);
         if( ! (((- (0.00000000000001) )<b2Total)&&(b2Total< (0.00000000000001) )) ) output += 2.0*(a2Total/b2Total);
         if( ! (((- (0.00000000000001) )<b3Total)&&(b3Total< (0.00000000000001) )) ) output += a3Total/b3Total;
         { tempLT = inLow[trailingIdx1]; tempHT = inHigh[trailingIdx1]; tempCY = inClose[trailingIdx1-1]; trueLow = (((tempLT) < (tempCY)) ? (tempLT) : (tempCY)) ; closeMinusTrueLow = inClose[trailingIdx1] - trueLow; trueRange = tempHT - tempLT; tempDouble = Math.abs ( tempCY - tempHT ); if( tempDouble > trueRange ) trueRange = tempDouble; tempDouble = Math.abs ( tempCY - tempLT ); if( tempDouble > trueRange ) trueRange = tempDouble; } ;
         a1Total -= closeMinusTrueLow;
         b1Total -= trueRange;
         { tempLT = inLow[trailingIdx2]; tempHT = inHigh[trailingIdx2]; tempCY = inClose[trailingIdx2-1]; trueLow = (((tempLT) < (tempCY)) ? (tempLT) : (tempCY)) ; closeMinusTrueLow = inClose[trailingIdx2] - trueLow; trueRange = tempHT - tempLT; tempDouble = Math.abs ( tempCY - tempHT ); if( tempDouble > trueRange ) trueRange = tempDouble; tempDouble = Math.abs ( tempCY - tempLT ); if( tempDouble > trueRange ) trueRange = tempDouble; } ;
         a2Total -= closeMinusTrueLow;
         b2Total -= trueRange;
         { tempLT = inLow[trailingIdx3]; tempHT = inHigh[trailingIdx3]; tempCY = inClose[trailingIdx3-1]; trueLow = (((tempLT) < (tempCY)) ? (tempLT) : (tempCY)) ; closeMinusTrueLow = inClose[trailingIdx3] - trueLow; trueRange = tempHT - tempLT; tempDouble = Math.abs ( tempCY - tempHT ); if( tempDouble > trueRange ) trueRange = tempDouble; tempDouble = Math.abs ( tempCY - tempLT ); if( tempDouble > trueRange ) trueRange = tempDouble; } ;
         a3Total -= closeMinusTrueLow;
         b3Total -= trueRange;
         outReal[outIdx] = 100.0 * (output / 7.0);
         outIdx++;
         today++;
         trailingIdx1++;
         trailingIdx2++;
         trailingIdx3++;
      }
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   /* Generated */
   public int varianceLookback( int optInTimePeriod,
      double optInNbDev )
   {
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 5;
      else if( ((int)optInTimePeriod < 1) || ((int)optInTimePeriod > 100000) )
         return -1;
      if( optInNbDev == (-4e+37) )
         optInNbDev = 1.000000e+0;
      else if( (optInNbDev < -3.000000e+37) || (optInNbDev > 3.000000e+37) )
         return -1;
      return optInTimePeriod-1;
   }
   public RetCode variance( int startIdx,
      int endIdx,
      double inReal[],
      int optInTimePeriod,
      double optInNbDev,
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 5;
      else if( ((int)optInTimePeriod < 1) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      if( optInNbDev == (-4e+37) )
         optInNbDev = 1.000000e+0;
      else if( (optInNbDev < -3.000000e+37) || (optInNbDev > 3.000000e+37) )
         return RetCode.BadParam ;
      return TA_INT_VAR ( startIdx, endIdx, inReal,
         optInTimePeriod,
         outBegIdx, outNBElement, outReal );
   }
   public RetCode TA_INT_VAR( int startIdx,
      int endIdx,
      double inReal[],
      int optInTimePeriod,
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      double tempReal, periodTotal1, periodTotal2, meanValue1, meanValue2;
      int i, outIdx, trailingIdx, nbInitialElementNeeded;
      nbInitialElementNeeded = (optInTimePeriod-1);
      if( startIdx < nbInitialElementNeeded )
         startIdx = nbInitialElementNeeded;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      periodTotal1 = 0;
      periodTotal2 = 0;
      trailingIdx = startIdx-nbInitialElementNeeded;
      i=trailingIdx;
      if( optInTimePeriod > 1 )
      {
         while( i < startIdx ) {
            tempReal = inReal[i++];
            periodTotal1 += tempReal;
            tempReal *= tempReal;
            periodTotal2 += tempReal;
         }
      }
      outIdx = 0;
      do
      {
         tempReal = inReal[i++];
         periodTotal1 += tempReal;
         tempReal *= tempReal;
         periodTotal2 += tempReal;
         meanValue1 = periodTotal1 / optInTimePeriod;
         meanValue2 = periodTotal2 / optInTimePeriod;
         tempReal = inReal[trailingIdx++];
         periodTotal1 -= tempReal;
         tempReal *= tempReal;
         periodTotal2 -= tempReal;
         outReal[outIdx++] = meanValue2-meanValue1*meanValue1;
      } while( i <= endIdx );
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   public int varianceStateInit( struct TA_variance_State** _state,
      int optInTimePeriod,
      double optInNbDev )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 5;
      else if( ((int)optInTimePeriod < 1) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      if( optInNbDev == (-4e+37) )
         optInNbDev = 1.000000e+0;
      else if( (optInNbDev < -3.000000e+37) || (optInNbDev > 3.000000e+37) )
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct variance ));
      _state.value .value .mem_index = 0;
      _state.value .value .optInTimePeriod = optInTimePeriod;
      _state.value .value .optInNbDev = optInNbDev;
      _state.value .value .mem_size = varianceLookback (optInTimePeriod, optInNbDev );
      if ( _state.value .value .mem_size > 0)
         _state.value .value .memory = TA_Calloc( _state.value .value .mem_size , sizeof(struct TA_VAR_Data));
      else
         _state.value .value .memory = NULL;
      return RetCode.Success ;
   }
   public int varianceState( struct TA_variance_State* _state,
      double inReal,
      double *outReal )
   {
      double tempReal, meanValue1, meanValue2;
      if (_state == NULL)
         return RetCode.BadParam ;
      size_t _cur_idx = _state.value .mem_index++;
      if ( _state.value .mem_size > 0) _cur_idx %= _state.value .mem_size ;
      if ( ( _state.value .mem_index == 1) )
      {
         _state.value .periodTotal1 = 0.;
         _state.value .periodTotal2 = 0.;
      }
      if ( _state.value .mem_size > _state.value .mem_index - 1 )
      {
         _state.value .periodTotal1 += inReal;
         _state.value .periodTotal2 += inReal*inReal;
         ( _state.value .memory+_cur_idx).value .inReal = inReal ;
         return RetCode.NeedMoreData ;
      }
      _state.value .periodTotal1 += inReal;
      _state.value .periodTotal2 += inReal*inReal;
      meanValue1 = _state.value .periodTotal1 / _state.value .optInTimePeriod;
      meanValue2 = _state.value .periodTotal2 / _state.value .optInTimePeriod;
      outReal.value = meanValue2 - meanValue1 * meanValue1;
      tempReal = ( _state.value .memory+_cur_idx).value .inReal ;
      _state.value .periodTotal1 -= tempReal;
      _state.value .periodTotal2 -= tempReal*tempReal;
      ( _state.value .memory+_cur_idx).value .inReal = inReal ;
      return RetCode.Success ;
   }
   public int varianceStateFree( struct TA_variance_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if ( _state.value != NULL) {
         if ( _state.value .value .memory != NULL) TA_Free( _state.value .value .memory );
         TA_Free( _state.value ); _state.value = NULL;}
      return RetCode.Success ;
   }
   public RetCode variance( int startIdx,
      int endIdx,
      float inReal[],
      int optInTimePeriod,
      double optInNbDev,
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 5;
      else if( ((int)optInTimePeriod < 1) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      if( optInNbDev == (-4e+37) )
         optInNbDev = 1.000000e+0;
      else if( (optInNbDev < -3.000000e+37) || (optInNbDev > 3.000000e+37) )
         return RetCode.BadParam ;
      return TA_INT_VAR ( startIdx, endIdx, inReal,
         optInTimePeriod,
         outBegIdx, outNBElement, outReal );
   }
   public RetCode TA_INT_VAR( int startIdx,
      int endIdx,
      float inReal[],
      int optInTimePeriod,
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      double tempReal, periodTotal1, periodTotal2, meanValue1, meanValue2;
      int i, outIdx, trailingIdx, nbInitialElementNeeded;
      nbInitialElementNeeded = (optInTimePeriod-1);
      if( startIdx < nbInitialElementNeeded )
         startIdx = nbInitialElementNeeded;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      periodTotal1 = 0;
      periodTotal2 = 0;
      trailingIdx = startIdx-nbInitialElementNeeded;
      i=trailingIdx;
      if( optInTimePeriod > 1 )
      {
         while( i < startIdx ) {
            tempReal = inReal[i++];
            periodTotal1 += tempReal;
            tempReal *= tempReal;
            periodTotal2 += tempReal;
         }
      }
      outIdx = 0;
      do
      {
         tempReal = inReal[i++];
         periodTotal1 += tempReal;
         tempReal *= tempReal;
         periodTotal2 += tempReal;
         meanValue1 = periodTotal1 / optInTimePeriod;
         meanValue2 = periodTotal2 / optInTimePeriod;
         tempReal = inReal[trailingIdx++];
         periodTotal1 -= tempReal;
         tempReal *= tempReal;
         periodTotal2 -= tempReal;
         outReal[outIdx++] = meanValue2-meanValue1*meanValue1;
      } while( i <= endIdx );
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   /* Generated */
   public int wclPriceLookback( )
   {
      return RetCode.Success ;
   }
   public RetCode wclPrice( int startIdx,
      int endIdx,
      double inHigh[],
      double inLow[],
      double inClose[],
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      int outIdx, i;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      outIdx = 0;
      for( i= startIdx; i <= endIdx; i++ )
      {
         outReal[outIdx++] = ( inHigh [i] +
            inLow [i] +
            (inClose[i]*2.0) ) / 4.0;
      }
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   public int wclPriceStateInit( struct TA_wclPrice_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct wclPrice ));
      _state.value .value .mem_index = 0;
      _state.value .value .mem_size = wclPriceLookback ();
      if ( _state.value .value .mem_size > 0)
         _state.value .value .memory = TA_Calloc( _state.value .value .mem_size , sizeof(struct TA_WCLPRICE_Data));
      else
         _state.value .value .memory = NULL;
      return RetCode.Success ;
   }
   public int wclPriceState( struct TA_wclPrice_State* _state,
      double inHigh,
      double inLow,
      double inClose,
      double *outReal )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      size_t _cur_idx = _state.value .mem_index++;
      if ( _state.value .mem_size > 0) _cur_idx %= _state.value .mem_size ;
      if ( _state.value .mem_size > _state.value .mem_index - 1 ) {
         ( _state.value .memory+_cur_idx).value .inHigh = inHigh ;
         ( _state.value .memory+_cur_idx).value .inLow = inLow ;
         ( _state.value .memory+_cur_idx).value .inClose = inClose ;
         return RetCode.NeedMoreData ; }
      outReal.value = ( inHigh + inLow + (inClose*2.0) ) / 4.0;
      return RetCode.Success ;
   }
   public int wclPriceStateFree( struct TA_wclPrice_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if ( _state.value != NULL) {
         if ( _state.value .value .memory != NULL) TA_Free( _state.value .value .memory );
         TA_Free( _state.value ); _state.value = NULL;}
      return RetCode.Success ;
   }
   public RetCode wclPrice( int startIdx,
      int endIdx,
      float inHigh[],
      float inLow[],
      float inClose[],
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      int outIdx, i;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      outIdx = 0;
      for( i= startIdx; i <= endIdx; i++ )
      {
         outReal[outIdx++] = ( inHigh [i] +
            inLow [i] +
            (inClose[i]*2.0) ) / 4.0;
      }
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   /* Generated */
   public int willRLookback( int optInTimePeriod )
   {
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 14;
      else if( ((int)optInTimePeriod < 2) || ((int)optInTimePeriod > 100000) )
         return -1;
      return (optInTimePeriod-1);
   }
   public RetCode willR( int startIdx,
      int endIdx,
      double inHigh[],
      double inLow[],
      double inClose[],
      int optInTimePeriod,
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      double lowest, highest, tmp, diff;
      int outIdx, nbInitialElementNeeded;
      int trailingIdx, lowestIdx, highestIdx;
      int today, i;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 14;
      else if( ((int)optInTimePeriod < 2) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      nbInitialElementNeeded = (optInTimePeriod-1);
      if( startIdx < nbInitialElementNeeded )
         startIdx = nbInitialElementNeeded;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      diff = 0.0;
      outIdx = 0;
      today = startIdx;
      trailingIdx = startIdx-nbInitialElementNeeded;
      lowestIdx = highestIdx = -1;
      diff = highest = lowest = 0.0;
      while( today <= endIdx )
      {
         tmp = inLow[today];
         if( lowestIdx < trailingIdx )
         {
            lowestIdx = trailingIdx;
            lowest = inLow[lowestIdx];
            i = lowestIdx;
            while( ++i<=today )
            {
               tmp = inLow[i];
               if( tmp < lowest )
               {
                  lowestIdx = i;
                  lowest = tmp;
               }
            }
            diff = (highest - lowest)/(-100.0);
         }
         else if( tmp <= lowest )
         {
            lowestIdx = today;
            lowest = tmp;
            diff = (highest - lowest)/(-100.0);
         }
         tmp = inHigh[today];
         if( highestIdx < trailingIdx )
         {
            highestIdx = trailingIdx;
            highest = inHigh[highestIdx];
            i = highestIdx;
            while( ++i<=today )
            {
               tmp = inHigh[i];
               if( tmp > highest )
               {
                  highestIdx = i;
                  highest = tmp;
               }
            }
            diff = (highest - lowest)/(-100.0);
         }
         else if( tmp >= highest )
         {
            highestIdx = today;
            highest = tmp;
            diff = (highest - lowest)/(-100.0);
         }
         if( diff != 0.0 )
            outReal[outIdx++] = (highest-inClose[today])/diff;
         else
            outReal[outIdx++] = 0.0;
         trailingIdx++;
         today++;
      }
      outBegIdx.value = startIdx;
      outNBElement.value = outIdx;
      return RetCode.Success ;
   }
   public int willRStateInit( struct TA_willR_State** _state,
      int optInTimePeriod )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 14;
      else if( ((int)optInTimePeriod < 2) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct willR ));
      _state.value .value .mem_index = 0;
      _state.value .value .optInTimePeriod = optInTimePeriod;
      _state.value .value .mem_size = willRLookback (optInTimePeriod );
      _state.value .value .memory = NULL;
      return RetCode.Success ;
   }
   public int willRState( struct TA_willR_State* _state,
      double inHigh,
      double inLow,
      double inClose,
      double *outReal )
   {
      double diff;
      if (_state == NULL)
         return RetCode.BadParam ;
      size_t _cur_idx = _state.value .mem_index++;
      if ( _state.value .mem_size > 0) _cur_idx %= _state.value .mem_size ;
      if ( ( _state.value .mem_index == 1) )
      {
         _state.value .lowest = 0.;
         _state.value .highest = 0.;
      }
      if (inLow < _state.value .lowest)
         _state.value .lowest = inLow;
      if (inHigh > _state.value .highest)
         _state.value .highest = inHigh;
      if ( _state.value .mem_size > _state.value .mem_index - 1 )
         return RetCode.NeedMoreData ;
      diff = ( _state.value .highest - _state.value .lowest)/(-100.0);
      if( diff != 0.0 )
         outReal.value = ( _state.value .highest-inClose)/diff;
      else
         outReal.value = 0.0;
      return RetCode.Success ;
   }
   public int willRStateFree( struct TA_willR_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if ( _state.value != NULL) {
         if ( _state.value .value .memory != NULL) TA_Free( _state.value .value .memory );
         TA_Free( _state.value ); _state.value = NULL;}
      return RetCode.Success ;
   }
   public RetCode willR( int startIdx,
      int endIdx,
      float inHigh[],
      float inLow[],
      float inClose[],
      int optInTimePeriod,
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      double lowest, highest, tmp, diff;
      int outIdx, nbInitialElementNeeded;
      int trailingIdx, lowestIdx, highestIdx;
      int today, i;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 14;
      else if( ((int)optInTimePeriod < 2) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      nbInitialElementNeeded = (optInTimePeriod-1);
      if( startIdx < nbInitialElementNeeded )
         startIdx = nbInitialElementNeeded;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      diff = 0.0;
      outIdx = 0;
      today = startIdx;
      trailingIdx = startIdx-nbInitialElementNeeded;
      lowestIdx = highestIdx = -1;
      diff = highest = lowest = 0.0;
      while( today <= endIdx )
      {
         tmp = inLow[today];
         if( lowestIdx < trailingIdx )
         {
            lowestIdx = trailingIdx;
            lowest = inLow[lowestIdx];
            i = lowestIdx;
            while( ++i<=today )
            {
               tmp = inLow[i];
               if( tmp < lowest )
               {
                  lowestIdx = i;
                  lowest = tmp;
               }
            }
            diff = (highest - lowest)/(-100.0);
         }
         else if( tmp <= lowest )
         {
            lowestIdx = today;
            lowest = tmp;
            diff = (highest - lowest)/(-100.0);
         }
         tmp = inHigh[today];
         if( highestIdx < trailingIdx )
         {
            highestIdx = trailingIdx;
            highest = inHigh[highestIdx];
            i = highestIdx;
            while( ++i<=today )
            {
               tmp = inHigh[i];
               if( tmp > highest )
               {
                  highestIdx = i;
                  highest = tmp;
               }
            }
            diff = (highest - lowest)/(-100.0);
         }
         else if( tmp >= highest )
         {
            highestIdx = today;
            highest = tmp;
            diff = (highest - lowest)/(-100.0);
         }
         if( diff != 0.0 )
            outReal[outIdx++] = (highest-inClose[today])/diff;
         else
            outReal[outIdx++] = 0.0;
         trailingIdx++;
         today++;
      }
      outBegIdx.value = startIdx;
      outNBElement.value = outIdx;
      return RetCode.Success ;
   }
   /* Generated */
   public int wmaLookback( int optInTimePeriod )
   {
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 30;
      else if( ((int)optInTimePeriod < 2) || ((int)optInTimePeriod > 100000) )
         return -1;
      return optInTimePeriod - 1;
   }
   public RetCode wma( int startIdx,
      int endIdx,
      double inReal[],
      int optInTimePeriod,
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      int inIdx, outIdx, i, trailingIdx, divider;
      double periodSum, periodSub, tempReal, trailingValue;
      int lookbackTotal;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 30;
      else if( ((int)optInTimePeriod < 2) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      lookbackTotal = optInTimePeriod-1;
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      if( optInTimePeriod == 1 )
      {
         outBegIdx.value = startIdx;
         outNBElement.value = endIdx-startIdx+1;
         System.arraycopy(inReal,startIdx,outReal,0,(int) outNBElement.value ) ;
         return RetCode.Success ;
      }
      divider = (optInTimePeriod*(optInTimePeriod+1))>>1;
      outIdx = 0;
      trailingIdx = startIdx - lookbackTotal;
      periodSum = periodSub = (double)0.0;
      inIdx=trailingIdx;
      i = 1;
      while( inIdx < startIdx )
      {
         tempReal = inReal[inIdx++];
         periodSub += tempReal;
         periodSum += tempReal*i;
         i++;
      }
      trailingValue = 0.0;
      while( inIdx <= endIdx )
      {
         tempReal = inReal[inIdx++];
         periodSub += tempReal;
         periodSub -= trailingValue;
         periodSum += tempReal*optInTimePeriod;
         trailingValue = inReal[trailingIdx++];
         outReal[outIdx++] = periodSum / divider;
         periodSum -= periodSub;
      }
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   public int wmaStateInit( struct TA_wma_State** _state,
      int optInTimePeriod )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 30;
      else if( ((int)optInTimePeriod < 2) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      _state.value = TA_Calloc(1, sizeof(struct wma ));
      _state.value .value .mem_index = 0;
      _state.value .value .optInTimePeriod = optInTimePeriod;
      _state.value .value .mem_size = wmaLookback (optInTimePeriod );
      if ( _state.value .value .mem_size > 0)
         _state.value .value .memory = TA_Calloc( _state.value .value .mem_size , sizeof(struct TA_WMA_Data));
      else
         _state.value .value .memory = NULL;
      return RetCode.Success ;
   }
   public int wmaState( struct TA_wma_State* _state,
      double inReal,
      double *outReal )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      size_t _cur_idx = _state.value .mem_index++;
      if ( _state.value .mem_size > 0) _cur_idx %= _state.value .mem_size ;
      if ( ( _state.value .mem_index == 1) )
      {
         _state.value .periodSum = 0.;
         _state.value .periodSub = 0.;
         _state.value .divider = ( _state.value .optInTimePeriod*( _state.value .optInTimePeriod+1))>>1;
      }
      if ( _state.value .mem_size > _state.value .mem_index - 1 )
      {
         _state.value .periodSum += inReal* _state.value .optInTimePeriod;
         _state.value .periodSub += inReal;
         _state.value .periodSum -= _state.value .periodSub;
         ( _state.value .memory+_cur_idx).value .inReal = inReal ;
         return RetCode.NeedMoreData ;
      }
      _state.value .periodSub += inReal;
      _state.value .periodSum += inReal* _state.value .optInTimePeriod;
      outReal.value = _state.value .periodSum / _state.value .divider;
      _state.value .periodSum -= _state.value .periodSub;
      _state.value .periodSub -= ( _state.value .memory+_cur_idx).value .inReal ;
      ( _state.value .memory+_cur_idx).value .inReal = inReal ;
      return RetCode.Success ;
   }
   public int wmaStateFree( struct TA_wma_State** _state )
   {
      if (_state == NULL)
         return RetCode.BadParam ;
      if ( _state.value != NULL) {
         if ( _state.value .value .memory != NULL) TA_Free( _state.value .value .memory );
         TA_Free( _state.value ); _state.value = NULL;}
      return RetCode.Success ;
   }
   public RetCode wma( int startIdx,
      int endIdx,
      float inReal[],
      int optInTimePeriod,
      MInteger outBegIdx,
      MInteger outNBElement,
      double outReal[] )
   {
      int inIdx, outIdx, i, trailingIdx, divider;
      double periodSum, periodSub, tempReal, trailingValue;
      int lookbackTotal;
      int mmmixi, mmmixdestIdx, mmmixsrcIdx ;
      if( startIdx < 0 )
         return RetCode.OutOfRangeStartIndex ;
      if( (endIdx < 0) || (endIdx < startIdx))
         return RetCode.OutOfRangeEndIndex ;
      if( (int)optInTimePeriod == ( Integer.MIN_VALUE ) )
         optInTimePeriod = 30;
      else if( ((int)optInTimePeriod < 2) || ((int)optInTimePeriod > 100000) )
         return RetCode.BadParam ;
      lookbackTotal = optInTimePeriod-1;
      if( startIdx < lookbackTotal )
         startIdx = lookbackTotal;
      if( startIdx > endIdx )
      {
         outBegIdx.value = 0 ;
         outNBElement.value = 0 ;
         return RetCode.Success ;
      }
      if( optInTimePeriod == 1 )
      {
         outBegIdx.value = startIdx;
         outNBElement.value = endIdx-startIdx+1;
         { for( mmmixi=0, mmmixdestIdx=0, mmmixsrcIdx=startIdx; mmmixi < (int) outNBElement.value ; mmmixi++, mmmixdestIdx++, mmmixsrcIdx++ ) { outReal[mmmixdestIdx] = inReal[mmmixsrcIdx]; } } ;
         return RetCode.Success ;
      }
      divider = (optInTimePeriod*(optInTimePeriod+1))>>1;
      outIdx = 0;
      trailingIdx = startIdx - lookbackTotal;
      periodSum = periodSub = (double)0.0;
      inIdx=trailingIdx;
      i = 1;
      while( inIdx < startIdx )
      {
         tempReal = inReal[inIdx++];
         periodSub += tempReal;
         periodSum += tempReal*i;
         i++;
      }
      trailingValue = 0.0;
      while( inIdx <= endIdx )
      {
         tempReal = inReal[inIdx++];
         periodSub += tempReal;
         periodSub -= trailingValue;
         periodSum += tempReal*optInTimePeriod;
         trailingValue = inReal[trailingIdx++];
         outReal[outIdx++] = periodSum / divider;
         periodSum -= periodSub;
      }
      outNBElement.value = outIdx;
      outBegIdx.value = startIdx;
      return RetCode.Success ;
   }
   /* Generated */
   /**** END GENCODE SECTION 1 - DO NOT DELETE THIS LINE ****/
   
}
